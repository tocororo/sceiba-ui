/**
 * @fileoverview added by tsickle
 * Generated from: lib/core/utils/validator.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
/**
 * Represents a class that contains a boolean property named `required`.
 * @record
 */
export function RequiredProperty() { }
if (false) {
    /**
     * Returns true if the control is required; otherwise, false.
     * @type {?}
     */
    RequiredProperty.prototype.required;
}
/**
 * \@description
 * Provides a set of extra validators that can be used by form controls.
 *
 * A validator is a function that processes a `FormControl` or collection of
 * controls and returns an error map or `null`. A `null` map means that validation has passed.
 *
 * @see [Form Validation](/guide/form-validation)
 */
var /**
 * \@description
 * Provides a set of extra validators that can be used by form controls.
 *
 * A validator is a function that processes a `FormControl` or collection of
 * controls and returns an error map or `null`. A `null` map means that validation has passed.
 *
 * @see [Form Validation](/guide/form-validation)
 */
ExtraValidators = /** @class */ (function () {
    function ExtraValidators() {
    }
    /**
     * @description
     * Validator that requires the length of the control's value to be equal to the
     * provided length. It assumes that the control's value is of string type.
     * This validator is used with Reactive Forms; if you want to use
     * an equivalent validator with Template-driven Form you must use the `equalLength` attribute.
     *
     * @usageNotes
     *
     * ### Validates that the field has a length of 4 characters:
     *
     * ```typescript
     * const control = new FormControl('ng', ExtraValidators.equalLength(4));
     *
     * console.log(control.errors); // { equalLength: { requiredLength: 4, actualLength: 2 } }
     * ```
     *
     * ```html
     * <input name="firstName" ngModel equallength="4">
     * ```
     *
     * @returns A validator function that returns an error map with the `equalLength`
     * if the validation check fails, otherwise `null`.
     */
    /**
     * \@description
     * Validator that requires the length of the control's value to be equal to the
     * provided length. It assumes that the control's value is of string type.
     * This validator is used with Reactive Forms; if you want to use
     * an equivalent validator with Template-driven Form you must use the `equalLength` attribute.
     *
     * \@usageNotes
     *
     * ### Validates that the field has a length of 4 characters:
     *
     * ```typescript
     * const control = new FormControl('ng', ExtraValidators.equalLength(4));
     *
     * console.log(control.errors); // { equalLength: { requiredLength: 4, actualLength: 2 } }
     * ```
     *
     * ```html
     * <input name="firstName" ngModel equallength="4">
     * ```
     *
     * @param {?} equalLength
     * @return {?} A validator function that returns an error map with the `equalLength`
     * if the validation check fails, otherwise `null`.
     */
    ExtraValidators.equalLength = /**
     * \@description
     * Validator that requires the length of the control's value to be equal to the
     * provided length. It assumes that the control's value is of string type.
     * This validator is used with Reactive Forms; if you want to use
     * an equivalent validator with Template-driven Form you must use the `equalLength` attribute.
     *
     * \@usageNotes
     *
     * ### Validates that the field has a length of 4 characters:
     *
     * ```typescript
     * const control = new FormControl('ng', ExtraValidators.equalLength(4));
     *
     * console.log(control.errors); // { equalLength: { requiredLength: 4, actualLength: 2 } }
     * ```
     *
     * ```html
     * <input name="firstName" ngModel equallength="4">
     * ```
     *
     * @param {?} equalLength
     * @return {?} A validator function that returns an error map with the `equalLength`
     * if the validation check fails, otherwise `null`.
     */
    function (equalLength) {
        /** @type {?} */
        var res = (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            /** @type {?} */
            var len = control.value ? control.value.length : 0;
            return ((len != 0) && (len != equalLength))
                ? { 'equalLength': { 'requiredLength': equalLength, 'actualLength': len } }
                : null;
        });
        return res;
    };
    /**
     * @description
     * Validator that is applied to `FormArray` controls. It requires that the amount of
     * `FormArray`'s child controls to be greater than or equal to the provided minimum length.
     * The validator exists only as a function and not as a directive.
     *
     * @usageNotes
     *
     * ### Validates that the `FormArray` field has a minimum of 2 child controls:
     *
     * ```typescript
     * const formArrayControl = new FormArray([new FormControl('ng')], ExtraValidators.minLength(2));
     *
     * console.log(formArrayControl.errors); // { minLength: { requiredLength: 2, actualLength: 1 } }
     * ```
     *
     * @returns A validator function that returns an error map with the
     * `minLength` if the validation check fails, otherwise `null`.
     */
    /**
     * \@description
     * Validator that is applied to `FormArray` controls. It requires that the amount of
     * `FormArray`'s child controls to be greater than or equal to the provided minimum length.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the `FormArray` field has a minimum of 2 child controls:
     *
     * ```typescript
     * const formArrayControl = new FormArray([new FormControl('ng')], ExtraValidators.minLength(2));
     *
     * console.log(formArrayControl.errors); // { minLength: { requiredLength: 2, actualLength: 1 } }
     * ```
     *
     * @param {?} minLength
     * @return {?} A validator function that returns an error map with the
     * `minLength` if the validation check fails, otherwise `null`.
     */
    ExtraValidators.minLength = /**
     * \@description
     * Validator that is applied to `FormArray` controls. It requires that the amount of
     * `FormArray`'s child controls to be greater than or equal to the provided minimum length.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the `FormArray` field has a minimum of 2 child controls:
     *
     * ```typescript
     * const formArrayControl = new FormArray([new FormControl('ng')], ExtraValidators.minLength(2));
     *
     * console.log(formArrayControl.errors); // { minLength: { requiredLength: 2, actualLength: 1 } }
     * ```
     *
     * @param {?} minLength
     * @return {?} A validator function that returns an error map with the
     * `minLength` if the validation check fails, otherwise `null`.
     */
    function (minLength) {
        /** @type {?} */
        var res = (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            /** @type {?} */
            var len = control.controls.length;
            return (len < minLength)
                ? { 'minLength': { 'requiredLength': minLength, 'actualLength': len } }
                : null;
        });
        return res;
    };
    /**
     * @description
     * Validator that is applied to a control that has an array of child controls.
     * It receives an object that fits the `RequiredProperty` interface and an array of child controls.
     * The behavior of the validator is the following:
     * If the control's value is required, then
     *   - all child controls must be different of empty.
     * If the control's value is not required, then
     *   - all child controls can be empty.
     *   - if there is at least one child control not empty, then all child controls must be different of empty.
     * The validator exists only as a function and not as a directive.
     *
     * @usageNotes
     *
     * ### Validates that the control does not have an empty child control:
     *
     * ```typescript
     * const control = new FormGroup({
     *     'fg': (firstGroup = new FormControl('2049')),
     *     'sg': (secondGroup = new FormControl(''))},
     *     ExtraValidators.requiredAndNotEmpty(this, [firstGroup, secondGroup]));
     *
     * console.log(control.errors); // { requiredAndNotEmpty: { required: true, pos: 1 } }
     * ```
     *
     * @returns A validator function that returns an error map with the `requiredAndNotEmpty`
     * if the validation check fails, otherwise `null`.
     */
    /**
     * \@description
     * Validator that is applied to a control that has an array of child controls.
     * It receives an object that fits the `RequiredProperty` interface and an array of child controls.
     * The behavior of the validator is the following:
     * If the control's value is required, then
     *   - all child controls must be different of empty.
     * If the control's value is not required, then
     *   - all child controls can be empty.
     *   - if there is at least one child control not empty, then all child controls must be different of empty.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the control does not have an empty child control:
     *
     * ```typescript
     * const control = new FormGroup({
     *     'fg': (firstGroup = new FormControl('2049')),
     *     'sg': (secondGroup = new FormControl(''))},
     *     ExtraValidators.requiredAndNotEmpty(this, [firstGroup, secondGroup]));
     *
     * console.log(control.errors); // { requiredAndNotEmpty: { required: true, pos: 1 } }
     * ```
     *
     * @param {?} requiredProperty
     * @param {?} childControls
     * @return {?} A validator function that returns an error map with the `requiredAndNotEmpty`
     * if the validation check fails, otherwise `null`.
     */
    ExtraValidators.requiredAndNotEmpty = /**
     * \@description
     * Validator that is applied to a control that has an array of child controls.
     * It receives an object that fits the `RequiredProperty` interface and an array of child controls.
     * The behavior of the validator is the following:
     * If the control's value is required, then
     *   - all child controls must be different of empty.
     * If the control's value is not required, then
     *   - all child controls can be empty.
     *   - if there is at least one child control not empty, then all child controls must be different of empty.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the control does not have an empty child control:
     *
     * ```typescript
     * const control = new FormGroup({
     *     'fg': (firstGroup = new FormControl('2049')),
     *     'sg': (secondGroup = new FormControl(''))},
     *     ExtraValidators.requiredAndNotEmpty(this, [firstGroup, secondGroup]));
     *
     * console.log(control.errors); // { requiredAndNotEmpty: { required: true, pos: 1 } }
     * ```
     *
     * @param {?} requiredProperty
     * @param {?} childControls
     * @return {?} A validator function that returns an error map with the `requiredAndNotEmpty`
     * if the validation check fails, otherwise `null`.
     */
    function (requiredProperty, childControls) {
        /** @type {?} */
        var res = (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            /** @type {?} */
            var i = 0;
            /** @type {?} */
            var controlsGroupLength = childControls.length;
            if (requiredProperty.required) {
                /* Only iterates to the first empty element. */
                for (; i < controlsGroupLength; i++) {
                    if (!childControls[i].value)
                        break;
                }
                return (i == controlsGroupLength)
                    ? null
                    : { 'requiredAndNotEmpty': { 'required': true, 'pos': i } };
            }
            else {
                /** @type {?} */
                var hasControlNotEmpty = false;
                /** @type {?} */
                var minEmptyPos = -1;
                /* Iterates to the first empty element. */
                for (; i < controlsGroupLength; i++) {
                    if (childControls[i].value) {
                        if (minEmptyPos != -1)
                            break;
                        hasControlNotEmpty = true;
                    }
                    else {
                        if (minEmptyPos == -1)
                            minEmptyPos = i;
                        if (hasControlNotEmpty)
                            break;
                    }
                }
                return (i == controlsGroupLength)
                    ? null
                    : { 'requiredAndNotEmpty': { 'required': true, 'pos': minEmptyPos } };
            }
        });
        return res;
    };
    /**
     * @description
     * Validator that requires the control's value pass an ISSN validation test (confirm the check digit).
     * Assumes that the code (control's value) is a string of length 11, with the form 'XXXX – XXXX'.
     * The validator exists only as a function and not as a directive.
     *
     * @usageNotes
     *
     * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
     *
     * ```typescript
     * const control = new FormControl('2049 – 3635', ExtraValidators.issnConfirmCheckDigitOneField(11));
     *
     * console.log(control.errors); // { issnConfirmCheckDigitOneField: true }
     * ```
     *
     * @returns A validator function that returns an error map with the `issnConfirmCheckDigitOneField`
     * if the validation check fails, otherwise `null`.
     */
    /**
     * \@description
     * Validator that requires the control's value pass an ISSN validation test (confirm the check digit).
     * Assumes that the code (control's value) is a string of length 11, with the form 'XXXX – XXXX'.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
     *
     * ```typescript
     * const control = new FormControl('2049 – 3635', ExtraValidators.issnConfirmCheckDigitOneField(11));
     *
     * console.log(control.errors); // { issnConfirmCheckDigitOneField: true }
     * ```
     *
     * @param {?} codeLength
     * @return {?} A validator function that returns an error map with the `issnConfirmCheckDigitOneField`
     * if the validation check fails, otherwise `null`.
     */
    ExtraValidators.issnConfirmCheckDigitOneField = /**
     * \@description
     * Validator that requires the control's value pass an ISSN validation test (confirm the check digit).
     * Assumes that the code (control's value) is a string of length 11, with the form 'XXXX – XXXX'.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
     *
     * ```typescript
     * const control = new FormControl('2049 – 3635', ExtraValidators.issnConfirmCheckDigitOneField(11));
     *
     * console.log(control.errors); // { issnConfirmCheckDigitOneField: true }
     * ```
     *
     * @param {?} codeLength
     * @return {?} A validator function that returns an error map with the `issnConfirmCheckDigitOneField`
     * if the validation check fails, otherwise `null`.
     */
    function (codeLength) {
        /** @type {?} */
        var res = (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            if (control.value.length == codeLength) {
                /** @type {?} */
                var code = control.value;
                /** @type {?} */
                var result = (code.charCodeAt(0) - 48) * 8;
                result += (code.charCodeAt(1) - 48) * 7;
                result += (code.charCodeAt(2) - 48) * 6;
                result += (code.charCodeAt(3) - 48) * 5;
                /* code[4] = ' ', code[5] = '–', code[6] = ' '. */
                result += (code.charCodeAt(7) - 48) * 4;
                result += (code.charCodeAt(8) - 48) * 3;
                result += (code.charCodeAt(9) - 48) * 2;
                result += ((code[10] == 'x') || (code[10] == 'X')) ? 10 : code.charCodeAt(10) - 48;
                return (result % 11)
                    ? { 'issnConfirmCheckDigitOneField': true }
                    : null;
            }
            return null;
        });
        return res;
    };
    /**
     * @description
     * Validator that requires the control's value passes an ISSN validation test (confirms the check digit).
     * The ISSN value is divided in two groups, therefore the control has two child controls and they are
     * arguments of the validator method. It assumes that the control's value is of string type.
     * The validator exists only as a function and not as a directive.
     *
     * @usageNotes
     *
     * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
     *
     * ```typescript
     * const control = new FormGroup({
     *     'fg': (firstGroup = new FormControl('2049')),
     *     'sg': (secondGroup = new FormControl('3635'))},
     *     ExtraValidators.issnConfirmCheckDigitTwoField(firstGroup, secondGroup, 4));
     *
     * console.log(control.errors); // { issnConfirmCheckDigitTwoField: true }
     * ```
     *
     * @returns A validator function that returns an error map with the `issnConfirmCheckDigitTwoField`
     * if the validation check fails, otherwise `null`.
     */
    /**
     * \@description
     * Validator that requires the control's value passes an ISSN validation test (confirms the check digit).
     * The ISSN value is divided in two groups, therefore the control has two child controls and they are
     * arguments of the validator method. It assumes that the control's value is of string type.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
     *
     * ```typescript
     * const control = new FormGroup({
     *     'fg': (firstGroup = new FormControl('2049')),
     *     'sg': (secondGroup = new FormControl('3635'))},
     *     ExtraValidators.issnConfirmCheckDigitTwoField(firstGroup, secondGroup, 4));
     *
     * console.log(control.errors); // { issnConfirmCheckDigitTwoField: true }
     * ```
     *
     * @param {?} firstGroup
     * @param {?} secondGroup
     * @param {?} groupLength
     * @return {?} A validator function that returns an error map with the `issnConfirmCheckDigitTwoField`
     * if the validation check fails, otherwise `null`.
     */
    ExtraValidators.issnConfirmCheckDigitTwoField = /**
     * \@description
     * Validator that requires the control's value passes an ISSN validation test (confirms the check digit).
     * The ISSN value is divided in two groups, therefore the control has two child controls and they are
     * arguments of the validator method. It assumes that the control's value is of string type.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
     *
     * ```typescript
     * const control = new FormGroup({
     *     'fg': (firstGroup = new FormControl('2049')),
     *     'sg': (secondGroup = new FormControl('3635'))},
     *     ExtraValidators.issnConfirmCheckDigitTwoField(firstGroup, secondGroup, 4));
     *
     * console.log(control.errors); // { issnConfirmCheckDigitTwoField: true }
     * ```
     *
     * @param {?} firstGroup
     * @param {?} secondGroup
     * @param {?} groupLength
     * @return {?} A validator function that returns an error map with the `issnConfirmCheckDigitTwoField`
     * if the validation check fails, otherwise `null`.
     */
    function (firstGroup, secondGroup, groupLength) {
        /** @type {?} */
        var res = (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            if ((firstGroup.value.length == groupLength) && (secondGroup.value.length == groupLength)) {
                /** @type {?} */
                var groupValue = firstGroup.value;
                /** @type {?} */
                var result = (groupValue.charCodeAt(0) - 48) * 8;
                result += (groupValue.charCodeAt(1) - 48) * 7;
                result += (groupValue.charCodeAt(2) - 48) * 6;
                result += (groupValue.charCodeAt(3) - 48) * 5;
                result += ((groupValue = secondGroup.value).charCodeAt(0) - 48) * 4;
                result += (groupValue.charCodeAt(1) - 48) * 3;
                result += (groupValue.charCodeAt(2) - 48) * 2;
                result += ((groupValue[3] == 'x') || (groupValue[3] == 'X')) ? 10 : groupValue.charCodeAt(3) - 48;
                return (result % 11)
                    ? { 'issnConfirmCheckDigitTwoField': true }
                    : null;
            }
            return null;
        });
        return res;
    };
    /**
     * @param {?} internalFormGroup
     * @return {?}
     */
    ExtraValidators.issnValidator = /**
     * @param {?} internalFormGroup
     * @return {?}
     */
    function (internalFormGroup) {
        /** @type {?} */
        var res = (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            return (!internalFormGroup.valid)
                ? { 'issnValidator': { 'requiredValid': internalFormGroup.valid } }
                : null;
        });
        return res;
    };
    return ExtraValidators;
}());
/**
 * \@description
 * Provides a set of extra validators that can be used by form controls.
 *
 * A validator is a function that processes a `FormControl` or collection of
 * controls and returns an error map or `null`. A `null` map means that validation has passed.
 *
 * @see [Form Validation](/guide/form-validation)
 */
export { ExtraValidators };
/**
 * \@description
 * A directive that represents a validator that requires the length of the control's value
 * to be equal to the provided length. The control must be marked with the `equalLength` attribute.
 * The directive is provided with the `NG_VALIDATORS` mult-provider list.
 * This validator is used with Template-driven Form; if you want to use an equivalent validator
 * with Reactive Forms you must use the `ExtraValidators.equalLength` method.
 *
 * \@usageNotes
 *
 * ### Validates that the field has a length of 4 characters:
 *
 * The following example shows how to add an equal length validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel equallength="4">
 * ```
 */
var EqualLengthDirective = /** @class */ (function () {
    function EqualLengthDirective() {
    }
    /**
     * @description
     * A lifecycle hook method that is called when the directive's inputs change. For internal use only.
     *
     * @param changes An object of key/value pairs for the set of changed inputs.
     */
    /**
     * \@description
     * A lifecycle hook method that is called when the directive's inputs change. For internal use only.
     *
     * @param {?} changes An object of key/value pairs for the set of changed inputs.
     * @return {?}
     */
    EqualLengthDirective.prototype.ngOnChanges = /**
     * \@description
     * A lifecycle hook method that is called when the directive's inputs change. For internal use only.
     *
     * @param {?} changes An object of key/value pairs for the set of changed inputs.
     * @return {?}
     */
    function (changes) {
        if ('equalLength' in changes) {
            this._validator = ExtraValidators.equalLength(parseInt(this.equalLength, 10));
            if (this._onChange)
                this._onChange();
        }
    };
    /**
     * @description
     * Method that performs synchronous validation against the provided control. It requires the length
     * of the control's value to be equal to the provided `equalLength`.
     *
     * @param control The control to validate against.
     *
     * @returns A map of validation errors if validation fails; otherwise, `null`.
     */
    /**
     * \@description
     * Method that performs synchronous validation against the provided control. It requires the length
     * of the control's value to be equal to the provided `equalLength`.
     *
     * @param {?} control The control to validate against.
     *
     * @return {?} A map of validation errors if validation fails; otherwise, `null`.
     */
    EqualLengthDirective.prototype.validate = /**
     * \@description
     * Method that performs synchronous validation against the provided control. It requires the length
     * of the control's value to be equal to the provided `equalLength`.
     *
     * @param {?} control The control to validate against.
     *
     * @return {?} A map of validation errors if validation fails; otherwise, `null`.
     */
    function (control) {
        return (this.equalLength)
            ? this._validator(control)
            : null;
    };
    /**
     * @description
     * Registers a callback function to call when the validator inputs change.
     *
     * @param fn The callback function to register.
     */
    /**
     * \@description
     * Registers a callback function to call when the validator inputs change.
     *
     * @param {?} fn The callback function to register.
     * @return {?}
     */
    EqualLengthDirective.prototype.registerOnValidatorChange = /**
     * \@description
     * Registers a callback function to call when the validator inputs change.
     *
     * @param {?} fn The callback function to register.
     * @return {?}
     */
    function (fn) {
        this._onChange = fn;
    };
    EqualLengthDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[equalLength]',
                    providers: [{
                            provide: NG_VALIDATORS,
                            useExisting: EqualLengthDirective,
                            multi: true
                        }]
                },] }
    ];
    EqualLengthDirective.propDecorators = {
        equalLength: [{ type: Input }]
    };
    return EqualLengthDirective;
}());
export { EqualLengthDirective };
if (false) {
    /**
     * \@description
     * Input variable that contains the length to check.
     * @type {?}
     */
    EqualLengthDirective.prototype.equalLength;
    /**
     * @type {?}
     * @private
     */
    EqualLengthDirective.prototype._validator;
    /**
     * @type {?}
     * @private
     */
    EqualLengthDirective.prototype._onChange;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vdG9jby1saWIvIiwic291cmNlcyI6WyJsaWIvY29yZS91dGlscy92YWxpZGF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQUUsU0FBUyxFQUFhLEtBQUssRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDM0UsT0FBTyxFQUEwRSxhQUFhLEVBQXdCLE1BQU0sZ0JBQWdCLENBQUM7Ozs7O0FBSzdJLHNDQU1DOzs7Ozs7SUFERyxvQ0FBMkI7Ozs7Ozs7Ozs7O0FBWS9COzs7Ozs7Ozs7O0lBQUE7SUFnUUEsQ0FBQztJQTlQRzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0F1Qkc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQ1csMkJBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBekIsVUFBMEIsV0FBbUI7O1lBRW5DLEdBQUc7Ozs7UUFBRyxVQUFDLE9BQXdCOztnQkFDM0IsR0FBRyxHQUFXLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTVELE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxXQUFXLENBQUMsQ0FBQztnQkFDdkMsQ0FBQyxDQUFDLEVBQUUsYUFBYSxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxHQUFHLEVBQUUsRUFBRTtnQkFDM0UsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUNmLENBQUMsQ0FBQTtRQUVELE9BQU8sR0FBRyxDQUFDO0lBQ2YsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUNXLHlCQUFTOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUF2QixVQUF3QixTQUFpQjs7WUFFL0IsR0FBRzs7OztRQUFHLFVBQUMsT0FBa0I7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QVUsQ0FBQyxPQUFPLENBQUM7WUFDMUIsQ0FBQyxDQUFDLElBQUksQ0FBQztJQUNmLENBQUM7SUFFRDs7Ozs7T0FLRzs7Ozs7Ozs7SUFDSSx3REFBeUI7Ozs7Ozs7SUFBaEMsVUFBaUMsRUFBYztRQUUzQyxJQUFJLENBQUMsU0FBUyxHQUFHLEVBQUUsQ0FBQztJQUN4QixDQUFDOztnQkE3REosU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxlQUFlO29CQUN6QixTQUFTLEVBQUUsQ0FBQzs0QkFDUixPQUFPLEVBQUUsYUFBYTs0QkFDdEIsV0FBVyxFQUFFLG9CQUFvQjs0QkFDakMsS0FBSyxFQUFFLElBQUk7eUJBQ2QsQ0FBQztpQkFDTDs7OzhCQU9JLEtBQUs7O0lBZ0RWLDJCQUFDO0NBQUEsQUE5REQsSUE4REM7U0F0RFksb0JBQW9COzs7Ozs7O0lBTTdCLDJDQUMyQjs7Ozs7SUFFM0IsMENBQWdDOzs7OztJQUNoQyx5Q0FBOEIiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IERpcmVjdGl2ZSwgT25DaGFuZ2VzLCBJbnB1dCwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sLCBGb3JtQ29udHJvbCwgVmFsaWRhdG9yRm4sIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciwgTkdfVkFMSURBVE9SUywgRm9ybUdyb3VwLCBGb3JtQXJyYXkgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNsYXNzIHRoYXQgY29udGFpbnMgYSBib29sZWFuIHByb3BlcnR5IG5hbWVkIGByZXF1aXJlZGAuIFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFJlcXVpcmVkUHJvcGVydHlcbntcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyb2wgaXMgcmVxdWlyZWQ7IG90aGVyd2lzZSwgZmFsc2UuIFxuICAgICAqL1xuICAgIHJlYWRvbmx5IHJlcXVpcmVkOiBib29sZWFuO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogUHJvdmlkZXMgYSBzZXQgb2YgZXh0cmEgdmFsaWRhdG9ycyB0aGF0IGNhbiBiZSB1c2VkIGJ5IGZvcm0gY29udHJvbHMuIFxuICpcbiAqIEEgdmFsaWRhdG9yIGlzIGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgYSBgRm9ybUNvbnRyb2xgIG9yIGNvbGxlY3Rpb24gb2YgXG4gKiBjb250cm9scyBhbmQgcmV0dXJucyBhbiBlcnJvciBtYXAgb3IgYG51bGxgLiBBIGBudWxsYCBtYXAgbWVhbnMgdGhhdCB2YWxpZGF0aW9uIGhhcyBwYXNzZWQuIFxuICpcbiAqIEBzZWUgW0Zvcm0gVmFsaWRhdGlvbl0oL2d1aWRlL2Zvcm0tdmFsaWRhdGlvbilcbiAqL1xuZXhwb3J0IGNsYXNzIEV4dHJhVmFsaWRhdG9yc1xue1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBsZW5ndGggb2YgdGhlIGNvbnRyb2wncyB2YWx1ZSB0byBiZSBlcXVhbCB0byB0aGUgXG4gICAgICogcHJvdmlkZWQgbGVuZ3RoLiBJdCBhc3N1bWVzIHRoYXQgdGhlIGNvbnRyb2wncyB2YWx1ZSBpcyBvZiBzdHJpbmcgdHlwZS4gXG4gICAgICogVGhpcyB2YWxpZGF0b3IgaXMgdXNlZCB3aXRoIFJlYWN0aXZlIEZvcm1zOyBpZiB5b3Ugd2FudCB0byB1c2UgXG4gICAgICogYW4gZXF1aXZhbGVudCB2YWxpZGF0b3Igd2l0aCBUZW1wbGF0ZS1kcml2ZW4gRm9ybSB5b3UgbXVzdCB1c2UgdGhlIGBlcXVhbExlbmd0aGAgYXR0cmlidXRlLiBcbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGVzIHRoYXQgdGhlIGZpZWxkIGhhcyBhIGxlbmd0aCBvZiA0IGNoYXJhY3RlcnM6IFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdCBcbiAgICAgKiBjb25zdCBjb250cm9sID0gbmV3IEZvcm1Db250cm9sKCduZycsIEV4dHJhVmFsaWRhdG9ycy5lcXVhbExlbmd0aCg0KSk7IFxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7IGVxdWFsTGVuZ3RoOiB7IHJlcXVpcmVkTGVuZ3RoOiA0LCBhY3R1YWxMZW5ndGg6IDIgfSB9IFxuICAgICAqIGBgYCBcbiAgICAgKlxuICAgICAqIGBgYGh0bWwgXG4gICAgICogPGlucHV0IG5hbWU9XCJmaXJzdE5hbWVcIiBuZ01vZGVsIGVxdWFsbGVuZ3RoPVwiNFwiPiBcbiAgICAgKiBgYGAgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZXJyb3IgbWFwIHdpdGggdGhlIGBlcXVhbExlbmd0aGAgXG4gICAgICogaWYgdGhlIHZhbGlkYXRpb24gY2hlY2sgZmFpbHMsIG90aGVyd2lzZSBgbnVsbGAuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZXF1YWxMZW5ndGgoZXF1YWxMZW5ndGg6IG51bWJlcik6IFZhbGlkYXRvckZuXG4gICAge1xuICAgICAgICBjb25zdCByZXMgPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuOiBudW1iZXIgPSBjb250cm9sLnZhbHVlID8gY29udHJvbC52YWx1ZS5sZW5ndGggOiAwO1xuXG4gICAgICAgICAgICByZXR1cm4gKChsZW4gIT0gMCkgJiYgKGxlbiAhPSBlcXVhbExlbmd0aCkpIFxuICAgICAgICAgICAgICAgID8geyAnZXF1YWxMZW5ndGgnOiB7ICdyZXF1aXJlZExlbmd0aCc6IGVxdWFsTGVuZ3RoLCAnYWN0dWFsTGVuZ3RoJzogbGVuIH0gfSBcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCBpcyBhcHBsaWVkIHRvIGBGb3JtQXJyYXlgIGNvbnRyb2xzLiBJdCByZXF1aXJlcyB0aGF0IHRoZSBhbW91bnQgb2YgXG5cdCAqIGBGb3JtQXJyYXlgJ3MgY2hpbGQgY29udHJvbHMgdG8gYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwcm92aWRlZCBtaW5pbXVtIGxlbmd0aC4gXG5cdCAqIFRoZSB2YWxpZGF0b3IgZXhpc3RzIG9ubHkgYXMgYSBmdW5jdGlvbiBhbmQgbm90IGFzIGEgZGlyZWN0aXZlLiBcbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGVzIHRoYXQgdGhlIGBGb3JtQXJyYXlgIGZpZWxkIGhhcyBhIG1pbmltdW0gb2YgMiBjaGlsZCBjb250cm9sczogXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0IFxuICAgICAqIGNvbnN0IGZvcm1BcnJheUNvbnRyb2wgPSBuZXcgRm9ybUFycmF5KFtuZXcgRm9ybUNvbnRyb2woJ25nJyldLCBFeHRyYVZhbGlkYXRvcnMubWluTGVuZ3RoKDIpKTsgXG4gICAgICpcblx0ICogY29uc29sZS5sb2coZm9ybUFycmF5Q29udHJvbC5lcnJvcnMpOyAvLyB7IG1pbkxlbmd0aDogeyByZXF1aXJlZExlbmd0aDogMiwgYWN0dWFsTGVuZ3RoOiAxIH0gfSBcbiAgICAgKiBgYGAgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZXJyb3IgbWFwIHdpdGggdGhlIFxuICAgICAqIGBtaW5MZW5ndGhgIGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG1pbkxlbmd0aChtaW5MZW5ndGg6IG51bWJlcik6IFZhbGlkYXRvckZuXG4gICAge1xuICAgICAgICBjb25zdCByZXMgPSAoY29udHJvbDogRm9ybUFycmF5KTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuOiBudW1iZXIgPSBjb250cm9sLmNvbnRyb2xzLmxlbmd0aDtcblxuICAgICAgICAgICAgcmV0dXJuIChsZW4gPCBtaW5MZW5ndGgpIFxuICAgICAgICAgICAgICAgID8geyAnbWluTGVuZ3RoJzogeyAncmVxdWlyZWRMZW5ndGgnOiBtaW5MZW5ndGgsICdhY3R1YWxMZW5ndGgnOiBsZW4gfSB9IFxuICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRvciB0aGF0IGlzIGFwcGxpZWQgdG8gYSBjb250cm9sIHRoYXQgaGFzIGFuIGFycmF5IG9mIGNoaWxkIGNvbnRyb2xzLiBcbiAgICAgKiBJdCByZWNlaXZlcyBhbiBvYmplY3QgdGhhdCBmaXRzIHRoZSBgUmVxdWlyZWRQcm9wZXJ0eWAgaW50ZXJmYWNlIGFuZCBhbiBhcnJheSBvZiBjaGlsZCBjb250cm9scy4gXG4gICAgICogVGhlIGJlaGF2aW9yIG9mIHRoZSB2YWxpZGF0b3IgaXMgdGhlIGZvbGxvd2luZzogXG4gICAgICogSWYgdGhlIGNvbnRyb2wncyB2YWx1ZSBpcyByZXF1aXJlZCwgdGhlbiBcbiAgICAgKiAgIC0gYWxsIGNoaWxkIGNvbnRyb2xzIG11c3QgYmUgZGlmZmVyZW50IG9mIGVtcHR5LiBcbiAgICAgKiBJZiB0aGUgY29udHJvbCdzIHZhbHVlIGlzIG5vdCByZXF1aXJlZCwgdGhlbiBcbiAgICAgKiAgIC0gYWxsIGNoaWxkIGNvbnRyb2xzIGNhbiBiZSBlbXB0eS4gXG4gICAgICogICAtIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBjaGlsZCBjb250cm9sIG5vdCBlbXB0eSwgdGhlbiBhbGwgY2hpbGQgY29udHJvbHMgbXVzdCBiZSBkaWZmZXJlbnQgb2YgZW1wdHkuIFxuICAgICAqIFRoZSB2YWxpZGF0b3IgZXhpc3RzIG9ubHkgYXMgYSBmdW5jdGlvbiBhbmQgbm90IGFzIGEgZGlyZWN0aXZlLiBcbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGVzIHRoYXQgdGhlIGNvbnRyb2wgZG9lcyBub3QgaGF2ZSBhbiBlbXB0eSBjaGlsZCBjb250cm9sOiBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHQgXG4gICAgICogY29uc3QgY29udHJvbCA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgICAnZmcnOiAoZmlyc3RHcm91cCA9IG5ldyBGb3JtQ29udHJvbCgnMjA0OScpKSwgXG4gICAgICogICAgICdzZyc6IChzZWNvbmRHcm91cCA9IG5ldyBGb3JtQ29udHJvbCgnJykpfSwgXG4gICAgICogICAgIEV4dHJhVmFsaWRhdG9ycy5yZXF1aXJlZEFuZE5vdEVtcHR5KHRoaXMsIFtmaXJzdEdyb3VwLCBzZWNvbmRHcm91cF0pKTsgXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHsgcmVxdWlyZWRBbmROb3RFbXB0eTogeyByZXF1aXJlZDogdHJ1ZSwgcG9zOiAxIH0gfSBcbiAgICAgKiBgYGAgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZXJyb3IgbWFwIHdpdGggdGhlIGByZXF1aXJlZEFuZE5vdEVtcHR5YCBcbiAgICAgKiBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC4gXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyByZXF1aXJlZEFuZE5vdEVtcHR5KHJlcXVpcmVkUHJvcGVydHk6IFJlcXVpcmVkUHJvcGVydHksIGNoaWxkQ29udHJvbHM6IEZvcm1Db250cm9sW10pOiBWYWxpZGF0b3JGblxuICAgIHtcbiAgICAgICAgY29uc3QgcmVzID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgICAgICAgIGxldCBpOiBudW1iZXIgPSAwO1xuICAgICAgICAgICAgbGV0IGNvbnRyb2xzR3JvdXBMZW5ndGg6IG51bWJlciA9IGNoaWxkQ29udHJvbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAocmVxdWlyZWRQcm9wZXJ0eS5yZXF1aXJlZClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvKiBPbmx5IGl0ZXJhdGVzIHRvIHRoZSBmaXJzdCBlbXB0eSBlbGVtZW50LiAqL1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgY29udHJvbHNHcm91cExlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGlsZENvbnRyb2xzW2ldLnZhbHVlKSBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKGkgPT0gY29udHJvbHNHcm91cExlbmd0aCkgXG4gICAgICAgICAgICAgICAgICAgID8gbnVsbCBcbiAgICAgICAgICAgICAgICAgICAgOiB7ICdyZXF1aXJlZEFuZE5vdEVtcHR5JzogeyAncmVxdWlyZWQnOiB0cnVlLCAncG9zJzogaSB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGhhc0NvbnRyb2xOb3RFbXB0eTogYm9vbGVhbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBtaW5FbXB0eVBvczogbnVtYmVyID0gLTE7XG5cbiAgICAgICAgICAgICAgICAvKiBJdGVyYXRlcyB0byB0aGUgZmlyc3QgZW1wdHkgZWxlbWVudC4gKi9cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNvbnRyb2xzR3JvdXBMZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZENvbnRyb2xzW2ldLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluRW1wdHlQb3MgIT0gLTEpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29udHJvbE5vdEVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5FbXB0eVBvcyA9PSAtMSkgbWluRW1wdHlQb3MgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0NvbnRyb2xOb3RFbXB0eSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKGkgPT0gY29udHJvbHNHcm91cExlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgICAgIDogeyAncmVxdWlyZWRBbmROb3RFbXB0eSc6IHsgJ3JlcXVpcmVkJzogdHJ1ZSwgJ3Bvcyc6IG1pbkVtcHR5UG9zIH0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sJ3MgdmFsdWUgcGFzcyBhbiBJU1NOIHZhbGlkYXRpb24gdGVzdCAoY29uZmlybSB0aGUgY2hlY2sgZGlnaXQpLiBcbiAgICAgKiBBc3N1bWVzIHRoYXQgdGhlIGNvZGUgKGNvbnRyb2wncyB2YWx1ZSkgaXMgYSBzdHJpbmcgb2YgbGVuZ3RoIDExLCB3aXRoIHRoZSBmb3JtICdYWFhYIOKAkyBYWFhYJy4gXG4gICAgICogVGhlIHZhbGlkYXRvciBleGlzdHMgb25seSBhcyBhIGZ1bmN0aW9uIGFuZCBub3QgYXMgYSBkaXJlY3RpdmUuIFxuICAgICAqXG4gICAgICogQHVzYWdlTm90ZXNcbiAgICAgKlxuICAgICAqICMjIyBWYWxpZGF0ZXMgdGhhdCB0aGUgZmllbGQgbWF0Y2hlcyBhIHZhbGlkIElTU04gcGF0dGVybiAoY29uZmlybXMgdGhlIGNoZWNrIGRpZ2l0KTogXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0IFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woJzIwNDkg4oCTIDM2MzUnLCBFeHRyYVZhbGlkYXRvcnMuaXNzbkNvbmZpcm1DaGVja0RpZ2l0T25lRmllbGQoMTEpKTsgXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHsgaXNzbkNvbmZpcm1DaGVja0RpZ2l0T25lRmllbGQ6IHRydWUgfSBcbiAgICAgKiBgYGAgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZXJyb3IgbWFwIHdpdGggdGhlIGBpc3NuQ29uZmlybUNoZWNrRGlnaXRPbmVGaWVsZGAgXG4gICAgICogaWYgdGhlIHZhbGlkYXRpb24gY2hlY2sgZmFpbHMsIG90aGVyd2lzZSBgbnVsbGAuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaXNzbkNvbmZpcm1DaGVja0RpZ2l0T25lRmllbGQoY29kZUxlbmd0aDogbnVtYmVyKTogVmFsaWRhdG9yRm5cbiAgICB7XG4gICAgICAgIGNvbnN0IHJlcyA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgICAgICAgICBpZiAoY29udHJvbC52YWx1ZS5sZW5ndGggPT0gY29kZUxlbmd0aClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgY29kZTogc3RyaW5nID0gY29udHJvbC52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ6IG51bWJlciA9IChjb2RlLmNoYXJDb2RlQXQoMCkgLSA0OCkgKiA4O1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoY29kZS5jaGFyQ29kZUF0KDEpIC0gNDgpICogNztcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gKGNvZGUuY2hhckNvZGVBdCgyKSAtIDQ4KSAqIDY7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IChjb2RlLmNoYXJDb2RlQXQoMykgLSA0OCkgKiA1O1xuXG4gICAgICAgICAgICAgICAgLyogY29kZVs0XSA9ICcgJywgY29kZVs1XSA9ICfigJMnLCBjb2RlWzZdID0gJyAnLiAqL1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IChjb2RlLmNoYXJDb2RlQXQoNykgLSA0OCkgKiA0O1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoY29kZS5jaGFyQ29kZUF0KDgpIC0gNDgpICogMztcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gKGNvZGUuY2hhckNvZGVBdCg5KSAtIDQ4KSAqIDI7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICgoY29kZVsxMF0gPT0gJ3gnKSB8fCAoY29kZVsxMF0gPT0gJ1gnKSkgPyAxMCA6IGNvZGUuY2hhckNvZGVBdCgxMCkgLSA0ODtcblxuICAgICAgICAgICAgICAgIHJldHVybiAocmVzdWx0ICUgMTEpIFxuICAgICAgICAgICAgICAgICAgICA/IHsgJ2lzc25Db25maXJtQ2hlY2tEaWdpdE9uZUZpZWxkJzogdHJ1ZSB9IFxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGNvbnRyb2wncyB2YWx1ZSBwYXNzZXMgYW4gSVNTTiB2YWxpZGF0aW9uIHRlc3QgKGNvbmZpcm1zIHRoZSBjaGVjayBkaWdpdCkuIFxuICAgICAqIFRoZSBJU1NOIHZhbHVlIGlzIGRpdmlkZWQgaW4gdHdvIGdyb3VwcywgdGhlcmVmb3JlIHRoZSBjb250cm9sIGhhcyB0d28gY2hpbGQgY29udHJvbHMgYW5kIHRoZXkgYXJlIFxuICAgICAqIGFyZ3VtZW50cyBvZiB0aGUgdmFsaWRhdG9yIG1ldGhvZC4gSXQgYXNzdW1lcyB0aGF0IHRoZSBjb250cm9sJ3MgdmFsdWUgaXMgb2Ygc3RyaW5nIHR5cGUuIFxuICAgICAqIFRoZSB2YWxpZGF0b3IgZXhpc3RzIG9ubHkgYXMgYSBmdW5jdGlvbiBhbmQgbm90IGFzIGEgZGlyZWN0aXZlLiBcbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGVzIHRoYXQgdGhlIGZpZWxkIG1hdGNoZXMgYSB2YWxpZCBJU1NOIHBhdHRlcm4gKGNvbmZpcm1zIHRoZSBjaGVjayBkaWdpdCk6IFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdCBcbiAgICAgKiBjb25zdCBjb250cm9sID0gbmV3IEZvcm1Hcm91cCh7XG4gICAgICogICAgICdmZyc6IChmaXJzdEdyb3VwID0gbmV3IEZvcm1Db250cm9sKCcyMDQ5JykpLCBcbiAgICAgKiAgICAgJ3NnJzogKHNlY29uZEdyb3VwID0gbmV3IEZvcm1Db250cm9sKCczNjM1JykpfSwgXG4gICAgICogICAgIEV4dHJhVmFsaWRhdG9ycy5pc3NuQ29uZmlybUNoZWNrRGlnaXRUd29GaWVsZChmaXJzdEdyb3VwLCBzZWNvbmRHcm91cCwgNCkpOyBcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGNvbnRyb2wuZXJyb3JzKTsgLy8geyBpc3NuQ29uZmlybUNoZWNrRGlnaXRUd29GaWVsZDogdHJ1ZSB9IFxuICAgICAqIGBgYCBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgdmFsaWRhdG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlcnJvciBtYXAgd2l0aCB0aGUgYGlzc25Db25maXJtQ2hlY2tEaWdpdFR3b0ZpZWxkYCBcbiAgICAgKiBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC4gXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBpc3NuQ29uZmlybUNoZWNrRGlnaXRUd29GaWVsZChmaXJzdEdyb3VwOiBGb3JtQ29udHJvbCwgc2Vjb25kR3JvdXA6IEZvcm1Db250cm9sLCBncm91cExlbmd0aDogbnVtYmVyKTogVmFsaWRhdG9yRm5cbiAgICB7XG4gICAgICAgIGNvbnN0IHJlcyA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgICAgICAgICBpZiAoKGZpcnN0R3JvdXAudmFsdWUubGVuZ3RoID09IGdyb3VwTGVuZ3RoKSAmJiAoc2Vjb25kR3JvdXAudmFsdWUubGVuZ3RoID09IGdyb3VwTGVuZ3RoKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsZXQgZ3JvdXBWYWx1ZTogc3RyaW5nID0gZmlyc3RHcm91cC52YWx1ZTtcblxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQ6IG51bWJlciA9IChncm91cFZhbHVlLmNoYXJDb2RlQXQoMCkgLSA0OCkgKiA4O1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoZ3JvdXBWYWx1ZS5jaGFyQ29kZUF0KDEpIC0gNDgpICogNztcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gKGdyb3VwVmFsdWUuY2hhckNvZGVBdCgyKSAtIDQ4KSAqIDY7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IChncm91cFZhbHVlLmNoYXJDb2RlQXQoMykgLSA0OCkgKiA1O1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICgoZ3JvdXBWYWx1ZSA9IHNlY29uZEdyb3VwLnZhbHVlKS5jaGFyQ29kZUF0KDApIC0gNDgpICogNDtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gKGdyb3VwVmFsdWUuY2hhckNvZGVBdCgxKSAtIDQ4KSAqIDM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IChncm91cFZhbHVlLmNoYXJDb2RlQXQoMikgLSA0OCkgKiAyO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoKGdyb3VwVmFsdWVbM10gPT0gJ3gnKSB8fCAoZ3JvdXBWYWx1ZVszXSA9PSAnWCcpKSA/IDEwIDogZ3JvdXBWYWx1ZS5jaGFyQ29kZUF0KDMpIC0gNDg7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCAlIDExKSBcbiAgICAgICAgICAgICAgICAgICAgPyB7ICdpc3NuQ29uZmlybUNoZWNrRGlnaXRUd29GaWVsZCc6IHRydWUgfSBcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgaXNzblZhbGlkYXRvcihpbnRlcm5hbEZvcm1Hcm91cDogRm9ybUdyb3VwKTogVmFsaWRhdG9yRm5cbiAgICB7XG4gICAgICAgIGNvbnN0IHJlcyA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKCFpbnRlcm5hbEZvcm1Hcm91cC52YWxpZCkgXG4gICAgICAgICAgICAgICAgPyB7ICdpc3NuVmFsaWRhdG9yJzogeyAncmVxdWlyZWRWYWxpZCc6IGludGVybmFsRm9ybUdyb3VwLnZhbGlkIH0gfSBcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IHJlcHJlc2VudHMgYSB2YWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9sJ3MgdmFsdWUgXG4gKiB0byBiZSBlcXVhbCB0byB0aGUgcHJvdmlkZWQgbGVuZ3RoLiBUaGUgY29udHJvbCBtdXN0IGJlIG1hcmtlZCB3aXRoIHRoZSBgZXF1YWxMZW5ndGhgIGF0dHJpYnV0ZS4gXG4gKiBUaGUgZGlyZWN0aXZlIGlzIHByb3ZpZGVkIHdpdGggdGhlIGBOR19WQUxJREFUT1JTYCBtdWx0LXByb3ZpZGVyIGxpc3QuIFxuICogVGhpcyB2YWxpZGF0b3IgaXMgdXNlZCB3aXRoIFRlbXBsYXRlLWRyaXZlbiBGb3JtOyBpZiB5b3Ugd2FudCB0byB1c2UgYW4gZXF1aXZhbGVudCB2YWxpZGF0b3IgXG4gKiB3aXRoIFJlYWN0aXZlIEZvcm1zIHlvdSBtdXN0IHVzZSB0aGUgYEV4dHJhVmFsaWRhdG9ycy5lcXVhbExlbmd0aGAgbWV0aG9kLiBcbiAqXG4gKiBAdXNhZ2VOb3Rlc1xuICpcbiAqICMjIyBWYWxpZGF0ZXMgdGhhdCB0aGUgZmllbGQgaGFzIGEgbGVuZ3RoIG9mIDQgY2hhcmFjdGVyczogXG4gKlxuICogVGhlIGZvbGxvd2luZyBleGFtcGxlIHNob3dzIGhvdyB0byBhZGQgYW4gZXF1YWwgbGVuZ3RoIHZhbGlkYXRvciB0byBhbiBpbnB1dCBhdHRhY2hlZCB0byBhbiBcbiAqIG5nTW9kZWwgYmluZGluZy4gXG4gKlxuICogYGBgaHRtbCBcbiAqIDxpbnB1dCBuYW1lPVwiZmlyc3ROYW1lXCIgbmdNb2RlbCBlcXVhbGxlbmd0aD1cIjRcIj4gXG4gKiBgYGAgXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2VxdWFsTGVuZ3RoXScsXG4gICAgcHJvdmlkZXJzOiBbeyBcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMSURBVE9SUywgXG4gICAgICAgIHVzZUV4aXN0aW5nOiBFcXVhbExlbmd0aERpcmVjdGl2ZSwgXG4gICAgICAgIG11bHRpOiB0cnVlXG4gICAgfV1cbn0pXG5leHBvcnQgY2xhc3MgRXF1YWxMZW5ndGhEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkNoYW5nZXMsIFZhbGlkYXRvclxue1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIElucHV0IHZhcmlhYmxlIHRoYXQgY29udGFpbnMgdGhlIGxlbmd0aCB0byBjaGVjay4gXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZXF1YWxMZW5ndGg6IHN0cmluZztcblxuICAgIHByaXZhdGUgX3ZhbGlkYXRvcjogVmFsaWRhdG9yRm47XG4gICAgcHJpdmF0ZSBfb25DaGFuZ2U6ICgpID0+IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBBIGxpZmVjeWNsZSBob29rIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBkaXJlY3RpdmUncyBpbnB1dHMgY2hhbmdlLiBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuIFxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5nZXMgQW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBmb3IgdGhlIHNldCBvZiBjaGFuZ2VkIGlucHV0cy4gXG4gICAgICovXG4gICAgcHVibGljIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkXG4gICAge1xuICAgICAgICBpZignZXF1YWxMZW5ndGgnIGluIGNoYW5nZXMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRvciA9IEV4dHJhVmFsaWRhdG9ycy5lcXVhbExlbmd0aChwYXJzZUludCh0aGlzLmVxdWFsTGVuZ3RoLCAxMCkpO1xuXG4gICAgICAgICAgICBpZih0aGlzLl9vbkNoYW5nZSkgdGhpcy5fb25DaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgIH0gICAgXG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBNZXRob2QgdGhhdCBwZXJmb3JtcyBzeW5jaHJvbm91cyB2YWxpZGF0aW9uIGFnYWluc3QgdGhlIHByb3ZpZGVkIGNvbnRyb2wuIEl0IHJlcXVpcmVzIHRoZSBsZW5ndGggXG4gICAgICogb2YgdGhlIGNvbnRyb2wncyB2YWx1ZSB0byBiZSBlcXVhbCB0byB0aGUgcHJvdmlkZWQgYGVxdWFsTGVuZ3RoYC4gXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJvbCBUaGUgY29udHJvbCB0byB2YWxpZGF0ZSBhZ2FpbnN0LiBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbWFwIG9mIHZhbGlkYXRpb24gZXJyb3JzIGlmIHZhbGlkYXRpb24gZmFpbHM7IG90aGVyd2lzZSwgYG51bGxgLiBcbiAgICAgKi8gICAgXG4gICAgcHVibGljIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsXG4gICAge1xuICAgICAgICByZXR1cm4gKHRoaXMuZXF1YWxMZW5ndGgpIFxuICAgICAgICAgICAgPyB0aGlzLl92YWxpZGF0b3IoY29udHJvbCkgXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogUmVnaXN0ZXJzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIHRoZSB2YWxpZGF0b3IgaW5wdXRzIGNoYW5nZS4gXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJlZ2lzdGVyLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZShmbjogKCkgPT4gdm9pZCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlID0gZm47XG4gICAgfVxufVxuIl19