/**
 * @fileoverview added by tsickle
 * Generated from: lib/core/utils/helpers.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { HttpEventType } from '@angular/common/http';
import { isArray, isRegExp, isDate, isError, isObject } from 'util';
/**
 * Corresponds to `Number.MAX_SAFE_INTEGER`. Moved out into a variable here due to
 * flaky browser support and the value not being defined in Closure's typings.
 * @type {?}
 */
export var MAX_SAFE_INTEGER = 9007199254740991;
/**
 * The markdown file extension.
 * @type {?}
 */
export var MARKDOWN_FILE_EXTENSION = '.md';
/** @enum {string} */
var ActionText = {
    /**
     * Viewing action.
     */
    view: "view",
    /**
     * Adding action.
     */
    add: "add",
    /**
     * Editing action.
     */
    edit: "edit",
};
export { ActionText };
/** @enum {string} */
var LanguageTexts = {
    /**
     * The Spanish language.
     */
    Español: "Espa\u00F1ol",
    /**
     * The English language.
     */
    English: "English",
};
export { LanguageTexts };
/** @enum {string} */
var LanguageAbbrs = {
    /**
     * The Spanish language abbreviation.
     */
    es: "es",
    /**
     * The English language abbreviation.
     */
    en: "en",
};
export { LanguageAbbrs };
/**
 * The list of language texts.
 * @type {?}
 */
export var LANGUAGE_TEXTS_LIST = [LanguageTexts.Español, LanguageTexts.English];
/**
 * The list of language text abbreviations.
 * @type {?}
 */
export var LANGUAGE_ABBRS_LIST = [LanguageAbbrs.es, LanguageAbbrs.en];
/**
 * Converts the language representation from string to number.
 * If the string specified is not registered as a language, then returns -1 number value.
 * The Spanish language is: 0 as number, and 'es' as string.
 * The English language is: 1 as number, and 'en' as string.
 * In other words, it follows the order of `LANGUAGE_TEXTS_LIST` and `LANGUAGE_ABBRS_LIST` enums.
 * @param {?} lang The language text abbreviation to be used.
 * @return {?} Returns the language as a number based on its representation as string.
 * If the string specified is not registered as a language, then returns -1 number value.
 */
export function convertLangFromStringToNumber(lang) {
    switch (lang) {
        case LanguageAbbrs.es: /* Spanish */
            {
                return 0;
            }
        case LanguageAbbrs.en: /* English */
            {
                return 1;
            }
    }
    return -1;
}
/**
 * Converts the language representation from number to string.
 * If the number specified is not registered as a language, then returns empty string value.
 * The Spanish language is: 0 as number, and 'es' as string.
 * The English language is: 1 as number, and 'en' as string.
 * In other words, it follows the order of `LANGUAGE_TEXTS_LIST` and `LANGUAGE_ABBRS_LIST` enums.
 * @param {?} index The language representation as number.
 * @return {?} Returns the language as a string based on its representation as number.
 * If the number specified is not registered as a language, then returns empty string value.
 */
export function convertLangFromNumberToString(index) {
    switch (index) {
        case 0: /* Spanish */
            {
                return LanguageAbbrs.es;
            }
        case 1: /* English */
            {
                return LanguageAbbrs.en;
            }
    }
    return '';
}
/**
 * Returns a string that is the result of concatenating the specified `path` argument,
 * the language extension, and the markdown file extension.
 * @param {?} path The path to markdown file without the language extension and the markdown file extension.
 * @param {?} lang The language text abbreviation to be used.
 * @return {?} Returns the correct path to the markdown file.
 */
export function getPathWithLangExtension(path, lang) {
    return (path + '.' + lang + MARKDOWN_FILE_EXTENSION);
}
/**
 * Returns true if the specified `possDescendant` is descendant from the specified `ancestorName`;
 * otherwise, false.
 * @param {?} possDescendant Possible descendant.
 * @param {?} ancestorName Ancestor name.
 * Example in usage:
 *  if (isDescendant(target.controlType.__proto__, InputControl.name)) { ... }
 * @return {?}
 */
export function isDescendant(possDescendant, ancestorName) {
    do {
        if (possDescendant.name == ancestorName)
            return true;
    } while ((possDescendant = possDescendant.__proto__).name != '');
    return false;
}
/**
 * Returns a new value that represents the clone of the specified `target` value.
 * Implementation notes:
 *  - If `target` is `undefined`, then returns `undefined`.
 *  - If `target` is an object, then returns a cloned object with all its properties cloned.
 *  - If `target` is an array, then returns a cloned array with all its values cloned.
 * @param {?} target The target value to clone.
 * @return {?}
 */
export function cloneValue(target) {
    if (isArray(target)) {
        return _cloneValue(target, []);
    }
    else if (isRegExp(target)) {
        return target; /* It can return `target` directly because all fields in a `RegExp` are read-only. */
    }
    else if (isDate(target)) {
        return new Date(target);
    }
    else if (isError(target)) {
        return target; /* It can return `target` directly because an `Error` is extremely dependent of the place where it is created. */
    }
    else if (isObject(target)) {
        return _cloneValue(target, {});
    }
    else {
        return target;
    }
}
/**
 * @param {?} target
 * @param {?} container
 * @return {?}
 */
function _cloneValue(target, container) {
    /** @type {?} */
    var temp;
    for (var prop in target) {
        temp = target[prop];
        if (isArray(temp)) {
            container[prop] = _cloneValue(temp, []);
        }
        else if (isRegExp(temp)) {
            container[prop] = temp; /* It can return `temp` directly because all fields in a `RegExp` are read-only. */
        }
        else if (isDate(temp)) {
            container[prop] = new Date(temp);
        }
        else if (isError(temp)) {
            container[prop] = temp; /* It can return `temp` directly because an `Error` is extremely dependent of the place where it is created. */
        }
        else if (isObject(temp)) {
            container[prop] = _cloneValue(temp, {});
        }
        else {
            container[prop] = temp;
        }
    }
    return container;
}
/**
 * Returns a new value that represents the clone of the specified `target` value, and
 * sets all its properties/values of built-in type to `undefined`.
 * Implementation notes:
 *  - If `target` is `undefined`, then returns `undefined`.
 *  - If `target` is an object, then returns an object with all its properties of built-in type to `undefined`.
 *  - If `target` is an array, then returns an array with all its values of built-in type to `undefined`.
 * @param {?} target The target value to clone.
 * @return {?}
 */
export function cloneValueToUndefined(target) {
    if (isArray(target)) {
        return _cloneValueToUndefined(target, []);
    }
    else if (isRegExp(target)) {
        return undefined;
    }
    else if (isDate(target)) {
        return undefined;
    }
    else if (isError(target)) {
        return undefined;
    }
    else if (isObject(target)) {
        return _cloneValueToUndefined(target, {});
    }
    else {
        return undefined;
    }
}
/**
 * @param {?} target
 * @param {?} container
 * @return {?}
 */
function _cloneValueToUndefined(target, container) {
    /** @type {?} */
    var temp;
    for (var prop in target) {
        temp = target[prop];
        if (isArray(temp)) {
            container[prop] = _cloneValueToUndefined(temp, []);
        }
        else if (isRegExp(target)) {
            container[prop] = undefined;
        }
        else if (isDate(target)) {
            container[prop] = undefined;
        }
        else if (isError(target)) {
            container[prop] = undefined;
        }
        else if (isObject(temp)) {
            container[prop] = _cloneValueToUndefined(temp, {});
        }
        else {
            container[prop] = undefined;
        }
    }
    return container;
}
/**
 * Logs an error notification message to the console.
 * @param {?} operation The operation during the error occurs.
 * @param {?} place The place where the error occurs.
 * @param {?} err The error that occurs.
 * @return {?}
 */
export function logError(operation, place, err) {
    console.log("The observable got an error '" + operation + "' in '" + place + "': " + err + ".");
}
/**
 * Logs a complete notification message to the console.
 * @param {?} operation The operation during the complete occurs.
 * @param {?} place The place where the complete occurs.
 * @return {?}
 */
export function logComplete(operation, place) {
    console.log("The observable got a complete notification '" + operation + "' in '" + place + "'.");
}
/**
 * Returns a string representation of `HttpEventType` specified.
 * @param {?} httpEventType Type enumeration for the different kinds of `HttpEvent`.
 * @return {?}
 */
export function getHttpEventTypeToString(httpEventType) {
    switch (httpEventType) {
        /* The request was sent out over the wire. */
        case HttpEventType.Sent:
            return "'Sent (0)'";
        /* An upload progress event was received. */
        case HttpEventType.UploadProgress:
            return "'UploadProgress (1)'";
        /* The response status code and headers were received. */
        case HttpEventType.ResponseHeader:
            return "'ResponseHeader (2)'";
        /* A download progress event was received. */
        case HttpEventType.DownloadProgress:
            return "'DownloadProgress (3)'";
        /* The full response including the body was received. */
        case HttpEventType.Response:
            return "'Response (4)'";
        /* A custom event from an interceptor or a backend. */
        case HttpEventType.User:
            return "'User (5)'";
        default:
            return "'It does not know the code'";
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGVscGVycy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3RvY28tbGliLyIsInNvdXJjZXMiOlsibGliL2NvcmUvdXRpbHMvaGVscGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUNyRCxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLE1BQU0sQ0FBQzs7Ozs7O0FBV3BFLE1BQU0sS0FBTyxnQkFBZ0IsR0FBVyxnQkFBZ0I7Ozs7O0FBS3hELE1BQU0sS0FBTyx1QkFBdUIsR0FBVyxLQUFLOztBQVlwRCxJQUFZLFVBQVU7SUFFbEI7O09BRUc7SUFDSCxJQUFJLFFBQVM7SUFFYjs7T0FFRztJQUNILEdBQUcsT0FBUTtJQUVYOztPQUVHO0lBQ0gsSUFBSSxRQUFTO0VBQ2hCOzs7QUFjRCxJQUFZLGFBQWE7SUFFckI7O09BRUc7SUFDSCxPQUFPLGdCQUFZO0lBRW5COztPQUVHO0lBQ0gsT0FBTyxXQUFZO0VBQ3RCOzs7QUFLRCxJQUFZLGFBQWE7SUFFckI7O09BRUc7SUFDSCxFQUFFLE1BQU87SUFFVDs7T0FFRztJQUNILEVBQUUsTUFBTztFQUNaOzs7Ozs7QUFLRCxNQUFNLEtBQU8sbUJBQW1CLEdBQW9CLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxhQUFhLENBQUMsT0FBTyxDQUFDOzs7OztBQUtsRyxNQUFNLEtBQU8sbUJBQW1CLEdBQW9CLENBQUMsYUFBYSxDQUFDLEVBQUUsRUFBRSxhQUFhLENBQUMsRUFBRSxDQUFDOzs7Ozs7Ozs7OztBQVl4RixNQUFNLFVBQVUsNkJBQTZCLENBQUMsSUFBNEI7SUFFdEUsUUFBUSxJQUFJLEVBQ1o7UUFDSSxLQUFLLGFBQWEsQ0FBQyxFQUFFLEVBQUcsYUFBYTtZQUNqQztnQkFDSSxPQUFPLENBQUMsQ0FBQzthQUNaO1FBRUwsS0FBSyxhQUFhLENBQUMsRUFBRSxF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QVE7WUFDdkIsT0FBTyxnQkFBZ0IsQ0FBQztRQUU1QixzREFBc0Q7UUFDdEQsS0FBSyxhQUFhLENBQUMsSUFBSTtZQUNuQixPQUFPLFlBQVksQ0FBQztRQUV4QjtZQUNJLE9BQU8sNkJBQTZCLENBQUM7S0FDNUM7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBIdHRwRXZlbnRUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgaXNBcnJheSwgaXNSZWdFeHAsIGlzRGF0ZSwgaXNFcnJvciwgaXNPYmplY3QgfSBmcm9tICd1dGlsJztcblxuLyoqXG4gKiBBIGZpbGUgd2l0aCBjb25zdGFudHMgYW5kIGZ1bmN0aW9ucyB0aGF0IGFyZSBoZWxwZXJzLiBcbiAqL1xuXG5cbi8qKlxuICogQ29ycmVzcG9uZHMgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC4gTW92ZWQgb3V0IGludG8gYSB2YXJpYWJsZSBoZXJlIGR1ZSB0byBcbiAqIGZsYWt5IGJyb3dzZXIgc3VwcG9ydCBhbmQgdGhlIHZhbHVlIG5vdCBiZWluZyBkZWZpbmVkIGluIENsb3N1cmUncyB0eXBpbmdzLiBcbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9TQUZFX0lOVEVHRVI6IG51bWJlciA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogVGhlIG1hcmtkb3duIGZpbGUgZXh0ZW5zaW9uLiBcbiAqL1xuZXhwb3J0IGNvbnN0IE1BUktET1dOX0ZJTEVfRVhURU5TSU9OOiBzdHJpbmcgPSAnLm1kJztcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Yga2V5L3ZhbHVlIGVsZW1lbnRzLCB3aGVyZSB0aGUga2V5cyBhcmUgc3RyaW5ncy4gXG4gKi9cbmV4cG9ydCB0eXBlIFBhcmFtczxUPiA9IHtcbiAgICBba2V5OiBzdHJpbmddOiBUO1xufTtcblxuLyoqXG4gKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIGFuIGFjdGlvbiB0aHJvdWdoIGEgdGV4dC4gXG4gKi9cbmV4cG9ydCBlbnVtIEFjdGlvblRleHRcbntcbiAgICAvKipcbiAgICAgKiBWaWV3aW5nIGFjdGlvbi4gXG4gICAgICovXG4gICAgdmlldyA9ICd2aWV3JyxcblxuICAgIC8qKlxuICAgICAqIEFkZGluZyBhY3Rpb24uIFxuICAgICAqL1xuICAgIGFkZCA9ICdhZGQnLFxuXG4gICAgLyoqXG4gICAgICogRWRpdGluZyBhY3Rpb24uIFxuICAgICAqL1xuICAgIGVkaXQgPSAnZWRpdCdcbn1cblxuLyoqXG4gKiBBbiBvYmplY3Qgb2YgcGF0aHMgdGhhdCBpcyB1c2VkIHRvIGdldCB0aGUgY2hpbGQgY29udHJvbHMgaW4gYSBgRm9ybUdyb3VwYC9gRm9ybUFycmF5YCBjb250cm9sLiBcbiAqIFRoZSB2YWx1ZSBvZiBpdHMgcHJvcGVydGllcyBpcyBhIGRvdC1kZWxpbWl0ZWQgc3RyaW5nIHZhbHVlIG9yIGFuIGFycmF5IG9mIHN0cmluZy9udW1iZXIgdmFsdWVzIFxuICogdGhhdCBkZWZpbmUgdGhlIHBhdGggdG8gYSBjaGlsZCBjb250cm9sLiBcbiAqL1xuZXhwb3J0IHR5cGUgQ2hpbGRDb250cm9sc1BhdGggPSB7XG4gICAgW2tleTogc3RyaW5nXTogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiB8IHN0cmluZztcbn07XG5cbi8qKlxuICogQW4gZW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIGxhbmd1YWdlIHRleHRzLiBcbiAqL1xuZXhwb3J0IGVudW0gTGFuZ3VhZ2VUZXh0c1xue1xuICAgIC8qKlxuICAgICAqIFRoZSBTcGFuaXNoIGxhbmd1YWdlLiBcbiAgICAgKi9cbiAgICBFc3Bhw7FvbCA9ICdFc3Bhw7FvbCcsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgRW5nbGlzaCBsYW5ndWFnZS4gXG4gICAgICovXG4gICAgRW5nbGlzaCA9ICdFbmdsaXNoJyxcbn1cblxuLyoqXG4gKiBBbiBlbnVtIHRoYXQgcmVwcmVzZW50cyB0aGUgbGFuZ3VhZ2UgdGV4dCBhYmJyZXZpYXRpb25zLiBcbiAqL1xuZXhwb3J0IGVudW0gTGFuZ3VhZ2VBYmJyc1xue1xuICAgIC8qKlxuICAgICAqIFRoZSBTcGFuaXNoIGxhbmd1YWdlIGFiYnJldmlhdGlvbi4gXG4gICAgICovXG4gICAgZXMgPSAnZXMnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIEVuZ2xpc2ggbGFuZ3VhZ2UgYWJicmV2aWF0aW9uLiBcbiAgICAgKi9cbiAgICBlbiA9ICdlbicsXG59XG5cbi8qKlxuICogVGhlIGxpc3Qgb2YgbGFuZ3VhZ2UgdGV4dHMuIFxuICovXG5leHBvcnQgY29uc3QgTEFOR1VBR0VfVEVYVFNfTElTVDogTGFuZ3VhZ2VUZXh0c1tdID0gW0xhbmd1YWdlVGV4dHMuRXNwYcOxb2wsIExhbmd1YWdlVGV4dHMuRW5nbGlzaF07XG5cbi8qKlxuICogVGhlIGxpc3Qgb2YgbGFuZ3VhZ2UgdGV4dCBhYmJyZXZpYXRpb25zLlxuICovXG5leHBvcnQgY29uc3QgTEFOR1VBR0VfQUJCUlNfTElTVDogTGFuZ3VhZ2VBYmJyc1tdID0gW0xhbmd1YWdlQWJicnMuZXMsIExhbmd1YWdlQWJicnMuZW5dO1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBsYW5ndWFnZSByZXByZXNlbnRhdGlvbiBmcm9tIHN0cmluZyB0byBudW1iZXIuIFxuICogSWYgdGhlIHN0cmluZyBzcGVjaWZpZWQgaXMgbm90IHJlZ2lzdGVyZWQgYXMgYSBsYW5ndWFnZSwgdGhlbiByZXR1cm5zIC0xIG51bWJlciB2YWx1ZS4gXG4gKiBUaGUgU3BhbmlzaCBsYW5ndWFnZSBpczogMCBhcyBudW1iZXIsIGFuZCAnZXMnIGFzIHN0cmluZy4gXG4gKiBUaGUgRW5nbGlzaCBsYW5ndWFnZSBpczogMSBhcyBudW1iZXIsIGFuZCAnZW4nIGFzIHN0cmluZy4gXG4gKiBJbiBvdGhlciB3b3JkcywgaXQgZm9sbG93cyB0aGUgb3JkZXIgb2YgYExBTkdVQUdFX1RFWFRTX0xJU1RgIGFuZCBgTEFOR1VBR0VfQUJCUlNfTElTVGAgZW51bXMuIFxuICogQHBhcmFtIGxhbmcgVGhlIGxhbmd1YWdlIHRleHQgYWJicmV2aWF0aW9uIHRvIGJlIHVzZWQuIFxuICogQHJldHVybnMgUmV0dXJucyB0aGUgbGFuZ3VhZ2UgYXMgYSBudW1iZXIgYmFzZWQgb24gaXRzIHJlcHJlc2VudGF0aW9uIGFzIHN0cmluZy4gXG4gKiBJZiB0aGUgc3RyaW5nIHNwZWNpZmllZCBpcyBub3QgcmVnaXN0ZXJlZCBhcyBhIGxhbmd1YWdlLCB0aGVuIHJldHVybnMgLTEgbnVtYmVyIHZhbHVlLiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRMYW5nRnJvbVN0cmluZ1RvTnVtYmVyKGxhbmc6IHN0cmluZyB8IExhbmd1YWdlQWJicnMpOiBudW1iZXJcbntcbiAgICBzd2l0Y2ggKGxhbmcpXG4gICAge1xuICAgICAgICBjYXNlIExhbmd1YWdlQWJicnMuZXM6ICAvKiBTcGFuaXNoICovXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBMYW5ndWFnZUFiYnJzLmVuOiAgLyogRW5nbGlzaCAqL1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgbGFuZ3VhZ2UgcmVwcmVzZW50YXRpb24gZnJvbSBudW1iZXIgdG8gc3RyaW5nLiBcbiAqIElmIHRoZSBudW1iZXIgc3BlY2lmaWVkIGlzIG5vdCByZWdpc3RlcmVkIGFzIGEgbGFuZ3VhZ2UsIHRoZW4gcmV0dXJucyBlbXB0eSBzdHJpbmcgdmFsdWUuIFxuICogVGhlIFNwYW5pc2ggbGFuZ3VhZ2UgaXM6IDAgYXMgbnVtYmVyLCBhbmQgJ2VzJyBhcyBzdHJpbmcuIFxuICogVGhlIEVuZ2xpc2ggbGFuZ3VhZ2UgaXM6IDEgYXMgbnVtYmVyLCBhbmQgJ2VuJyBhcyBzdHJpbmcuIFxuICogSW4gb3RoZXIgd29yZHMsIGl0IGZvbGxvd3MgdGhlIG9yZGVyIG9mIGBMQU5HVUFHRV9URVhUU19MSVNUYCBhbmQgYExBTkdVQUdFX0FCQlJTX0xJU1RgIGVudW1zLiBcbiAqIEBwYXJhbSBpbmRleCBUaGUgbGFuZ3VhZ2UgcmVwcmVzZW50YXRpb24gYXMgbnVtYmVyLiBcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIGxhbmd1YWdlIGFzIGEgc3RyaW5nIGJhc2VkIG9uIGl0cyByZXByZXNlbnRhdGlvbiBhcyBudW1iZXIuIFxuICogSWYgdGhlIG51bWJlciBzcGVjaWZpZWQgaXMgbm90IHJlZ2lzdGVyZWQgYXMgYSBsYW5ndWFnZSwgdGhlbiByZXR1cm5zIGVtcHR5IHN0cmluZyB2YWx1ZS4gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0TGFuZ0Zyb21OdW1iZXJUb1N0cmluZyhpbmRleDogbnVtYmVyKTogc3RyaW5nXG57XG4gICAgc3dpdGNoIChpbmRleClcbiAgICB7XG4gICAgICAgIGNhc2UgMDogIC8qIFNwYW5pc2ggKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTGFuZ3VhZ2VBYmJycy5lcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIDE6ICAvKiBFbmdsaXNoICovXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIExhbmd1YWdlQWJicnMuZW47XG4gICAgICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlIHNwZWNpZmllZCBgcGF0aGAgYXJndW1lbnQsIFxuICogdGhlIGxhbmd1YWdlIGV4dGVuc2lvbiwgYW5kIHRoZSBtYXJrZG93biBmaWxlIGV4dGVuc2lvbi4gXG4gKiBAcGFyYW0gcGF0aCBUaGUgcGF0aCB0byBtYXJrZG93biBmaWxlIHdpdGhvdXQgdGhlIGxhbmd1YWdlIGV4dGVuc2lvbiBhbmQgdGhlIG1hcmtkb3duIGZpbGUgZXh0ZW5zaW9uLiBcbiAqIEBwYXJhbSBsYW5nIFRoZSBsYW5ndWFnZSB0ZXh0IGFiYnJldmlhdGlvbiB0byBiZSB1c2VkLiBcbiAqIEByZXR1cm5zIFJldHVybnMgdGhlIGNvcnJlY3QgcGF0aCB0byB0aGUgbWFya2Rvd24gZmlsZS4gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQYXRoV2l0aExhbmdFeHRlbnNpb24ocGF0aDogc3RyaW5nLCBsYW5nOiBzdHJpbmcgfCBMYW5ndWFnZUFiYnJzKTogc3RyaW5nXG57XG4gICAgcmV0dXJuIChwYXRoICsgJy4nICsgbGFuZyArIE1BUktET1dOX0ZJTEVfRVhURU5TSU9OKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBgcG9zc0Rlc2NlbmRhbnRgIGlzIGRlc2NlbmRhbnQgZnJvbSB0aGUgc3BlY2lmaWVkIGBhbmNlc3Rvck5hbWVgOyBcbiAqIG90aGVyd2lzZSwgZmFsc2UuIFxuICogQHBhcmFtIHBvc3NEZXNjZW5kYW50IFBvc3NpYmxlIGRlc2NlbmRhbnQuIFxuICogQHBhcmFtIGFuY2VzdG9yTmFtZSBBbmNlc3RvciBuYW1lLiBcbiAqIEV4YW1wbGUgaW4gdXNhZ2U6IFxuICogIGlmIChpc0Rlc2NlbmRhbnQodGFyZ2V0LmNvbnRyb2xUeXBlLl9fcHJvdG9fXywgSW5wdXRDb250cm9sLm5hbWUpKSB7IC4uLiB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Rlc2NlbmRhbnQocG9zc0Rlc2NlbmRhbnQ6IGFueSwgYW5jZXN0b3JOYW1lOiBzdHJpbmcpOiBib29sZWFuXG57XG4gICAgZG9cbiAgICB7XG4gICAgICAgIGlmIChwb3NzRGVzY2VuZGFudC5uYW1lID09IGFuY2VzdG9yTmFtZSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHdoaWxlKChwb3NzRGVzY2VuZGFudCA9IHBvc3NEZXNjZW5kYW50Ll9fcHJvdG9fXykubmFtZSAhPSAnJyk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNsb25lIG9mIHRoZSBzcGVjaWZpZWQgYHRhcmdldGAgdmFsdWUuIFxuICogSW1wbGVtZW50YXRpb24gbm90ZXM6IFxuICogIC0gSWYgYHRhcmdldGAgaXMgYHVuZGVmaW5lZGAsIHRoZW4gcmV0dXJucyBgdW5kZWZpbmVkYC4gXG4gKiAgLSBJZiBgdGFyZ2V0YCBpcyBhbiBvYmplY3QsIHRoZW4gcmV0dXJucyBhIGNsb25lZCBvYmplY3Qgd2l0aCBhbGwgaXRzIHByb3BlcnRpZXMgY2xvbmVkLiBcbiAqICAtIElmIGB0YXJnZXRgIGlzIGFuIGFycmF5LCB0aGVuIHJldHVybnMgYSBjbG9uZWQgYXJyYXkgd2l0aCBhbGwgaXRzIHZhbHVlcyBjbG9uZWQuIFxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHZhbHVlIHRvIGNsb25lLiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVmFsdWUodGFyZ2V0OiBhbnkpOiBhbnlcbntcbiAgICBpZiAoaXNBcnJheSh0YXJnZXQpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIF9jbG9uZVZhbHVlKHRhcmdldCwgWyBdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSZWdFeHAodGFyZ2V0KSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7ICAvKiBJdCBjYW4gcmV0dXJuIGB0YXJnZXRgIGRpcmVjdGx5IGJlY2F1c2UgYWxsIGZpZWxkcyBpbiBhIGBSZWdFeHBgIGFyZSByZWFkLW9ubHkuICovXG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRGF0ZSh0YXJnZXQpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRXJyb3IodGFyZ2V0KSlcbiAgICB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7ICAvKiBJdCBjYW4gcmV0dXJuIGB0YXJnZXRgIGRpcmVjdGx5IGJlY2F1c2UgYW4gYEVycm9yYCBpcyBleHRyZW1lbHkgZGVwZW5kZW50IG9mIHRoZSBwbGFjZSB3aGVyZSBpdCBpcyBjcmVhdGVkLiAqL1xuICAgIH1cbiAgICBlbHNlIGlmIChpc09iamVjdCh0YXJnZXQpKVxuICAgIHtcbiAgICAgICAgcmV0dXJuIF9jbG9uZVZhbHVlKHRhcmdldCwgeyB9KTtcbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9jbG9uZVZhbHVlKHRhcmdldDogYW55LCBjb250YWluZXI6IGFueSk6IGFueVxue1xuICAgIGxldCB0ZW1wOiBhbnk7XG5cbiAgICBmb3IgKGxldCBwcm9wIGluIHRhcmdldClcbiAgICB7XG4gICAgICAgIHRlbXAgPSB0YXJnZXRbcHJvcF07XG5cbiAgICAgICAgaWYgKGlzQXJyYXkodGVtcCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcltwcm9wXSA9IF9jbG9uZVZhbHVlKHRlbXAsIFsgXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdFeHAodGVtcCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcltwcm9wXSA9IHRlbXA7ICAvKiBJdCBjYW4gcmV0dXJuIGB0ZW1wYCBkaXJlY3RseSBiZWNhdXNlIGFsbCBmaWVsZHMgaW4gYSBgUmVnRXhwYCBhcmUgcmVhZC1vbmx5LiAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZSh0ZW1wKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGFpbmVyW3Byb3BdID0gbmV3IERhdGUodGVtcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNFcnJvcih0ZW1wKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGFpbmVyW3Byb3BdID0gdGVtcDsgIC8qIEl0IGNhbiByZXR1cm4gYHRlbXBgIGRpcmVjdGx5IGJlY2F1c2UgYW4gYEVycm9yYCBpcyBleHRyZW1lbHkgZGVwZW5kZW50IG9mIHRoZSBwbGFjZSB3aGVyZSBpdCBpcyBjcmVhdGVkLiAqL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHRlbXApKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250YWluZXJbcHJvcF0gPSBfY2xvbmVWYWx1ZSh0ZW1wLCB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGFpbmVyW3Byb3BdID0gdGVtcDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyB2YWx1ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNsb25lIG9mIHRoZSBzcGVjaWZpZWQgYHRhcmdldGAgdmFsdWUsIGFuZCBcbiAqIHNldHMgYWxsIGl0cyBwcm9wZXJ0aWVzL3ZhbHVlcyBvZiBidWlsdC1pbiB0eXBlIHRvIGB1bmRlZmluZWRgLiBcbiAqIEltcGxlbWVudGF0aW9uIG5vdGVzOiBcbiAqICAtIElmIGB0YXJnZXRgIGlzIGB1bmRlZmluZWRgLCB0aGVuIHJldHVybnMgYHVuZGVmaW5lZGAuIFxuICogIC0gSWYgYHRhcmdldGAgaXMgYW4gb2JqZWN0LCB0aGVuIHJldHVybnMgYW4gb2JqZWN0IHdpdGggYWxsIGl0cyBwcm9wZXJ0aWVzIG9mIGJ1aWx0LWluIHR5cGUgdG8gYHVuZGVmaW5lZGAuIFxuICogIC0gSWYgYHRhcmdldGAgaXMgYW4gYXJyYXksIHRoZW4gcmV0dXJucyBhbiBhcnJheSB3aXRoIGFsbCBpdHMgdmFsdWVzIG9mIGJ1aWx0LWluIHR5cGUgdG8gYHVuZGVmaW5lZGAuIFxuICogQHBhcmFtIHRhcmdldCBUaGUgdGFyZ2V0IHZhbHVlIHRvIGNsb25lLiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVmFsdWVUb1VuZGVmaW5lZCh0YXJnZXQ6IGFueSk6IGFueVxue1xuICAgIGlmIChpc0FycmF5KHRhcmdldCkpXG4gICAge1xuICAgICAgICByZXR1cm4gX2Nsb25lVmFsdWVUb1VuZGVmaW5lZCh0YXJnZXQsIFsgXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUmVnRXhwKHRhcmdldCkpXG4gICAge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0RhdGUodGFyZ2V0KSlcbiAgICB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRXJyb3IodGFyZ2V0KSlcbiAgICB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KHRhcmdldCkpXG4gICAge1xuICAgICAgICByZXR1cm4gX2Nsb25lVmFsdWVUb1VuZGVmaW5lZCh0YXJnZXQsIHsgfSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfY2xvbmVWYWx1ZVRvVW5kZWZpbmVkKHRhcmdldDogYW55LCBjb250YWluZXI6IGFueSk6IGFueVxue1xuICAgIGxldCB0ZW1wOiBhbnk7XG5cbiAgICBmb3IobGV0IHByb3AgaW4gdGFyZ2V0KVxuICAgIHtcbiAgICAgICAgdGVtcCA9IHRhcmdldFtwcm9wXTtcblxuICAgICAgICBpZiAoaXNBcnJheSh0ZW1wKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGFpbmVyW3Byb3BdID0gX2Nsb25lVmFsdWVUb1VuZGVmaW5lZCh0ZW1wLCBbIF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKHRhcmdldCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcltwcm9wXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RhdGUodGFyZ2V0KSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGFpbmVyW3Byb3BdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXJyb3IodGFyZ2V0KSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29udGFpbmVyW3Byb3BdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHRlbXApKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250YWluZXJbcHJvcF0gPSBfY2xvbmVWYWx1ZVRvVW5kZWZpbmVkKHRlbXAsIHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBjb250YWluZXJbcHJvcF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xufVxuXG4vKipcbiAqIExvZ3MgYW4gZXJyb3Igbm90aWZpY2F0aW9uIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGUuIFxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIGR1cmluZyB0aGUgZXJyb3Igb2NjdXJzLiBcbiAqIEBwYXJhbSBwbGFjZSBUaGUgcGxhY2Ugd2hlcmUgdGhlIGVycm9yIG9jY3Vycy4gXG4gKiBAcGFyYW0gZXJyIFRoZSBlcnJvciB0aGF0IG9jY3Vycy4gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2dFcnJvcihvcGVyYXRpb246IHN0cmluZywgcGxhY2U6IHN0cmluZywgZXJyOiBhbnkpOiB2b2lkXG57XG4gICAgY29uc29sZS5sb2coYFRoZSBvYnNlcnZhYmxlIGdvdCBhbiBlcnJvciAnJHsgb3BlcmF0aW9uIH0nIGluICckeyBwbGFjZSB9JzogJHsgZXJyIH0uYCk7XG59XG5cbi8qKlxuICogTG9ncyBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiBtZXNzYWdlIHRvIHRoZSBjb25zb2xlLiBcbiAqIEBwYXJhbSBvcGVyYXRpb24gVGhlIG9wZXJhdGlvbiBkdXJpbmcgdGhlIGNvbXBsZXRlIG9jY3Vycy4gXG4gKiBAcGFyYW0gcGxhY2UgVGhlIHBsYWNlIHdoZXJlIHRoZSBjb21wbGV0ZSBvY2N1cnMuIFxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9nQ29tcGxldGUob3BlcmF0aW9uOiBzdHJpbmcsIHBsYWNlOiBzdHJpbmcpOiB2b2lkXG57XG4gICAgY29uc29sZS5sb2coYFRoZSBvYnNlcnZhYmxlIGdvdCBhIGNvbXBsZXRlIG5vdGlmaWNhdGlvbiAnJHsgb3BlcmF0aW9uIH0nIGluICckeyBwbGFjZSB9Jy5gKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGBIdHRwRXZlbnRUeXBlYCBzcGVjaWZpZWQuIFxuICogQHBhcmFtIGh0dHBFdmVudFR5cGUgVHlwZSBlbnVtZXJhdGlvbiBmb3IgdGhlIGRpZmZlcmVudCBraW5kcyBvZiBgSHR0cEV2ZW50YC4gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIdHRwRXZlbnRUeXBlVG9TdHJpbmcoaHR0cEV2ZW50VHlwZTogSHR0cEV2ZW50VHlwZSk6IHN0cmluZ1xue1xuICAgIHN3aXRjaCAoaHR0cEV2ZW50VHlwZSlcbiAgICB7XG4gICAgICAgIC8qIFRoZSByZXF1ZXN0IHdhcyBzZW50IG91dCBvdmVyIHRoZSB3aXJlLiAqL1xuICAgICAgICBjYXNlIEh0dHBFdmVudFR5cGUuU2VudDpcbiAgICAgICAgICAgIHJldHVybiBcIidTZW50ICgwKSdcIjtcblxuICAgICAgICAvKiBBbiB1cGxvYWQgcHJvZ3Jlc3MgZXZlbnQgd2FzIHJlY2VpdmVkLiAqL1xuICAgICAgICBjYXNlIEh0dHBFdmVudFR5cGUuVXBsb2FkUHJvZ3Jlc3M6XG4gICAgICAgICAgICByZXR1cm4gXCInVXBsb2FkUHJvZ3Jlc3MgKDEpJ1wiO1xuXG4gICAgICAgIC8qIFRoZSByZXNwb25zZSBzdGF0dXMgY29kZSBhbmQgaGVhZGVycyB3ZXJlIHJlY2VpdmVkLiAqL1xuICAgICAgICBjYXNlIEh0dHBFdmVudFR5cGUuUmVzcG9uc2VIZWFkZXI6XG4gICAgICAgICAgICByZXR1cm4gXCInUmVzcG9uc2VIZWFkZXIgKDIpJ1wiO1xuXG4gICAgICAgIC8qIEEgZG93bmxvYWQgcHJvZ3Jlc3MgZXZlbnQgd2FzIHJlY2VpdmVkLiAqL1xuICAgICAgICBjYXNlIEh0dHBFdmVudFR5cGUuRG93bmxvYWRQcm9ncmVzczpcbiAgICAgICAgICAgIHJldHVybiBcIidEb3dubG9hZFByb2dyZXNzICgzKSdcIjtcblxuICAgICAgICAvKiBUaGUgZnVsbCByZXNwb25zZSBpbmNsdWRpbmcgdGhlIGJvZHkgd2FzIHJlY2VpdmVkLiAqL1xuICAgICAgICBjYXNlIEh0dHBFdmVudFR5cGUuUmVzcG9uc2U6XG4gICAgICAgICAgICByZXR1cm4gXCInUmVzcG9uc2UgKDQpJ1wiO1xuXG4gICAgICAgIC8qIEEgY3VzdG9tIGV2ZW50IGZyb20gYW4gaW50ZXJjZXB0b3Igb3IgYSBiYWNrZW5kLiAqL1xuICAgICAgICBjYXNlIEh0dHBFdmVudFR5cGUuVXNlcjpcbiAgICAgICAgICAgIHJldHVybiBcIidVc2VyICg1KSdcIjtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiJ0l0IGRvZXMgbm90IGtub3cgdGhlIGNvZGUnXCI7XG4gICAgfVxufVxuIl19