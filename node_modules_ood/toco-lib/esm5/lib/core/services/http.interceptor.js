/**
 * @fileoverview added by tsickle
 * Generated from: lib/core/services/http.interceptor.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { HttpResponse } from '@angular/common/http';
import { of } from 'rxjs';
import { tap } from 'rxjs/operators';
import { REFRESH_X_CACHE, Cachable, RequestCache } from './request-cache.service';
import * as i0 from "@angular/core";
import * as i1 from "./request-cache.service";
/* Note: When you are going to use the Interceptors, make a "Barrel" of Http Interceptors.
 * Angular applies interceptors in the order that you provide them. If you provide interceptors A,
 * then B, then C, requests will flow in A->B->C and responses will flow out C->B->A.
 * You cannot change the order or remove interceptors later. If you need to enable and disable
 * an interceptor dynamically, you'll have to build that capability into the interceptor itself. */
/**
 * A service that caches certain requests and responses to improve performance.
 * It is delegated to an interceptor without disturbing the existing data services.
 *
 * - If request is cachable (e.g., package search) and response is in cache,
 * then returns the cached response as observable.
 * - If request is cachable and has `REFRESH_X_CACHE` option header in true (or the request is not in cache),
 * then passes request to the following `HttpHandler` and makes a cache from response.
 * - If request is not cachable,
 * then passes request to the following `HttpHandler`.
 */
var CachingInterceptor = /** @class */ (function () {
    function CachingInterceptor(_cachable, _cache) {
        this._cachable = _cachable;
        this._cache = _cache;
    }
    /**
     * Identifies and handles a given HTTP request.
     * @param req The outgoing request object to handle.
     * @param next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
     * @returns An observable of the event stream.
     */
    /**
     * Identifies and handles a given HTTP request.
     * @param {?} req The outgoing request object to handle.
     * @param {?} next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
     * @return {?} An observable of the event stream.
     */
    CachingInterceptor.prototype.intercept = /**
     * Identifies and handles a given HTTP request.
     * @param {?} req The outgoing request object to handle.
     * @param {?} next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
     * @return {?} An observable of the event stream.
     */
    function (req, next) {
        /** @type {?} */
        var maxAgeInCache;
        /* Continues if not cachable. */
        if (!(maxAgeInCache = this._cachable.isCachable(req))) {
            return next.handle(req);
        }
        /* This option is triggered by the presence of a custom `REFRESH_X_CACHE` header with true value. */
        if (req.headers.get(REFRESH_X_CACHE)) {
            /* fetch. */
            return this._sendRequest(req, maxAgeInCache, true, next);
        }
        /* cache-or-fetch. */
        /** @type {?} */
        var cachedResponse = this._cache.get(req);
        return (cachedResponse
            ? of(cachedResponse)
            : this._sendRequest(req, maxAgeInCache, false, next));
    };
    /**
     * Gets server response observable by sending request to `next` argument.
     * It will add the response to the cache on the way out.
     * @param req The outgoing request object to handle.
     * @param maxAgeInCache The maximum cache age in milliseconds.
     * @param hasRefreshXCache It is true if the custom `REFRESH_X_CACHE` header is present; otherwise, false.
     * @param next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
     * @returns An observable of the event stream.
     */
    /**
     * Gets server response observable by sending request to `next` argument.
     * It will add the response to the cache on the way out.
     * @private
     * @param {?} req The outgoing request object to handle.
     * @param {?} maxAgeInCache The maximum cache age in milliseconds.
     * @param {?} hasRefreshXCache It is true if the custom `REFRESH_X_CACHE` header is present; otherwise, false.
     * @param {?} next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
     * @return {?} An observable of the event stream.
     */
    CachingInterceptor.prototype._sendRequest = /**
     * Gets server response observable by sending request to `next` argument.
     * It will add the response to the cache on the way out.
     * @private
     * @param {?} req The outgoing request object to handle.
     * @param {?} maxAgeInCache The maximum cache age in milliseconds.
     * @param {?} hasRefreshXCache It is true if the custom `REFRESH_X_CACHE` header is present; otherwise, false.
     * @param {?} next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
     * @return {?} An observable of the event stream.
     */
    function (req, maxAgeInCache, hasRefreshXCache, next) {
        var _this = this;
        /* Removes the `REFRESH_X_CACHE` custom option from header. */
        /** @type {?} */
        var reqWithoutCustomHeader = (hasRefreshXCache)
            ? req.clone({ headers: (req.headers.delete(REFRESH_X_CACHE)) })
            : req;
        console.log('Req-2: ', reqWithoutCustomHeader.headers);
        return next.handle(reqWithoutCustomHeader).pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        function (event) {
            /* There may be other events besides the response. */
            if (event instanceof HttpResponse) {
                /* Updates the cache. */
                _this._cache.set(req, maxAgeInCache, event); /* Cached the original request `req`. */
            }
        })));
    };
    CachingInterceptor.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    CachingInterceptor.ctorParameters = function () { return [
        { type: Cachable },
        { type: RequestCache }
    ]; };
    /** @nocollapse */ CachingInterceptor.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function CachingInterceptor_Factory() { return new CachingInterceptor(i0.ɵɵinject(i1.Cachable), i0.ɵɵinject(i1.RequestCache)); }, token: CachingInterceptor, providedIn: "root" });
    return CachingInterceptor;
}());
export { CachingInterceptor };
if (false) {
    /**
     * @type {?}
     * @private
     */
    CachingInterceptor.prototype._cachable;
    /**
     * @type {?}
     * @private
     */
    CachingInterceptor.prototype._cache;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3RvY28tbGliLyIsInNvdXJjZXMiOlsibGliL2NvcmUvc2VydmljZXMvaHR0cC5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUF3RCxZQUFZLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMxRyxPQUFPLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVyQyxPQUFPLEVBQUUsZUFBZSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW9CbEY7SUFLSSw0QkFBMkIsU0FBbUIsRUFBVSxNQUFvQjtRQUFqRCxjQUFTLEdBQVQsU0FBUyxDQUFVO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBYztJQUMxRSxDQUFDO0lBRUg7Ozs7O09BS0c7Ozs7Ozs7SUFDSSxzQ0FBUzs7Ozs7O0lBQWhCLFVBQWlCLEdBQXFCLEVBQUUsSUFBaUI7O1lBRWpELGFBQXFCO1FBRXpCLGdDQUFnQztRQUNoQyxJQUFJLENBQUMsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDckQ7WUFDSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDM0I7UUFFRCxvR0FBb0c7UUFDcEcsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsRUFDcEM7WUFDSSxZQUFZO1lBQ1osT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzVEOzs7WUFHSyxjQUFjLEdBQXNCLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUM5RCxPQUFPLENBQUMsY0FBYztZQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQztZQUNwQixDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFFRDs7Ozs7Ozs7T0FRRzs7Ozs7Ozs7Ozs7SUFDSyx5Q0FBWTs7Ozs7Ozs7OztJQUFwQixVQUFxQixHQUFxQixFQUFFLGFBQXFCLEVBQUUsZ0JBQXlCLEVBQUUsSUFBaUI7UUFBL0csaUJBbUJDOzs7WUFoQk8sc0JBQXNCLEdBQXFCLENBQUMsZ0JBQWdCLENBQUM7WUFDN0QsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDL0QsQ0FBQyxDQUFDLEdBQUc7UUFFVCxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxzQkFBc0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUV2RCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxJQUFJLENBQzNDLEdBQUc7Ozs7UUFBQyxVQUFDLEtBQXFCO1lBQ3RCLHFEQUFxRDtZQUNyRCxJQUFJLEtBQUssWUFBWSxZQUFZLEVBQ2pDO2dCQUNJLHdCQUF3QjtnQkFDeEIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLGFBQWEsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFFLHdDQUF3QzthQUN4RjtRQUNMLENBQUMsRUFBQyxDQUNMLENBQUM7SUFDTixDQUFDOztnQkFsRUosVUFBVSxTQUFDO29CQUNSLFVBQVUsRUFBRSxNQUFNO2lCQUNyQjs7OztnQkF0QnlCLFFBQVE7Z0JBQUUsWUFBWTs7OzZCQU5oRDtDQTZGQyxBQW5FRCxJQW1FQztTQWhFWSxrQkFBa0I7Ozs7OztJQUVSLHVDQUEyQjs7Ozs7SUFBRSxvQ0FBNEIiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBJbnRlcmNlcHRvciwgSHR0cFJlcXVlc3QsIEh0dHBIYW5kbGVyLCBIdHRwRXZlbnQsIEh0dHBSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IFJFRlJFU0hfWF9DQUNIRSwgQ2FjaGFibGUsIFJlcXVlc3RDYWNoZSB9IGZyb20gJy4vcmVxdWVzdC1jYWNoZS5zZXJ2aWNlJztcblxuLyogTm90ZTogV2hlbiB5b3UgYXJlIGdvaW5nIHRvIHVzZSB0aGUgSW50ZXJjZXB0b3JzLCBtYWtlIGEgXCJCYXJyZWxcIiBvZiBIdHRwIEludGVyY2VwdG9ycy4gXG4gKiBBbmd1bGFyIGFwcGxpZXMgaW50ZXJjZXB0b3JzIGluIHRoZSBvcmRlciB0aGF0IHlvdSBwcm92aWRlIHRoZW0uIElmIHlvdSBwcm92aWRlIGludGVyY2VwdG9ycyBBLCBcbiAqIHRoZW4gQiwgdGhlbiBDLCByZXF1ZXN0cyB3aWxsIGZsb3cgaW4gQS0+Qi0+QyBhbmQgcmVzcG9uc2VzIHdpbGwgZmxvdyBvdXQgQy0+Qi0+QS4gXG4gKiBZb3UgY2Fubm90IGNoYW5nZSB0aGUgb3JkZXIgb3IgcmVtb3ZlIGludGVyY2VwdG9ycyBsYXRlci4gSWYgeW91IG5lZWQgdG8gZW5hYmxlIGFuZCBkaXNhYmxlIFxuICogYW4gaW50ZXJjZXB0b3IgZHluYW1pY2FsbHksIHlvdSdsbCBoYXZlIHRvIGJ1aWxkIHRoYXQgY2FwYWJpbGl0eSBpbnRvIHRoZSBpbnRlcmNlcHRvciBpdHNlbGYuICovXG5cblxuLyoqXG4gKiBBIHNlcnZpY2UgdGhhdCBjYWNoZXMgY2VydGFpbiByZXF1ZXN0cyBhbmQgcmVzcG9uc2VzIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuIFxuICogSXQgaXMgZGVsZWdhdGVkIHRvIGFuIGludGVyY2VwdG9yIHdpdGhvdXQgZGlzdHVyYmluZyB0aGUgZXhpc3RpbmcgZGF0YSBzZXJ2aWNlcy4gXG4gKiBcbiAqIC0gSWYgcmVxdWVzdCBpcyBjYWNoYWJsZSAoZS5nLiwgcGFja2FnZSBzZWFyY2gpIGFuZCByZXNwb25zZSBpcyBpbiBjYWNoZSwgXG4gKiB0aGVuIHJldHVybnMgdGhlIGNhY2hlZCByZXNwb25zZSBhcyBvYnNlcnZhYmxlLiBcbiAqIC0gSWYgcmVxdWVzdCBpcyBjYWNoYWJsZSBhbmQgaGFzIGBSRUZSRVNIX1hfQ0FDSEVgIG9wdGlvbiBoZWFkZXIgaW4gdHJ1ZSAob3IgdGhlIHJlcXVlc3QgaXMgbm90IGluIGNhY2hlKSwgXG4gKiB0aGVuIHBhc3NlcyByZXF1ZXN0IHRvIHRoZSBmb2xsb3dpbmcgYEh0dHBIYW5kbGVyYCBhbmQgbWFrZXMgYSBjYWNoZSBmcm9tIHJlc3BvbnNlLiBcbiAqIC0gSWYgcmVxdWVzdCBpcyBub3QgY2FjaGFibGUsIFxuICogdGhlbiBwYXNzZXMgcmVxdWVzdCB0byB0aGUgZm9sbG93aW5nIGBIdHRwSGFuZGxlcmAuIFxuICovXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIENhY2hpbmdJbnRlcmNlcHRvciBpbXBsZW1lbnRzIEh0dHBJbnRlcmNlcHRvclxue1xuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIF9jYWNoYWJsZTogQ2FjaGFibGUsIHByaXZhdGUgX2NhY2hlOiBSZXF1ZXN0Q2FjaGUpXG4gICAgeyB9XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVzIGFuZCBoYW5kbGVzIGEgZ2l2ZW4gSFRUUCByZXF1ZXN0LiBcbiAgICAgKiBAcGFyYW0gcmVxIFRoZSBvdXRnb2luZyByZXF1ZXN0IG9iamVjdCB0byBoYW5kbGUuIFxuICAgICAqIEBwYXJhbSBuZXh0IFRoZSBuZXh0IGludGVyY2VwdG9yIGluIHRoZSBjaGFpbiwgb3IgdGhlIGJhY2tlbmQgaWYgbm8gaW50ZXJjZXB0b3JzIHJlbWFpbiBpbiB0aGUgY2hhaW4uIFxuICAgICAqIEByZXR1cm5zIEFuIG9ic2VydmFibGUgb2YgdGhlIGV2ZW50IHN0cmVhbS4gXG4gICAgICovXG4gICAgcHVibGljIGludGVyY2VwdChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj5cbiAgICB7XG4gICAgICAgIGxldCBtYXhBZ2VJbkNhY2hlOiBudW1iZXI7XG5cbiAgICAgICAgLyogQ29udGludWVzIGlmIG5vdCBjYWNoYWJsZS4gKi9cbiAgICAgICAgaWYgKCEobWF4QWdlSW5DYWNoZSA9IHRoaXMuX2NhY2hhYmxlLmlzQ2FjaGFibGUocmVxKSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0LmhhbmRsZShyZXEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogVGhpcyBvcHRpb24gaXMgdHJpZ2dlcmVkIGJ5IHRoZSBwcmVzZW5jZSBvZiBhIGN1c3RvbSBgUkVGUkVTSF9YX0NBQ0hFYCBoZWFkZXIgd2l0aCB0cnVlIHZhbHVlLiAqL1xuICAgICAgICBpZiAocmVxLmhlYWRlcnMuZ2V0KFJFRlJFU0hfWF9DQUNIRSkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qIGZldGNoLiAqL1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRSZXF1ZXN0KHJlcSwgbWF4QWdlSW5DYWNoZSwgdHJ1ZSwgbmV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBjYWNoZS1vci1mZXRjaC4gKi9cbiAgICAgICAgY29uc3QgY2FjaGVkUmVzcG9uc2U6IEh0dHBSZXNwb25zZTxhbnk+ID0gdGhpcy5fY2FjaGUuZ2V0KHJlcSk7XG4gICAgICAgIHJldHVybiAoY2FjaGVkUmVzcG9uc2VcbiAgICAgICAgICAgID8gb2YoY2FjaGVkUmVzcG9uc2UpXG4gICAgICAgICAgICA6IHRoaXMuX3NlbmRSZXF1ZXN0KHJlcSwgbWF4QWdlSW5DYWNoZSwgZmFsc2UsIG5leHQpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHNlcnZlciByZXNwb25zZSBvYnNlcnZhYmxlIGJ5IHNlbmRpbmcgcmVxdWVzdCB0byBgbmV4dGAgYXJndW1lbnQuIFxuICAgICAqIEl0IHdpbGwgYWRkIHRoZSByZXNwb25zZSB0byB0aGUgY2FjaGUgb24gdGhlIHdheSBvdXQuIFxuICAgICAqIEBwYXJhbSByZXEgVGhlIG91dGdvaW5nIHJlcXVlc3Qgb2JqZWN0IHRvIGhhbmRsZS4gXG4gICAgICogQHBhcmFtIG1heEFnZUluQ2FjaGUgVGhlIG1heGltdW0gY2FjaGUgYWdlIGluIG1pbGxpc2Vjb25kcy4gXG4gICAgICogQHBhcmFtIGhhc1JlZnJlc2hYQ2FjaGUgSXQgaXMgdHJ1ZSBpZiB0aGUgY3VzdG9tIGBSRUZSRVNIX1hfQ0FDSEVgIGhlYWRlciBpcyBwcmVzZW50OyBvdGhlcndpc2UsIGZhbHNlLiBcbiAgICAgKiBAcGFyYW0gbmV4dCBUaGUgbmV4dCBpbnRlcmNlcHRvciBpbiB0aGUgY2hhaW4sIG9yIHRoZSBiYWNrZW5kIGlmIG5vIGludGVyY2VwdG9ycyByZW1haW4gaW4gdGhlIGNoYWluLiBcbiAgICAgKiBAcmV0dXJucyBBbiBvYnNlcnZhYmxlIG9mIHRoZSBldmVudCBzdHJlYW0uIFxuICAgICAqL1xuICAgIHByaXZhdGUgX3NlbmRSZXF1ZXN0KHJlcTogSHR0cFJlcXVlc3Q8YW55PiwgbWF4QWdlSW5DYWNoZTogbnVtYmVyLCBoYXNSZWZyZXNoWENhY2hlOiBib29sZWFuLCBuZXh0OiBIdHRwSGFuZGxlcik6IE9ic2VydmFibGU8SHR0cEV2ZW50PGFueT4+XG4gICAge1xuICAgICAgICAvKiBSZW1vdmVzIHRoZSBgUkVGUkVTSF9YX0NBQ0hFYCBjdXN0b20gb3B0aW9uIGZyb20gaGVhZGVyLiAqL1xuICAgICAgICBsZXQgcmVxV2l0aG91dEN1c3RvbUhlYWRlcjogSHR0cFJlcXVlc3Q8YW55PiA9IChoYXNSZWZyZXNoWENhY2hlKVxuICAgICAgICAgICAgPyByZXEuY2xvbmUoeyBoZWFkZXJzOiAocmVxLmhlYWRlcnMuZGVsZXRlKFJFRlJFU0hfWF9DQUNIRSkpIH0pXG4gICAgICAgICAgICA6IHJlcTtcblxuICAgICAgICBjb25zb2xlLmxvZygnUmVxLTI6ICcsIHJlcVdpdGhvdXRDdXN0b21IZWFkZXIuaGVhZGVycyk7XG5cbiAgICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcVdpdGhvdXRDdXN0b21IZWFkZXIpLnBpcGUoXG4gICAgICAgICAgICB0YXAoKGV2ZW50OiBIdHRwRXZlbnQ8YW55PikgPT4ge1xuICAgICAgICAgICAgICAgIC8qIFRoZXJlIG1heSBiZSBvdGhlciBldmVudHMgYmVzaWRlcyB0aGUgcmVzcG9uc2UuICovXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLyogVXBkYXRlcyB0aGUgY2FjaGUuICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlLnNldChyZXEsIG1heEFnZUluQ2FjaGUsIGV2ZW50KTsgIC8qIENhY2hlZCB0aGUgb3JpZ2luYWwgcmVxdWVzdCBgcmVxYC4gKi9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==