/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/input/rnps/rnps-input.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component } from '@angular/core';
import { FormControl, Validators } from '@angular/forms';
import { ExtraValidators } from '../../../core/utils/validator';
import { RnpsValue } from './rnps-value';
import { InputControl } from '../input.control';
/**
 * Represents a control that allows the writing of an RNPS.
 * An RNPS (Registro Nacional de Publicaciones Seriadas) is an 4-digit code used to control
 * the serial publications authorized to be edited, printed and circulated in Cuba.
 * For more information follow the link: http://www.seriadas.cult.cu/.
 * It uses the `RnpsValue.rnps_Abbreviation` as a label if the `content.label` is not specified.
 * It uses the `RnpsValue.rnps_Placeholder` as a placeholder if the `content.placeholder` is not specified.
 */
var InputRnpsComponent = /** @class */ (function (_super) {
    tslib_1.__extends(InputRnpsComponent, _super);
    function InputRnpsComponent() {
        var _this = _super.call(this) || this;
        _this._codeOldValue = undefined;
        return _this;
    }
    /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputRnpsComponent`'s `content.formControl` value by default.
     * In this case, the `validatorArguments` argument is always `undefined`.
     */
    /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputRnpsComponent`'s `content.formControl` value by default.
     * In this case, the `validatorArguments` argument is always `undefined`.
     * @param {?=} validatorArguments
     * @return {?}
     */
    InputRnpsComponent.getFormControlByDefault = /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputRnpsComponent`'s `content.formControl` value by default.
     * In this case, the `validatorArguments` argument is always `undefined`.
     * @param {?=} validatorArguments
     * @return {?}
     */
    function (validatorArguments) {
        if (validatorArguments === void 0) { validatorArguments = undefined; }
        return new FormControl('', [
            ExtraValidators.equalLength(RnpsValue.codeLength),
            Validators.pattern('^[0-9]*$')
        ]);
    };
    /**
     * @return {?}
     */
    InputRnpsComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /* Sets the default values. */
        this.init(RnpsValue.rnps_Abbreviation, RnpsValue.rnps_Placeholder, true, true);
        /* The '_codeOldValue' must be set after the 'content.formControl.value' is set. */
        this.handleSpecificInput();
    };
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     */
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * @return {?}
     */
    InputRnpsComponent.prototype.getErrorMessage = /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var result = '';
        /** @type {?} */
        var result_alreadyHaveErrorInfo = false;
        /** @type {?} */
        var validationErrors = this.content.formControl.errors;
        /* Shows the code errors. */
        if (validationErrors) {
            if ((validationErrors[ExtraValidators.equalLength.name]) || (validationErrors[Validators.required.name])) {
                result = 'TOCO_NG_ERROR_MSG_RNPS_LONG_INVAL';
                result_alreadyHaveErrorInfo = true;
            }
            if (validationErrors[Validators.pattern.name]) {
                if (result_alreadyHaveErrorInfo) {
                    result = 'TOCO_NG_ERROR_MSG_RNPS_LONG_Y_DIG_INVAL';
                }
                else {
                    result = 'TOCO_NG_ERROR_MSG_RNPS_DIG_INVAL';
                }
                result_alreadyHaveErrorInfo = true;
            }
        }
        return result;
    };
    /**
     * Handler method that is called by the internal logic when the control's value changes in the UI.
     * This method contains the specific handling of the input that the derived class wants to do.
     */
    /**
     * Handler method that is called by the internal logic when the control's value changes in the UI.
     * This method contains the specific handling of the input that the derived class wants to do.
     * @return {?}
     */
    InputRnpsComponent.prototype.handleSpecificInput = /**
     * Handler method that is called by the internal logic when the control's value changes in the UI.
     * This method contains the specific handling of the input that the derived class wants to do.
     * @return {?}
     */
    function () {
        if (this.content.formControl.value.length > RnpsValue.codeLength) {
            /* Sets the old value. */
            this.content.formControl.setValue(this._codeOldValue);
        }
        else {
            /* Updates the old values. */
            this._codeOldValue = this.content.formControl.value;
        }
    };
    InputRnpsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'input-rnps',
                    template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                    host: {
                        '[style.minWidth]': 'content.minWidth',
                        '[style.width]': 'content.width'
                    },
                    styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
                }] }
    ];
    /** @nocollapse */
    InputRnpsComponent.ctorParameters = function () { return []; };
    return InputRnpsComponent;
}(InputControl));
export { InputRnpsComponent };
if (false) {
    /**
     * It is used by `handleSpecificInput` method.
     * @type {?}
     * @private
     */
    InputRnpsComponent.prototype._codeOldValue;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm5wcy1pbnB1dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly90b2NvLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9mb3Jtcy9pbnB1dC9ybnBzL3JucHMtaW5wdXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQVUsTUFBTSxlQUFlLENBQUM7QUFDbEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQW9CLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0UsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLCtCQUErQixDQUFDO0FBRWhFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDekMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDOzs7Ozs7Ozs7QUFXaEQ7SUFTd0MsOENBQVk7SUFvQmhEO1FBQUEsWUFFSSxpQkFBTyxTQUdWO1FBREcsS0FBSSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUM7O0lBQ25DLENBQUM7SUF2QkQ7Ozs7T0FJRzs7Ozs7Ozs7SUFDVywwQ0FBdUI7Ozs7Ozs7SUFBckMsVUFBc0Msa0JBQWtEO1FBQWxELG1DQUFBLEVBQUEsOEJBQWtEO1FBRXBGLE9BQU8sSUFBSSxXQUFXLENBQUMsRUFBRSxFQUFFO1lBQ3ZCLGVBQWUsQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQztZQUNqRCxVQUFVLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQztTQUNqQyxDQUFDLENBQUM7SUFDUCxDQUFDOzs7O0lBY00scUNBQVE7OztJQUFmO1FBRUksOEJBQThCO1FBRTlCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixFQUFFLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFL0UsbUZBQW1GO1FBQ25GLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7T0FFRzs7Ozs7SUFDSSw0Q0FBZTs7OztJQUF0Qjs7WUFFUSxNQUFNLEdBQVcsRUFBRTs7WUFDbkIsMkJBQTJCLEdBQVksS0FBSzs7WUFDNUMsZ0JBQWdCLEdBQXFCLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLE1BQU07UUFFeEUsNEJBQTRCO1FBQzVCLElBQUksZ0JBQWdCLEVBQ3BCO1lBQ0ksSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsRUFDeEc7Z0JBQ0ksTUFBTSxHQUFHLG1DQUFtQyxDQUFDO2dCQUM3QywyQkFBMkIsR0FBRyxJQUFJLENBQUM7YUFDdEM7WUFFRCxJQUFJLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQzdDO2dCQUNJLElBQUksMkJBQTJCLEVBQy9CO29CQUNJLE1BQU0sR0FBRyx5Q0FBeUMsQ0FBQztpQkFDdEQ7cUJBRUQ7b0JBQ0ksTUFBTSxHQUFHLGtDQUFrQyxDQUFDO2lCQUMvQztnQkFFRCwyQkFBMkIsR0FBRyxJQUFJLENBQUM7YUFDdEM7U0FDSjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFFSjs7O09BR0c7Ozs7OztJQUNJLGdEQUFtQjs7Ozs7SUFBMUI7UUFFQyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLFVBQVUsRUFDaEU7WUFDQyx5QkFBeUI7WUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNoRDthQUVEO1lBQ0ksNkJBQTZCO1lBQzdCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO1NBQ3ZEO0lBQ0wsQ0FBQzs7Z0JBbEdKLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsWUFBWTtvQkFDdEIseXdHQUFnRDtvQkFFaEQsSUFBSSxFQUFFO3dCQUNGLGtCQUFrQixFQUFFLGtCQUFrQjt3QkFDdEMsZUFBZSxFQUFFLGVBQWU7cUJBQ25DOztpQkFDSjs7OztJQTJGRCx5QkFBQztDQUFBLEFBbkdELENBU3dDLFlBQVksR0EwRm5EO1NBMUZZLGtCQUFrQjs7Ozs7OztJQWtCM0IsMkNBQThCIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIFZhbGlkYXRvcnMsIFZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IEV4dHJhVmFsaWRhdG9ycyB9IGZyb20gJy4uLy4uLy4uL2NvcmUvdXRpbHMvdmFsaWRhdG9yJztcblxuaW1wb3J0IHsgUm5wc1ZhbHVlIH0gZnJvbSAnLi9ybnBzLXZhbHVlJztcbmltcG9ydCB7IElucHV0Q29udHJvbCB9IGZyb20gJy4uL2lucHV0LmNvbnRyb2wnO1xuaW1wb3J0IHsgVmFsaWRhdG9yQXJndW1lbnRzIH0gZnJvbSAnLi4vLi4vZm9ybS1maWVsZC5jb250cm9sJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29udHJvbCB0aGF0IGFsbG93cyB0aGUgd3JpdGluZyBvZiBhbiBSTlBTLiBcbiAqIEFuIFJOUFMgKFJlZ2lzdHJvIE5hY2lvbmFsIGRlIFB1YmxpY2FjaW9uZXMgU2VyaWFkYXMpIGlzIGFuIDQtZGlnaXQgY29kZSB1c2VkIHRvIGNvbnRyb2wgXG4gKiB0aGUgc2VyaWFsIHB1YmxpY2F0aW9ucyBhdXRob3JpemVkIHRvIGJlIGVkaXRlZCwgcHJpbnRlZCBhbmQgY2lyY3VsYXRlZCBpbiBDdWJhLiBcbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGZvbGxvdyB0aGUgbGluazogaHR0cDovL3d3dy5zZXJpYWRhcy5jdWx0LmN1Ly4gXG4gKiBJdCB1c2VzIHRoZSBgUm5wc1ZhbHVlLnJucHNfQWJicmV2aWF0aW9uYCBhcyBhIGxhYmVsIGlmIHRoZSBgY29udGVudC5sYWJlbGAgaXMgbm90IHNwZWNpZmllZC4gXG4gKiBJdCB1c2VzIHRoZSBgUm5wc1ZhbHVlLnJucHNfUGxhY2Vob2xkZXJgIGFzIGEgcGxhY2Vob2xkZXIgaWYgdGhlIGBjb250ZW50LnBsYWNlaG9sZGVyYCBpcyBub3Qgc3BlY2lmaWVkLiBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpbnB1dC1ybnBzJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4uL3RleHQvdGV4dC1pbnB1dC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4uL3RleHQvdGV4dC1pbnB1dC5jb21wb25lbnQuc2NzcyddLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJ1tzdHlsZS5taW5XaWR0aF0nOiAnY29udGVudC5taW5XaWR0aCcsXG4gICAgICAgICdbc3R5bGUud2lkdGhdJzogJ2NvbnRlbnQud2lkdGgnXG4gICAgfVxufSlcbmV4cG9ydCBjbGFzcyBJbnB1dFJucHNDb21wb25lbnQgZXh0ZW5kcyBJbnB1dENvbnRyb2wgaW1wbGVtZW50cyBPbkluaXRcbntcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgYEZvcm1Db250cm9sYCBieSBkZWZhdWx0LiBcbiAgICAgKiBJdCBpcyB1c2VkIHRvIGluaXRpYWxpemVkIHRoZSBgSW5wdXRSbnBzQ29tcG9uZW50YCdzIGBjb250ZW50LmZvcm1Db250cm9sYCB2YWx1ZSBieSBkZWZhdWx0LiBcbiAgICAgKiBJbiB0aGlzIGNhc2UsIHRoZSBgdmFsaWRhdG9yQXJndW1lbnRzYCBhcmd1bWVudCBpcyBhbHdheXMgYHVuZGVmaW5lZGAuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Rm9ybUNvbnRyb2xCeURlZmF1bHQodmFsaWRhdG9yQXJndW1lbnRzOiBWYWxpZGF0b3JBcmd1bWVudHMgPSB1bmRlZmluZWQpOiBGb3JtQ29udHJvbFxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtQ29udHJvbCgnJywgW1xuICAgICAgICAgICAgRXh0cmFWYWxpZGF0b3JzLmVxdWFsTGVuZ3RoKFJucHNWYWx1ZS5jb2RlTGVuZ3RoKSxcbiAgICAgICAgICAgIFZhbGlkYXRvcnMucGF0dGVybignXlswLTldKiQnKVxuICAgICAgICBdKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEl0IGlzIHVzZWQgYnkgYGhhbmRsZVNwZWNpZmljSW5wdXRgIG1ldGhvZC4gXG5cdCAqL1xuICAgIHByaXZhdGUgX2NvZGVPbGRWYWx1ZTogc3RyaW5nO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5fY29kZU9sZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkXG4gICAge1xuICAgICAgICAvKiBTZXRzIHRoZSBkZWZhdWx0IHZhbHVlcy4gKi9cblxuICAgICAgICB0aGlzLmluaXQoUm5wc1ZhbHVlLnJucHNfQWJicmV2aWF0aW9uLCBSbnBzVmFsdWUucm5wc19QbGFjZWhvbGRlciwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgLyogVGhlICdfY29kZU9sZFZhbHVlJyBtdXN0IGJlIHNldCBhZnRlciB0aGUgJ2NvbnRlbnQuZm9ybUNvbnRyb2wudmFsdWUnIGlzIHNldC4gKi9cbiAgICAgICAgdGhpcy5oYW5kbGVTcGVjaWZpY0lucHV0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlcnJvciBzdHJpbmcgaWYgdGhlIGNvbnRyb2wgaXMgaW4gYW4gZXJyb3Igc3RhdGU7IG90aGVyd2lzZSwgZW1wdHkgc3RyaW5nLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0RXJyb3JNZXNzYWdlKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgbGV0IHJlc3VsdDogc3RyaW5nID0gJyc7XG4gICAgICAgIGxldCByZXN1bHRfYWxyZWFkeUhhdmVFcnJvckluZm86IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAgICAgbGV0IHZhbGlkYXRpb25FcnJvcnM6IFZhbGlkYXRpb25FcnJvcnMgPSB0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wuZXJyb3JzO1xuXG4gICAgICAgIC8qIFNob3dzIHRoZSBjb2RlIGVycm9ycy4gKi9cbiAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICgodmFsaWRhdGlvbkVycm9yc1tFeHRyYVZhbGlkYXRvcnMuZXF1YWxMZW5ndGgubmFtZV0pIHx8ICh2YWxpZGF0aW9uRXJyb3JzW1ZhbGlkYXRvcnMucmVxdWlyZWQubmFtZV0pKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdUT0NPX05HX0VSUk9SX01TR19STlBTX0xPTkdfSU5WQUwnO1xuICAgICAgICAgICAgICAgIHJlc3VsdF9hbHJlYWR5SGF2ZUVycm9ySW5mbyA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3JzW1ZhbGlkYXRvcnMucGF0dGVybi5uYW1lXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0X2FscmVhZHlIYXZlRXJyb3JJbmZvKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gJ1RPQ09fTkdfRVJST1JfTVNHX1JOUFNfTE9OR19ZX0RJR19JTlZBTCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdUT0NPX05HX0VSUk9SX01TR19STlBTX0RJR19JTlZBTCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0X2FscmVhZHlIYXZlRXJyb3JJbmZvID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVyIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCBieSB0aGUgaW50ZXJuYWwgbG9naWMgd2hlbiB0aGUgY29udHJvbCdzIHZhbHVlIGNoYW5nZXMgaW4gdGhlIFVJLiBcbiAgICAgKiBUaGlzIG1ldGhvZCBjb250YWlucyB0aGUgc3BlY2lmaWMgaGFuZGxpbmcgb2YgdGhlIGlucHV0IHRoYXQgdGhlIGRlcml2ZWQgY2xhc3Mgd2FudHMgdG8gZG8uIFxuXHQgKi9cblx0cHVibGljIGhhbmRsZVNwZWNpZmljSW5wdXQoKTogdm9pZFxuXHR7XG5cdFx0aWYgKHRoaXMuY29udGVudC5mb3JtQ29udHJvbC52YWx1ZS5sZW5ndGggPiBSbnBzVmFsdWUuY29kZUxlbmd0aClcblx0XHR7XG5cdFx0XHQvKiBTZXRzIHRoZSBvbGQgdmFsdWUuICovXG5cdFx0XHR0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5fY29kZU9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qIFVwZGF0ZXMgdGhlIG9sZCB2YWx1ZXMuICovXG4gICAgICAgICAgICB0aGlzLl9jb2RlT2xkVmFsdWUgPSB0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=