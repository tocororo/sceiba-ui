/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/input/text/text-input.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component } from '@angular/core';
import { FormControl, Validators } from '@angular/forms';
import { InputControl } from '../input.control';
/**
 * Represents a control that allows the writing of a text.
 */
var InputTextComponent = /** @class */ (function (_super) {
    tslib_1.__extends(InputTextComponent, _super);
    function InputTextComponent() {
        return _super.call(this) || this;
    }
    /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputTextComponent`'s `content.formControl` value by default.
     * @param validatorArguments An object that has only one field of `pattern` name and its value is a string.
     * The `pattern` name is the validator name and the value is the value that the validator needs to check.
     * For example, you can call the `getFormControlByDefault` method in this way:
     * InputTextComponent.getFormControlByDefault({ 'pattern': '^[a-zA-Z][a-zA-Z\-\_\ 0-9]*$' });
     * If this argument is not specified, by default its value is `undefined`.
     */
    /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputTextComponent`'s `content.formControl` value by default.
     * @param {?=} validatorArguments An object that has only one field of `pattern` name and its value is a string.
     * The `pattern` name is the validator name and the value is the value that the validator needs to check.
     * For example, you can call the `getFormControlByDefault` method in this way:
     * InputTextComponent.getFormControlByDefault({ 'pattern': '^[a-zA-Z][a-zA-Z\-\_\ 0-9]*$' });
     * If this argument is not specified, by default its value is `undefined`.
     * @return {?}
     */
    InputTextComponent.getFormControlByDefault = /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputTextComponent`'s `content.formControl` value by default.
     * @param {?=} validatorArguments An object that has only one field of `pattern` name and its value is a string.
     * The `pattern` name is the validator name and the value is the value that the validator needs to check.
     * For example, you can call the `getFormControlByDefault` method in this way:
     * InputTextComponent.getFormControlByDefault({ 'pattern': '^[a-zA-Z][a-zA-Z\-\_\ 0-9]*$' });
     * If this argument is not specified, by default its value is `undefined`.
     * @return {?}
     */
    function (validatorArguments) {
        if (validatorArguments === void 0) { validatorArguments = undefined; }
        return new FormControl('', (((validatorArguments) && (validatorArguments.pattern)) ? [Validators.pattern(validatorArguments.pattern)] : []));
    };
    /**
     * @return {?}
     */
    InputTextComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /* Sets the default values. */
        this.init('', '', false, true);
    };
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     */
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * @return {?}
     */
    InputTextComponent.prototype.getErrorMessage = /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validationErrors = this.content.formControl.errors;
        /* Shows the identifier errors. */
        if (validationErrors) {
            if (validationErrors[Validators.required.name]) {
                return this.validationError_required;
            }
            else {
                /* It is `validationErrors[Validators.pattern.name]`. */
                return 'TOCO_NG_ERROR_MSG_TEXTO_INVAL';
            }
        }
        return '';
    };
    InputTextComponent.decorators = [
        { type: Component, args: [{
                    selector: 'input-text',
                    template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                    host: {
                        '[style.minWidth]': 'content.minWidth',
                        '[style.width]': 'content.width'
                    },
                    styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
                }] }
    ];
    /** @nocollapse */
    InputTextComponent.ctorParameters = function () { return []; };
    return InputTextComponent;
}(InputControl));
export { InputTextComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC1pbnB1dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly90b2NvLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9mb3Jtcy9pbnB1dC90ZXh0L3RleHQtaW5wdXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQVUsTUFBTSxlQUFlLENBQUM7QUFDbEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQW9CLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0UsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDOzs7O0FBTWhEO0lBU3dDLDhDQUFZO0lBZ0JoRDtlQUVJLGlCQUFPO0lBQ1gsQ0FBQztJQWpCRDs7Ozs7Ozs7T0FRRzs7Ozs7Ozs7Ozs7SUFDVywwQ0FBdUI7Ozs7Ozs7Ozs7SUFBckMsVUFBc0Msa0JBQWtEO1FBQWxELG1DQUFBLEVBQUEsOEJBQWtEO1FBRXBGLE9BQU8sSUFBSSxXQUFXLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRyxDQUFDLENBQUMsQ0FBQztJQUNsSixDQUFDOzs7O0lBT00scUNBQVE7OztJQUFmO1FBRUksOEJBQThCO1FBQzlCLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVEOztPQUVHOzs7OztJQUNJLDRDQUFlOzs7O0lBQXRCOztZQUVRLGdCQUFnQixHQUFxQixJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxNQUFNO1FBRXhFLGtDQUFrQztRQUNsQyxJQUFJLGdCQUFnQixFQUNwQjtZQUNJLElBQUksZ0JBQWdCLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFDOUM7Z0JBQ0ksT0FBTyxJQUFJLENBQUMsd0JBQXdCLENBQUM7YUFDeEM7aUJBRUQ7Z0JBQ0ksd0RBQXdEO2dCQUN4RCxPQUFPLCtCQUErQixDQUFDO2FBQzFDO1NBQ0o7UUFFRCxPQUFPLEVBQUUsQ0FBQztJQUNkLENBQUM7O2dCQTFESixTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLFlBQVk7b0JBQ3RCLHl3R0FBMEM7b0JBRTFDLElBQUksRUFBRTt3QkFDRixrQkFBa0IsRUFBRSxrQkFBa0I7d0JBQ3RDLGVBQWUsRUFBRSxlQUFlO3FCQUNuQzs7aUJBQ0o7Ozs7SUFtREQseUJBQUM7Q0FBQSxBQTNERCxDQVN3QyxZQUFZLEdBa0RuRDtTQWxEWSxrQkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtQ29udHJvbCwgVmFsaWRhdG9ycywgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcblxuaW1wb3J0IHsgSW5wdXRDb250cm9sIH0gZnJvbSAnLi4vaW5wdXQuY29udHJvbCc7XG5pbXBvcnQgeyBWYWxpZGF0b3JBcmd1bWVudHMgfSBmcm9tICcuLi8uLi9mb3JtLWZpZWxkLmNvbnRyb2wnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb250cm9sIHRoYXQgYWxsb3dzIHRoZSB3cml0aW5nIG9mIGEgdGV4dC4gXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaW5wdXQtdGV4dCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RleHQtaW5wdXQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3RleHQtaW5wdXQuY29tcG9uZW50LnNjc3MnXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdbc3R5bGUubWluV2lkdGhdJzogJ2NvbnRlbnQubWluV2lkdGgnLFxuICAgICAgICAnW3N0eWxlLndpZHRoXSc6ICdjb250ZW50LndpZHRoJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgSW5wdXRUZXh0Q29tcG9uZW50IGV4dGVuZHMgSW5wdXRDb250cm9sIGltcGxlbWVudHMgT25Jbml0XG57XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBGb3JtQ29udHJvbGAgYnkgZGVmYXVsdC4gXG4gICAgICogSXQgaXMgdXNlZCB0byBpbml0aWFsaXplZCB0aGUgYElucHV0VGV4dENvbXBvbmVudGAncyBgY29udGVudC5mb3JtQ29udHJvbGAgdmFsdWUgYnkgZGVmYXVsdC4gXG4gICAgICogQHBhcmFtIHZhbGlkYXRvckFyZ3VtZW50cyBBbiBvYmplY3QgdGhhdCBoYXMgb25seSBvbmUgZmllbGQgb2YgYHBhdHRlcm5gIG5hbWUgYW5kIGl0cyB2YWx1ZSBpcyBhIHN0cmluZy4gXG4gICAgICogVGhlIGBwYXR0ZXJuYCBuYW1lIGlzIHRoZSB2YWxpZGF0b3IgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIHRoZSB2YWx1ZSB0aGF0IHRoZSB2YWxpZGF0b3IgbmVlZHMgdG8gY2hlY2suIFxuICAgICAqIEZvciBleGFtcGxlLCB5b3UgY2FuIGNhbGwgdGhlIGBnZXRGb3JtQ29udHJvbEJ5RGVmYXVsdGAgbWV0aG9kIGluIHRoaXMgd2F5OiBcbiAgICAgKiBJbnB1dFRleHRDb21wb25lbnQuZ2V0Rm9ybUNvbnRyb2xCeURlZmF1bHQoeyAncGF0dGVybic6ICdeW2EtekEtWl1bYS16QS1aXFwtXFxfXFwgMC05XSokJyB9KTtcbiAgICAgKiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWQsIGJ5IGRlZmF1bHQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldEZvcm1Db250cm9sQnlEZWZhdWx0KHZhbGlkYXRvckFyZ3VtZW50czogVmFsaWRhdG9yQXJndW1lbnRzID0gdW5kZWZpbmVkKTogRm9ybUNvbnRyb2xcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgRm9ybUNvbnRyb2woJycsICgoKHZhbGlkYXRvckFyZ3VtZW50cykgJiYgKHZhbGlkYXRvckFyZ3VtZW50cy5wYXR0ZXJuKSkgPyBbVmFsaWRhdG9ycy5wYXR0ZXJuKHZhbGlkYXRvckFyZ3VtZW50cy5wYXR0ZXJuKV0gOiBbIF0pKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZXMuICovXG4gICAgICAgIHRoaXMuaW5pdCgnJywgJycsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVycm9yIHN0cmluZyBpZiB0aGUgY29udHJvbCBpcyBpbiBhbiBlcnJvciBzdGF0ZTsgb3RoZXJ3aXNlLCBlbXB0eSBzdHJpbmcuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRFcnJvck1lc3NhZ2UoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBsZXQgdmFsaWRhdGlvbkVycm9yczogVmFsaWRhdGlvbkVycm9ycyA9IHRoaXMuY29udGVudC5mb3JtQ29udHJvbC5lcnJvcnM7XG5cbiAgICAgICAgLyogU2hvd3MgdGhlIGlkZW50aWZpZXIgZXJyb3JzLiAqL1xuICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9ycylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnNbVmFsaWRhdG9ycy5yZXF1aXJlZC5uYW1lXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0aW9uRXJyb3JfcmVxdWlyZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLyogSXQgaXMgYHZhbGlkYXRpb25FcnJvcnNbVmFsaWRhdG9ycy5wYXR0ZXJuLm5hbWVdYC4gKi9cbiAgICAgICAgICAgICAgICByZXR1cm4gJ1RPQ09fTkdfRVJST1JfTVNHX1RFWFRPX0lOVkFMJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4iXX0=