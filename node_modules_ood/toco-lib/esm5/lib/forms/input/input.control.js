/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/input/input.control.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*
 *   Copyright (c) 2020 Universidad de Pinar del Río "Hermanos Saíz Montes de Oca"
 *   All rights reserved.
 */
import { Input, ViewChild } from '@angular/core';
import { Validators, FormControl } from '@angular/forms';
import { isNullOrUndefined } from 'util';
import { ContentPosition, HintPosition, HintValue, FormFieldControl } from '../form-field.control';
/** @enum {string} */
var TextInputAppearance = {
    /**
     * The `standard` appearance is the default style. It shows the input box with an underline underneath it.
     */
    standard: "standard",
    /**
     * The `fill` appearance displays the form field with a filled background box in addition to the underline.
     */
    fill: "fill",
    /**
     * The `outline` appearance shows the form field with a border all the way around, not just an underline.
     */
    outline: "outline",
};
export { TextInputAppearance };
/**
 * A base interface that represents the content of an `InputControl`.
 * @record
 */
export function InputContent() { }
if (false) {
    /**
     * Returns the `FormControl` that tracks the value and validity state of the internal control that contains the text input.
     * Implementation notes: There are two cases:
     *  - You only have the `content.formControl` field as the `InputEmailComponent` class.
     *  - You have the `content.formControl` and `InputControl.internalComponent` fields as the `InputIssnComponent` class.
     *  - It must be specified; otherwise, an exception is thrown.
     * @type {?|undefined}
     */
    InputContent.prototype.formControl;
    /**
     * Returns the control's appearance.
     * By default, its value is `TextInputAppearance.standard`.
     * @type {?|undefined}
     */
    InputContent.prototype.appearance;
    /**
     * Returns the control's prefix icon.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.prefixIcon;
    /**
     * Returns the control's suffix icon.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.suffixIcon;
    /**
     * Returns the control's prefix text.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.prefixText;
    /**
     * Returns the control's suffix text.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.suffixText;
    /**
     * Returns the control's start hint.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.startHint;
    /**
     * Returns the control's end hint.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.endHint;
}
/**
 * An interface which allows to manipulate the internal component that contains the text input.
 * This interface is implemented when it is created a custom `MatFormFieldControl`.
 * @record
 */
export function IInternalComponent() { }
if (false) {
    /**
     * Tracks the value and validity state of the internal control that contains the text input.
     * @type {?}
     */
    IInternalComponent.prototype.formControl;
    /**
     * Returns or sets the value of the control.
     * @type {?}
     */
    IInternalComponent.prototype.value;
    /**
     * Returns true if the control is empty; otherwise, false.
     * A control is empty if its value is `undefined` or empty string.
     * @type {?}
     */
    IInternalComponent.prototype.empty;
    /**
     * Returns true if the control is in an error state; otherwise, false.
     * @type {?}
     */
    IInternalComponent.prototype.errorState;
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * @return {?}
     */
    IInternalComponent.prototype.getErrorMessage = function () { };
}
/**
 * Represents the base abstract class for a control that allows the writing/selection of a text.
 * @abstract
 */
var InputControl = /** @class */ (function (_super) {
    tslib_1.__extends(InputControl, _super);
    /**
     * Constructs a new instance of this class.
     */
    function InputControl() {
        var _this = _super.call(this) || this;
        _this.validationError_required = '';
        return _this;
    }
    /**
     * Returns a `FormControl` by default.
     * Its value is empty, and does not have validators.
     * @param validatorArguments A collection of key/value elements, where the key is the validator name
     * and the value is the value that the validator needs to check.
     */
    /**
     * Returns a `FormControl` by default.
     * Its value is empty, and does not have validators.
     * @param {?=} validatorArguments A collection of key/value elements, where the key is the validator name
     * and the value is the value that the validator needs to check.
     * @return {?}
     */
    InputControl.getFormControlByDefault = /**
     * Returns a `FormControl` by default.
     * Its value is empty, and does not have validators.
     * @param {?=} validatorArguments A collection of key/value elements, where the key is the validator name
     * and the value is the value that the validator needs to check.
     * @return {?}
     */
    function (validatorArguments) {
        if (validatorArguments === void 0) { validatorArguments = undefined; }
        return new FormControl('', []);
    };
    /**
     * Sets the new language.
     * @param transServ The `TranslateService` instance injected.
     */
    /**
     * Sets the new language.
     * @protected
     * @param {?} transServ The `TranslateService` instance injected.
     * @return {?}
     */
    InputControl.prototype.setNewLanguage = /**
     * Sets the new language.
     * @protected
     * @param {?} transServ The `TranslateService` instance injected.
     * @return {?}
     */
    function (transServ) {
        /* The `InputControl.currentLang != transServ.currentLang` test is NOT necessary here because it is done in the non-abstract child classes. */
        _super.prototype.setNewLanguage.call(this, transServ);
        /* The `InputControl.currentLang` value is updated correctly in the parent class. */
        transServ.get('TOCO_NG_ERROR_MSG_REQUERIDO').subscribe((/**
         * @param {?} res
         * @return {?}
         */
        function (res) {
            InputControl.toco_ng_Error_Msg_Requerido = res;
        }));
    };
    /**
     * Initializes the `content` input property.
     * @param label The default label to use. It is used if the `content.label` is not specified.
     * @param placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
     * @param isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
     * @param alwaysHint If it is true then there is always at leat one hint start-aligned.
     */
    /**
     * Initializes the `content` input property.
     * @protected
     * @param {?} label The default label to use. It is used if the `content.label` is not specified.
     * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
     * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
     * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
     * @return {?}
     */
    InputControl.prototype.init = /**
     * Initializes the `content` input property.
     * @protected
     * @param {?} label The default label to use. It is used if the `content.label` is not specified.
     * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
     * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
     * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
     * @return {?}
     */
    function (label, placeholder, isAbbreviation, alwaysHint) {
        /* Sets the default values. */
        if (placeholder === void 0) { placeholder = ''; }
        if (isAbbreviation === void 0) { isAbbreviation = false; }
        if (alwaysHint === void 0) { alwaysHint = true; }
        _super.prototype.init.call(this, label, placeholder);
        if (this.content.formControl == undefined) {
            if (this.internalComponent == undefined)
                throw new Error("For the '" + this.content.name + "' control, the 'content.formControl' value can not be undefined; it must be a 'FormControl' value.");
            this.content.formControl = this.internalComponent.formControl;
        }
        // let temp: string = (isAbbreviation) ? this.content.label : this.content.label.toLowerCase();
        this.validationError_required = 'TOCO_NG_ERROR_MSG_REQUERIDO';
        /************************** Internal control properties. **************************/
        if (this.content.required == undefined)
            this.content.required = false;
        /************************** `mat-form-field` properties. **************************/
        if (this.content.appearance == undefined)
            this.content.appearance = TextInputAppearance.standard;
        /***************************** `mat-icon` properties. *****************************/
        if (this.content.prefixIcon != undefined)
            this.content.prefixIcon.setDefaultValueIfUndefined_setPosition(ContentPosition.prefix);
        if (this.content.suffixIcon != undefined)
            this.content.suffixIcon.setDefaultValueIfUndefined_setPosition(ContentPosition.suffix);
        /***************************** `mat-hint` properties. *****************************/
        if (alwaysHint && (this.content.startHint == undefined) && (this.content.endHint == undefined)) {
            this.content.startHint = new HintValue(HintPosition.start, 'TOCO_NG_HINT_TEXTO_POR_DEFECTO');
        }
        else {
            if (this.content.startHint != undefined)
                this.content.startHint.setDefaultValueIfUndefined_setPosition(HintPosition.start);
            if (this.content.endHint != undefined)
                this.content.endHint.setDefaultValueIfUndefined_setPosition(HintPosition.end);
        }
        /* Adds this control as a child to the `content.parentFormSection`.
        It must be called at the end. */
        if (this.content.parentFormSection != undefined) {
            console.log('addAsChildControl(this.content.formControl)');
            this.addAsChildControl(this, this.content.formControl);
        }
    };
    /**
     * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
     * It also checks if the specified `content.value` is correct. For internal use only.
     */
    /**
     * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
     * It also checks if the specified `content.value` is correct. For internal use only.
     * @protected
     * @return {?}
     */
    InputControl.prototype.initValue = /**
     * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
     * It also checks if the specified `content.value` is correct. For internal use only.
     * @protected
     * @return {?}
     */
    function () {
        /* In this way, checks if the specified `content.value` is correct. */
        this.content.formControl.setValue(this.content.value);
        /* Marks the control as `touched`. */
        this.content.formControl.markAsTouched({
            onlySelf: true
        });
    };
    Object.defineProperty(InputControl.prototype, "getInstance", {
        /**
         * Returns this instance.
         */
        get: /**
         * Returns this instance.
         * @return {?}
         */
        function () {
            return this;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputControl.prototype, "empty", {
        /**
         * Returns true if the control is empty; otherwise, false.
         * A control is empty if its value is `undefined` or empty string.
         */
        get: /**
         * Returns true if the control is empty; otherwise, false.
         * A control is empty if its value is `undefined` or empty string.
         * @return {?}
         */
        function () {
            if (this.internalComponent == undefined)
                return ((isNullOrUndefined(this.content.formControl.value)) || (this.content.formControl.value === ''));
            return this.internalComponent.empty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputControl.prototype, "hintState", {
        /**
         * Returns true if the control is in a hint state; otherwise, false.
         */
        get: /**
         * Returns true if the control is in a hint state; otherwise, false.
         * @return {?}
         */
        function () {
            return this.empty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(InputControl.prototype, "errorState", {
        /**
         * Returns true if the control is in an error state; otherwise, false.
         */
        get: /**
         * Returns true if the control is in an error state; otherwise, false.
         * @return {?}
         */
        function () {
            /* The control does not display errors before the user has a
             * chance to edit the form. The checks for dirty and touched prevent errors
             * from showing until the user does one of two things: changes the value,
             * turning the control dirty; or blurs the form control element, setting the
             * control to touched.
             * Thus, it reveals an error message only if the control is invalid and
             * the control is either dirty or touched. */
            if (this.internalComponent == undefined)
                return ((this.content.formControl.invalid) && (this.content.formControl.dirty || this.content.formControl.touched));
            return this.internalComponent.errorState;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Handler method that is called when the control's value changes in the UI. For internal use only.
     * If a derived class wants to do some specific handling then it must overwrite
     * the `handleSpecificInput` method.
     */
    /**
     * Handler method that is called when the control's value changes in the UI. For internal use only.
     * If a derived class wants to do some specific handling then it must overwrite
     * the `handleSpecificInput` method.
     * @return {?}
     */
    InputControl.prototype.handleInput = /**
     * Handler method that is called when the control's value changes in the UI. For internal use only.
     * If a derived class wants to do some specific handling then it must overwrite
     * the `handleSpecificInput` method.
     * @return {?}
     */
    function () {
        /* Calls the specific handling of the input that the derived class wants to do. */
        this.handleSpecificInput();
        // TODO: hacer la salva del valor del control para `this.content.value` de una mejor forma 
        // porque hacerlo aquí genera inconsistencias. Una mejor forma sería proporcionar un method que 
        // haga la función de salvar el valor y entonces es llamado cuando haga falta. 
        /* If the control does not have error ... */
        if (!this.errorState) {
            /* ... sets the new value of the control in the `content`. */
            this.content.value = this.content.formControl.value;
        }
        /* If the control is not marked as `touched` ... */
        if (this.content.formControl.untouched) {
            /* ... marks the control as `touched`. */
            this.content.formControl.markAsTouched({
                onlySelf: true
            });
        }
    };
    Object.defineProperty(InputControl.prototype, "getDefaultValue", {
        /**
         * Returns the control's default value.
         * This function can be overwrite in the derived class.
         */
        get: /**
         * Returns the control's default value.
         * This function can be overwrite in the derived class.
         * @return {?}
         */
        function () {
            /* By default, its implementation is returning the empty string. */
            return '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * This function can be overwrite in the derived class.
     */
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * This function can be overwrite in the derived class.
     * @return {?}
     */
    InputControl.prototype.getErrorMessage = /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * This function can be overwrite in the derived class.
     * @return {?}
     */
    function () {
        /* By default, its implementation is returning the error of the `internalComponent.getErrorMessage`
         * method or returning the text errors. */
        if (this.internalComponent != undefined)
            return this.internalComponent.getErrorMessage();
        /** @type {?} */
        var validationErrors = this.content.formControl.errors;
        /* Shows the text errors. */
        if (validationErrors) {
            if (validationErrors[Validators.required.name]) {
                return ((this.isTranslationBuiltByControl) ? InputControl.toco_ng_Error_Msg_Requerido : this.validationError_required);
            }
        }
        return '';
    };
    /**
     * Handler method that is called by the internal logic when the control's value changes in the UI.
     * This method contains the specific handling of the input that the derived class wants to do.
     * This function can be overwrite in the derived class.
     */
    /**
     * Handler method that is called by the internal logic when the control's value changes in the UI.
     * This method contains the specific handling of the input that the derived class wants to do.
     * This function can be overwrite in the derived class.
     * @return {?}
     */
    InputControl.prototype.handleSpecificInput = /**
     * Handler method that is called by the internal logic when the control's value changes in the UI.
     * This method contains the specific handling of the input that the derived class wants to do.
     * This function can be overwrite in the derived class.
     * @return {?}
     */
    function () {
        /* By default, its implementation has nothing to do. */
    };
    InputControl.toco_ng_Error_Msg_Requerido = '';
    InputControl.propDecorators = {
        content: [{ type: Input }],
        internalComponent: [{ type: ViewChild, args: ['internalComponent', { static: true },] }]
    };
    return InputControl;
}(FormFieldControl));
export { InputControl };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    InputControl.toco_ng_Error_Msg_Requerido;
    /**
     * Input field that contains the content of this class.
     * @type {?}
     */
    InputControl.prototype.content;
    /**
     * Tracks the value and validity state of the internal component that contains the text input.
     * Implementation notes: There are two cases:
     *  - You only have the `content.formControl` field as the `InputEmailComponent` class.
     *  - You have the `content.formControl` and `internalComponent` fields as the `InputIssnComponent` class.
     * @type {?}
     * @protected
     */
    InputControl.prototype.internalComponent;
    /**
     * Represents the validation error of required. Its default value can be overwritten.
     * @type {?}
     * @protected
     */
    InputControl.prototype.validationError_required;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuY29udHJvbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3RvY28tbGliLyIsInNvdXJjZXMiOlsibGliL2Zvcm1zL2lucHV0L2lucHV0LmNvbnRyb2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQU1BLE9BQU8sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2pELE9BQU8sRUFBRSxVQUFVLEVBQW9CLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUV6QyxPQUFPLEVBQUUsZUFBZSxFQUFhLFlBQVksRUFBRSxTQUFTLEVBQ3RDLGdCQUFnQixFQUFzQixNQUFNLHVCQUF1QixDQUFDOztBQUsxRixJQUFZLG1CQUFtQjtJQUUzQjs7T0FFRztJQUNILFFBQVEsWUFBYTtJQUVyQjs7T0FFRztJQUNILElBQUksUUFBUztJQUViOztPQUVHO0lBQ0gsT0FBTyxXQUFZO0VBQ3RCOzs7Ozs7QUFLRCxrQ0E0REM7Ozs7Ozs7Ozs7SUFuREcsbUNBQTBCOzs7Ozs7SUFRMUIsa0NBQWlDOzs7Ozs7SUFRakMsa0NBQXVCOzs7Ozs7SUFNdkIsa0NBQXVCOzs7Ozs7SUFRdkIsa0NBQW9COzs7Ozs7SUFNcEIsa0NBQW9COzs7Ozs7SUFRcEIsaUNBQXNCOzs7Ozs7SUFNdEIsK0JBQW9COzs7Ozs7O0FBT3hCLHdDQTJCQzs7Ozs7O0lBdEJHLHlDQUFrQzs7Ozs7SUFLbEMsbUNBQXVCOzs7Ozs7SUFNMUIsbUNBQXdCOzs7OztJQUtyQix3Q0FBNkI7Ozs7O0lBSzdCLCtEQUEwQjs7Ozs7O0FBTTlCO0lBQTJDLHdDQUFnQjtJQW1DdkQ7O09BRUc7SUFDSDtRQUFBLFlBRUksaUJBQU8sU0FHVjtRQURHLEtBQUksQ0FBQyx3QkFBd0IsR0FBRyxFQUFFLENBQUM7O0lBQ3ZDLENBQUM7SUF6Q0Q7Ozs7O09BS0c7Ozs7Ozs7O0lBQ1csb0NBQXVCOzs7Ozs7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QUFJLElBQUksQ0FBQyxpQkFBaUIsSUFBSSxTQUFTO1lBQUUsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsZUFBZSxFQUFFLENBQUM7O1lBRXJGLGdCQUFnQixHQUFxQixJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxNQUFNO1FBRXhFLDRCQUE0QjtRQUM1QixJQUFJLGdCQUFnQixFQUNwQjtZQUNJLElBQUksZ0JBQWdCLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFDOUM7Z0JBQ0ksT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLDJCQUEyQixDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQywyQkFBMkIsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLHdCQUF3QixDQUFDLENBQUM7YUFDMUg7U0FDSjtRQUVELE9BQU8sRUFBRSxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7OztPQUlHOzs7Ozs7O0lBQ08sMENBQW1COzs7Ozs7SUFBMUI7UUFFSSx1REFBdUQ7SUFDM0QsQ0FBQztJQTNOZ0Isd0NBQTJCLEdBQVcsRUFBRSxDQUFDOzswQkFaekQsS0FBSztvQ0FTUixTQUFTLFNBQUMsbUJBQW1CLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFOztJQStOakQsbUJBQUM7Q0FBQSxBQXhQRCxDQUEyQyxnQkFBZ0IsR0F3UDFEO1NBeFBxQixZQUFZOzs7Ozs7SUE0QjlCLHlDQUEwRDs7Ozs7SUFaMUQsK0JBQzZCOzs7Ozs7Ozs7SUFRaEMseUNBQzREOzs7Ozs7SUFPekQsZ0RBQTJDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICAgQ29weXJpZ2h0IChjKSAyMDIwIFVuaXZlcnNpZGFkIGRlIFBpbmFyIGRlbCBSw61vIFwiSGVybWFub3MgU2HDrXogTW9udGVzIGRlIE9jYVwiXG4gKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuXG5pbXBvcnQgeyBJbnB1dCwgVmlld0NoaWxkIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBWYWxpZGF0b3JzLCBWYWxpZGF0aW9uRXJyb3JzLCBGb3JtQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IGlzTnVsbE9yVW5kZWZpbmVkIH0gZnJvbSAndXRpbCc7XG5cbmltcG9ydCB7IENvbnRlbnRQb3NpdGlvbiwgSWNvblZhbHVlLCBIaW50UG9zaXRpb24sIEhpbnRWYWx1ZSxcbiAgICBGb3JtRmllbGRDb250ZW50LCBGb3JtRmllbGRDb250cm9sLCBWYWxpZGF0b3JBcmd1bWVudHMgfSBmcm9tICcuLi9mb3JtLWZpZWxkLmNvbnRyb2wnO1xuXG4vKipcbiAqIEFuIGVudW0gdGhhdCByZXByZXNlbnRzIHRoZSBhcHBlYXJhbmNlIHN0eWxlIG9mIGFuIGBJbnB1dENvbnRyb2xgLiBcbiAqL1xuZXhwb3J0IGVudW0gVGV4dElucHV0QXBwZWFyYW5jZVxue1xuICAgIC8qKlxuICAgICAqIFRoZSBgc3RhbmRhcmRgIGFwcGVhcmFuY2UgaXMgdGhlIGRlZmF1bHQgc3R5bGUuIEl0IHNob3dzIHRoZSBpbnB1dCBib3ggd2l0aCBhbiB1bmRlcmxpbmUgdW5kZXJuZWF0aCBpdC4gXG4gICAgICovXG4gICAgc3RhbmRhcmQgPSAnc3RhbmRhcmQnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGBmaWxsYCBhcHBlYXJhbmNlIGRpc3BsYXlzIHRoZSBmb3JtIGZpZWxkIHdpdGggYSBmaWxsZWQgYmFja2dyb3VuZCBib3ggaW4gYWRkaXRpb24gdG8gdGhlIHVuZGVybGluZS4gXG4gICAgICovXG4gICAgZmlsbCA9ICdmaWxsJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBgb3V0bGluZWAgYXBwZWFyYW5jZSBzaG93cyB0aGUgZm9ybSBmaWVsZCB3aXRoIGEgYm9yZGVyIGFsbCB0aGUgd2F5IGFyb3VuZCwgbm90IGp1c3QgYW4gdW5kZXJsaW5lLiBcbiAgICAgKi9cbiAgICBvdXRsaW5lID0gJ291dGxpbmUnXG59XG5cbi8qKlxuICogQSBiYXNlIGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgb2YgYW4gYElucHV0Q29udHJvbGAuIFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElucHV0Q29udGVudCBleHRlbmRzIEZvcm1GaWVsZENvbnRlbnRcbntcbiAgICAvKipcblx0ICogUmV0dXJucyB0aGUgYEZvcm1Db250cm9sYCB0aGF0IHRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIHRoZSBpbnRlcm5hbCBjb250cm9sIHRoYXQgY29udGFpbnMgdGhlIHRleHQgaW5wdXQuIFxuICAgICAqIEltcGxlbWVudGF0aW9uIG5vdGVzOiBUaGVyZSBhcmUgdHdvIGNhc2VzOiBcbiAgICAgKiAgLSBZb3Ugb25seSBoYXZlIHRoZSBgY29udGVudC5mb3JtQ29udHJvbGAgZmllbGQgYXMgdGhlIGBJbnB1dEVtYWlsQ29tcG9uZW50YCBjbGFzcy4gXG4gICAgICogIC0gWW91IGhhdmUgdGhlIGBjb250ZW50LmZvcm1Db250cm9sYCBhbmQgYElucHV0Q29udHJvbC5pbnRlcm5hbENvbXBvbmVudGAgZmllbGRzIGFzIHRoZSBgSW5wdXRJc3NuQ29tcG9uZW50YCBjbGFzcy4gXG4gICAgICogIC0gSXQgbXVzdCBiZSBzcGVjaWZpZWQ7IG90aGVyd2lzZSwgYW4gZXhjZXB0aW9uIGlzIHRocm93bi4gXG5cdCAqL1xuICAgIGZvcm1Db250cm9sPzogRm9ybUNvbnRyb2w7XG5cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udHJvbCdzIGFwcGVhcmFuY2UuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgVGV4dElucHV0QXBwZWFyYW5jZS5zdGFuZGFyZGAuIFxuICAgICAqL1xuICAgIGFwcGVhcmFuY2U/OiBUZXh0SW5wdXRBcHBlYXJhbmNlO1xuXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyb2wncyBwcmVmaXggaWNvbi4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLiBcbiAgICAgKi9cbiAgICBwcmVmaXhJY29uPzogSWNvblZhbHVlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udHJvbCdzIHN1ZmZpeCBpY29uLiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuIFxuICAgICAqL1xuICAgIHN1ZmZpeEljb24/OiBJY29uVmFsdWU7XG5cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udHJvbCdzIHByZWZpeCB0ZXh0LiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuIFxuICAgICAqL1xuICAgIHByZWZpeFRleHQ/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cm9sJ3Mgc3VmZml4IHRleHQuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4gXG4gICAgICovXG4gICAgc3VmZml4VGV4dD86IHN0cmluZztcblxuXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvbnRyb2wncyBzdGFydCBoaW50LiBcblx0ICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLiBcblx0ICovXG4gICAgc3RhcnRIaW50PzogSGludFZhbHVlO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb250cm9sJ3MgZW5kIGhpbnQuIFxuXHQgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuIFxuXHQgKi9cbiAgICBlbmRIaW50PzogSGludFZhbHVlO1xufVxuXG4vKipcbiAqIEFuIGludGVyZmFjZSB3aGljaCBhbGxvd3MgdG8gbWFuaXB1bGF0ZSB0aGUgaW50ZXJuYWwgY29tcG9uZW50IHRoYXQgY29udGFpbnMgdGhlIHRleHQgaW5wdXQuIFxuICogVGhpcyBpbnRlcmZhY2UgaXMgaW1wbGVtZW50ZWQgd2hlbiBpdCBpcyBjcmVhdGVkIGEgY3VzdG9tIGBNYXRGb3JtRmllbGRDb250cm9sYC4gXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSUludGVybmFsQ29tcG9uZW50XG57XG5cdC8qKlxuXHQgKiBUcmFja3MgdGhlIHZhbHVlIGFuZCB2YWxpZGl0eSBzdGF0ZSBvZiB0aGUgaW50ZXJuYWwgY29udHJvbCB0aGF0IGNvbnRhaW5zIHRoZSB0ZXh0IGlucHV0LiBcblx0ICovXG4gICAgcmVhZG9ubHkgZm9ybUNvbnRyb2w6IEZvcm1Db250cm9sO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIG9yIHNldHMgdGhlIHZhbHVlIG9mIHRoZSBjb250cm9sLiBcblx0ICovXG4gICAgdmFsdWU6IGFueSB8IHVuZGVmaW5lZDtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cm9sIGlzIGVtcHR5OyBvdGhlcndpc2UsIGZhbHNlLiBcbiAgICAgKiBBIGNvbnRyb2wgaXMgZW1wdHkgaWYgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgIG9yIGVtcHR5IHN0cmluZy4gXG5cdCAqL1xuXHRyZWFkb25seSBlbXB0eTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJvbCBpcyBpbiBhbiBlcnJvciBzdGF0ZTsgb3RoZXJ3aXNlLCBmYWxzZS4gXG4gICAgICovXG4gICAgcmVhZG9ubHkgZXJyb3JTdGF0ZTogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZXJyb3Igc3RyaW5nIGlmIHRoZSBjb250cm9sIGlzIGluIGFuIGVycm9yIHN0YXRlOyBvdGhlcndpc2UsIGVtcHR5IHN0cmluZy4gXG4gICAgICovXG4gICAgZ2V0RXJyb3JNZXNzYWdlKCk6IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBiYXNlIGFic3RyYWN0IGNsYXNzIGZvciBhIGNvbnRyb2wgdGhhdCBhbGxvd3MgdGhlIHdyaXRpbmcvc2VsZWN0aW9uIG9mIGEgdGV4dC4gXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBJbnB1dENvbnRyb2wgZXh0ZW5kcyBGb3JtRmllbGRDb250cm9sXG57XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBGb3JtQ29udHJvbGAgYnkgZGVmYXVsdC4gXG4gICAgICogSXRzIHZhbHVlIGlzIGVtcHR5LCBhbmQgZG9lcyBub3QgaGF2ZSB2YWxpZGF0b3JzLiBcbiAgICAgKiBAcGFyYW0gdmFsaWRhdG9yQXJndW1lbnRzIEEgY29sbGVjdGlvbiBvZiBrZXkvdmFsdWUgZWxlbWVudHMsIHdoZXJlIHRoZSBrZXkgaXMgdGhlIHZhbGlkYXRvciBuYW1lIFxuICAgICAqIGFuZCB0aGUgdmFsdWUgaXMgdGhlIHZhbHVlIHRoYXQgdGhlIHZhbGlkYXRvciBuZWVkcyB0byBjaGVjay4gXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRGb3JtQ29udHJvbEJ5RGVmYXVsdCh2YWxpZGF0b3JBcmd1bWVudHM6IFZhbGlkYXRvckFyZ3VtZW50cyA9IHVuZGVmaW5lZCk6IEZvcm1Db250cm9sXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IEZvcm1Db250cm9sKCcnLCBbIF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIElucHV0IGZpZWxkIHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnQgb2YgdGhpcyBjbGFzcy4gXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY29udGVudDogSW5wdXRDb250ZW50O1xuXG4gICAgLyoqXG5cdCAqIFRyYWNrcyB0aGUgdmFsdWUgYW5kIHZhbGlkaXR5IHN0YXRlIG9mIHRoZSBpbnRlcm5hbCBjb21wb25lbnQgdGhhdCBjb250YWlucyB0aGUgdGV4dCBpbnB1dC4gXG4gICAgICogSW1wbGVtZW50YXRpb24gbm90ZXM6IFRoZXJlIGFyZSB0d28gY2FzZXM6IFxuICAgICAqICAtIFlvdSBvbmx5IGhhdmUgdGhlIGBjb250ZW50LmZvcm1Db250cm9sYCBmaWVsZCBhcyB0aGUgYElucHV0RW1haWxDb21wb25lbnRgIGNsYXNzLiBcbiAgICAgKiAgLSBZb3UgaGF2ZSB0aGUgYGNvbnRlbnQuZm9ybUNvbnRyb2xgIGFuZCBgaW50ZXJuYWxDb21wb25lbnRgIGZpZWxkcyBhcyB0aGUgYElucHV0SXNzbkNvbXBvbmVudGAgY2xhc3MuIFxuXHQgKi9cblx0QFZpZXdDaGlsZCgnaW50ZXJuYWxDb21wb25lbnQnLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByb3RlY3RlZCByZWFkb25seSBpbnRlcm5hbENvbXBvbmVudDogSUludGVybmFsQ29tcG9uZW50O1xuXG4gICAgcHJvdGVjdGVkIHN0YXRpYyB0b2NvX25nX0Vycm9yX01zZ19SZXF1ZXJpZG86IHN0cmluZyA9ICcnO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyB0aGUgdmFsaWRhdGlvbiBlcnJvciBvZiByZXF1aXJlZC4gSXRzIGRlZmF1bHQgdmFsdWUgY2FuIGJlIG92ZXJ3cml0dGVuLiBcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdmFsaWRhdGlvbkVycm9yX3JlcXVpcmVkOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuIFxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMudmFsaWRhdGlvbkVycm9yX3JlcXVpcmVkID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbmV3IGxhbmd1YWdlLiBcbiAgICAgKiBAcGFyYW0gdHJhbnNTZXJ2IFRoZSBgVHJhbnNsYXRlU2VydmljZWAgaW5zdGFuY2UgaW5qZWN0ZWQuIFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzZXROZXdMYW5ndWFnZSh0cmFuc1NlcnY6IFRyYW5zbGF0ZVNlcnZpY2UpOiB2b2lkXG4gICAge1xuICAgICAgICAvKiBUaGUgYElucHV0Q29udHJvbC5jdXJyZW50TGFuZyAhPSB0cmFuc1NlcnYuY3VycmVudExhbmdgIHRlc3QgaXMgTk9UIG5lY2Vzc2FyeSBoZXJlIGJlY2F1c2UgaXQgaXMgZG9uZSBpbiB0aGUgbm9uLWFic3RyYWN0IGNoaWxkIGNsYXNzZXMuICovXG5cbiAgICAgICAgc3VwZXIuc2V0TmV3TGFuZ3VhZ2UodHJhbnNTZXJ2KTtcblxuICAgICAgICAvKiBUaGUgYElucHV0Q29udHJvbC5jdXJyZW50TGFuZ2AgdmFsdWUgaXMgdXBkYXRlZCBjb3JyZWN0bHkgaW4gdGhlIHBhcmVudCBjbGFzcy4gKi9cblxuICAgICAgICB0cmFuc1NlcnYuZ2V0KCdUT0NPX05HX0VSUk9SX01TR19SRVFVRVJJRE8nKS5zdWJzY3JpYmUoKHJlczogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICBJbnB1dENvbnRyb2wudG9jb19uZ19FcnJvcl9Nc2dfUmVxdWVyaWRvID0gcmVzO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYGNvbnRlbnRgIGlucHV0IHByb3BlcnR5LiBcbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGRlZmF1bHQgbGFiZWwgdG8gdXNlLiBJdCBpcyB1c2VkIGlmIHRoZSBgY29udGVudC5sYWJlbGAgaXMgbm90IHNwZWNpZmllZC4gXG4gICAgICogQHBhcmFtIHBsYWNlaG9sZGVyIFRoZSBkZWZhdWx0IHBsYWNlaG9sZGVyIHRvIHVzZS4gSXQgaXMgdXNlZCBpZiB0aGUgYGNvbnRlbnQucGxhY2Vob2xkZXJgIGlzIG5vdCBzcGVjaWZpZWQuIFxuICAgICAqIEBwYXJhbSBpc0FiYnJldmlhdGlvbiBJZiBpdCBpcyB0cnVlIHRoZW4gdGhlIGBsYWJlbGAgYXJndW1lbnQgcmVwcmVzZW50cyBhbiBhYmJyZXZpYXRpb247IG90aGVyd2lzZSwgZmFsc2UuIFxuICAgICAqIEBwYXJhbSBhbHdheXNIaW50IElmIGl0IGlzIHRydWUgdGhlbiB0aGVyZSBpcyBhbHdheXMgYXQgbGVhdCBvbmUgaGludCBzdGFydC1hbGlnbmVkLiBcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdChsYWJlbDogc3RyaW5nLCBwbGFjZWhvbGRlcjogc3RyaW5nID0gJycsIGlzQWJicmV2aWF0aW9uOiBib29sZWFuID0gZmFsc2UsIGFsd2F5c0hpbnQ6IGJvb2xlYW4gPSB0cnVlKTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZXMuICovXG5cbiAgICAgICAgc3VwZXIuaW5pdChsYWJlbCwgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wgPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbENvbXBvbmVudCA9PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgRm9yIHRoZSAnJHsgdGhpcy5jb250ZW50Lm5hbWUgfScgY29udHJvbCwgdGhlICdjb250ZW50LmZvcm1Db250cm9sJyB2YWx1ZSBjYW4gbm90IGJlIHVuZGVmaW5lZDsgaXQgbXVzdCBiZSBhICdGb3JtQ29udHJvbCcgdmFsdWUuYCk7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGVudC5mb3JtQ29udHJvbCA9IHRoaXMuaW50ZXJuYWxDb21wb25lbnQuZm9ybUNvbnRyb2w7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZXQgdGVtcDogc3RyaW5nID0gKGlzQWJicmV2aWF0aW9uKSA/IHRoaXMuY29udGVudC5sYWJlbCA6IHRoaXMuY29udGVudC5sYWJlbC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLnZhbGlkYXRpb25FcnJvcl9yZXF1aXJlZCA9ICdUT0NPX05HX0VSUk9SX01TR19SRVFVRVJJRE8nO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKiBJbnRlcm5hbCBjb250cm9sIHByb3BlcnRpZXMuICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LnJlcXVpcmVkID09IHVuZGVmaW5lZCkgdGhpcy5jb250ZW50LnJlcXVpcmVkID0gZmFsc2U7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqIGBtYXQtZm9ybS1maWVsZGAgcHJvcGVydGllcy4gKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuYXBwZWFyYW5jZSA9PSB1bmRlZmluZWQpIHRoaXMuY29udGVudC5hcHBlYXJhbmNlID0gVGV4dElucHV0QXBwZWFyYW5jZS5zdGFuZGFyZDtcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogYG1hdC1pY29uYCBwcm9wZXJ0aWVzLiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5wcmVmaXhJY29uICE9IHVuZGVmaW5lZCkgdGhpcy5jb250ZW50LnByZWZpeEljb24uc2V0RGVmYXVsdFZhbHVlSWZVbmRlZmluZWRfc2V0UG9zaXRpb24oQ29udGVudFBvc2l0aW9uLnByZWZpeCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc3VmZml4SWNvbiAhPSB1bmRlZmluZWQpIHRoaXMuY29udGVudC5zdWZmaXhJY29uLnNldERlZmF1bHRWYWx1ZUlmVW5kZWZpbmVkX3NldFBvc2l0aW9uKENvbnRlbnRQb3NpdGlvbi5zdWZmaXgpO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBgbWF0LWhpbnRgIHByb3BlcnRpZXMuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBpZiAoYWx3YXlzSGludCAmJiAodGhpcy5jb250ZW50LnN0YXJ0SGludCA9PSB1bmRlZmluZWQpICYmICh0aGlzLmNvbnRlbnQuZW5kSGludCA9PSB1bmRlZmluZWQpKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuc3RhcnRIaW50ID0gbmV3IEhpbnRWYWx1ZShIaW50UG9zaXRpb24uc3RhcnQsICdUT0NPX05HX0hJTlRfVEVYVE9fUE9SX0RFRkVDVE8nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc3RhcnRIaW50ICE9IHVuZGVmaW5lZCkgdGhpcy5jb250ZW50LnN0YXJ0SGludC5zZXREZWZhdWx0VmFsdWVJZlVuZGVmaW5lZF9zZXRQb3NpdGlvbihIaW50UG9zaXRpb24uc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5lbmRIaW50ICE9IHVuZGVmaW5lZCkgdGhpcy5jb250ZW50LmVuZEhpbnQuc2V0RGVmYXVsdFZhbHVlSWZVbmRlZmluZWRfc2V0UG9zaXRpb24oSGludFBvc2l0aW9uLmVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBBZGRzIHRoaXMgY29udHJvbCBhcyBhIGNoaWxkIHRvIHRoZSBgY29udGVudC5wYXJlbnRGb3JtU2VjdGlvbmAuIFxuICAgICAgICBJdCBtdXN0IGJlIGNhbGxlZCBhdCB0aGUgZW5kLiAqL1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LnBhcmVudEZvcm1TZWN0aW9uICE9IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2FkZEFzQ2hpbGRDb250cm9sKHRoaXMuY29udGVudC5mb3JtQ29udHJvbCknKTtcblxuICAgICAgICAgICAgdGhpcy5hZGRBc0NoaWxkQ29udHJvbCh0aGlzLCB0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wpO1xuICAgICAgICB9XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgY29udHJvbCdzIHZhbHVlLiBJdCB1c2VzIHRoZSBgY29udGVudC52YWx1ZWAgYW5kIGl0IGlzIGFscmVhZHkgZGlmZmVyZW50IG9mIGB1bmRlZmluZWRgLiBcbiAgICAgKiBJdCBhbHNvIGNoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGBjb250ZW50LnZhbHVlYCBpcyBjb3JyZWN0LiBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuIFxuXHQgKi9cblx0cHJvdGVjdGVkIGluaXRWYWx1ZSgpOiB2b2lkXG5cdHtcbiAgICAgICAgLyogSW4gdGhpcyB3YXksIGNoZWNrcyBpZiB0aGUgc3BlY2lmaWVkIGBjb250ZW50LnZhbHVlYCBpcyBjb3JyZWN0LiAqL1xuICAgICAgICB0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wuc2V0VmFsdWUodGhpcy5jb250ZW50LnZhbHVlKTtcblxuICAgICAgICAvKiBNYXJrcyB0aGUgY29udHJvbCBhcyBgdG91Y2hlZGAuICovXG4gICAgICAgIHRoaXMuY29udGVudC5mb3JtQ29udHJvbC5tYXJrQXNUb3VjaGVkKHtcbiAgICAgICAgICAgIG9ubHlTZWxmOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBpbnN0YW5jZS4gXG4gICAgICovXG4gICAgcHVibGljIGdldCBnZXRJbnN0YW5jZSgpOiBJbnB1dENvbnRyb2xcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cm9sIGlzIGVtcHR5OyBvdGhlcndpc2UsIGZhbHNlLiBcbiAgICAgKiBBIGNvbnRyb2wgaXMgZW1wdHkgaWYgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgIG9yIGVtcHR5IHN0cmluZy4gXG5cdCAqL1xuXHRwdWJsaWMgZ2V0IGVtcHR5KCk6IGJvb2xlYW5cblx0e1xuICAgICAgICBpZiAodGhpcy5pbnRlcm5hbENvbXBvbmVudCA9PSB1bmRlZmluZWQpIHJldHVybiAoKGlzTnVsbE9yVW5kZWZpbmVkKHRoaXMuY29udGVudC5mb3JtQ29udHJvbC52YWx1ZSkpIHx8ICh0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wudmFsdWUgPT09ICcnKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQ29tcG9uZW50LmVtcHR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJvbCBpcyBpbiBhIGhpbnQgc3RhdGU7IG90aGVyd2lzZSwgZmFsc2UuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaGludFN0YXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtcHR5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJvbCBpcyBpbiBhbiBlcnJvciBzdGF0ZTsgb3RoZXJ3aXNlLCBmYWxzZS4gXG4gICAgICovXG4gICAgcHVibGljIGdldCBlcnJvclN0YXRlKCk6IGJvb2xlYW5cbiAgICB7XG4gICAgICAgIC8qIFRoZSBjb250cm9sIGRvZXMgbm90IGRpc3BsYXkgZXJyb3JzIGJlZm9yZSB0aGUgdXNlciBoYXMgYSBcbiAgICAgICAgICogY2hhbmNlIHRvIGVkaXQgdGhlIGZvcm0uIFRoZSBjaGVja3MgZm9yIGRpcnR5IGFuZCB0b3VjaGVkIHByZXZlbnQgZXJyb3JzIFxuICAgICAgICAgKiBmcm9tIHNob3dpbmcgdW50aWwgdGhlIHVzZXIgZG9lcyBvbmUgb2YgdHdvIHRoaW5nczogY2hhbmdlcyB0aGUgdmFsdWUsIFxuICAgICAgICAgKiB0dXJuaW5nIHRoZSBjb250cm9sIGRpcnR5OyBvciBibHVycyB0aGUgZm9ybSBjb250cm9sIGVsZW1lbnQsIHNldHRpbmcgdGhlIFxuICAgICAgICAgKiBjb250cm9sIHRvIHRvdWNoZWQuIFxuICAgICAgICAgKiBUaHVzLCBpdCByZXZlYWxzIGFuIGVycm9yIG1lc3NhZ2Ugb25seSBpZiB0aGUgY29udHJvbCBpcyBpbnZhbGlkIGFuZCBcbiAgICAgICAgICogdGhlIGNvbnRyb2wgaXMgZWl0aGVyIGRpcnR5IG9yIHRvdWNoZWQuICovXG4gICAgICAgIGlmICh0aGlzLmludGVybmFsQ29tcG9uZW50ID09IHVuZGVmaW5lZCkgcmV0dXJuICgodGhpcy5jb250ZW50LmZvcm1Db250cm9sLmludmFsaWQpICYmICh0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wuZGlydHkgfHwgdGhpcy5jb250ZW50LmZvcm1Db250cm9sLnRvdWNoZWQpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxDb21wb25lbnQuZXJyb3JTdGF0ZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEhhbmRsZXIgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIGNvbnRyb2wncyB2YWx1ZSBjaGFuZ2VzIGluIHRoZSBVSS4gRm9yIGludGVybmFsIHVzZSBvbmx5LiBcbiAgICAgKiBJZiBhIGRlcml2ZWQgY2xhc3Mgd2FudHMgdG8gZG8gc29tZSBzcGVjaWZpYyBoYW5kbGluZyB0aGVuIGl0IG11c3Qgb3ZlcndyaXRlIFxuICAgICAqIHRoZSBgaGFuZGxlU3BlY2lmaWNJbnB1dGAgbWV0aG9kLiBcblx0ICovXG5cdHB1YmxpYyBoYW5kbGVJbnB1dCgpOiB2b2lkXG5cdHtcbiAgICAgICAgLyogQ2FsbHMgdGhlIHNwZWNpZmljIGhhbmRsaW5nIG9mIHRoZSBpbnB1dCB0aGF0IHRoZSBkZXJpdmVkIGNsYXNzIHdhbnRzIHRvIGRvLiAqL1xuICAgICAgICB0aGlzLmhhbmRsZVNwZWNpZmljSW5wdXQoKTtcblxuICAgICAgICAvLyBUT0RPOiBoYWNlciBsYSBzYWx2YSBkZWwgdmFsb3IgZGVsIGNvbnRyb2wgcGFyYSBgdGhpcy5jb250ZW50LnZhbHVlYCBkZSB1bmEgbWVqb3IgZm9ybWEgXG4gICAgICAgIC8vIHBvcnF1ZSBoYWNlcmxvIGFxdcOtIGdlbmVyYSBpbmNvbnNpc3RlbmNpYXMuIFVuYSBtZWpvciBmb3JtYSBzZXLDrWEgcHJvcG9yY2lvbmFyIHVuIG1ldGhvZCBxdWUgXG4gICAgICAgIC8vIGhhZ2EgbGEgZnVuY2nDs24gZGUgc2FsdmFyIGVsIHZhbG9yIHkgZW50b25jZXMgZXMgbGxhbWFkbyBjdWFuZG8gaGFnYSBmYWx0YS4gXG4gICAgICAgIC8qIElmIHRoZSBjb250cm9sIGRvZXMgbm90IGhhdmUgZXJyb3IgLi4uICovXG4gICAgICAgIGlmICghdGhpcy5lcnJvclN0YXRlKVxuICAgICAgICB7XG4gICAgICAgICAgICAvKiAuLi4gc2V0cyB0aGUgbmV3IHZhbHVlIG9mIHRoZSBjb250cm9sIGluIHRoZSBgY29udGVudGAuICovXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQudmFsdWUgPSB0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBJZiB0aGUgY29udHJvbCBpcyBub3QgbWFya2VkIGFzIGB0b3VjaGVkYCAuLi4gKi9cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5mb3JtQ29udHJvbC51bnRvdWNoZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qIC4uLiBtYXJrcyB0aGUgY29udHJvbCBhcyBgdG91Y2hlZGAuICovXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wubWFya0FzVG91Y2hlZCh7XG4gICAgICAgICAgICAgICAgb25seVNlbGY6IHRydWVcbiAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGNvbnRyb2wncyBkZWZhdWx0IHZhbHVlLiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBvdmVyd3JpdGUgaW4gdGhlIGRlcml2ZWQgY2xhc3MuIFxuXHQgKi9cbiAgICBwdWJsaWMgZ2V0IGdldERlZmF1bHRWYWx1ZSgpOiBhbnlcbiAgICB7XG4gICAgICAgIC8qIEJ5IGRlZmF1bHQsIGl0cyBpbXBsZW1lbnRhdGlvbiBpcyByZXR1cm5pbmcgdGhlIGVtcHR5IHN0cmluZy4gKi9cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlcnJvciBzdHJpbmcgaWYgdGhlIGNvbnRyb2wgaXMgaW4gYW4gZXJyb3Igc3RhdGU7IG90aGVyd2lzZSwgZW1wdHkgc3RyaW5nLiBcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBvdmVyd3JpdGUgaW4gdGhlIGRlcml2ZWQgY2xhc3MuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRFcnJvck1lc3NhZ2UoKTogc3RyaW5nXG5cdHtcbiAgICAgICAgLyogQnkgZGVmYXVsdCwgaXRzIGltcGxlbWVudGF0aW9uIGlzIHJldHVybmluZyB0aGUgZXJyb3Igb2YgdGhlIGBpbnRlcm5hbENvbXBvbmVudC5nZXRFcnJvck1lc3NhZ2VgIFxuICAgICAgICAgKiBtZXRob2Qgb3IgcmV0dXJuaW5nIHRoZSB0ZXh0IGVycm9ycy4gKi9cblxuICAgICAgICBpZiAodGhpcy5pbnRlcm5hbENvbXBvbmVudCAhPSB1bmRlZmluZWQpIHJldHVybiB0aGlzLmludGVybmFsQ29tcG9uZW50LmdldEVycm9yTWVzc2FnZSgpO1xuXG4gICAgICAgIGxldCB2YWxpZGF0aW9uRXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JzID0gdGhpcy5jb250ZW50LmZvcm1Db250cm9sLmVycm9ycztcblxuICAgICAgICAvKiBTaG93cyB0aGUgdGV4dCBlcnJvcnMuICovXG4gICAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3JzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yc1tWYWxpZGF0b3JzLnJlcXVpcmVkLm5hbWVdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKHRoaXMuaXNUcmFuc2xhdGlvbkJ1aWx0QnlDb250cm9sKSA/IElucHV0Q29udHJvbC50b2NvX25nX0Vycm9yX01zZ19SZXF1ZXJpZG8gOiB0aGlzLnZhbGlkYXRpb25FcnJvcl9yZXF1aXJlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG5cdH1cbiAgICBcblx0LyoqXG5cdCAqIEhhbmRsZXIgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIGJ5IHRoZSBpbnRlcm5hbCBsb2dpYyB3aGVuIHRoZSBjb250cm9sJ3MgdmFsdWUgY2hhbmdlcyBpbiB0aGUgVUkuIFxuICAgICAqIFRoaXMgbWV0aG9kIGNvbnRhaW5zIHRoZSBzcGVjaWZpYyBoYW5kbGluZyBvZiB0aGUgaW5wdXQgdGhhdCB0aGUgZGVyaXZlZCBjbGFzcyB3YW50cyB0byBkby4gXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgb3ZlcndyaXRlIGluIHRoZSBkZXJpdmVkIGNsYXNzLiBcblx0ICovXG4gICAgcHVibGljIGhhbmRsZVNwZWNpZmljSW5wdXQoKTogdm9pZFxuXHR7XG4gICAgICAgIC8qIEJ5IGRlZmF1bHQsIGl0cyBpbXBsZW1lbnRhdGlvbiBoYXMgbm90aGluZyB0byBkby4gKi9cbiAgICB9XG59XG4iXX0=