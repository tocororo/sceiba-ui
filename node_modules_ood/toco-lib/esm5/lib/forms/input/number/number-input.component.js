/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/input/number/number-input.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component } from '@angular/core';
import { FormControl, Validators } from '@angular/forms';
import { TranslateService } from '@ngx-translate/core';
import { InputControl } from '../input.control';
/**
 * Represents a control that allows the writing of a number.
 */
var InputNumberComponent = /** @class */ (function (_super) {
    tslib_1.__extends(InputNumberComponent, _super);
    function InputNumberComponent(_transServ) {
        var _this = _super.call(this) || this;
        _this._transServ = _transServ;
        /* The translation is built by the control. */
        _this.isTranslationBuiltByControl = true;
        return _this;
    }
    // TODO: Puedo hacer que este control sea más general, que permita la entrada de valores 
    // enteros y doubles haciendo las siguientes modificaciones: 
    //  * Inicializar el `Validators.pattern('----')` con un patrón para double values según valor que recibe en 
    //    `validatorArguments` que dice si integer o double. 
    //  * Hacer tratamiento de error correctamente em método `getErrorMessage()`. 
    /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputNumberComponent`'s `content.formControl` value by default.
     * @param validatorArguments A collection of key/value elements, where the key is the validator name
     * and the value is the value that the validator needs to check.
     * In the `validatorArguments` argument, you can specify an object with the minimum and maximum possible
     * values for the number that holds the control.
     * For example: If the minimum possible value is 0 and maximum is 50, you can call the `getFormControlByDefault`
     * method in this way:
     * InputNumberComponent.getFormControlByDefault({ 'min': 0, 'max': 50 });
     */
    // TODO: Puedo hacer que este control sea más general, que permita la entrada de valores 
    // enteros y doubles haciendo las siguientes modificaciones: 
    //  * Inicializar el `Validators.pattern('----')` con un patrón para double values según valor que recibe en 
    //    `validatorArguments` que dice si integer o double. 
    //  * Hacer tratamiento de error correctamente em método `getErrorMessage()`. 
    /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputNumberComponent`'s `content.formControl` value by default.
     * @param {?=} validatorArguments A collection of key/value elements, where the key is the validator name
     * and the value is the value that the validator needs to check.
     * In the `validatorArguments` argument, you can specify an object with the minimum and maximum possible
     * values for the number that holds the control.
     * For example: If the minimum possible value is 0 and maximum is 50, you can call the `getFormControlByDefault`
     * method in this way:
     * InputNumberComponent.getFormControlByDefault({ 'min': 0, 'max': 50 });
     * @return {?}
     */
    InputNumberComponent.getFormControlByDefault = 
    // TODO: Puedo hacer que este control sea más general, que permita la entrada de valores 
    // enteros y doubles haciendo las siguientes modificaciones: 
    //  * Inicializar el `Validators.pattern('----')` con un patrón para double values según valor que recibe en 
    //    `validatorArguments` que dice si integer o double. 
    //  * Hacer tratamiento de error correctamente em método `getErrorMessage()`. 
    /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputNumberComponent`'s `content.formControl` value by default.
     * @param {?=} validatorArguments A collection of key/value elements, where the key is the validator name
     * and the value is the value that the validator needs to check.
     * In the `validatorArguments` argument, you can specify an object with the minimum and maximum possible
     * values for the number that holds the control.
     * For example: If the minimum possible value is 0 and maximum is 50, you can call the `getFormControlByDefault`
     * method in this way:
     * InputNumberComponent.getFormControlByDefault({ 'min': 0, 'max': 50 });
     * @return {?}
     */
    function (validatorArguments) {
        if (validatorArguments === void 0) { validatorArguments = undefined; }
        return new FormControl(0, [
            Validators.pattern('^-?[0-9]+$'),
            Validators.min(((validatorArguments) && (validatorArguments.min != undefined)) ? validatorArguments.min : Number.MIN_SAFE_INTEGER),
            Validators.max(((validatorArguments) && (validatorArguments.max != undefined)) ? validatorArguments.max : Number.MAX_SAFE_INTEGER),
        ]);
    };
    /**
     * @return {?}
     */
    InputNumberComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /* This needs to be called at first. */
        this.setNewLanguage(this._transServ);
        /* Sets the default values. */
        this.init('', '', false, false);
        /* Changes the translation when the language changes. */
        this._transServ.onLangChange.subscribe((/**
         * @param {?} params
         * @return {?}
         */
        function (params) {
            _this.setNewLanguage(_this._transServ);
        }));
    };
    /**
     * Sets the new language.
     * @param transServ The `TranslateService` instance injected.
     */
    /**
     * Sets the new language.
     * @protected
     * @param {?} transServ The `TranslateService` instance injected.
     * @return {?}
     */
    InputNumberComponent.prototype.setNewLanguage = /**
     * Sets the new language.
     * @protected
     * @param {?} transServ The `TranslateService` instance injected.
     * @return {?}
     */
    function (transServ) {
        /* First, do this test for optimization. */
        if (InputNumberComponent.currentLang != transServ.currentLang) {
            _super.prototype.setNewLanguage.call(this, transServ);
            /* The `InputNumberComponent.currentLang` value is updated correctly in the parent class. */
            transServ.get(['TOCO_NG_ERROR_MSG_NUM_INVAL', 'TOCO_NG_ERROR_MSG_NUM_MINIMO', 'TOCO_NG_ERROR_MSG_NUM_MAXIMO']).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            function (res) {
                InputNumberComponent.toco_ng_Error_Msg_Num_Inval = res.TOCO_NG_ERROR_MSG_NUM_INVAL;
                InputNumberComponent.toco_ng_Error_Msg_Num_Minimo = res.TOCO_NG_ERROR_MSG_NUM_MINIMO;
                InputNumberComponent.toco_ng_Error_Msg_Num_Maximo = res.TOCO_NG_ERROR_MSG_NUM_MAXIMO;
            }));
        }
    };
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     */
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * @return {?}
     */
    InputNumberComponent.prototype.getErrorMessage = /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var validationErrors = this.content.formControl.errors;
        /* Shows the code errors. */
        if (validationErrors) {
            if (validationErrors[Validators.required.name]) {
                return InputNumberComponent.toco_ng_Error_Msg_Requerido;
            }
            if (validationErrors[Validators.pattern.name]) {
                return InputNumberComponent.toco_ng_Error_Msg_Num_Inval;
            }
            if (validationErrors[Validators.min.name]) {
                return InputNumberComponent.toco_ng_Error_Msg_Num_Minimo + validationErrors[Validators.min.name].min + '.';
            }
            if (validationErrors[Validators.max.name]) {
                return InputNumberComponent.toco_ng_Error_Msg_Num_Maximo + validationErrors[Validators.max.name].max + '.';
            }
        }
        return '';
    };
    InputNumberComponent.toco_ng_Error_Msg_Num_Inval = '';
    InputNumberComponent.toco_ng_Error_Msg_Num_Minimo = '';
    InputNumberComponent.toco_ng_Error_Msg_Num_Maximo = '';
    InputNumberComponent.decorators = [
        { type: Component, args: [{
                    selector: 'input-number',
                    template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                    host: {
                        '[style.minWidth]': 'content.minWidth',
                        '[style.width]': 'content.width'
                    },
                    styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
                }] }
    ];
    /** @nocollapse */
    InputNumberComponent.ctorParameters = function () { return [
        { type: TranslateService }
    ]; };
    return InputNumberComponent;
}(InputControl));
export { InputNumberComponent };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    InputNumberComponent.toco_ng_Error_Msg_Num_Inval;
    /**
     * @type {?}
     * @protected
     */
    InputNumberComponent.toco_ng_Error_Msg_Num_Minimo;
    /**
     * @type {?}
     * @protected
     */
    InputNumberComponent.toco_ng_Error_Msg_Num_Maximo;
    /**
     * @type {?}
     * @private
     */
    InputNumberComponent.prototype._transServ;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnVtYmVyLWlucHV0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3RvY28tbGliLyIsInNvdXJjZXMiOlsibGliL2Zvcm1zL2lucHV0L251bWJlci9udW1iZXItaW5wdXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQVUsTUFBTSxlQUFlLENBQUM7QUFDbEQsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQW9CLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0UsT0FBTyxFQUFtQixnQkFBZ0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBSXhFLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7OztBQUtoRDtJQVMwQyxnREFBWTtJQWdDbEQsOEJBQTJCLFVBQTRCO1FBQXZELFlBRUksaUJBQU8sU0FJVjtRQU4wQixnQkFBVSxHQUFWLFVBQVUsQ0FBa0I7UUFJbkQsOENBQThDO1FBQzlDLEtBQUksQ0FBQywyQkFBMkIsR0FBRyxJQUFJLENBQUM7O0lBQzVDLENBQUM7SUFwQ0QseUZBQXlGO0lBQ3pGLDZEQUE2RDtJQUM3RCw2R0FBNkc7SUFDN0cseURBQXlEO0lBQ3pELDhFQUE4RTtJQUU5RTs7Ozs7Ozs7OztPQVVHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFDVyw0Q0FBdUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUFyQyxVQUFzQyxrQkFBa0Q7UUFBbEQsbUNBQUEsRUFBQSw4QkFBa0Q7UUFFcEYsT0FBTyxJQUFJLFdBQVcsQ0FBQyxDQUFDLEVBQUU7WUFDdEIsVUFBVSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUM7WUFDaEMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsa0JBQWtCLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0s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QkFDUCxRQUFRLEVBQUUsY0FBYztvQkFDeEIseXdHQUFnRDtvQkFFaEQsSUFBSSxFQUFFO3dCQUNGLGtCQUFrQixFQUFFLGtCQUFrQjt3QkFDdEMsZUFBZSxFQUFFLGVBQWU7cUJBQ25DOztpQkFDSjs7OztnQkFqQnlCLGdCQUFnQjs7SUE4SDFDLDJCQUFDO0NBQUEsQUFySEQsQ0FTMEMsWUFBWSxHQTRHckQ7U0E1R1ksb0JBQW9COzs7Ozs7SUE0QjdCLGlEQUEwRDs7Ozs7SUFDMUQsa0RBQTJEOzs7OztJQUMzRCxrREFBMkQ7Ozs7O0lBRXhDLDBDQUFvQyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sLCBWYWxpZGF0b3JzLCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgTGFuZ0NoYW5nZUV2ZW50LCBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XG5cbmltcG9ydCB7IFZhbGlkYXRvckFyZ3VtZW50cyB9IGZyb20gJy4uLy4uL2Zvcm0tZmllbGQuY29udHJvbCc7XG5cbmltcG9ydCB7IElucHV0Q29udHJvbCB9IGZyb20gJy4uL2lucHV0LmNvbnRyb2wnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb250cm9sIHRoYXQgYWxsb3dzIHRoZSB3cml0aW5nIG9mIGEgbnVtYmVyLiBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpbnB1dC1udW1iZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi4vdGV4dC90ZXh0LWlucHV0LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi4vdGV4dC90ZXh0LWlucHV0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgaG9zdDoge1xuICAgICAgICAnW3N0eWxlLm1pbldpZHRoXSc6ICdjb250ZW50Lm1pbldpZHRoJyxcbiAgICAgICAgJ1tzdHlsZS53aWR0aF0nOiAnY29udGVudC53aWR0aCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIElucHV0TnVtYmVyQ29tcG9uZW50IGV4dGVuZHMgSW5wdXRDb250cm9sIGltcGxlbWVudHMgT25Jbml0XG57XG4gICAgLy8gVE9ETzogUHVlZG8gaGFjZXIgcXVlIGVzdGUgY29udHJvbCBzZWEgbcOhcyBnZW5lcmFsLCBxdWUgcGVybWl0YSBsYSBlbnRyYWRhIGRlIHZhbG9yZXMgXG4gICAgLy8gZW50ZXJvcyB5IGRvdWJsZXMgaGFjaWVuZG8gbGFzIHNpZ3VpZW50ZXMgbW9kaWZpY2FjaW9uZXM6IFxuICAgIC8vICAqIEluaWNpYWxpemFyIGVsIGBWYWxpZGF0b3JzLnBhdHRlcm4oJy0tLS0nKWAgY29uIHVuIHBhdHLDs24gcGFyYSBkb3VibGUgdmFsdWVzIHNlZ8O6biB2YWxvciBxdWUgcmVjaWJlIGVuIFxuICAgIC8vICAgIGB2YWxpZGF0b3JBcmd1bWVudHNgIHF1ZSBkaWNlIHNpIGludGVnZXIgbyBkb3VibGUuIFxuICAgIC8vICAqIEhhY2VyIHRyYXRhbWllbnRvIGRlIGVycm9yIGNvcnJlY3RhbWVudGUgZW0gbcOpdG9kbyBgZ2V0RXJyb3JNZXNzYWdlKClgLiBcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgRm9ybUNvbnRyb2xgIGJ5IGRlZmF1bHQuIFxuICAgICAqIEl0IGlzIHVzZWQgdG8gaW5pdGlhbGl6ZWQgdGhlIGBJbnB1dE51bWJlckNvbXBvbmVudGAncyBgY29udGVudC5mb3JtQ29udHJvbGAgdmFsdWUgYnkgZGVmYXVsdC4gXG4gICAgICogQHBhcmFtIHZhbGlkYXRvckFyZ3VtZW50cyBBIGNvbGxlY3Rpb24gb2Yga2V5L3ZhbHVlIGVsZW1lbnRzLCB3aGVyZSB0aGUga2V5IGlzIHRoZSB2YWxpZGF0b3IgbmFtZSBcbiAgICAgKiBhbmQgdGhlIHZhbHVlIGlzIHRoZSB2YWx1ZSB0aGF0IHRoZSB2YWxpZGF0b3IgbmVlZHMgdG8gY2hlY2suIFxuICAgICAqIEluIHRoZSBgdmFsaWRhdG9yQXJndW1lbnRzYCBhcmd1bWVudCwgeW91IGNhbiBzcGVjaWZ5IGFuIG9iamVjdCB3aXRoIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHBvc3NpYmxlIFxuICAgICAqIHZhbHVlcyBmb3IgdGhlIG51bWJlciB0aGF0IGhvbGRzIHRoZSBjb250cm9sLiBcbiAgICAgKiBGb3IgZXhhbXBsZTogSWYgdGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUgaXMgMCBhbmQgbWF4aW11bSBpcyA1MCwgeW91IGNhbiBjYWxsIHRoZSBgZ2V0Rm9ybUNvbnRyb2xCeURlZmF1bHRgIFxuICAgICAqIG1ldGhvZCBpbiB0aGlzIHdheTogXG4gICAgICogSW5wdXROdW1iZXJDb21wb25lbnQuZ2V0Rm9ybUNvbnRyb2xCeURlZmF1bHQoeyAnbWluJzogMCwgJ21heCc6IDUwIH0pO1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Rm9ybUNvbnRyb2xCeURlZmF1bHQodmFsaWRhdG9yQXJndW1lbnRzOiBWYWxpZGF0b3JBcmd1bWVudHMgPSB1bmRlZmluZWQpOiBGb3JtQ29udHJvbFxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtQ29udHJvbCgwLCBbXG4gICAgICAgICAgICBWYWxpZGF0b3JzLnBhdHRlcm4oJ14tP1swLTldKyQnKSxcbiAgICAgICAgICAgIFZhbGlkYXRvcnMubWluKCgodmFsaWRhdG9yQXJndW1lbnRzKSAmJiAodmFsaWRhdG9yQXJndW1lbnRzLm1pbiAhPSB1bmRlZmluZWQpKSA/IHZhbGlkYXRvckFyZ3VtZW50cy5taW4gOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiksXG4gICAgICAgICAgICBWYWxpZGF0b3JzLm1heCgoKHZhbGlkYXRvckFyZ3VtZW50cykgJiYgKHZhbGlkYXRvckFyZ3VtZW50cy5tYXggIT0gdW5kZWZpbmVkKSkgPyB2YWxpZGF0b3JBcmd1bWVudHMubWF4IDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLFxuICAgICAgICBdKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc3RhdGljIHRvY29fbmdfRXJyb3JfTXNnX051bV9JbnZhbDogc3RyaW5nID0gJyc7XG4gICAgcHJvdGVjdGVkIHN0YXRpYyB0b2NvX25nX0Vycm9yX01zZ19OdW1fTWluaW1vOiBzdHJpbmcgPSAnJztcbiAgICBwcm90ZWN0ZWQgc3RhdGljIHRvY29fbmdfRXJyb3JfTXNnX051bV9NYXhpbW86IHN0cmluZyA9ICcnO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RyYW5zU2VydjogVHJhbnNsYXRlU2VydmljZSlcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgLyogVGhlIHRyYW5zbGF0aW9uIGlzIGJ1aWx0IGJ5IHRoZSBjb250cm9sLiAqL1xuICAgICAgICB0aGlzLmlzVHJhbnNsYXRpb25CdWlsdEJ5Q29udHJvbCA9IHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gYmUgY2FsbGVkIGF0IGZpcnN0LiAqL1xuICAgICAgICB0aGlzLnNldE5ld0xhbmd1YWdlKHRoaXMuX3RyYW5zU2Vydik7XG5cbiAgICAgICAgLyogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZXMuICovXG4gICAgICAgIHRoaXMuaW5pdCgnJywgJycsIGZhbHNlLCBmYWxzZSk7XG5cblx0XHQvKiBDaGFuZ2VzIHRoZSB0cmFuc2xhdGlvbiB3aGVuIHRoZSBsYW5ndWFnZSBjaGFuZ2VzLiAqL1xuXHRcdHRoaXMuX3RyYW5zU2Vydi5vbkxhbmdDaGFuZ2Uuc3Vic2NyaWJlKChwYXJhbXM6IExhbmdDaGFuZ2VFdmVudCkgPT4ge1xuXHRcdFx0dGhpcy5zZXROZXdMYW5ndWFnZSh0aGlzLl90cmFuc1NlcnYpO1xuXHRcdH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG5ldyBsYW5ndWFnZS4gXG4gICAgICogQHBhcmFtIHRyYW5zU2VydiBUaGUgYFRyYW5zbGF0ZVNlcnZpY2VgIGluc3RhbmNlIGluamVjdGVkLiBcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2V0TmV3TGFuZ3VhZ2UodHJhbnNTZXJ2OiBUcmFuc2xhdGVTZXJ2aWNlKTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogRmlyc3QsIGRvIHRoaXMgdGVzdCBmb3Igb3B0aW1pemF0aW9uLiAqL1xuICAgICAgICBpZiAoSW5wdXROdW1iZXJDb21wb25lbnQuY3VycmVudExhbmcgIT0gdHJhbnNTZXJ2LmN1cnJlbnRMYW5nKVxuICAgICAgICB7XG4gICAgICAgICAgICBzdXBlci5zZXROZXdMYW5ndWFnZSh0cmFuc1NlcnYpO1xuXG4gICAgICAgICAgICAvKiBUaGUgYElucHV0TnVtYmVyQ29tcG9uZW50LmN1cnJlbnRMYW5nYCB2YWx1ZSBpcyB1cGRhdGVkIGNvcnJlY3RseSBpbiB0aGUgcGFyZW50IGNsYXNzLiAqL1xuXG4gICAgICAgICAgICB0cmFuc1NlcnYuZ2V0KFsnVE9DT19OR19FUlJPUl9NU0dfTlVNX0lOVkFMJywgJ1RPQ09fTkdfRVJST1JfTVNHX05VTV9NSU5JTU8nLCAnVE9DT19OR19FUlJPUl9NU0dfTlVNX01BWElNTyddKS5zdWJzY3JpYmUoKHJlczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgSW5wdXROdW1iZXJDb21wb25lbnQudG9jb19uZ19FcnJvcl9Nc2dfTnVtX0ludmFsID0gcmVzLlRPQ09fTkdfRVJST1JfTVNHX05VTV9JTlZBTDtcbiAgICAgICAgICAgICAgICBJbnB1dE51bWJlckNvbXBvbmVudC50b2NvX25nX0Vycm9yX01zZ19OdW1fTWluaW1vID0gcmVzLlRPQ09fTkdfRVJST1JfTVNHX05VTV9NSU5JTU87XG4gICAgICAgICAgICAgICAgSW5wdXROdW1iZXJDb21wb25lbnQudG9jb19uZ19FcnJvcl9Nc2dfTnVtX01heGltbyA9IHJlcy5UT0NPX05HX0VSUk9SX01TR19OVU1fTUFYSU1PO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVycm9yIHN0cmluZyBpZiB0aGUgY29udHJvbCBpcyBpbiBhbiBlcnJvciBzdGF0ZTsgb3RoZXJ3aXNlLCBlbXB0eSBzdHJpbmcuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRFcnJvck1lc3NhZ2UoKTogc3RyaW5nXG4gICAge1xuICAgICAgICBsZXQgdmFsaWRhdGlvbkVycm9yczogVmFsaWRhdGlvbkVycm9ycyA9IHRoaXMuY29udGVudC5mb3JtQ29udHJvbC5lcnJvcnM7XG5cbiAgICAgICAgLyogU2hvd3MgdGhlIGNvZGUgZXJyb3JzLiAqL1xuICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9ycylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnNbVmFsaWRhdG9ycy5yZXF1aXJlZC5uYW1lXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5wdXROdW1iZXJDb21wb25lbnQudG9jb19uZ19FcnJvcl9Nc2dfUmVxdWVyaWRvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yc1tWYWxpZGF0b3JzLnBhdHRlcm4ubmFtZV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElucHV0TnVtYmVyQ29tcG9uZW50LnRvY29fbmdfRXJyb3JfTXNnX051bV9JbnZhbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnNbVmFsaWRhdG9ycy5taW4ubmFtZV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElucHV0TnVtYmVyQ29tcG9uZW50LnRvY29fbmdfRXJyb3JfTXNnX051bV9NaW5pbW8gKyB2YWxpZGF0aW9uRXJyb3JzW1ZhbGlkYXRvcnMubWluLm5hbWVdLm1pbiArICcuJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnNbVmFsaWRhdG9ycy5tYXgubmFtZV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElucHV0TnVtYmVyQ29tcG9uZW50LnRvY29fbmdfRXJyb3JfTXNnX051bV9NYXhpbW8gKyB2YWxpZGF0aW9uRXJyb3JzW1ZhbGlkYXRvcnMubWF4Lm5hbWVdLm1heCArICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG59XG4iXX0=