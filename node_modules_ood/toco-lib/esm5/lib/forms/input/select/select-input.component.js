/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/input/select/select-input.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, Input } from '@angular/core';
import { Observable } from 'rxjs';
import { TranslateService } from '@ngx-translate/core';
import { isArray } from 'util';
import { InputControl } from '../input.control';
import { HintPosition, HintValue } from '../../form-field.control';
/**
 * An interface that represents a selectable option.
 * @record
 */
export function SelectOption() { }
if (false) {
    /**
     * Returns the label that is showed.
     * @type {?}
     */
    SelectOption.prototype.label;
    /**
     * Returns the value that is stored internally.
     * @type {?}
     */
    SelectOption.prototype.value;
}
/**
 * An interface that represents the content of a select control.
 * @record
 */
export function SelectContent() { }
if (false) {
    /**
     * Returns the options list that can be selected.
     * This field can be set using three ways:
     *  - Its value is `undefined`, then it takes the options from the `content.value` field.
     *  - Its value is a `SelectOption[]`, then it already contains the options.
     *  - Its value is an `Observable<SelectOption[]>`, then it takes the options when the observable emits values.
     * By default, its value is `[]`.
     * @type {?|undefined}
     */
    SelectContent.prototype.selectOptions;
    /**
     * Returns true if the selection can be multiple; otherwise, false.
     * By default, its value is `false`.
     * @type {?|undefined}
     */
    SelectContent.prototype.multiple;
    /**
     * Returns true if the tooltip is showed; otherwise, false.
     * By default, its value is `false`.
     * @type {?|undefined}
     */
    SelectContent.prototype.showTooltip;
    /**
     * Returns a value that allows the user to define the position of the tooltip for the select control.
     * It is used if the `showTooltip` field value is `true`.
     * By default, its value is `'below'`.
     * Its value can be one of these values: 'left', 'right', 'above', 'below', 'after', 'before'
     * @type {?|undefined}
     */
    SelectContent.prototype.selectTooltipPosition;
    /**
     * Returns a value that allows the user to define the position of the tooltip for the select control's options.
     * It is used if the `showTooltip` field value is `true`.
     * By default, its value is `'right'`.
     * Its value can be one of these values: 'left', 'right', 'above', 'below', 'after', 'before'
     * @type {?|undefined}
     */
    SelectContent.prototype.optionsTooltipPosition;
}
/**
 * Represents a control that allows to select one value or multiple values.
 * Implementation notes:
 * The `extraContent` recibe una funcion llamada getOptions() que se encarga de contruir un SelectOption[].
 * Si es multiple, entonces el `value` es un array de valores.
 */
var InputSelectComponent = /** @class */ (function (_super) {
    tslib_1.__extends(InputSelectComponent, _super);
    function InputSelectComponent(_transServ) {
        var _this = _super.call(this) || this;
        _this._transServ = _transServ;
        _this._selectOptionsSubscription = null;
        _this.selectTooltip = '';
        return _this;
    }
    /**
     * @return {?}
     */
    InputSelectComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        /* Sets the default values. */
        this.init('', '', false, true);
        /* The `selectTooltip` value is set in `onSelectionChange` method when happening initialization or selection change. */
        this.onSelectionChange();
    };
    /**
     * @return {?}
     */
    InputSelectComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        /* Disposes the resources held by the subscription. */
        this._selectOptions_Unsubscription();
    };
    /**
     * Initializes the `content` input property.
     * @param label The default label to use. It is used if the `content.label` is not specified.
     * @param placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
     * @param isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
     * @param alwaysHint If it is true then there is always at leat one hint start-aligned.
     */
    /**
     * Initializes the `content` input property.
     * @protected
     * @param {?} label The default label to use. It is used if the `content.label` is not specified.
     * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
     * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
     * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
     * @return {?}
     */
    InputSelectComponent.prototype.init = /**
     * Initializes the `content` input property.
     * @protected
     * @param {?} label The default label to use. It is used if the `content.label` is not specified.
     * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
     * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
     * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
     * @return {?}
     */
    function (label, placeholder, isAbbreviation, alwaysHint) {
        var _this = this;
        if (placeholder === void 0) { placeholder = ''; }
        /* Changes the translation when the language changes. */
        this._transServ.onLangChange.subscribe((/**
         * @param {?} params
         * @return {?}
         */
        function (params) {
            _this._setSelectTooltip();
        }));
        /* Sets the default values. */
        _super.prototype.init.call(this, label, placeholder, isAbbreviation, alwaysHint);
        if (this.content.startHint != undefined) {
            if (this.content.startHint.label == 'TOCO_NG_HINT_TEXTO_POR_DEFECTO')
                this.content.startHint.label = 'TOCO_NG_HINT_TEXTO_SELECC_POR_DEFECTO';
        }
        else
            this.content.startHint = new HintValue(HintPosition.start, 'TOCO_NG_HINT_TEXTO_SELECC_POR_DEFECTO');
        if (this.content.multiple == undefined)
            this.content.multiple = false;
        if (this.content.showTooltip == undefined)
            this.content.showTooltip = false;
        if (this.content.selectTooltipPosition == undefined)
            this.content.selectTooltipPosition = 'below';
        if (this.content.optionsTooltipPosition == undefined)
            this.content.optionsTooltipPosition = 'right';
        if (this.content.selectOptions == undefined) {
            if (this.content.value == undefined) {
                this.content.selectOptions = [];
            }
            else {
                /* Gets the `content.selectOptions` from the `content.value` field. */
                if (isArray(this.content.value)) {
                    this.content.multiple = true; /* The control must be multiple. */
                    this.content.selectOptions = [];
                    this.content.value.forEach((/**
                     * @param {?} option
                     * @return {?}
                     */
                    function (option) {
                        ((/** @type {?} */ (_this.content.selectOptions))).push({
                            'label': option,
                            'value': option.toUpperCase()
                        });
                    }));
                }
                else {
                    this.content.selectOptions = [
                        {
                            'label': this.content.value,
                            'value': this.content.value.toUpperCase()
                        }
                    ];
                }
            }
        }
        else if (isArray(this.content.selectOptions)) {
            /* Nothing to do here, but this case must be here. */
        }
        else if (this.content.selectOptions instanceof Observable) {
            /* Gets the `content.selectOptions` from an `Observable` when it emits values. */
            this._selectOptions_Unsubscription();
            this._selectOptionsSubscription = this.content.selectOptions.subscribe((/**
             * @param {?} selectOptions
             * @return {?}
             */
            function (selectOptions) {
                _this.content.selectOptions = selectOptions;
            }));
        }
        else {
            throw new Error("For the '" + InputSelectComponent.name + "' control, the 'content.selectOptions' type value has a configuration error because the programme does not know what to do with it!");
        }
        /* The `selectTooltip` value is set in `onSelectionChange` method when happening initialization or selection change. */
    };
    /**
     * @private
     * @return {?}
     */
    InputSelectComponent.prototype._selectOptions_Unsubscription = /**
     * @private
     * @return {?}
     */
    function () {
        /* Disposes the resources held by the subscription. */
        if (this._selectOptionsSubscription) {
            this._selectOptionsSubscription.unsubscribe();
        }
    };
    /**
     * @return {?}
     */
    InputSelectComponent.prototype.onSelectionChange = /**
     * @return {?}
     */
    function () {
        // console.log('Call `onSelectionChange` - ', 'Select value: ', this.content.formControl.value);
        this._setSelectTooltip();
        if ((this.content.extraContent) && (this.content.extraContent.selectionChange)) {
            this.content.extraContent.selectionChange(this.content.formControl.value);
        }
    };
    /**
     * Does the translation for a key (or an array of keys).
     * @param key The key (or an array of keys) to translate.
     */
    /**
     * Does the translation for a key (or an array of keys).
     * @private
     * @param {?} key The key (or an array of keys) to translate.
     * @return {?}
     */
    InputSelectComponent.prototype._doTranslation = /**
     * Does the translation for a key (or an array of keys).
     * @private
     * @param {?} key The key (or an array of keys) to translate.
     * @return {?}
     */
    function (key) {
        var _this = this;
        if (key.length == 0) {
            this.selectTooltip = '';
            return;
        }
        this._transServ.get(key).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        function (res) {
            // console.log(key, ' --> ', res);
            if (_this.content.multiple) {
                /* `res` is an object of translated keys. */
                /** @type {?} */
                var translationKeys = Object.keys(res);
                /** @type {?} */
                var len = translationKeys.length;
                /** @type {?} */
                var translationRes = res[translationKeys[0]];
                for (var i = 1; i < len; ++i) {
                    translationRes += '\n' + res[translationKeys[i]];
                }
                _this.selectTooltip = translationRes;
            }
            else {
                /* `res` is a translated key. */
                _this.selectTooltip = res;
            }
        }));
    };
    /**
     * Finds the label for a value (or an array of values).
     * @param value The value (or an array of values) to find the label.
     * @returns Returns a label (or an array of labels).
     */
    /**
     * Finds the label for a value (or an array of values).
     * @private
     * @param {?} value The value (or an array of values) to find the label.
     * @return {?} Returns a label (or an array of labels).
     */
    InputSelectComponent.prototype._findLabel = /**
     * Finds the label for a value (or an array of values).
     * @private
     * @param {?} value The value (or an array of values) to find the label.
     * @return {?} Returns a label (or an array of labels).
     */
    function (value) {
        var e_1, _a, e_2, _b, e_3, _c;
        if (this.content.multiple) {
            /** @type {?} */
            var label = [];
            try {
                for (var value_1 = tslib_1.__values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                    var val = value_1_1.value;
                    try {
                        for (var _d = (e_2 = void 0, tslib_1.__values(((/** @type {?} */ (this.content.selectOptions))))), _e = _d.next(); !_e.done; _e = _d.next()) {
                            var opt = _e.value;
                            if (opt.value == val) {
                                label.push(opt.label);
                                break;
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return label;
        }
        else {
            /** @type {?} */
            var label = '';
            try {
                for (var _f = tslib_1.__values(((/** @type {?} */ (this.content.selectOptions)))), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var opt = _g.value;
                    if (opt.value == value) {
                        label = opt.label;
                        break;
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return label;
        }
    };
    /**
     * Sets the `selectTooltip` field value.
     */
    /**
     * Sets the `selectTooltip` field value.
     * @private
     * @return {?}
     */
    InputSelectComponent.prototype._setSelectTooltip = /**
     * Sets the `selectTooltip` field value.
     * @private
     * @return {?}
     */
    function () {
        if (this.content.formControl.value != undefined) {
            this._doTranslation(this._findLabel(this.content.formControl.value));
        }
        else {
            this.selectTooltip = '';
        }
    };
    InputSelectComponent.decorators = [
        { type: Component, args: [{
                    selector: 'input-select',
                    template: "\n<mat-form-field\n\tclass=\"select-mat-form-field\"\n\t[appearance]=\"content.appearance\"\n>\n\n\t<mat-label>\n\t\t{{ content.label | translate }}\n\t</mat-label>\n\n\t<ng-container *ngIf=\"content.showTooltip; then thenTemplate_Tooltip; else elseTemplate_WithoutTooltip\"></ng-container>\n\n\t<ng-template #thenTemplate_Tooltip>\n\t\t<mat-select \n\t\t\t[formControl]=\"content.formControl\"\n\t\t\t[required]=\"content.required\"\n\t\t\t[style.textAlign]=\"content.textAlign\"\n\t\t\t[attr.aria-label]=\"content.ariaLabel | translate\"\n\t\t\t[(value)]=\"content.value\"\n\t\t\t[multiple]=\"content.multiple\"\n\t\t\t(selectionChange)=\"onSelectionChange()\"\n\t\t\t[matTooltip]=\"selectTooltip\" [matTooltipPosition]=\"content.selectTooltipPosition\" [matTooltipClass]=\"'tooltip-multiple-lines'\"\n\t\t>\n\t\t\t<mat-option \n\t\t\t\t*ngFor=\"let option of content.selectOptions\" \n\t\t\t\t[value]=\"option.value\"\n\t\t\t\t[matTooltip]=\"option.label | translate\" [matTooltipPosition]=\"content.optionsTooltipPosition\"\n\t\t\t>\n\t\t\t\t{{ option.label | translate }}\n\t\t\t</mat-option>\n\t\t</mat-select>\n\t</ng-template>\n\n\t<ng-template #elseTemplate_WithoutTooltip>\n\t\t<mat-select \n\t\t\t[formControl]=\"content.formControl\"\n\t\t\t[required]=\"content.required\"\n\t\t\t[style.textAlign]=\"content.textAlign\"\n\t\t\t[attr.aria-label]=\"content.ariaLabel | translate\"\n\t\t\t[(value)]=\"content.value\"\n\t\t\t[multiple]=\"content.multiple\"\n\t\t\t(selectionChange)=\"onSelectionChange()\"\n\t\t>\n\t\t\t<mat-option \n\t\t\t\t*ngFor=\"let option of content.selectOptions\" \n\t\t\t\t[value]=\"option.value\"\n\t\t\t>\n\t\t\t\t{{ option.label | translate }}\n\t\t\t</mat-option>\n\t\t</mat-select>\n\t</ng-template>\n\n\t<mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                    host: {
                        '[style.minWidth]': 'content.minWidth',
                        '[style.width]': 'content.width'
                    },
                    styles: [".select-mat-form-field{width:100%}::ng-deep .tooltip-multiple-lines{white-space:pre-line!important}"]
                }] }
    ];
    /** @nocollapse */
    InputSelectComponent.ctorParameters = function () { return [
        { type: TranslateService }
    ]; };
    InputSelectComponent.propDecorators = {
        content: [{ type: Input }]
    };
    return InputSelectComponent;
}(InputControl));
export { InputSelectComponent };
if (false) {
    /**
     * Input field that contains the content of this class.
     * @type {?}
     */
    InputSelectComponent.prototype.content;
    /**
     * Returns the current selected option tooltip.
     * If nothing is selected, then its value is `''`.
     * @type {?}
     */
    InputSelectComponent.prototype.selectTooltip;
    /**
     * @type {?}
     * @private
     */
    InputSelectComponent.prototype._selectOptionsSubscription;
    /**
     * @type {?}
     * @private
     */
    InputSelectComponent.prototype._transServ;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LWlucHV0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3RvY28tbGliLyIsInNvdXJjZXMiOlsibGliL2Zvcm1zL2lucHV0L3NlbGVjdC9zZWxlY3QtaW5wdXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQXFCLEtBQUssRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNwRSxPQUFPLEVBQUUsVUFBVSxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUVoRCxPQUFPLEVBQW1CLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDeEUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUUvQixPQUFPLEVBQUUsWUFBWSxFQUFnQixNQUFNLGtCQUFrQixDQUFDO0FBQzlELE9BQU8sRUFBRSxZQUFZLEVBQUUsU0FBUyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7Ozs7O0FBS25FLGtDQWdCQzs7Ozs7O0lBWEEsNkJBQWM7Ozs7O0lBS2QsNkJBQVc7Ozs7OztBQVdaLG1DQXVDQzs7Ozs7Ozs7Ozs7SUE3QkEsc0NBQTREOzs7Ozs7SUFNNUQsaUNBQW1COzs7Ozs7SUFNbkIsb0NBQXNCOzs7Ozs7OztJQVF0Qiw4Q0FBd0M7Ozs7Ozs7O0lBUXhDLCtDQUF5Qzs7Ozs7Ozs7QUFTMUM7SUFTMEMsZ0RBQVk7SUFnQnJELDhCQUEyQixVQUE0QjtRQUF2RCxZQUVPLGlCQUFPLFNBR2I7UUFMMEIsZ0JBQVUsR0FBVixVQUFVLENBQWtCO1FBRi9DLGdDQUEwQixHQUFpQixJQUFJLENBQUM7UUFNdkQsS0FBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUM7O0lBQ3pCLENBQUM7Ozs7SUFFTSx1Q0FBUTs7O0lBQWY7UUFFTyw4QkFBOEI7UUFDcEMsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztRQUUvQix1SEFBdUg7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RUFBRSxlQUFlO3FCQUNoQzs7aUJBQ0Q7Ozs7Z0JBckZ5QixnQkFBZ0I7OzswQkEyRnJDLEtBQUs7O0lBOE9WLDJCQUFDO0NBQUEsQUE1UEQsQ0FTMEMsWUFBWSxHQW1QckQ7U0FuUFksb0JBQW9COzs7Ozs7SUFLN0IsdUNBQzJCOzs7Ozs7SUFNOUIsNkNBQTZCOzs7OztJQUU3QiwwREFBd0Q7Ozs7O0lBRXJDLDBDQUFvQyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIE9uRGVzdHJveSwgSW5wdXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgVG9vbHRpcFBvc2l0aW9uIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvdG9vbHRpcCc7XG5pbXBvcnQgeyBMYW5nQ2hhbmdlRXZlbnQsIFRyYW5zbGF0ZVNlcnZpY2UgfSBmcm9tICdAbmd4LXRyYW5zbGF0ZS9jb3JlJztcbmltcG9ydCB7IGlzQXJyYXkgfSBmcm9tICd1dGlsJztcblxuaW1wb3J0IHsgSW5wdXRDb250cm9sLCBJbnB1dENvbnRlbnQgfSBmcm9tICcuLi9pbnB1dC5jb250cm9sJztcbmltcG9ydCB7IEhpbnRQb3NpdGlvbiwgSGludFZhbHVlIH0gZnJvbSAnLi4vLi4vZm9ybS1maWVsZC5jb250cm9sJztcblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIGEgc2VsZWN0YWJsZSBvcHRpb24uIFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdE9wdGlvblxue1xuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbGFiZWwgdGhhdCBpcyBzaG93ZWQuIFxuXHQgKi9cblx0bGFiZWw6IHN0cmluZztcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgdmFsdWUgdGhhdCBpcyBzdG9yZWQgaW50ZXJuYWxseS4gXG5cdCAqL1xuXHR2YWx1ZTogYW55O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBvcHRpb24gaXMgc2VsZWN0ZWQ7IG90aGVyd2lzZSwgZmFsc2UuIFxuXHQgKi9cblx0Ly8gc2VsZWN0ZWQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEFuIGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgb2YgYSBzZWxlY3QgY29udHJvbC4gXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VsZWN0Q29udGVudCBleHRlbmRzIElucHV0Q29udGVudFxue1xuXHQvKipcblx0ICogUmV0dXJucyB0aGUgb3B0aW9ucyBsaXN0IHRoYXQgY2FuIGJlIHNlbGVjdGVkLiBcblx0ICogVGhpcyBmaWVsZCBjYW4gYmUgc2V0IHVzaW5nIHRocmVlIHdheXM6IFxuXHQgKiAgLSBJdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAsIHRoZW4gaXQgdGFrZXMgdGhlIG9wdGlvbnMgZnJvbSB0aGUgYGNvbnRlbnQudmFsdWVgIGZpZWxkLiBcblx0ICogIC0gSXRzIHZhbHVlIGlzIGEgYFNlbGVjdE9wdGlvbltdYCwgdGhlbiBpdCBhbHJlYWR5IGNvbnRhaW5zIHRoZSBvcHRpb25zLiBcblx0ICogIC0gSXRzIHZhbHVlIGlzIGFuIGBPYnNlcnZhYmxlPFNlbGVjdE9wdGlvbltdPmAsIHRoZW4gaXQgdGFrZXMgdGhlIG9wdGlvbnMgd2hlbiB0aGUgb2JzZXJ2YWJsZSBlbWl0cyB2YWx1ZXMuIFxuXHQgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYFtdYC4gXG5cdCAqL1xuXHRzZWxlY3RPcHRpb25zPzogU2VsZWN0T3B0aW9uW10gfCBPYnNlcnZhYmxlPFNlbGVjdE9wdGlvbltdPjtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBzZWxlY3Rpb24gY2FuIGJlIG11bHRpcGxlOyBvdGhlcndpc2UsIGZhbHNlLiBcblx0ICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBmYWxzZWAuIFxuXHQgKi9cblx0bXVsdGlwbGU/OiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRvb2x0aXAgaXMgc2hvd2VkOyBvdGhlcndpc2UsIGZhbHNlLiBcblx0ICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBmYWxzZWAuIFxuXHQgKi9cblx0c2hvd1Rvb2x0aXA/OiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCBmb3IgdGhlIHNlbGVjdCBjb250cm9sLiBcblx0ICogSXQgaXMgdXNlZCBpZiB0aGUgYHNob3dUb29sdGlwYCBmaWVsZCB2YWx1ZSBpcyBgdHJ1ZWAuIFxuXHQgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYCdiZWxvdydgLiBcblx0ICogSXRzIHZhbHVlIGNhbiBiZSBvbmUgb2YgdGhlc2UgdmFsdWVzOiAnbGVmdCcsICdyaWdodCcsICdhYm92ZScsICdiZWxvdycsICdhZnRlcicsICdiZWZvcmUnIFxuXHQgKi9cblx0c2VsZWN0VG9vbHRpcFBvc2l0aW9uPzogVG9vbHRpcFBvc2l0aW9uO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmFsdWUgdGhhdCBhbGxvd3MgdGhlIHVzZXIgdG8gZGVmaW5lIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcCBmb3IgdGhlIHNlbGVjdCBjb250cm9sJ3Mgb3B0aW9ucy4gXG5cdCAqIEl0IGlzIHVzZWQgaWYgdGhlIGBzaG93VG9vbHRpcGAgZmllbGQgdmFsdWUgaXMgYHRydWVgLiBcblx0ICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGAncmlnaHQnYC4gXG5cdCAqIEl0cyB2YWx1ZSBjYW4gYmUgb25lIG9mIHRoZXNlIHZhbHVlczogJ2xlZnQnLCAncmlnaHQnLCAnYWJvdmUnLCAnYmVsb3cnLCAnYWZ0ZXInLCAnYmVmb3JlJyBcblx0ICovXG5cdG9wdGlvbnNUb29sdGlwUG9zaXRpb24/OiBUb29sdGlwUG9zaXRpb247XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbnRyb2wgdGhhdCBhbGxvd3MgdG8gc2VsZWN0IG9uZSB2YWx1ZSBvciBtdWx0aXBsZSB2YWx1ZXMuIFxuICogSW1wbGVtZW50YXRpb24gbm90ZXM6IFxuICogVGhlIGBleHRyYUNvbnRlbnRgIHJlY2liZSB1bmEgZnVuY2lvbiBsbGFtYWRhIGdldE9wdGlvbnMoKSBxdWUgc2UgZW5jYXJnYSBkZSBjb250cnVpciB1biBTZWxlY3RPcHRpb25bXS4gXG4gKiBTaSBlcyBtdWx0aXBsZSwgZW50b25jZXMgZWwgYHZhbHVlYCBlcyB1biBhcnJheSBkZSB2YWxvcmVzLiBcbiAqL1xuQENvbXBvbmVudCh7XG5cdHNlbGVjdG9yOiAnaW5wdXQtc2VsZWN0Jyxcblx0dGVtcGxhdGVVcmw6ICcuL3NlbGVjdC1pbnB1dC5jb21wb25lbnQuaHRtbCcsXG5cdHN0eWxlVXJsczogWycuL3NlbGVjdC1pbnB1dC5jb21wb25lbnQuc2NzcyddLFxuXHRob3N0OiB7XG5cdFx0J1tzdHlsZS5taW5XaWR0aF0nOiAnY29udGVudC5taW5XaWR0aCcsXG5cdFx0J1tzdHlsZS53aWR0aF0nOiAnY29udGVudC53aWR0aCdcblx0fVxufSlcbmV4cG9ydCBjbGFzcyBJbnB1dFNlbGVjdENvbXBvbmVudCBleHRlbmRzIElucHV0Q29udHJvbCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95XG57XG5cdC8qKlxuICAgICAqIElucHV0IGZpZWxkIHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnQgb2YgdGhpcyBjbGFzcy4gXG4gICAgICovXG4gICAgQElucHV0KClcblx0cHVibGljIGNvbnRlbnQ6IFNlbGVjdENvbnRlbnQ7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgb3B0aW9uIHRvb2x0aXAuIFxuXHQgKiBJZiBub3RoaW5nIGlzIHNlbGVjdGVkLCB0aGVuIGl0cyB2YWx1ZSBpcyBgJydgLiBcblx0ICovXG5cdHB1YmxpYyBzZWxlY3RUb29sdGlwOiBzdHJpbmc7XG5cblx0cHJpdmF0ZSBfc2VsZWN0T3B0aW9uc1N1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uID0gbnVsbDtcblxuXHRwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBfdHJhbnNTZXJ2OiBUcmFuc2xhdGVTZXJ2aWNlKVxuXHR7XG4gICAgICAgIHN1cGVyKCk7XG5cblx0XHR0aGlzLnNlbGVjdFRvb2x0aXAgPSAnJztcblx0fVxuXG5cdHB1YmxpYyBuZ09uSW5pdCgpOiB2b2lkXG5cdHtcbiAgICAgICAgLyogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZXMuICovXG5cdFx0dGhpcy5pbml0KCcnLCAnJywgZmFsc2UsIHRydWUpO1xuXG5cdFx0LyogVGhlIGBzZWxlY3RUb29sdGlwYCB2YWx1ZSBpcyBzZXQgaW4gYG9uU2VsZWN0aW9uQ2hhbmdlYCBtZXRob2Qgd2hlbiBoYXBwZW5pbmcgaW5pdGlhbGl6YXRpb24gb3Igc2VsZWN0aW9uIGNoYW5nZS4gKi9cblx0XHR0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKCk7XG5cdH1cblxuXHRwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZFxuXHR7XG5cdFx0LyogRGlzcG9zZXMgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uICovXG5cdFx0dGhpcy5fc2VsZWN0T3B0aW9uc19VbnN1YnNjcmlwdGlvbigpO1xuXHR9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYGNvbnRlbnRgIGlucHV0IHByb3BlcnR5LiBcbiAgICAgKiBAcGFyYW0gbGFiZWwgVGhlIGRlZmF1bHQgbGFiZWwgdG8gdXNlLiBJdCBpcyB1c2VkIGlmIHRoZSBgY29udGVudC5sYWJlbGAgaXMgbm90IHNwZWNpZmllZC4gXG5cdCAqIEBwYXJhbSBwbGFjZWhvbGRlciBUaGUgZGVmYXVsdCBwbGFjZWhvbGRlciB0byB1c2UuIEl0IGlzIHVzZWQgaWYgdGhlIGBjb250ZW50LnBsYWNlaG9sZGVyYCBpcyBub3Qgc3BlY2lmaWVkLiBcbiAgICAgKiBAcGFyYW0gaXNBYmJyZXZpYXRpb24gSWYgaXQgaXMgdHJ1ZSB0aGVuIHRoZSBgbGFiZWxgIGFyZ3VtZW50IHJlcHJlc2VudHMgYW4gYWJicmV2aWF0aW9uOyBvdGhlcndpc2UsIGZhbHNlLiBcbiAgICAgKiBAcGFyYW0gYWx3YXlzSGludCBJZiBpdCBpcyB0cnVlIHRoZW4gdGhlcmUgaXMgYWx3YXlzIGF0IGxlYXQgb25lIGhpbnQgc3RhcnQtYWxpZ25lZC4gXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluaXQobGFiZWw6IHN0cmluZywgcGxhY2Vob2xkZXI6IHN0cmluZyA9ICcnLCBpc0FiYnJldmlhdGlvbjogYm9vbGVhbiwgYWx3YXlzSGludDogYm9vbGVhbik6IHZvaWRcbiAgICB7XG5cdFx0LyogQ2hhbmdlcyB0aGUgdHJhbnNsYXRpb24gd2hlbiB0aGUgbGFuZ3VhZ2UgY2hhbmdlcy4gKi9cblx0XHR0aGlzLl90cmFuc1NlcnYub25MYW5nQ2hhbmdlLnN1YnNjcmliZSgocGFyYW1zOiBMYW5nQ2hhbmdlRXZlbnQpID0+IHtcblx0XHRcdHRoaXMuX3NldFNlbGVjdFRvb2x0aXAoKTtcblx0XHR9KTtcblxuICAgICAgICAvKiBTZXRzIHRoZSBkZWZhdWx0IHZhbHVlcy4gKi9cblxuXHRcdHN1cGVyLmluaXQobGFiZWwsIHBsYWNlaG9sZGVyLCBpc0FiYnJldmlhdGlvbiwgYWx3YXlzSGludCk7XG5cblx0XHRpZiAodGhpcy5jb250ZW50LnN0YXJ0SGludCAhPSB1bmRlZmluZWQpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuY29udGVudC5zdGFydEhpbnQubGFiZWwgPT0gJ1RPQ09fTkdfSElOVF9URVhUT19QT1JfREVGRUNUTycpIHRoaXMuY29udGVudC5zdGFydEhpbnQubGFiZWwgPSAnVE9DT19OR19ISU5UX1RFWFRPX1NFTEVDQ19QT1JfREVGRUNUTyc7XG5cdFx0fVxuXHRcdGVsc2UgdGhpcy5jb250ZW50LnN0YXJ0SGludCA9IG5ldyBIaW50VmFsdWUoSGludFBvc2l0aW9uLnN0YXJ0LCAnVE9DT19OR19ISU5UX1RFWFRPX1NFTEVDQ19QT1JfREVGRUNUTycpO1xuXG5cdFx0aWYgKHRoaXMuY29udGVudC5tdWx0aXBsZSA9PSB1bmRlZmluZWQpIHRoaXMuY29udGVudC5tdWx0aXBsZSA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLmNvbnRlbnQuc2hvd1Rvb2x0aXAgPT0gdW5kZWZpbmVkKSB0aGlzLmNvbnRlbnQuc2hvd1Rvb2x0aXAgPSBmYWxzZTtcblx0XHRpZiAodGhpcy5jb250ZW50LnNlbGVjdFRvb2x0aXBQb3NpdGlvbiA9PSB1bmRlZmluZWQpIHRoaXMuY29udGVudC5zZWxlY3RUb29sdGlwUG9zaXRpb24gPSAnYmVsb3cnO1xuXHRcdGlmICh0aGlzLmNvbnRlbnQub3B0aW9uc1Rvb2x0aXBQb3NpdGlvbiA9PSB1bmRlZmluZWQpIHRoaXMuY29udGVudC5vcHRpb25zVG9vbHRpcFBvc2l0aW9uID0gJ3JpZ2h0JztcblxuXHRcdGlmICh0aGlzLmNvbnRlbnQuc2VsZWN0T3B0aW9ucyA9PSB1bmRlZmluZWQpXG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuY29udGVudC52YWx1ZSA9PSB1bmRlZmluZWQpXG5cdFx0XHR7XG5cdFx0XHRcdHRoaXMuY29udGVudC5zZWxlY3RPcHRpb25zID0gWyBdO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBHZXRzIHRoZSBgY29udGVudC5zZWxlY3RPcHRpb25zYCBmcm9tIHRoZSBgY29udGVudC52YWx1ZWAgZmllbGQuICovXG5cblx0XHRcdFx0aWYgKGlzQXJyYXkodGhpcy5jb250ZW50LnZhbHVlKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuY29udGVudC5tdWx0aXBsZSA9IHRydWU7ICAvKiBUaGUgY29udHJvbCBtdXN0IGJlIG11bHRpcGxlLiAqL1xuXHRcdFx0XHRcdHRoaXMuY29udGVudC5zZWxlY3RPcHRpb25zID0gWyBdO1xuXG5cdFx0XHRcdFx0dGhpcy5jb250ZW50LnZhbHVlLmZvckVhY2goXG5cdFx0XHRcdFx0XHQob3B0aW9uOiBzdHJpbmcpOiB2b2lkID0+IHtcblx0XHRcdFx0XHRcdFx0KHRoaXMuY29udGVudC5zZWxlY3RPcHRpb25zIGFzIFNlbGVjdE9wdGlvbltdKS5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHQnbGFiZWwnOiBvcHRpb24sXG5cdFx0XHRcdFx0XHRcdFx0J3ZhbHVlJzogb3B0aW9uLnRvVXBwZXJDYXNlKClcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmNvbnRlbnQuc2VsZWN0T3B0aW9ucyA9IFtcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0J2xhYmVsJzogdGhpcy5jb250ZW50LnZhbHVlLFxuXHRcdFx0XHRcdFx0XHQndmFsdWUnOiB0aGlzLmNvbnRlbnQudmFsdWUudG9VcHBlckNhc2UoKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSBpZiAoaXNBcnJheSh0aGlzLmNvbnRlbnQuc2VsZWN0T3B0aW9ucykpXG5cdFx0e1xuXHRcdFx0LyogTm90aGluZyB0byBkbyBoZXJlLCBidXQgdGhpcyBjYXNlIG11c3QgYmUgaGVyZS4gKi9cblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5jb250ZW50LnNlbGVjdE9wdGlvbnMgaW5zdGFuY2VvZiBPYnNlcnZhYmxlKVxuXHRcdHtcblx0XHRcdC8qIEdldHMgdGhlIGBjb250ZW50LnNlbGVjdE9wdGlvbnNgIGZyb20gYW4gYE9ic2VydmFibGVgIHdoZW4gaXQgZW1pdHMgdmFsdWVzLiAqL1xuXG5cdFx0XHR0aGlzLl9zZWxlY3RPcHRpb25zX1Vuc3Vic2NyaXB0aW9uKCk7XG5cblx0XHRcdHRoaXMuX3NlbGVjdE9wdGlvbnNTdWJzY3JpcHRpb24gPSB0aGlzLmNvbnRlbnQuc2VsZWN0T3B0aW9ucy5zdWJzY3JpYmUoXG5cdFx0XHRcdChzZWxlY3RPcHRpb25zOiBTZWxlY3RPcHRpb25bXSk6IHZvaWQgPT4ge1xuXHRcdFx0XHRcdHRoaXMuY29udGVudC5zZWxlY3RPcHRpb25zID0gc2VsZWN0T3B0aW9ucztcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRm9yIHRoZSAnJHsgSW5wdXRTZWxlY3RDb21wb25lbnQubmFtZSB9JyBjb250cm9sLCB0aGUgJ2NvbnRlbnQuc2VsZWN0T3B0aW9ucycgdHlwZSB2YWx1ZSBoYXMgYSBjb25maWd1cmF0aW9uIGVycm9yIGJlY2F1c2UgdGhlIHByb2dyYW1tZSBkb2VzIG5vdCBrbm93IHdoYXQgdG8gZG8gd2l0aCBpdCFgKTtcblx0XHR9XG5cblx0XHQvKiBUaGUgYHNlbGVjdFRvb2x0aXBgIHZhbHVlIGlzIHNldCBpbiBgb25TZWxlY3Rpb25DaGFuZ2VgIG1ldGhvZCB3aGVuIGhhcHBlbmluZyBpbml0aWFsaXphdGlvbiBvciBzZWxlY3Rpb24gY2hhbmdlLiAqL1xuXHR9XG5cdFxuXHRwcml2YXRlIF9zZWxlY3RPcHRpb25zX1Vuc3Vic2NyaXB0aW9uKCk6IHZvaWRcblx0e1xuXHRcdC8qIERpc3Bvc2VzIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLiAqL1xuXHRcdGlmICh0aGlzLl9zZWxlY3RPcHRpb25zU3Vic2NyaXB0aW9uKVxuXHRcdHtcblx0XHRcdHRoaXMuX3NlbGVjdE9wdGlvbnNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdH1cblxuXHRwdWJsaWMgb25TZWxlY3Rpb25DaGFuZ2UoKTogdm9pZFxuXHR7XG5cdFx0Ly8gY29uc29sZS5sb2coJ0NhbGwgYG9uU2VsZWN0aW9uQ2hhbmdlYCAtICcsICdTZWxlY3QgdmFsdWU6ICcsIHRoaXMuY29udGVudC5mb3JtQ29udHJvbC52YWx1ZSk7XG5cblx0XHR0aGlzLl9zZXRTZWxlY3RUb29sdGlwKCk7XG5cblx0XHRpZiAoKHRoaXMuY29udGVudC5leHRyYUNvbnRlbnQpICYmICh0aGlzLmNvbnRlbnQuZXh0cmFDb250ZW50LnNlbGVjdGlvbkNoYW5nZSkpXG5cdFx0e1xuXHRcdFx0dGhpcy5jb250ZW50LmV4dHJhQ29udGVudC5zZWxlY3Rpb25DaGFuZ2UodGhpcy5jb250ZW50LmZvcm1Db250cm9sLnZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogRG9lcyB0aGUgdHJhbnNsYXRpb24gZm9yIGEga2V5IChvciBhbiBhcnJheSBvZiBrZXlzKS4gXG5cdCAqIEBwYXJhbSBrZXkgVGhlIGtleSAob3IgYW4gYXJyYXkgb2Yga2V5cykgdG8gdHJhbnNsYXRlLiBcblx0ICovXG5cdHByaXZhdGUgX2RvVHJhbnNsYXRpb24oa2V5OiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogdm9pZFxuXHR7XG5cdFx0aWYgKGtleS5sZW5ndGggPT0gMClcblx0XHR7XG5cdFx0XHR0aGlzLnNlbGVjdFRvb2x0aXAgPSAnJztcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl90cmFuc1NlcnYuZ2V0KGtleSkuc3Vic2NyaWJlKChyZXM6IGFueSkgPT4ge1xuXHRcdFx0Ly8gY29uc29sZS5sb2coa2V5LCAnIC0tPiAnLCByZXMpO1xuXG5cdFx0XHRpZiAodGhpcy5jb250ZW50Lm11bHRpcGxlKVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBgcmVzYCBpcyBhbiBvYmplY3Qgb2YgdHJhbnNsYXRlZCBrZXlzLiAqL1xuXG5cdFx0XHRcdGxldCB0cmFuc2xhdGlvbktleXM6IHN0cmluZ1tdID0gT2JqZWN0LmtleXMocmVzKTtcblx0XHRcdFx0bGV0IGxlbjogbnVtYmVyID0gdHJhbnNsYXRpb25LZXlzLmxlbmd0aDtcblxuXHRcdFx0XHRsZXQgdHJhbnNsYXRpb25SZXM6IHN0cmluZyA9IHJlc1t0cmFuc2xhdGlvbktleXNbMF1dO1xuXG5cdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgbGVuOyArK2kpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0cmFuc2xhdGlvblJlcyArPSAnXFxuJyArIHJlc1t0cmFuc2xhdGlvbktleXNbaV1dO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpcy5zZWxlY3RUb29sdGlwID0gdHJhbnNsYXRpb25SZXM7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdC8qIGByZXNgIGlzIGEgdHJhbnNsYXRlZCBrZXkuICovXG5cblx0XHRcdFx0dGhpcy5zZWxlY3RUb29sdGlwID0gcmVzO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEZpbmRzIHRoZSBsYWJlbCBmb3IgYSB2YWx1ZSAob3IgYW4gYXJyYXkgb2YgdmFsdWVzKS4gXG5cdCAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgKG9yIGFuIGFycmF5IG9mIHZhbHVlcykgdG8gZmluZCB0aGUgbGFiZWwuIFxuXHQgKiBAcmV0dXJucyBSZXR1cm5zIGEgbGFiZWwgKG9yIGFuIGFycmF5IG9mIGxhYmVscykuIFxuXHQgKi9cblx0cHJpdmF0ZSBfZmluZExhYmVsKHZhbHVlOiBzdHJpbmcgfCBBcnJheTxzdHJpbmc+KTogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPlxuXHR7XG5cdFx0aWYgKHRoaXMuY29udGVudC5tdWx0aXBsZSlcblx0XHR7XG5cdFx0XHRsZXQgbGFiZWw6IEFycmF5PHN0cmluZz4gPSBbIF07XG5cblx0XHRcdGZvciAobGV0IHZhbCBvZiB2YWx1ZSlcblx0XHRcdHtcblx0XHRcdFx0Zm9yIChsZXQgb3B0IG9mICh0aGlzLmNvbnRlbnQuc2VsZWN0T3B0aW9ucyBhcyBTZWxlY3RPcHRpb25bXSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAob3B0LnZhbHVlID09IHZhbClcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRsYWJlbC5wdXNoKG9wdC5sYWJlbCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0bGV0IGxhYmVsOiBzdHJpbmcgPSAnJztcblxuXHRcdFx0Zm9yIChsZXQgb3B0IG9mICh0aGlzLmNvbnRlbnQuc2VsZWN0T3B0aW9ucyBhcyBTZWxlY3RPcHRpb25bXSkpXG5cdFx0XHR7XG5cdFx0XHRcdGlmIChvcHQudmFsdWUgPT0gdmFsdWUpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbCA9IG9wdC5sYWJlbDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbGFiZWw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGBzZWxlY3RUb29sdGlwYCBmaWVsZCB2YWx1ZS4gXG5cdCAqL1xuXHRwcml2YXRlIF9zZXRTZWxlY3RUb29sdGlwKCk6IHZvaWRcblx0e1xuXHRcdGlmICh0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wudmFsdWUgIT0gdW5kZWZpbmVkKVxuXHRcdHtcblx0XHRcdHRoaXMuX2RvVHJhbnNsYXRpb24odGhpcy5fZmluZExhYmVsKHRoaXMuY29udGVudC5mb3JtQ29udHJvbC52YWx1ZSkpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5zZWxlY3RUb29sdGlwID0gJyc7XG5cdFx0fVxuXHR9XG59XG4iXX0=