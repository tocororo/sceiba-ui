/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/experimental/select-tree/select-tree.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
/*
 *   Copyright (c) 2020 Universidad de Pinar del Río "Hermanos Saíz Montes de Oca"
 *   All rights reserved.
 */
import { Component } from "@angular/core";
import { FlatTreeControl } from "@angular/cdk/tree";
import { MatTreeFlattener, MatTreeFlatDataSource } from "@angular/material";
import { SelectionModel } from "@angular/cdk/collections";
import { of } from "rxjs";
import { InputControl } from '../../input/input.control';
/**
 * @record
 */
export function SelectOptionNode() { }
if (false) {
    /** @type {?} */
    SelectOptionNode.prototype.element;
    /** @type {?|undefined} */
    SelectOptionNode.prototype.parent;
    /** @type {?|undefined} */
    SelectOptionNode.prototype.children;
}
/**
 * @record
 */
export function FlatTreeNode() { }
if (false) {
    /** @type {?} */
    FlatTreeNode.prototype.name;
    /** @type {?} */
    FlatTreeNode.prototype.level;
    /** @type {?} */
    FlatTreeNode.prototype.expandable;
    /** @type {?} */
    FlatTreeNode.prototype.element;
}
/**
 * @record
 */
function TreeFilterData() { }
if (false) {
    /** @type {?} */
    TreeFilterData.prototype.selectOptions;
    /** @type {?} */
    TreeFilterData.prototype.type;
    /** @type {?} */
    TreeFilterData.prototype.placeholder;
    /** @type {?} */
    TreeFilterData.prototype.text;
    /** @type {?} */
    TreeFilterData.prototype.field;
    /** @type {?} */
    TreeFilterData.prototype.index;
    /** @type {?} */
    TreeFilterData.prototype.value;
    /** @type {?} */
    TreeFilterData.prototype.idVocab;
}
var SelectTreeComponent = /** @class */ (function (_super) {
    tslib_1.__extends(SelectTreeComponent, _super);
    function SelectTreeComponent() {
        var _this = _super.call(this) || this;
        _this.checklistSelection = new SelectionModel(true /* multiple */);
        _this.treeFlattener = new MatTreeFlattener(_this.transformer, _this.getLevel, _this.isExpandable, _this.getChildren);
        _this.treeControl = new FlatTreeControl(_this.getLevel, _this.isExpandable);
        _this.dataSource = new MatTreeFlatDataSource(_this.treeControl, _this.treeFlattener);
        return _this;
    }
    /**
     * @return {?}
     */
    SelectTreeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // (this.content.parentFormSection as FormGroup).addControl(
        //   this.content.name,
        //   this.internalControl
        // );
        var _this = this;
        this.init('', '', false, true);
        if (this.content.extraContent) {
            if (this.content.extraContent.observable) {
                this.content.extraContent.observable.subscribe((
                // next
                // next
                /**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    console.log(response);
                    _this.data = _this.content.extraContent.getOptions(response);
                    console.log(_this.data);
                    _this.dataSource.data = _this.data;
                    console.log(_this.dataSource);
                    _this.content.extraContent.selectedTermsIds.forEach((/**
                     * @param {?} uuid
                     * @return {?}
                     */
                    function (uuid) {
                        console.log(uuid);
                        _this.treeControl.dataNodes.forEach((/**
                         * @param {?} node
                         * @return {?}
                         */
                        function (node) {
                            if (node.element.value == uuid) {
                                console.log(node);
                                if (node.expandable) {
                                    _this.itemSelectionToggle(node);
                                }
                                else {
                                    _this.leafItemSelectionToggle(node);
                                }
                            }
                        }));
                    }));
                }), (
                // error
                // error
                /**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) {
                    console.log(error);
                }), (
                // complete
                // complete
                /**
                 * @return {?}
                 */
                function () { }));
            }
            else {
                this.data = this.content.extraContent.getOptions();
                this.dataSource.data = this.data;
            }
            if (!this.content.extraContent.selectedTermsIds) {
                this.content.extraContent.selectedTermsIds = [];
            }
        }
        this.content.value = "";
    };
    /**
     * @return {?}
     */
    SelectTreeComponent.prototype.remove_component = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    SelectTreeComponent.prototype.onChange = /**
     * @return {?}
     */
    function () {
        console.log("ttree change");
    };
    /**
     * @return {?}
     */
    SelectTreeComponent.prototype.emitSelection = /**
     * @return {?}
     */
    function () {
        this.content.formControl.setValue(this.checklistSelection.selected);
        // this.content.extraContent.selectionChange(this.checklistSelection.selected)
        // var valueEmiter = "OR";
        // this.checklistSelection.selected.forEach(node => {
        //   valueEmiter = valueEmiter + "," + node.element.value;
        // });
        // if (this.content.extraContent.selectionChange) {
        //   this.content.extraContent.selectionChange(this.content.value);
        // }
    };
    /** Transform the data to something the tree can read. */
    /**
     * Transform the data to something the tree can read.
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    SelectTreeComponent.prototype.transformer = /**
     * Transform the data to something the tree can read.
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    function (node, level) {
        /** @type {?} */
        var result = {
            name: node.element.label,
            level: level,
            expandable: node.children.length > 0,
            element: node.element
        };
        return result;
    };
    /** Get the level of the node */
    /**
     * Get the level of the node
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.getLevel = /**
     * Get the level of the node
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.level;
    };
    /** Get whether the node is expanded or not. */
    /**
     * Get whether the node is expanded or not.
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.isExpandable = /**
     * Get whether the node is expanded or not.
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.expandable;
    };
    /** Get whether the node has children or not. */
    /**
     * Get whether the node has children or not.
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.hasChild = /**
     * Get whether the node has children or not.
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    function (index, node) {
        return node.expandable;
    };
    /** Get the children for the node. */
    /**
     * Get the children for the node.
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.getChildren = /**
     * Get the children for the node.
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return of(node.children);
    };
    /** Whether all the descendants of the node are selected. */
    /**
     * Whether all the descendants of the node are selected.
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.descendantsAllSelected = /**
     * Whether all the descendants of the node are selected.
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        if (this.treeControl.dataNodes != undefined) {
            /** @type {?} */
            var descendants = this.treeControl.getDescendants(node);
            /** @type {?} */
            var descAllSelected = descendants.every((/**
             * @param {?} child
             * @return {?}
             */
            function (child) {
                return _this.checklistSelection.isSelected(child);
            }));
            return descAllSelected;
        }
        return false;
    };
    /** Whether part of the descendants are selected */
    /**
     * Whether part of the descendants are selected
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.descendantsPartiallySelected = /**
     * Whether part of the descendants are selected
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        if (this.treeControl.dataNodes != undefined) {
            /** @type {?} */
            var descendants = this.treeControl.getDescendants(node);
            /** @type {?} */
            var result = descendants.some((/**
             * @param {?} child
             * @return {?}
             */
            function (child) {
                return _this.checklistSelection.isSelected(child);
            }));
            return result && !this.descendantsAllSelected(node);
        }
        return false;
    };
    /** Select/deselect all the descendants node */
    /**
     * Select/deselect all the descendants node
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.itemSelectionToggle = /**
     * Select/deselect all the descendants node
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _a, _b;
        var _this = this;
        this.checklistSelection.toggle(node);
        /** @type {?} */
        var descendants = this.treeControl.getDescendants(node);
        this.checklistSelection.isSelected(node)
            ? (_a = this.checklistSelection).select.apply(_a, tslib_1.__spread(descendants)) : (_b = this.checklistSelection).deselect.apply(_b, tslib_1.__spread(descendants));
        // Force update for the parent
        descendants.every((/**
         * @param {?} child
         * @return {?}
         */
        function (child) { return _this.checklistSelection.isSelected(child); }));
        this.checkAllParentsSelection(node);
        this.emitSelection();
    };
    /** Check all the parents to see if they changed */
    /**
     * Check all the parents to see if they changed
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.leafItemSelectionToggle = /**
     * Check all the parents to see if they changed
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.checklistSelection.toggle(node);
        this.checkAllParentsSelection(node);
        this.emitSelection();
    };
    /* Checks all the parents when a leaf node is selected/unselected */
    /* Checks all the parents when a leaf node is selected/unselected */
    /**
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.checkAllParentsSelection = /* Checks all the parents when a leaf node is selected/unselected */
    /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var parent = this.getParentNode(node);
        while (parent) {
            this.checkRootNodeSelection(parent);
            parent = this.getParentNode(parent);
        }
    };
    /** Check root node checked state and change it accordingly */
    /**
     * Check root node checked state and change it accordingly
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.checkRootNodeSelection = /**
     * Check root node checked state and change it accordingly
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        /** @type {?} */
        var nodeSelected = this.checklistSelection.isSelected(node);
        /** @type {?} */
        var descendants = this.treeControl.getDescendants(node);
        /** @type {?} */
        var descAllSelected = descendants.every((/**
         * @param {?} child
         * @return {?}
         */
        function (child) {
            return _this.checklistSelection.isSelected(child);
        }));
        if (nodeSelected && !descAllSelected) {
            this.checklistSelection.deselect(node);
        }
        else if (!nodeSelected && descAllSelected) {
            this.checklistSelection.select(node);
        }
    };
    /* Get the parent node of a node */
    /* Get the parent node of a node */
    /**
     * @param {?} node
     * @return {?}
     */
    SelectTreeComponent.prototype.getParentNode = /* Get the parent node of a node */
    /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        /** @type {?} */
        var currentLevel = this.getLevel(node);
        if (currentLevel < 1) {
            return null;
        }
        /** @type {?} */
        var startIndex = this.treeControl.dataNodes.indexOf(node) - 1;
        for (var i = startIndex; i >= 0; i--) {
            /** @type {?} */
            var currentNode = this.treeControl.dataNodes[i];
            if (this.getLevel(currentNode) < currentLevel) {
                return currentNode;
            }
        }
        return null;
    };
    SelectTreeComponent.decorators = [
        { type: Component, args: [{
                    selector: "toco-select-tree",
                    template: "<mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" class=\"scrolleable\">\n  <mat-tree-node\n    class=\"hover\"\n    *matTreeNodeDef=\"let node\"\n    matTreeNodeToggle\n    matTreeNodePadding\n    fxLayout=\"row\"\n    fxLayoutAlign=\"space-between center\"\n    [ngStyle]=\"{ 'white-space': 'normal !important' }\"\n  >\n    <div fxLayout=\"row\" fxLayoutAlign=\"start center\">\n      <button mat-icon-button disabled></button>\n      <mat-checkbox\n        class=\"checklist-leaf-node\"\n        [checked]=\"checklistSelection.isSelected(node)\"\n        (change)=\"leafItemSelectionToggle(node)\"\n        matTooltip=\"{{ node.name }}\"\n        [ngStyle]=\"{ 'white-space': 'normal !important' }\"\n      >\n          {{ node.name }}\n      </mat-checkbox>\n    </div>\n  </mat-tree-node>\n\n  <mat-tree-node\n    class=\"hover\"\n    *matTreeNodeDef=\"let node; when: hasChild\"\n    matTreeNodePadding\n    [ngStyle]=\"{ 'white-space': 'normal !important' }\"\n  >\n    <button\n      mat-icon-button\n      matTreeNodeToggle\n      [attr.aria-label]=\"'toggle ' + node.name\"\n    >\n      <mat-icon class=\"mat-icon-rtl-mirror\">\n        {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n      </mat-icon>\n    </button>\n    <div class=\"item-width\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n      <mat-checkbox\n        [checked]=\"descendantsAllSelected(node)\"\n        [indeterminate]=\"descendantsPartiallySelected(node)\"\n        (change)=\"itemSelectionToggle(node)\"\n        matTooltip=\"{{ node.name }}\"\n        [ngStyle]=\"{ 'white-space': 'normal !important' }\"\n        >{{ node.name }}</mat-checkbox\n      >\n    </div>\n  </mat-tree-node>\n</mat-tree>\n",
                    styles: [".scrolleable{max-height:20em;min-width:15em;overflow:auto}"]
                }] }
    ];
    /** @nocollapse */
    SelectTreeComponent.ctorParameters = function () { return []; };
    return SelectTreeComponent;
}(InputControl));
export { SelectTreeComponent };
if (false) {
    /** @type {?} */
    SelectTreeComponent.prototype.data;
    /** @type {?} */
    SelectTreeComponent.prototype.treeControl;
    /** @type {?} */
    SelectTreeComponent.prototype.treeFlattener;
    /** @type {?} */
    SelectTreeComponent.prototype.dataSource;
    /** @type {?} */
    SelectTreeComponent.prototype.checklistSelection;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LXRyZWUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vdG9jby1saWIvIiwic291cmNlcyI6WyJsaWIvZm9ybXMvZXhwZXJpbWVudGFsL3NlbGVjdC10cmVlL3NlbGVjdC10cmVlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBS0EsT0FBTyxFQUFFLFNBQVMsRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUVsRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDcEQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLHFCQUFxQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDNUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQzFELE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFJMUIsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLDJCQUEyQixDQUFDOzs7O0FBRXpELHNDQUlDOzs7SUFIQyxtQ0FBc0I7O0lBQ3RCLGtDQUEwQjs7SUFDMUIsb0NBQThCOzs7OztBQUdoQyxrQ0FLQzs7O0lBSkMsNEJBQWE7O0lBQ2IsNkJBQWM7O0lBQ2Qsa0NBQW9COztJQUNwQiwrQkFBc0I7Ozs7O0FBRXhCLDZCQVNDOzs7SUFSQyx1Q0FBa0M7O0lBQ2xDLDhCQUFhOztJQUNiLHFDQUFvQjs7SUFDcEIsOEJBQWE7O0lBQ2IsK0JBQWM7O0lBQ2QsK0JBQWM7O0lBQ2QsK0JBQVc7O0lBQ1gsaUNBQWdCOztBQUdsQjtJQUt5QywrQ0FBWTtJQVduRDtRQUFBLFlBQ0UsaUJBQU8sU0FhUjtRQWhCRCx3QkFBa0IsR0FBRyxJQUFJLGNBQWMsQ0FBZSxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7UUFJekUsS0FBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLGdCQUFnQixDQUN2QyxLQUFJLENBQUMsV0FBVyxFQUNoQixLQUFJLENBQUMsUUFBUSxFQUNiLEtBQUksQ0FBQyxZQUFZLEVBQ2pCLEtBQUksQ0FBQyxXQUFXLENBQ2pCLENBQUM7UUFFRixLQUFJLENBQUMsV0FBVyxHQUFHLElBQUksZUFBZSxDQUFDLEtBQUksQ0FBQyxRQUFRLEVBQUUsS0FBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO1FBQ3pFLEtBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxxQkFBcUIsQ0FDekMsS0FBSSxDQUFDLFdBQVcsRUFDaEIsS0FBSSxDQUFDLGFBQWEsQ0FDbkIsQ0FBQzs7SUFDSixDQUFDOzs7O0lBRUQsc0NBQVE7OztJQUFSO1FBRUUsNERBQTREO1FBQzVELHVCQUF1QjtRQUN2Qix5QkFBeUI7UUFDekIsS0FBSztRQUxQLGlCQXdEQztRQWpEQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQy9CLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLEVBQUM7WUFDNUIsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUU7Z0JBQ3hDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxTQUFTO2dCQUM1QyxPQUFPOzs7Ozs7Z0JBQ1AsVUFBQyxRQUFhO29CQUNaLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBRXRCLEtBQUksQ0FBQyxJQUFJLEdBQUcsS0FBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUMzRCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDdkIsS0FBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEdBQUcsS0FBSSxDQUFDLElBQUksQ0FBQztvQkFDakMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBQzdCLEtBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLE9BQU87Ozs7b0JBQUMsVUFBQyxJQUFXO3dCQUM3RCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO3dCQUVsQixLQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxPQUFPOzs7O3dCQUFDLFVBQUEsSUFBSTs0QkFHckMsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQUM7Z0NBQzdCLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7Z0NBRWxCLElBQUcsSUFBSSxDQUFDLFVBQVUsRUFBQztvQ0FDakIsS0FBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO2lDQUNoQztxQ0FBTTtvQ0FDTCxLQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUM7aUNBQ3BDOzZCQUNGO3dCQUNILENBQUMsRUFBQyxDQUFBO29CQUNKLENBQUMsRUFBQyxDQUFDO2dCQUNMLENBQUM7Z0JBRUQsUUFBUTs7Ozs7O2dCQUNSLFVBQUMsS0FBVTtvQkFDVCxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dCQUNyQixDQUFDO2dCQUNELFdBQVc7Ozs7O2dCQUNYLGNBQU8sQ0FBQyxFQUNULENBQUM7YUFDSDtpQkFBTTtnQkFDTCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNuRCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDO2FBQ2xDO1lBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLGdCQUFnQixFQUFFO2dCQUMvQyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsR0FBRyxFQUFFLENBQUM7YUFDakQ7U0FDRjtRQUdELElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLEVBQUUsQ0FBQztJQUMxQixDQUFDOzs7O0lBRUQsOENBQWdCOzs7SUFBaEIsY0FBb0IsQ0FBQzs7OztJQUVyQixzQ0FBUTs7O0lBQVI7UUFDRSxPQUFPLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzlCLENBQUM7Ozs7SUFFRCwyQ0FBYTs7O0lBQWI7UUFDRSxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRXBFLDhFQUE4RTtRQUM5RSwwQkFBMEI7UUFDMUIscURBQXFEO1FBQ3JELDBEQUEwRDtRQUMxRCxNQUFNO1FBRU4sbURBQW1EO1FBQ25ELG1FQUFtRTtRQUNuRSxJQUFJO0lBQ04sQ0FBQztJQUVELHlEQUF5RDs7Ozs7OztJQUN6RCx5Q0FBVzs7Ozs7O0lBQVgsVUFBWSxJQUFzQixFQUFFLEtBQWE7O1lBQ3pDLE1BQU0sR0FBRztZQUNiLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUs7WUFDeEIsS0FBSyxFQUFFLEtBQUs7WUFDWixVQUFVLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQztZQUNwQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU87U0FDdEI7UUFDRCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsZ0NBQWdDOzs7Ozs7SUFDaEMsc0NBQVE7Ozs7O0lBQVIsVUFBUyxJQUFrQjtRQUN6QixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7SUFDcEIsQ0FBQztJQUVELCtDQUErQzs7Ozs7O0lBQy9DLDBDQUFZOzs7OztJQUFaLFVBQWEsSUFBa0I7UUFDN0IsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQ3pCLENBQUM7SUFFRCxnREFBZ0Q7Ozs7Ozs7SUFDaEQsc0NBQVE7Ozs7OztJQUFSLFVBQVMsS0FBYSxFQUFFLElBQWtCO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUN6QixDQUFDO0lBRUQscUNBQXFDOzs7Ozs7SUFDckMseUNBQVc7Ozs7O0lBQVgsVUFBWSxJQUFzQjtRQUNoQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFDM0IsQ0FBQztJQUVELDREQUE0RDs7Ozs7O0lBQzVELG9EQUFzQjs7Ozs7SUFBdEIsVUFBdUIsSUFBa0I7UUFBekMsaUJBU0M7UUFSQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxJQUFJLFNBQVMsRUFBRTs7Z0JBQ3JDLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUM7O2dCQUNuRCxlQUFlLEdBQUcsV0FBVyxDQUFDLEtBQUs7Ozs7WUFBQyxVQUFBLEtBQUs7Z0JBQzdDLE9BQUEsS0FBSSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUM7WUFBekMsQ0FBeUMsRUFDMUM7WUFDRCxPQUFPLGVBQWUsQ0FBQztTQUN4QjtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELG1EQUFtRDs7Ozs7O0lBQ25ELDBEQUE0Qjs7Ozs7SUFBNUIsVUFBNkIsSUFBa0I7UUFBL0MsaUJBU0M7UUFSQyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxJQUFJLFNBQVMsRUFBRTs7Z0JBQ3JDLFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUM7O2dCQUNuRCxNQUFNLEdBQUcsV0FBVyxDQUFDLElBQUk7Ozs7WUFBQyxVQUFBLEtBQUs7Z0JBQ25DLE9BQUEsS0FBSSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUM7WUFBekMsQ0FBeUMsRUFDMUM7WUFDRCxPQUFPLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNyRDtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVELCtDQUErQzs7Ozs7O0lBQy9DLGlEQUFtQjs7Ozs7SUFBbkIsVUFBb0IsSUFBa0I7O1FBQXRDLGlCQVdDO1FBVkMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQzs7WUFDL0IsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQztRQUN6RCxJQUFJLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQztZQUN0QyxDQUFDLENBQUMsQ0FBQSxLQUFBLElBQUksQ0FBQyxrQkFBa0IsQ0FBQSxDQUFDLE1BQU0sNEJBQUksV0FBVyxHQUMvQyxDQUFDLENBQUMsQ0FBQSxLQUFBLElBQUksQ0FBQyxrQkFBa0IsQ0FBQSxDQUFDLFFBQVEsNEJBQUksV0FBVyxFQUFDLENBQUM7UUFFckQsOEJBQThCO1FBQzlCLFdBQVcsQ0FBQyxLQUFLOzs7O1FBQUMsVUFBQSxLQUFLLElBQUksT0FBQSxLQUFJLENBQUMsa0JBQWtCLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUF6QyxDQUF5QyxFQUFDLENBQUM7UUFDdEUsSUFBSSxDQUFDLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQztJQUN2QixDQUFDO0lBRUQsbURBQW1EOzs7Ozs7SUFDbkQscURBQXVCOzs7OztJQUF2QixVQUF3QixJQUFrQjtRQUN4QyxJQUFJLENBQUMsa0JBQWtCLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwQyxJQUFJLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVELG9FQUFvRTs7Ozs7O0lBQ3BFLHNEQUF3Qjs7Ozs7SUFBeEIsVUFBeUIsSUFBa0I7O1lBQ3JDLE1BQU0sR0FBd0IsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUM7UUFDMUQsT0FBTyxNQUFNLEVBQUU7WUFDYixJQUFJLENBQUMsc0JBQXNCLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDcEMsTUFBTSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDckM7SUFDSCxDQUFDO0lBRUQsOERBQThEOzs7Ozs7SUFDOUQsb0RBQXNCOzs7OztJQUF0QixVQUF1QixJQUFrQjtRQUF6QyxpQkFXQzs7WUFWTyxZQUFZLEdBQUcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUM7O1lBQ3ZELFdBQVcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUM7O1lBQ25ELGVBQWUsR0FBRyxXQUFXLENBQUMsS0FBSzs7OztRQUFDLFVBQUEsS0FBSztZQUM3QyxPQUFBLEtBQUksQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDO1FBQXpDLENBQXlDLEVBQzFDO1FBQ0QsSUFBSSxZQUFZLElBQUksQ0FBQyxlQUFlLEVBQUU7WUFDcEMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUN4QzthQUFNLElBQUksQ0FBQyxZQUFZLElBQUksZUFBZSxFQUFFO1lBQzNDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDdEM7SUFDSCxDQUFDO0lBRUQsbUNBQW1DOzs7Ozs7SUFDbkMsMkNBQWE7Ozs7O0lBQWIsVUFBYyxJQUFrQjs7WUFDeEIsWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDO1FBRXhDLElBQUksWUFBWSxHQUFHLENBQUMsRUFBRTtZQUNwQixPQUFPLElBQUksQ0FBQztTQUNiOztZQUVLLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztRQUUvRCxLQUFLLElBQUksQ0FBQyxHQUFHLFVBQVUsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFOztnQkFDOUIsV0FBVyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUVqRCxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLEdBQUcsWUFBWSxFQUFFO2dCQUM3QyxPQUFPLFdBQVcsQ0FBQzthQUNwQjtTQUNGO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDOztnQkFuT0YsU0FBUyxTQUFDO29CQUNULFFBQVEsRUFBRSxrQkFBa0I7b0JBQzVCLDR0REFBMkM7O2lCQUU1Qzs7OztJQWdPRCwwQkFBQztDQUFBLEFBcE9ELENBS3lDLFlBQVksR0ErTnBEO1NBL05ZLG1CQUFtQjs7O0lBRTlCLG1DQUF5Qjs7SUFJekIsMENBQTJDOztJQUMzQyw0Q0FBZ0U7O0lBQ2hFLHlDQUFrRTs7SUFDbEUsaURBQTJFIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqICAgQ29weXJpZ2h0IChjKSAyMDIwIFVuaXZlcnNpZGFkIGRlIFBpbmFyIGRlbCBSw61vIFwiSGVybWFub3MgU2HDrXogTW9udGVzIGRlIE9jYVwiXG4gKiAgIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIEZvcm1Hcm91cCB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuaW1wb3J0IHsgRmxhdFRyZWVDb250cm9sIH0gZnJvbSBcIkBhbmd1bGFyL2Nkay90cmVlXCI7XG5pbXBvcnQgeyBNYXRUcmVlRmxhdHRlbmVyLCBNYXRUcmVlRmxhdERhdGFTb3VyY2UgfSBmcm9tIFwiQGFuZ3VsYXIvbWF0ZXJpYWxcIjtcbmltcG9ydCB7IFNlbGVjdGlvbk1vZGVsIH0gZnJvbSBcIkBhbmd1bGFyL2Nkay9jb2xsZWN0aW9uc1wiO1xuaW1wb3J0IHsgb2YgfSBmcm9tIFwicnhqc1wiO1xuXG5pbXBvcnQgeyBGb3JtRmllbGRDb250cm9sX0V4cGVyaW1lbnRhbCB9IGZyb20gXCIuLi9mb3JtLWZpZWxkLmNvbnRyb2wuZXhwZXJpbWVudGFsXCI7XG5pbXBvcnQgeyBTZWxlY3RPcHRpb24gfSBmcm9tICcuLi8uLi9pbnB1dC9zZWxlY3Qvc2VsZWN0LWlucHV0LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJbnB1dENvbnRyb2wgfSBmcm9tICcuLi8uLi9pbnB1dC9pbnB1dC5jb250cm9sJztcblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RPcHRpb25Ob2RlIHtcbiAgZWxlbWVudDogU2VsZWN0T3B0aW9uO1xuICBwYXJlbnQ/OiBTZWxlY3RPcHRpb25Ob2RlO1xuICBjaGlsZHJlbj86IFNlbGVjdE9wdGlvbk5vZGVbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGbGF0VHJlZU5vZGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIGxldmVsOiBudW1iZXI7XG4gIGV4cGFuZGFibGU6IGJvb2xlYW47XG4gIGVsZW1lbnQ6IFNlbGVjdE9wdGlvbjtcbn1cbmludGVyZmFjZSBUcmVlRmlsdGVyRGF0YSB7XG4gIHNlbGVjdE9wdGlvbnM6IFNlbGVjdE9wdGlvbk5vZGVbXTtcbiAgdHlwZTogc3RyaW5nO1xuICBwbGFjZWhvbGRlcjogc3RyaW5nO1xuICB0ZXh0OiBzdHJpbmc7XG4gIGZpZWxkOiBzdHJpbmc7XG4gIGluZGV4OiBudW1iZXI7XG4gIHZhbHVlOiBhbnk7XG4gIGlkVm9jYWI6IG51bWJlcjtcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiBcInRvY28tc2VsZWN0LXRyZWVcIixcbiAgdGVtcGxhdGVVcmw6IFwiLi9zZWxlY3QtdHJlZS5jb21wb25lbnQuaHRtbFwiLFxuICBzdHlsZVVybHM6IFtcIi4vc2VsZWN0LXRyZWUuY29tcG9uZW50LnNjc3NcIl1cbn0pXG5leHBvcnQgY2xhc3MgU2VsZWN0VHJlZUNvbXBvbmVudCBleHRlbmRzIElucHV0Q29udHJvbFxuICBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gIGRhdGE6IFNlbGVjdE9wdGlvbk5vZGVbXTtcblxuICAvLyBpbnRlcm5hbENvbnRyb2wgPSBuZXcgRm9ybUNvbnRyb2woKTtcblxuICB0cmVlQ29udHJvbDogRmxhdFRyZWVDb250cm9sPEZsYXRUcmVlTm9kZT47XG4gIHRyZWVGbGF0dGVuZXI6IE1hdFRyZWVGbGF0dGVuZXI8U2VsZWN0T3B0aW9uTm9kZSwgRmxhdFRyZWVOb2RlPjtcbiAgZGF0YVNvdXJjZTogTWF0VHJlZUZsYXREYXRhU291cmNlPFNlbGVjdE9wdGlvbk5vZGUsIEZsYXRUcmVlTm9kZT47XG4gIGNoZWNrbGlzdFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb25Nb2RlbDxGbGF0VHJlZU5vZGU+KHRydWUgLyogbXVsdGlwbGUgKi8pO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50cmVlRmxhdHRlbmVyID0gbmV3IE1hdFRyZWVGbGF0dGVuZXIoXG4gICAgICB0aGlzLnRyYW5zZm9ybWVyLFxuICAgICAgdGhpcy5nZXRMZXZlbCxcbiAgICAgIHRoaXMuaXNFeHBhbmRhYmxlLFxuICAgICAgdGhpcy5nZXRDaGlsZHJlblxuICAgICk7XG5cbiAgICB0aGlzLnRyZWVDb250cm9sID0gbmV3IEZsYXRUcmVlQ29udHJvbCh0aGlzLmdldExldmVsLCB0aGlzLmlzRXhwYW5kYWJsZSk7XG4gICAgdGhpcy5kYXRhU291cmNlID0gbmV3IE1hdFRyZWVGbGF0RGF0YVNvdXJjZShcbiAgICAgIHRoaXMudHJlZUNvbnRyb2wsXG4gICAgICB0aGlzLnRyZWVGbGF0dGVuZXJcbiAgICApO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG5cbiAgICAvLyAodGhpcy5jb250ZW50LnBhcmVudEZvcm1TZWN0aW9uIGFzIEZvcm1Hcm91cCkuYWRkQ29udHJvbChcbiAgICAvLyAgIHRoaXMuY29udGVudC5uYW1lLFxuICAgIC8vICAgdGhpcy5pbnRlcm5hbENvbnRyb2xcbiAgICAvLyApO1xuXG4gICAgdGhpcy5pbml0KCcnLCAnJywgZmFsc2UsIHRydWUpO1xuICAgIGlmICh0aGlzLmNvbnRlbnQuZXh0cmFDb250ZW50KXtcbiAgICAgIGlmICh0aGlzLmNvbnRlbnQuZXh0cmFDb250ZW50Lm9ic2VydmFibGUpIHtcbiAgICAgICAgdGhpcy5jb250ZW50LmV4dHJhQ29udGVudC5vYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICAgICAvLyBuZXh0XG4gICAgICAgICAgKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcblxuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5jb250ZW50LmV4dHJhQ29udGVudC5nZXRPcHRpb25zKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YVNvdXJjZSk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuZXh0cmFDb250ZW50LnNlbGVjdGVkVGVybXNJZHMuZm9yRWFjaCgodXVpZDpzdHJpbmcpID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2codXVpZCk7XG5cbiAgICAgICAgICAgICAgdGhpcy50cmVlQ29udHJvbC5kYXRhTm9kZXMuZm9yRWFjaChub2RlID0+IHtcblxuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZWxlbWVudC52YWx1ZSA9PSB1dWlkKXtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGUpO1xuXG4gICAgICAgICAgICAgICAgICBpZihub2RlLmV4cGFuZGFibGUpe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1TZWxlY3Rpb25Ub2dnbGUobm9kZSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlYWZJdGVtU2VsZWN0aW9uVG9nZ2xlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgIChlcnJvcjogYW55KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBjb21wbGV0ZVxuICAgICAgICAgICgpID0+IHt9XG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmNvbnRlbnQuZXh0cmFDb250ZW50LmdldE9wdGlvbnMoKTtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY29udGVudC5leHRyYUNvbnRlbnQuc2VsZWN0ZWRUZXJtc0lkcykge1xuICAgICAgICB0aGlzLmNvbnRlbnQuZXh0cmFDb250ZW50LnNlbGVjdGVkVGVybXNJZHMgPSBbXTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIHRoaXMuY29udGVudC52YWx1ZSA9IFwiXCI7XG4gIH1cblxuICByZW1vdmVfY29tcG9uZW50KCkge31cblxuICBvbkNoYW5nZSgpIHtcbiAgICBjb25zb2xlLmxvZyhcInR0cmVlIGNoYW5nZVwiKTtcbiAgfVxuXG4gIGVtaXRTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5jb250ZW50LmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLnNlbGVjdGVkKTtcblxuICAgIC8vIHRoaXMuY29udGVudC5leHRyYUNvbnRlbnQuc2VsZWN0aW9uQ2hhbmdlKHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLnNlbGVjdGVkKVxuICAgIC8vIHZhciB2YWx1ZUVtaXRlciA9IFwiT1JcIjtcbiAgICAvLyB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5zZWxlY3RlZC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgIC8vICAgdmFsdWVFbWl0ZXIgPSB2YWx1ZUVtaXRlciArIFwiLFwiICsgbm9kZS5lbGVtZW50LnZhbHVlO1xuICAgIC8vIH0pO1xuXG4gICAgLy8gaWYgKHRoaXMuY29udGVudC5leHRyYUNvbnRlbnQuc2VsZWN0aW9uQ2hhbmdlKSB7XG4gICAgLy8gICB0aGlzLmNvbnRlbnQuZXh0cmFDb250ZW50LnNlbGVjdGlvbkNoYW5nZSh0aGlzLmNvbnRlbnQudmFsdWUpO1xuICAgIC8vIH1cbiAgfVxuXG4gIC8qKiBUcmFuc2Zvcm0gdGhlIGRhdGEgdG8gc29tZXRoaW5nIHRoZSB0cmVlIGNhbiByZWFkLiAqL1xuICB0cmFuc2Zvcm1lcihub2RlOiBTZWxlY3RPcHRpb25Ob2RlLCBsZXZlbDogbnVtYmVyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgbmFtZTogbm9kZS5lbGVtZW50LmxhYmVsLFxuICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgZXhwYW5kYWJsZTogbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwLFxuICAgICAgZWxlbWVudDogbm9kZS5lbGVtZW50XG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqIEdldCB0aGUgbGV2ZWwgb2YgdGhlIG5vZGUgKi9cbiAgZ2V0TGV2ZWwobm9kZTogRmxhdFRyZWVOb2RlKSB7XG4gICAgcmV0dXJuIG5vZGUubGV2ZWw7XG4gIH1cblxuICAvKiogR2V0IHdoZXRoZXIgdGhlIG5vZGUgaXMgZXhwYW5kZWQgb3Igbm90LiAqL1xuICBpc0V4cGFuZGFibGUobm9kZTogRmxhdFRyZWVOb2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZXhwYW5kYWJsZTtcbiAgfVxuXG4gIC8qKiBHZXQgd2hldGhlciB0aGUgbm9kZSBoYXMgY2hpbGRyZW4gb3Igbm90LiAqL1xuICBoYXNDaGlsZChpbmRleDogbnVtYmVyLCBub2RlOiBGbGF0VHJlZU5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5leHBhbmRhYmxlO1xuICB9XG5cbiAgLyoqIEdldCB0aGUgY2hpbGRyZW4gZm9yIHRoZSBub2RlLiAqL1xuICBnZXRDaGlsZHJlbihub2RlOiBTZWxlY3RPcHRpb25Ob2RlKSB7XG4gICAgcmV0dXJuIG9mKG5vZGUuY2hpbGRyZW4pO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgYWxsIHRoZSBkZXNjZW5kYW50cyBvZiB0aGUgbm9kZSBhcmUgc2VsZWN0ZWQuICovXG4gIGRlc2NlbmRhbnRzQWxsU2VsZWN0ZWQobm9kZTogRmxhdFRyZWVOb2RlKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMudHJlZUNvbnRyb2wuZGF0YU5vZGVzICE9IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZGVzY2VuZGFudHMgPSB0aGlzLnRyZWVDb250cm9sLmdldERlc2NlbmRhbnRzKG5vZGUpO1xuICAgICAgY29uc3QgZGVzY0FsbFNlbGVjdGVkID0gZGVzY2VuZGFudHMuZXZlcnkoY2hpbGQgPT5cbiAgICAgICAgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChjaGlsZClcbiAgICAgICk7XG4gICAgICByZXR1cm4gZGVzY0FsbFNlbGVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogV2hldGhlciBwYXJ0IG9mIHRoZSBkZXNjZW5kYW50cyBhcmUgc2VsZWN0ZWQgKi9cbiAgZGVzY2VuZGFudHNQYXJ0aWFsbHlTZWxlY3RlZChub2RlOiBGbGF0VHJlZU5vZGUpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy50cmVlQ29udHJvbC5kYXRhTm9kZXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkZXNjZW5kYW50cyA9IHRoaXMudHJlZUNvbnRyb2wuZ2V0RGVzY2VuZGFudHMobm9kZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBkZXNjZW5kYW50cy5zb21lKGNoaWxkID0+XG4gICAgICAgIHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQoY2hpbGQpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHJlc3VsdCAmJiAhdGhpcy5kZXNjZW5kYW50c0FsbFNlbGVjdGVkKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogU2VsZWN0L2Rlc2VsZWN0IGFsbCB0aGUgZGVzY2VuZGFudHMgbm9kZSAqL1xuICBpdGVtU2VsZWN0aW9uVG9nZ2xlKG5vZGU6IEZsYXRUcmVlTm9kZSk6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLnRvZ2dsZShub2RlKTtcbiAgICBjb25zdCBkZXNjZW5kYW50cyA9IHRoaXMudHJlZUNvbnRyb2wuZ2V0RGVzY2VuZGFudHMobm9kZSk7XG4gICAgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChub2RlKVxuICAgICAgPyB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5zZWxlY3QoLi4uZGVzY2VuZGFudHMpXG4gICAgICA6IHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLmRlc2VsZWN0KC4uLmRlc2NlbmRhbnRzKTtcblxuICAgIC8vIEZvcmNlIHVwZGF0ZSBmb3IgdGhlIHBhcmVudFxuICAgIGRlc2NlbmRhbnRzLmV2ZXJ5KGNoaWxkID0+IHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQoY2hpbGQpKTtcbiAgICB0aGlzLmNoZWNrQWxsUGFyZW50c1NlbGVjdGlvbihub2RlKTtcbiAgICB0aGlzLmVtaXRTZWxlY3Rpb24oKTtcbiAgfVxuXG4gIC8qKiBDaGVjayBhbGwgdGhlIHBhcmVudHMgdG8gc2VlIGlmIHRoZXkgY2hhbmdlZCAqL1xuICBsZWFmSXRlbVNlbGVjdGlvblRvZ2dsZShub2RlOiBGbGF0VHJlZU5vZGUpOiB2b2lkIHtcbiAgICB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi50b2dnbGUobm9kZSk7XG4gICAgdGhpcy5jaGVja0FsbFBhcmVudHNTZWxlY3Rpb24obm9kZSk7XG4gICAgdGhpcy5lbWl0U2VsZWN0aW9uKCk7XG4gIH1cblxuICAvKiBDaGVja3MgYWxsIHRoZSBwYXJlbnRzIHdoZW4gYSBsZWFmIG5vZGUgaXMgc2VsZWN0ZWQvdW5zZWxlY3RlZCAqL1xuICBjaGVja0FsbFBhcmVudHNTZWxlY3Rpb24obm9kZTogRmxhdFRyZWVOb2RlKTogdm9pZCB7XG4gICAgbGV0IHBhcmVudDogRmxhdFRyZWVOb2RlIHwgbnVsbCA9IHRoaXMuZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICB0aGlzLmNoZWNrUm9vdE5vZGVTZWxlY3Rpb24ocGFyZW50KTtcbiAgICAgIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50Tm9kZShwYXJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBDaGVjayByb290IG5vZGUgY2hlY2tlZCBzdGF0ZSBhbmQgY2hhbmdlIGl0IGFjY29yZGluZ2x5ICovXG4gIGNoZWNrUm9vdE5vZGVTZWxlY3Rpb24obm9kZTogRmxhdFRyZWVOb2RlKTogdm9pZCB7XG4gICAgY29uc3Qgbm9kZVNlbGVjdGVkID0gdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChub2RlKTtcbiAgICBjb25zdCBkZXNjZW5kYW50cyA9IHRoaXMudHJlZUNvbnRyb2wuZ2V0RGVzY2VuZGFudHMobm9kZSk7XG4gICAgY29uc3QgZGVzY0FsbFNlbGVjdGVkID0gZGVzY2VuZGFudHMuZXZlcnkoY2hpbGQgPT5cbiAgICAgIHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQoY2hpbGQpXG4gICAgKTtcbiAgICBpZiAobm9kZVNlbGVjdGVkICYmICFkZXNjQWxsU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLmRlc2VsZWN0KG5vZGUpO1xuICAgIH0gZWxzZSBpZiAoIW5vZGVTZWxlY3RlZCAmJiBkZXNjQWxsU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLnNlbGVjdChub2RlKTtcbiAgICB9XG4gIH1cblxuICAvKiBHZXQgdGhlIHBhcmVudCBub2RlIG9mIGEgbm9kZSAqL1xuICBnZXRQYXJlbnROb2RlKG5vZGU6IEZsYXRUcmVlTm9kZSk6IEZsYXRUcmVlTm9kZSB8IG51bGwge1xuICAgIGNvbnN0IGN1cnJlbnRMZXZlbCA9IHRoaXMuZ2V0TGV2ZWwobm9kZSk7XG5cbiAgICBpZiAoY3VycmVudExldmVsIDwgMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IHRoaXMudHJlZUNvbnRyb2wuZGF0YU5vZGVzLmluZGV4T2Yobm9kZSkgLSAxO1xuXG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHRoaXMudHJlZUNvbnRyb2wuZGF0YU5vZGVzW2ldO1xuXG4gICAgICBpZiAodGhpcy5nZXRMZXZlbChjdXJyZW50Tm9kZSkgPCBjdXJyZW50TGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuIl19