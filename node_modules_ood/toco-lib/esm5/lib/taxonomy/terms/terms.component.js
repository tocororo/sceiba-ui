/**
 * @fileoverview added by tsickle
 * Generated from: lib/taxonomy/terms/terms.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input } from '@angular/core';
import { of as observableOf, of } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { FlatTreeControl } from '@angular/cdk/tree';
import { MatDialog } from '@angular/material/dialog';
import { MatTreeFlatDataSource, MatTreeFlattener } from '@angular/material/tree';
import { MatSnackBar } from '@angular/material/snack-bar';
import { MessageHandler, StatusCode } from '../../core/public-api';
import { Vocabulary } from '../../entities/public-api';
import { TaxonomyService } from '../../backend/public-api';
import { TermGenericComponent } from '../term-generic/term-generic.component';
import { OAuthStorage } from 'angular-oauth2-oidc';
/**
 * Flattened tree node that has been created from a TermNode through the flattener. Flattened
 * nodes include level index and whether they can be expanded or not.
 * @record
 */
export function FlatTreeNode() { }
if (false) {
    /** @type {?} */
    FlatTreeNode.prototype.name;
    /** @type {?} */
    FlatTreeNode.prototype.level;
    /** @type {?} */
    FlatTreeNode.prototype.expandable;
}
var TermsComponent = /** @class */ (function () {
    function TermsComponent(service, oautheStorage, dialog, _snackBar) {
        var _this = this;
        this.service = service;
        this.oautheStorage = oautheStorage;
        this.dialog = dialog;
        this._snackBar = _snackBar;
        this.loading = false;
        this.termsTreeObserver = {
            next: (/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                _this.dataSource.data = response.data.tree.term_node;
                _this.loading = !_this.loading;
            }),
            error: (/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                console.log('error: ' + err + '.');
            }),
            complete: (/**
             * @return {?}
             */
            function () {
                console.log('complete');
            })
        };
        this.termChangeObserver = {
            next: (/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                _this.loading = !_this.loading;
                _this.service.getTermsTreeByVocab(_this.currentVocab.id).subscribe(_this.termsTreeObserver);
                _this.dialog.closeAll();
                /** @type {?} */
                var m = new MessageHandler(_this._snackBar);
                m.showMessage(StatusCode.OK, response.message);
            }),
            error: (/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                console.log('error: ' + err + '.');
            }),
            complete: (/**
             * @return {?}
             */
            function () {
                console.log('complete');
            })
        };
        this.currentVocab = null;
        this.treeFlattener = new MatTreeFlattener(this.transformer, this.getLevel, this.isExpandable, this.getChildren);
        this.treeControl = new FlatTreeControl(this.getLevel, this.isExpandable);
        this.dataSource = new MatTreeFlatDataSource(this.treeControl, this.treeFlattener);
    }
    /**
     * @return {?}
     */
    TermsComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.oautheStorage.getItem('user_permission')) {
            this.getAuthenticatedUserPermissions();
        }
    };
    /**
     * @return {?}
     */
    TermsComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.currentVocab != null) {
            this.loading = true;
            this.service.getTermsTreeByVocab(this.currentVocab.id)
                .subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                _this.dataSource.data = response.data.tree.term_node;
            }), (/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                console.log('error: ' + err + '.');
            }), (/**
             * @return {?}
             */
            function () {
                _this.loading = false;
            }));
        }
    };
    /**
     * @return {?}
     */
    TermsComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
    };
    /** Transform the data to something the tree can read. */
    /**
     * Transform the data to something the tree can read.
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    TermsComponent.prototype.transformer = /**
     * Transform the data to something the tree can read.
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    function (node, level) {
        return {
            name: node.term.identifier,
            term: node.term,
            level: level,
            expandable: (node.children.length > 0)
        };
    };
    /** Get the level of the node */
    /**
     * Get the level of the node
     * @param {?} node
     * @return {?}
     */
    TermsComponent.prototype.getLevel = /**
     * Get the level of the node
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.level;
    };
    /** Get whether the node is expanded or not. */
    /**
     * Get whether the node is expanded or not.
     * @param {?} node
     * @return {?}
     */
    TermsComponent.prototype.isExpandable = /**
     * Get whether the node is expanded or not.
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return node.expandable;
    };
    /** Get whether the node has children or not. */
    /**
     * Get whether the node has children or not.
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    TermsComponent.prototype.hasChild = /**
     * Get whether the node has children or not.
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    function (index, node) {
        return node.expandable;
    };
    /** Get the children for the node. */
    /**
     * Get the children for the node.
     * @param {?} node
     * @return {?}
     */
    TermsComponent.prototype.getChildren = /**
     * Get the children for the node.
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return observableOf(node.children);
    };
    /**
     * @return {?}
     */
    TermsComponent.prototype.addTerm = /**
     * @return {?}
     */
    function () {
        this.openTermDialog(null);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    TermsComponent.prototype.editTerm = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.openTermDialog(node.term);
    };
    /**
     * @private
     * @param {?} term
     * @return {?}
     */
    TermsComponent.prototype.openTermDialog = /**
     * @private
     * @param {?} term
     * @return {?}
     */
    function (term) {
        var _this = this;
        /** @type {?} */
        var dialogRef = this.dialog.open(TermGenericComponent, {
            data: {
                term: term,
                terms: this.dataSource.data,
                currentVocab: this.currentVocab,
                accept: (/**
                 * @param {?} term
                 * @return {?}
                 */
                function (term) {
                    _this.dialog.closeAll();
                    if (term.isNew) {
                        _this.service.newTerm(term).pipe().subscribe(_this.termChangeObserver);
                    }
                    else {
                        _this.service.editTerm(term).pipe().subscribe(_this.termChangeObserver);
                    }
                })
            }
        });
        dialogRef.afterClosed().subscribe((/**
         * @param {?} result
         * @return {?}
         */
        function (result) {
            console.log('dialog closed');
        }));
    };
    /**
     * @param {?} node
     * @return {?}
     */
    TermsComponent.prototype.deleteTerm = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        console.log(node);
    };
    /**
     * @return {?}
     */
    TermsComponent.prototype.getAuthenticatedUserPermissions = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.service.getCurrentUserPermissions().pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        function (err) {
            /** @type {?} */
            var m = new MessageHandler(_this._snackBar);
            m.showMessage(StatusCode.serverError, err.message);
            // TODO: Maybe you must set a better return.
            return of(null);
        })))
            .subscribe((/**
         * @param {?} request
         * @return {?}
         */
        function (request) {
            if (request.status == 'success') {
                /** @type {?} */
                var permJson = JSON.stringify(request.data.permissions.actions);
                _this.oautheStorage.setItem('user_permissions', permJson);
            }
        }));
    };
    /**
     * @param {?} permission
     * @param {?=} id
     * @return {?}
     */
    TermsComponent.prototype.hasPermission = /**
     * @param {?} permission
     * @param {?=} id
     * @return {?}
     */
    function (permission, id) {
        /** @type {?} */
        var userPermission = JSON.parse(this.oautheStorage.getItem('user_permissions'));
        if (!userPermission) {
            return false;
        }
        switch (permission) {
            case 'add':
                if (userPermission.taxonomy_full_editor_actions === null)
                    return true;
                return false;
            case 'edit':
                if (userPermission.taxonomy_full_editor_actions === null)
                    return true;
                if (userPermission.vocabulary_editor_actions) {
                    /** @type {?} */
                    var arr = userPermission.vocabulary_editor_actions;
                    if (arr.includes(id)) {
                        return true;
                    }
                }
                else if (userPermission.taxonomy_full_editor_actions) {
                    return true;
                }
                return false;
            default:
                return false;
        }
    };
    TermsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'toco-terms',
                    template: "<mat-card>\n    <mat-card-header>\n        <mat-card-title>\n            <div fxLayout=\"row\" fxLayoutAlign=\"space-between none\">\n                T\u00E9rminos\n                <ng-container *ngIf=\"currentVocab\"> de {{ currentVocab.human_name}} </ng-container>\n\n                <button mat-icon-button *ngIf=\"currentVocab && hasPermission('add')\" (click)=\"addTerm()\"\n                    matTooltip=\"Adicionar T\u00E9rmino\">\n                    <mat-icon>library_add</mat-icon>\n                </button>\n\n            </div>\n        </mat-card-title>\n    </mat-card-header>\n    <mat-card-content [style.overflow]=\"'auto'\" [style.height]=\"'25em'\">\n        <mat-spinner *ngIf=\"loading; else elseTemplate\"></mat-spinner>\n\n        <ng-template #elseTemplate>\n            <mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" class=\"padd\">\n                <mat-tree-node class=\"hover\" *matTreeNodeDef=\"let node\" matTreeNodeToggle matTreeNodePadding\n                    fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n                    <div fxLayout=\"row\" fxLayoutAlign=\"start center\">\n                        <button mat-icon-button disabled></button>\n                        {{ node.name }}\n                    </div> \n                    <button mat-icon-button *ngIf=\"currentVocab && hasPermission('edit', currentVocab.id)\" (click)=\"editTerm(node)\" matTooltip=\"Editar\">\n                    <mat-icon>edit</mat-icon>\n                    </button>\n                </mat-tree-node>\n\n                <mat-tree-node class=\"hover\" *matTreeNodeDef=\"let node; when: hasChild\" matTreeNodePadding>\n                    <button mat-icon-button matTreeNodeToggle [attr.aria-label]=\"'toggle ' + node.name\">\n                        <mat-icon class=\"mat-icon-rtl-mirror\">\n                            {{treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right'}}\n                        </mat-icon>\n                    </button>\n                    <div class=\"item-width\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n                        {{ node.name }}\n                        <div>\n                            <button mat-icon-button *ngIf=\"currentVocab && hasPermission('edit', currentVocab.id)\" (click)=\"editTerm(node)\" matTooltip=\"Editar\">\n                                <mat-icon>edit</mat-icon>\n                            </button>\n                            <!-- <button mat-icon-button (click)=\"deleteTerm(node)\" matTooltip=\"Eliminar\">\n                                <mat-icon>delete</mat-icon>\n                            </button> -->\n                        </div>\n                    </div>\n\n                </mat-tree-node>\n            </mat-tree>\n        </ng-template>\n    </mat-card-content>\n</mat-card>",
                    styles: [".type-icon{color:#757575;margin-right:5px}.item-width{width:100%}.padd{padding:.7em}.hover:hover{transform:scale(1.02);box-shadow:0 0 10px 0 rgba(0,0,0,.4);border-radius:3px}"]
                }] }
    ];
    /** @nocollapse */
    TermsComponent.ctorParameters = function () { return [
        { type: TaxonomyService },
        { type: OAuthStorage },
        { type: MatDialog },
        { type: MatSnackBar }
    ]; };
    TermsComponent.propDecorators = {
        currentVocab: [{ type: Input }]
    };
    return TermsComponent;
}());
export { TermsComponent };
if (false) {
    /** @type {?} */
    TermsComponent.prototype.loading;
    /**
     * The TreeControl controls the expand/collapse state of tree nodes.
     * @type {?}
     */
    TermsComponent.prototype.treeControl;
    /**
     * The TreeFlattener is used to generate the flat list of items from hierarchical data.
     * @type {?}
     */
    TermsComponent.prototype.treeFlattener;
    /**
     * The MatTreeFlatDataSource connects the control and flattener to provide data.
     * @type {?}
     */
    TermsComponent.prototype.dataSource;
    /**
     * @type {?}
     * @private
     */
    TermsComponent.prototype.termsTreeObserver;
    /**
     * @type {?}
     * @private
     */
    TermsComponent.prototype.termChangeObserver;
    /** @type {?} */
    TermsComponent.prototype.currentVocab;
    /**
     * @type {?}
     * @private
     */
    TermsComponent.prototype.service;
    /**
     * @type {?}
     * @private
     */
    TermsComponent.prototype.oautheStorage;
    /** @type {?} */
    TermsComponent.prototype.dialog;
    /**
     * @type {?}
     * @private
     */
    TermsComponent.prototype._snackBar;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVybXMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vdG9jby1saWIvIiwic291cmNlcyI6WyJsaWIvdGF4b25vbXkvdGVybXMvdGVybXMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBcUIsS0FBSyxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQy9FLE9BQU8sRUFBRSxFQUFFLElBQUksWUFBWSxFQUFpQyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDN0UsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDckQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDakYsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRTFELE9BQU8sRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFZLE1BQU0sdUJBQXVCLENBQUM7QUFDN0UsT0FBTyxFQUFFLFVBQVUsRUFBa0IsTUFBTSwyQkFBMkIsQ0FBQztBQUV2RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDM0QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFFOUUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7Ozs7QUFNbkQsa0NBSUM7OztJQUhHLDRCQUFhOztJQUNiLDZCQUFjOztJQUNkLGtDQUFvQjs7QUFHeEI7SUF1REksd0JBQW9CLE9BQXdCLEVBQ2hDLGFBQTJCLEVBQzVCLE1BQWlCLEVBQ2hCLFNBQXNCO1FBSGxDLGlCQVlDO1FBWm1CLFlBQU8sR0FBUCxPQUFPLENBQWlCO1FBQ2hDLGtCQUFhLEdBQWIsYUFBYSxD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QixLQUFLLElBQUk7b0JBQ3BELE9BQU8sSUFBSSxDQUFDO2dCQUVoQixJQUFJLGNBQWMsQ0FBQyx5QkFBeUIsRUFBRTs7d0JBQ3BDLEdBQUcsR0FBa0IsY0FBYyxDQUFDLHlCQUF5QjtvQkFFbkUsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFO3dCQUNsQixPQUFPLElBQUksQ0FBQTtxQkFDZDtpQkFFSjtxQkFDSSxJQUFJLGNBQWMsQ0FBQyw0QkFBNEIsRUFBRTtvQkFDbEQsT0FBTyxJQUFJLENBQUM7aUJBQ2Y7Z0JBRUQsT0FBTyxLQUFLLENBQUM7WUFFakI7Z0JBQ0ksT0FBTyxLQUFLLENBQUM7U0FDcEI7SUFDTCxDQUFDOztnQkFuTkosU0FBUyxTQUFDO29CQUNQLFFBQVEsRUFBRSxZQUFZO29CQUN0QiwreUZBQXFDOztpQkFFeEM7Ozs7Z0JBbkJRLGVBQWU7Z0JBR2YsWUFBWTtnQkFWWixTQUFTO2dCQUVULFdBQVc7OzsrQkF3RWYsS0FBSzs7SUFnS1YscUJBQUM7Q0FBQSxBQXBORCxJQW9OQztTQS9NWSxjQUFjOzs7SUFHdkIsaUNBQXlCOzs7OztJQUd6QixxQ0FBMkM7Ozs7O0lBRzNDLHVDQUF3RDs7Ozs7SUFHeEQsb0NBQTBEOzs7OztJQUUxRCwyQ0FhRTs7Ozs7SUFFRiw0Q0FnQkU7O0lBRUYsc0NBQ2dDOzs7OztJQUVwQixpQ0FBZ0M7Ozs7O0lBQ3hDLHVDQUFtQzs7SUFDbkMsZ0NBQXdCOzs7OztJQUN4QixtQ0FBOEIiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBPbkRlc3Ryb3ksIElucHV0LCBPbkNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG9mIGFzIG9ic2VydmFibGVPZiwgUGFydGlhbE9ic2VydmVyLCBTdWJzY3JpcHRpb24sIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRmxhdFRyZWVDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3RyZWUnO1xuaW1wb3J0IHsgTWF0RGlhbG9nIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZGlhbG9nJztcbmltcG9ydCB7IE1hdFRyZWVGbGF0RGF0YVNvdXJjZSwgTWF0VHJlZUZsYXR0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3RyZWUnO1xuaW1wb3J0IHsgTWF0U25hY2tCYXIgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9zbmFjay1iYXInO1xuXG5pbXBvcnQgeyBNZXNzYWdlSGFuZGxlciwgU3RhdHVzQ29kZSwgUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9jb3JlL3B1YmxpYy1hcGknO1xuaW1wb3J0IHsgVm9jYWJ1bGFyeSwgVGVybSwgVGVybU5vZGUgfSBmcm9tICcuLi8uLi9lbnRpdGllcy9wdWJsaWMtYXBpJztcblxuaW1wb3J0IHsgVGF4b25vbXlTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vYmFja2VuZC9wdWJsaWMtYXBpJztcbmltcG9ydCB7IFRlcm1HZW5lcmljQ29tcG9uZW50IH0gZnJvbSAnLi4vdGVybS1nZW5lcmljL3Rlcm0tZ2VuZXJpYy5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBPQXV0aFN0b3JhZ2UgfSBmcm9tICdhbmd1bGFyLW9hdXRoMi1vaWRjJztcblxuLyoqXG4gKiBGbGF0dGVuZWQgdHJlZSBub2RlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZCBmcm9tIGEgVGVybU5vZGUgdGhyb3VnaCB0aGUgZmxhdHRlbmVyLiBGbGF0dGVuZWRcbiAqIG5vZGVzIGluY2x1ZGUgbGV2ZWwgaW5kZXggYW5kIHdoZXRoZXIgdGhleSBjYW4gYmUgZXhwYW5kZWQgb3Igbm90LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZsYXRUcmVlTm9kZSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGxldmVsOiBudW1iZXI7XG4gICAgZXhwYW5kYWJsZTogYm9vbGVhbjtcbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd0b2NvLXRlcm1zJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdGVybXMuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3Rlcm1zLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgVGVybXNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuXG4gICAgbG9hZGluZzogQm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIFRoZSBUcmVlQ29udHJvbCBjb250cm9scyB0aGUgZXhwYW5kL2NvbGxhcHNlIHN0YXRlIG9mIHRyZWUgbm9kZXMuICAqL1xuICAgIHRyZWVDb250cm9sOiBGbGF0VHJlZUNvbnRyb2w8RmxhdFRyZWVOb2RlPjtcblxuICAgIC8qKiBUaGUgVHJlZUZsYXR0ZW5lciBpcyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBmbGF0IGxpc3Qgb2YgaXRlbXMgZnJvbSBoaWVyYXJjaGljYWwgZGF0YS4gKi9cbiAgICB0cmVlRmxhdHRlbmVyOiBNYXRUcmVlRmxhdHRlbmVyPFRlcm1Ob2RlLCBGbGF0VHJlZU5vZGU+O1xuXG4gICAgLyoqIFRoZSBNYXRUcmVlRmxhdERhdGFTb3VyY2UgY29ubmVjdHMgdGhlIGNvbnRyb2wgYW5kIGZsYXR0ZW5lciB0byBwcm92aWRlIGRhdGEuICovXG4gICAgZGF0YVNvdXJjZTogTWF0VHJlZUZsYXREYXRhU291cmNlPFRlcm1Ob2RlLCBGbGF0VHJlZU5vZGU+O1xuXG4gICAgcHJpdmF0ZSB0ZXJtc1RyZWVPYnNlcnZlcjogUGFydGlhbE9ic2VydmVyPFJlc3BvbnNlPGFueT4+ID0ge1xuICAgICAgICBuZXh0OiAocmVzcG9uc2U6IFJlc3BvbnNlPGFueT4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5kYXRhID0gcmVzcG9uc2UuZGF0YS50cmVlLnRlcm1fbm9kZTtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9ICF0aGlzLmxvYWRpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXJyb3I6IChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yOiAnICsgZXJyICsgJy4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvbXBsZXRlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSB0ZXJtQ2hhbmdlT2JzZXJ2ZXI6IFBhcnRpYWxPYnNlcnZlcjxSZXNwb25zZTxhbnk+PiA9IHtcbiAgICAgICAgbmV4dDogKHJlc3BvbnNlOiBSZXNwb25zZTxhbnk+KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSAhdGhpcy5sb2FkaW5nO1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLmdldFRlcm1zVHJlZUJ5Vm9jYWIodGhpcy5jdXJyZW50Vm9jYWIuaWQpLnN1YnNjcmliZSh0aGlzLnRlcm1zVHJlZU9ic2VydmVyKTtcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLmNsb3NlQWxsKCk7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1lc3NhZ2VIYW5kbGVyKHRoaXMuX3NuYWNrQmFyKTtcbiAgICAgICAgICAgIG0uc2hvd01lc3NhZ2UoU3RhdHVzQ29kZS5PSywgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXJyb3I6IChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yOiAnICsgZXJyICsgJy4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvbXBsZXRlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQElucHV0KClcbiAgICBjdXJyZW50Vm9jYWI6IFZvY2FidWxhcnkgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBzZXJ2aWNlOiBUYXhvbm9teVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgb2F1dGhlU3RvcmFnZTogT0F1dGhTdG9yYWdlLFxuICAgICAgICBwdWJsaWMgZGlhbG9nOiBNYXREaWFsb2csXG4gICAgICAgIHByaXZhdGUgX3NuYWNrQmFyOiBNYXRTbmFja0Jhcikge1xuICAgICAgICB0aGlzLnRyZWVGbGF0dGVuZXIgPSBuZXcgTWF0VHJlZUZsYXR0ZW5lcihcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtZXIsXG4gICAgICAgICAgICB0aGlzLmdldExldmVsLFxuICAgICAgICAgICAgdGhpcy5pc0V4cGFuZGFibGUsXG4gICAgICAgICAgICB0aGlzLmdldENoaWxkcmVuKTtcblxuICAgICAgICB0aGlzLnRyZWVDb250cm9sID0gbmV3IEZsYXRUcmVlQ29udHJvbCh0aGlzLmdldExldmVsLCB0aGlzLmlzRXhwYW5kYWJsZSk7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IG5ldyBNYXRUcmVlRmxhdERhdGFTb3VyY2UodGhpcy50cmVlQ29udHJvbCwgdGhpcy50cmVlRmxhdHRlbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICBpZiAoIXRoaXMub2F1dGhlU3RvcmFnZS5nZXRJdGVtKCd1c2VyX3Blcm1pc3Npb24nKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRBdXRoZW50aWNhdGVkVXNlclBlcm1pc3Npb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRWb2NhYiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLmdldFRlcm1zVHJlZUJ5Vm9jYWIodGhpcy5jdXJyZW50Vm9jYWIuaWQpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlOiBSZXNwb25zZTxhbnk+KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YSA9IHJlc3BvbnNlLmRhdGEudHJlZS50ZXJtX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yOiAnICsgZXJyICsgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuXG4gICAgfVxuXG4gICAgLyoqIFRyYW5zZm9ybSB0aGUgZGF0YSB0byBzb21ldGhpbmcgdGhlIHRyZWUgY2FuIHJlYWQuICovXG4gICAgdHJhbnNmb3JtZXIobm9kZTogVGVybU5vZGUsIGxldmVsOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5vZGUudGVybS5pZGVudGlmaWVyLFxuICAgICAgICAgICAgdGVybTogbm9kZS50ZXJtLFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgZXhwYW5kYWJsZTogKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBsZXZlbCBvZiB0aGUgbm9kZSAqL1xuICAgIGdldExldmVsKG5vZGU6IEZsYXRUcmVlTm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5sZXZlbDtcbiAgICB9XG5cbiAgICAvKiogR2V0IHdoZXRoZXIgdGhlIG5vZGUgaXMgZXhwYW5kZWQgb3Igbm90LiAqL1xuICAgIGlzRXhwYW5kYWJsZShub2RlOiBGbGF0VHJlZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZXhwYW5kYWJsZTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHdoZXRoZXIgdGhlIG5vZGUgaGFzIGNoaWxkcmVuIG9yIG5vdC4gKi9cbiAgICBoYXNDaGlsZChpbmRleDogbnVtYmVyLCBub2RlOiBGbGF0VHJlZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZXhwYW5kYWJsZTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBjaGlsZHJlbiBmb3IgdGhlIG5vZGUuICovXG4gICAgZ2V0Q2hpbGRyZW4obm9kZTogVGVybU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVPZihub2RlLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBhZGRUZXJtKCkge1xuICAgICAgICB0aGlzLm9wZW5UZXJtRGlhbG9nKG51bGwpO1xuICAgIH1cbiAgICBlZGl0VGVybShub2RlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5vcGVuVGVybURpYWxvZyhub2RlLnRlcm0pO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBvcGVuVGVybURpYWxvZyh0ZXJtOiBUZXJtKSB7XG5cbiAgICAgICAgY29uc3QgZGlhbG9nUmVmID0gdGhpcy5kaWFsb2cub3BlbihUZXJtR2VuZXJpY0NvbXBvbmVudCwge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHRlcm06IHRlcm0sXG4gICAgICAgICAgICAgICAgdGVybXM6IHRoaXMuZGF0YVNvdXJjZS5kYXRhLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRWb2NhYjogdGhpcy5jdXJyZW50Vm9jYWIsXG4gICAgICAgICAgICAgICAgYWNjZXB0OiAodGVybTogVGVybSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5jbG9zZUFsbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVybS5pc05ldyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2UubmV3VGVybSh0ZXJtKS5waXBlKCkuc3Vic2NyaWJlKHRoaXMudGVybUNoYW5nZU9ic2VydmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZS5lZGl0VGVybSh0ZXJtKS5waXBlKCkuc3Vic2NyaWJlKHRoaXMudGVybUNoYW5nZU9ic2VydmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRpYWxvZ1JlZi5hZnRlckNsb3NlZCgpLnN1YnNjcmliZShyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2RpYWxvZyBjbG9zZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVsZXRlVGVybShub2RlOiBUZXJtTm9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhub2RlKTtcbiAgICB9XG5cbiAgICBnZXRBdXRoZW50aWNhdGVkVXNlclBlcm1pc3Npb25zKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2UuZ2V0Q3VycmVudFVzZXJQZXJtaXNzaW9ucygpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNZXNzYWdlSGFuZGxlcih0aGlzLl9zbmFja0Jhcik7XG4gICAgICAgICAgICAgICAgbS5zaG93TWVzc2FnZShTdGF0dXNDb2RlLnNlcnZlckVycm9yLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgeW91IG11c3Qgc2V0IGEgYmV0dGVyIHJldHVybi5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2YobnVsbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHJlcXVlc3QgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PSAnc3VjY2VzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcm1Kc29uID0gSlNPTi5zdHJpbmdpZnkocmVxdWVzdC5kYXRhLnBlcm1pc3Npb25zLmFjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9hdXRoZVN0b3JhZ2Uuc2V0SXRlbSgndXNlcl9wZXJtaXNzaW9ucycsIHBlcm1Kc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYXNQZXJtaXNzaW9uKHBlcm1pc3Npb246IHN0cmluZywgaWQ/OiBzdHJpbmcpOiBib29sZWFuIHtcblxuICAgICAgICBjb25zdCB1c2VyUGVybWlzc2lvbiA9IEpTT04ucGFyc2UodGhpcy5vYXV0aGVTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfcGVybWlzc2lvbnMnKSk7XG4gICAgICAgIGlmICghdXNlclBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJQZXJtaXNzaW9uLnRheG9ub215X2Z1bGxfZWRpdG9yX2FjdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBjYXNlICdlZGl0JzpcbiAgICAgICAgICAgICAgICBpZiAodXNlclBlcm1pc3Npb24udGF4b25vbXlfZnVsbF9lZGl0b3JfYWN0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlclBlcm1pc3Npb24udm9jYWJ1bGFyeV9lZGl0b3JfYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnI6IEFycmF5PHN0cmluZz4gPSB1c2VyUGVybWlzc2lvbi52b2NhYnVsYXJ5X2VkaXRvcl9hY3Rpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnIuaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXNlclBlcm1pc3Npb24udGF4b25vbXlfZnVsbF9lZGl0b3JfYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19