/**
 * @fileoverview added by tsickle
 * Generated from: lib/filters/tree-filter/tree-filter.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *   Copyright (c) 2020 Universidad de Pinar del Río "Hermanos Saíz Montes de Oca"
 *   All rights reserved.
 */
import { Component, Input } from '@angular/core';
import { FiltersService } from '../filters.service';
import { FilterContainerService } from '../filter-container.service';
import { FlatTreeControl } from '@angular/cdk/tree';
import { MatTreeFlattener, MatTreeFlatDataSource } from '@angular/material';
import { of } from 'rxjs';
import { SelectionModel } from '@angular/cdk/collections';
import { FormControl } from '@angular/forms';
/**
 * @record
 */
export function FlatTreeNodeFilter() { }
if (false) {
    /** @type {?} */
    FlatTreeNodeFilter.prototype.name;
    /** @type {?} */
    FlatTreeNodeFilter.prototype.level;
    /** @type {?} */
    FlatTreeNodeFilter.prototype.expandable;
    /** @type {?} */
    FlatTreeNodeFilter.prototype.term;
}
/**
 * @record
 */
function TreeFilterData() { }
if (false) {
    /** @type {?} */
    TreeFilterData.prototype.selectOptions;
    /** @type {?} */
    TreeFilterData.prototype.type;
    /** @type {?} */
    TreeFilterData.prototype.placeholder;
    /** @type {?} */
    TreeFilterData.prototype.text;
    /** @type {?} */
    TreeFilterData.prototype.field;
    /** @type {?} */
    TreeFilterData.prototype.index;
    /** @type {?} */
    TreeFilterData.prototype.value;
    /** @type {?} */
    TreeFilterData.prototype.idVocab;
}
export class TreeFilterComponent {
    /**
     * @param {?} filterService
     * @param {?} filterContainerService
     */
    constructor(filterService, filterContainerService) {
        this.filterService = filterService;
        this.filterContainerService = filterContainerService;
        this.checklistSelection = new SelectionModel(true /* multiple */);
        this.myControl = new FormControl();
        this.treeFlattener = new MatTreeFlattener(this.transformer, this.getLevel, this.isExpandable, this.getChildren);
        this.treeControl = new FlatTreeControl(this.getLevel, this.isExpandable);
        this.dataSource = new MatTreeFlatDataSource(this.treeControl, this.treeFlattener);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.data.value = '';
        this.dataSource.data = this.data.selectOptions;
        this.myControl.valueChanges.subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => {
            this._filter(value);
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => { }), (/**
         * @return {?}
         */
        () => {
        }));
        this.inputId = this.data.placeholder.trim().toLowerCase();
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    _filter(value) {
        /** @type {?} */
        const filterValue = value.toLowerCase();
        console.log(filterValue);
        /** @type {?} */
        const newData = this.data.selectOptions.filter((/**
         * @param {?} node
         * @return {?}
         */
        node => this._include_node(filterValue, node)));
        this.dataSource.data = newData;
        this._fix_selection();
    }
    /**
     * return true if any children is include, false otherwise
     * @private
     * @param {?} filter
     * @param {?} node
     * @return {?}
     */
    _include_node(filter, node) {
        if (node.term.identifier.toLowerCase().includes(filter)) {
            return true;
        }
        else if (node.children) {
            for (const child of node.children) {
                if (this._include_node(filter, child)) {
                    return true;
                }
            }
        }
        else {
            return false;
        }
        return false;
    }
    /**
     * @private
     * @return {?}
     */
    _fix_selection() {
        for (const node of this.treeControl.dataNodes) {
            console.log(node);
        }
        // if (this.checklistSelection.selected) {
        //   const old = this.checklistSelection.selected.find(
        //     (value: FlatTreeNode, index: number, obj: FlatTreeNode[]) => value.term.id === node.term.id
        //   );
        //   if (old !== undefined) {
        //     this.checklistSelection.deselect(old);
        //     this.checklistSelection.select(result);
        //   }
        // }
    }
    /**
     * @return {?}
     */
    remove_component() {
        this.filterService.deleteParameter(this.data.field);
        this.filterContainerService.filterDeleted(this.data.index);
    }
    /**
     * @return {?}
     */
    onChange() {
        this.filterService.changeFilter(this.data.field, this.data.value);
    }
    /**
     * @return {?}
     */
    emitSelection() {
        console.log(this.checklistSelection.selected);
        /** @type {?} */
        var valueEmiter = 'OR';
        this.checklistSelection.selected.forEach((/**
         * @param {?} node
         * @return {?}
         */
        node => {
            valueEmiter = valueEmiter + ',' + node.term.id;
        }));
        this.filterService.changeAutocompleteFilter(this.data.idVocab.toString(10), valueEmiter);
    }
    /**
     * Transform the data to something the tree can read.
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    transformer(node, level) {
        /** @type {?} */
        const result = {
            name: node.term.identifier,
            level: level,
            expandable: (node.children.length > 0),
            term: node.term,
        };
        return result;
    }
    /**
     * Get the level of the node
     * @param {?} node
     * @return {?}
     */
    getLevel(node) {
        return node.level;
    }
    /**
     * Get whether the node is expanded or not.
     * @param {?} node
     * @return {?}
     */
    isExpandable(node) {
        return node.expandable;
    }
    /**
     * Get whether the node has children or not.
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    hasChild(index, node) {
        return node.expandable;
    }
    /**
     * Get the children for the node.
     * @param {?} node
     * @return {?}
     */
    getChildren(node) {
        return of(node.children);
    }
    /**
     * Whether all the descendants of the node are selected.
     * @param {?} node
     * @return {?}
     */
    descendantsAllSelected(node) {
        /** @type {?} */
        const descendants = this.treeControl.getDescendants(node);
        /** @type {?} */
        const descAllSelected = descendants.every((/**
         * @param {?} child
         * @return {?}
         */
        child => this.checklistSelection.isSelected(child)));
        return descAllSelected;
    }
    /**
     * Whether part of the descendants are selected
     * @param {?} node
     * @return {?}
     */
    descendantsPartiallySelected(node) {
        /** @type {?} */
        const descendants = this.treeControl.getDescendants(node);
        /** @type {?} */
        const result = descendants.some((/**
         * @param {?} child
         * @return {?}
         */
        child => this.checklistSelection.isSelected(child)));
        return result && !this.descendantsAllSelected(node);
    }
    /**
     * Select/deselect all the descendants node
     * @param {?} node
     * @return {?}
     */
    itemSelectionToggle(node) {
        this.checklistSelection.toggle(node);
        /** @type {?} */
        const descendants = this.treeControl.getDescendants(node);
        this.checklistSelection.isSelected(node)
            ? this.checklistSelection.select(...descendants)
            : this.checklistSelection.deselect(...descendants);
        // Force update for the parent
        descendants.every((/**
         * @param {?} child
         * @return {?}
         */
        child => this.checklistSelection.isSelected(child)));
        this.checkAllParentsSelection(node);
        this.emitSelection();
    }
    /**
     * Check all the parents to see if they changed
     * @param {?} node
     * @return {?}
     */
    leafItemSelectionToggle(node) {
        this.checklistSelection.toggle(node);
        this.checkAllParentsSelection(node);
        this.emitSelection();
    }
    /* Checks all the parents when a leaf node is selected/unselected */
    /**
     * @param {?} node
     * @return {?}
     */
    checkAllParentsSelection(node) {
        /** @type {?} */
        let parent = this.getParentNode(node);
        while (parent) {
            this.checkRootNodeSelection(parent);
            parent = this.getParentNode(parent);
        }
    }
    /**
     * Check root node checked state and change it accordingly
     * @param {?} node
     * @return {?}
     */
    checkRootNodeSelection(node) {
        /** @type {?} */
        const nodeSelected = this.checklistSelection.isSelected(node);
        /** @type {?} */
        const descendants = this.treeControl.getDescendants(node);
        /** @type {?} */
        const descAllSelected = descendants.every((/**
         * @param {?} child
         * @return {?}
         */
        child => this.checklistSelection.isSelected(child)));
        if (nodeSelected && !descAllSelected) {
            this.checklistSelection.deselect(node);
        }
        else if (!nodeSelected && descAllSelected) {
            this.checklistSelection.select(node);
        }
    }
    /* Get the parent node of a node */
    /**
     * @param {?} node
     * @return {?}
     */
    getParentNode(node) {
        /** @type {?} */
        const currentLevel = this.getLevel(node);
        if (currentLevel < 1) {
            return null;
        }
        /** @type {?} */
        const startIndex = this.treeControl.dataNodes.indexOf(node) - 1;
        for (let i = startIndex; i >= 0; i--) {
            /** @type {?} */
            const currentNode = this.treeControl.dataNodes[i];
            if (this.getLevel(currentNode) < currentLevel) {
                return currentNode;
            }
        }
        return null;
    }
    /**
     * @param {?} i
     * @return {?}
     */
    removeChip(i) {
        console.log(i);
    }
}
TreeFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'toco-tree-filter',
                template: "<div class=\"card-filter\">\n  <input\n    type=\"text\"\n    placeholder=\"{{ data.placeholder }}\"\n    aria-label=\"Number\"\n    matInput\n    [formControl]=\"myControl\"\n    id=\"{{ inputId }}\"\n  />\n\n  <mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" class=\"padd\">\n    <mat-tree-node\n      class=\"hover\"\n      *matTreeNodeDef=\"let node\"\n      matTreeNodeToggle\n      matTreeNodePadding\n      fxLayout=\"row\"\n      fxLayoutAlign=\"space-between center\"\n    >\n      <div fxLayout=\"row\" fxLayoutAlign=\"start center\">\n        <button mat-icon-button disabled></button>\n        <mat-checkbox\n          class=\"checklist-leaf-node\"\n          [checked]=\"checklistSelection.isSelected(node)\"\n          (change)=\"leafItemSelectionToggle(node)\"\n          matTooltip=\"{{ node.name }}\"\n          >{{ node.name }}</mat-checkbox\n        >\n      </div>\n    </mat-tree-node>\n\n    <mat-tree-node\n      class=\"hover\"\n      *matTreeNodeDef=\"let node; when: hasChild\"\n      matTreeNodePadding\n    >\n      <button\n        mat-icon-button\n        matTreeNodeToggle\n        [attr.aria-label]=\"'toggle ' + node.name\"\n      >\n        <mat-icon class=\"mat-icon-rtl-mirror\">\n          {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n        </mat-icon>\n      </button>\n      <div\n        class=\"item-width\"\n        fxLayout=\"row\"\n        fxLayoutAlign=\"space-between center\"\n      >\n        <mat-checkbox\n          [checked]=\"descendantsAllSelected(node)\"\n          [indeterminate]=\"descendantsPartiallySelected(node)\"\n          (change)=\"itemSelectionToggle(node)\"\n          matTooltip=\"{{ node.name }}\"\n          >{{ node.name }}</mat-checkbox\n        >\n      </div>\n    </mat-tree-node>\n  </mat-tree>\n\n  <button\n    mat-icon-button\n    color=\"accent\"\n    class=\"delete-filter\"\n    (click)=\"remove_component()\"\n  >\n    <mat-icon>close</mat-icon>\n  </button>\n\n  <mat-chip-list\n    fxLayout=\"row\"\n    fxLayoutAlign=\"start center\"\n    style=\"margin-bottom: .5em\"\n    id=\"chiplist\"\n  >\n    <mat-chip\n      *ngFor=\"let item of chipsList; let i = index\"\n      (click)=\"removeChip(i)\"\n      >{{ item.name }}</mat-chip\n    >\n  </mat-chip-list>\n</div>\n",
                styles: [".card-filter{border:2px solid #e4e4e4;border-radius:5px;padding:5px .5em 0;position:relative;box-shadow:2px 3px 10px RGB(0,0,0,.053);width:15em;margin:.4em 0}.delete-filter{position:absolute;top:-1.9em;right:-1.4em;width:2em;height:2em}.delete-filter mat-icon{font-size:medium}"]
            }] }
];
/** @nocollapse */
TreeFilterComponent.ctorParameters = () => [
    { type: FiltersService },
    { type: FilterContainerService }
];
TreeFilterComponent.propDecorators = {
    data: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TreeFilterComponent.prototype.data;
    /** @type {?} */
    TreeFilterComponent.prototype.chipsList;
    /** @type {?} */
    TreeFilterComponent.prototype.treeControl;
    /** @type {?} */
    TreeFilterComponent.prototype.treeFlattener;
    /** @type {?} */
    TreeFilterComponent.prototype.dataSource;
    /** @type {?} */
    TreeFilterComponent.prototype.checklistSelection;
    /** @type {?} */
    TreeFilterComponent.prototype.myControl;
    /** @type {?} */
    TreeFilterComponent.prototype.inputId;
    /**
     * @type {?}
     * @private
     */
    TreeFilterComponent.prototype.filterService;
    /**
     * @type {?}
     * @private
     */
    TreeFilterComponent.prototype.filterContainerService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1maWx0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vdG9jby1saWIvIiwic291cmNlcyI6WyJsaWIvZmlsdGVycy90cmVlLWZpbHRlci90cmVlLWZpbHRlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBTUEsT0FBTyxFQUFFLFNBQVMsRUFBVSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHekQsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRXJFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM1RSxPQUFPLEVBQUUsRUFBRSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxjQUFjLEVBQW9CLE1BQU0sMEJBQTBCLENBQUM7QUFDNUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7O0FBRzdDLHdDQUtDOzs7SUFKQyxrQ0FBYTs7SUFDYixtQ0FBYzs7SUFDZCx3Q0FBb0I7O0lBQ3BCLGtDQUFXOzs7OztBQUViLDZCQVNDOzs7SUFSQyx1Q0FBMEI7O0lBQzFCLDhCQUFhOztJQUNiLHFDQUFvQjs7SUFDcEIsOEJBQWE7O0lBQ2IsK0JBQWM7O0lBQ2QsK0JBQWM7O0lBQ2QsK0JBQVc7O0lBQ1gsaUNBQWdCOztBQVFsQixNQUFNLE9BQU8sbUJBQW1COzs7OztJQWM5QixZQUNVLGFBQTZCLEVBQzdCLHNCQUE4QztRQUQ5QyxrQkFBYSxHQUFiLGFBQWEsQ0FBZ0I7UUFDN0IsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUF3QjtRQVJ4RCx1QkFBa0IsR0FBRyxJQUFJLGNBQWMsQ0FBcUIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FB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QUNqRCw0Q0FBOEQ7O0lBQzlELHlDQUFnRTs7SUFDaEUsaURBQWlGOztJQUVqRix3Q0FBOEI7O0lBRTlCLHNDQUFnQjs7Ozs7SUFHZCw0Q0FBcUM7Ozs7O0lBQ3JDLHFEQUFzRCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgIENvcHlyaWdodCAoYykgMjAyMCBVbml2ZXJzaWRhZCBkZSBQaW5hciBkZWwgUsOtbyBcIkhlcm1hbm9zIFNhw616IE1vbnRlcyBkZSBPY2FcIlxuICogICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEZpbHRlckNvbXBvbmVudCB9IGZyb20gJy4uL2ZpbHRlci5jb21wb25lbnQnO1xuaW1wb3J0IHsgRmlsdGVyc1NlcnZpY2UgfSBmcm9tICcuLi9maWx0ZXJzLnNlcnZpY2UnO1xuaW1wb3J0IHsgRmlsdGVyQ29udGFpbmVyU2VydmljZSB9IGZyb20gJy4uL2ZpbHRlci1jb250YWluZXIuc2VydmljZSc7XG5pbXBvcnQgeyBUZXJtTm9kZSwgVGVybSB9IGZyb20gJy4uLy4uL2VudGl0aWVzL3B1YmxpYy1hcGknO1xuaW1wb3J0IHsgRmxhdFRyZWVDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3RyZWUnO1xuaW1wb3J0IHsgTWF0VHJlZUZsYXR0ZW5lciwgTWF0VHJlZUZsYXREYXRhU291cmNlIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgb2YsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFNlbGVjdGlvbk1vZGVsLCBDb2xsZWN0aW9uVmlld2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2NvbGxlY3Rpb25zJztcbmltcG9ydCB7IEZvcm1Db250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgc3RhcnRXaXRoLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmxhdFRyZWVOb2RlRmlsdGVyIHtcbiAgbmFtZTogc3RyaW5nO1xuICBsZXZlbDogbnVtYmVyO1xuICBleHBhbmRhYmxlOiBib29sZWFuO1xuICB0ZXJtOiBUZXJtO1xufVxuaW50ZXJmYWNlIFRyZWVGaWx0ZXJEYXRhIHtcbiAgc2VsZWN0T3B0aW9uczogVGVybU5vZGVbXTtcbiAgdHlwZTogc3RyaW5nO1xuICBwbGFjZWhvbGRlcjogc3RyaW5nO1xuICB0ZXh0OiBzdHJpbmc7XG4gIGZpZWxkOiBzdHJpbmc7XG4gIGluZGV4OiBudW1iZXI7XG4gIHZhbHVlOiBhbnk7XG4gIGlkVm9jYWI6IG51bWJlcjtcbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAndG9jby10cmVlLWZpbHRlcicsXG4gIHRlbXBsYXRlVXJsOiAnLi90cmVlLWZpbHRlci5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlVXJsczogWycuL3RyZWUtZmlsdGVyLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgVHJlZUZpbHRlckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgRmlsdGVyQ29tcG9uZW50IHtcbiAgQElucHV0KCkgZGF0YTogVHJlZUZpbHRlckRhdGE7XG5cbiAgY2hpcHNMaXN0OiBbXTtcblxuICB0cmVlQ29udHJvbDogRmxhdFRyZWVDb250cm9sPEZsYXRUcmVlTm9kZUZpbHRlcj47XG4gIHRyZWVGbGF0dGVuZXI6IE1hdFRyZWVGbGF0dGVuZXI8VGVybU5vZGUsIEZsYXRUcmVlTm9kZUZpbHRlcj47XG4gIGRhdGFTb3VyY2U6IE1hdFRyZWVGbGF0RGF0YVNvdXJjZTxUZXJtTm9kZSwgRmxhdFRyZWVOb2RlRmlsdGVyPjtcbiAgY2hlY2tsaXN0U2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbk1vZGVsPEZsYXRUcmVlTm9kZUZpbHRlcj4odHJ1ZSAvKiBtdWx0aXBsZSAqLyk7XG5cbiAgbXlDb250cm9sID0gbmV3IEZvcm1Db250cm9sKCk7XG5cbiAgaW5wdXRJZDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgZmlsdGVyU2VydmljZTogRmlsdGVyc1NlcnZpY2UsXG4gICAgcHJpdmF0ZSBmaWx0ZXJDb250YWluZXJTZXJ2aWNlOiBGaWx0ZXJDb250YWluZXJTZXJ2aWNlKSB7XG4gICAgdGhpcy50cmVlRmxhdHRlbmVyID0gbmV3IE1hdFRyZWVGbGF0dGVuZXIoXG4gICAgICB0aGlzLnRyYW5zZm9ybWVyLFxuICAgICAgdGhpcy5nZXRMZXZlbCxcbiAgICAgIHRoaXMuaXNFeHBhbmRhYmxlLFxuICAgICAgdGhpcy5nZXRDaGlsZHJlbik7XG5cbiAgICB0aGlzLnRyZWVDb250cm9sID0gbmV3IEZsYXRUcmVlQ29udHJvbCh0aGlzLmdldExldmVsLCB0aGlzLmlzRXhwYW5kYWJsZSk7XG4gICAgdGhpcy5kYXRhU291cmNlID0gbmV3IE1hdFRyZWVGbGF0RGF0YVNvdXJjZSh0aGlzLnRyZWVDb250cm9sLCB0aGlzLnRyZWVGbGF0dGVuZXIpO1xuICB9XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgdGhpcy5kYXRhLnZhbHVlID0gJyc7XG4gICAgdGhpcy5kYXRhU291cmNlLmRhdGEgPSB0aGlzLmRhdGEuc2VsZWN0T3B0aW9ucztcbiAgICB0aGlzLm15Q29udHJvbC52YWx1ZUNoYW5nZXMuc3Vic2NyaWJlKFxuICAgICAgKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgdGhpcy5fZmlsdGVyKHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICAoZXJyb3I6IGFueSkgPT4geyB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5pbnB1dElkID0gdGhpcy5kYXRhLnBsYWNlaG9sZGVyLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfZmlsdGVyKHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBjb25zdCBmaWx0ZXJWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc29sZS5sb2coZmlsdGVyVmFsdWUpO1xuXG4gICAgY29uc3QgbmV3RGF0YSA9IHRoaXMuZGF0YS5zZWxlY3RPcHRpb25zLmZpbHRlcihub2RlID0+IHRoaXMuX2luY2x1ZGVfbm9kZShmaWx0ZXJWYWx1ZSwgbm9kZSkpO1xuXG4gICAgdGhpcy5kYXRhU291cmNlLmRhdGEgPSBuZXdEYXRhO1xuICAgIHRoaXMuX2ZpeF9zZWxlY3Rpb24oKTtcbiAgfVxuICAvKiogcmV0dXJuIHRydWUgaWYgYW55IGNoaWxkcmVuIGlzIGluY2x1ZGUsIGZhbHNlIG90aGVyd2lzZSAqL1xuICBwcml2YXRlIF9pbmNsdWRlX25vZGUoZmlsdGVyOiBzdHJpbmcsIG5vZGU6IFRlcm1Ob2RlKTogYm9vbGVhbiB7XG4gICAgaWYgKG5vZGUudGVybS5pZGVudGlmaWVyLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmlsdGVyKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX2luY2x1ZGVfbm9kZShmaWx0ZXIsIGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcHJpdmF0ZSBfZml4X3NlbGVjdGlvbigpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy50cmVlQ29udHJvbC5kYXRhTm9kZXMpIHtcbiAgICAgIGNvbnNvbGUubG9nKG5vZGUpO1xuICAgIH1cblxuICAgIC8vIGlmICh0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5zZWxlY3RlZCkge1xuICAgIC8vICAgY29uc3Qgb2xkID0gdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uc2VsZWN0ZWQuZmluZChcbiAgICAvLyAgICAgKHZhbHVlOiBGbGF0VHJlZU5vZGUsIGluZGV4OiBudW1iZXIsIG9iajogRmxhdFRyZWVOb2RlW10pID0+IHZhbHVlLnRlcm0uaWQgPT09IG5vZGUudGVybS5pZFxuICAgIC8vICAgKTtcbiAgICAvLyAgIGlmIChvbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgICB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5kZXNlbGVjdChvbGQpO1xuICAgIC8vICAgICB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5zZWxlY3QocmVzdWx0KTtcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gIH1cbiAgcmVtb3ZlX2NvbXBvbmVudCgpIHtcbiAgICB0aGlzLmZpbHRlclNlcnZpY2UuZGVsZXRlUGFyYW1ldGVyKHRoaXMuZGF0YS5maWVsZCk7XG4gICAgdGhpcy5maWx0ZXJDb250YWluZXJTZXJ2aWNlLmZpbHRlckRlbGV0ZWQodGhpcy5kYXRhLmluZGV4KTtcblxuICB9XG4gIG9uQ2hhbmdlKCkge1xuICAgIHRoaXMuZmlsdGVyU2VydmljZS5jaGFuZ2VGaWx0ZXIodGhpcy5kYXRhLmZpZWxkLCB0aGlzLmRhdGEudmFsdWUpO1xuICB9XG5cbiAgZW1pdFNlbGVjdGlvbigpIHtcbiAgICBjb25zb2xlLmxvZyh0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5zZWxlY3RlZCk7XG4gICAgdmFyIHZhbHVlRW1pdGVyID0gJ09SJztcbiAgICB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5zZWxlY3RlZC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgdmFsdWVFbWl0ZXIgPSB2YWx1ZUVtaXRlciArICcsJyArIG5vZGUudGVybS5pZDtcbiAgICB9KTtcbiAgICB0aGlzLmZpbHRlclNlcnZpY2UuY2hhbmdlQXV0b2NvbXBsZXRlRmlsdGVyKHRoaXMuZGF0YS5pZFZvY2FiLnRvU3RyaW5nKDEwKSwgdmFsdWVFbWl0ZXIpO1xuICB9XG5cblxuICAvKiogVHJhbnNmb3JtIHRoZSBkYXRhIHRvIHNvbWV0aGluZyB0aGUgdHJlZSBjYW4gcmVhZC4gKi9cbiAgdHJhbnNmb3JtZXIobm9kZTogVGVybU5vZGUsIGxldmVsOiBudW1iZXIpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBuYW1lOiBub2RlLnRlcm0uaWRlbnRpZmllcixcbiAgICAgIGxldmVsOiBsZXZlbCxcbiAgICAgIGV4cGFuZGFibGU6IChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApLFxuICAgICAgdGVybTogbm9kZS50ZXJtLFxuICAgIH07XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKiBHZXQgdGhlIGxldmVsIG9mIHRoZSBub2RlICovXG4gIGdldExldmVsKG5vZGU6IEZsYXRUcmVlTm9kZUZpbHRlcikge1xuICAgIHJldHVybiBub2RlLmxldmVsO1xuICB9XG5cbiAgLyoqIEdldCB3aGV0aGVyIHRoZSBub2RlIGlzIGV4cGFuZGVkIG9yIG5vdC4gKi9cbiAgaXNFeHBhbmRhYmxlKG5vZGU6IEZsYXRUcmVlTm9kZUZpbHRlcikge1xuICAgIHJldHVybiBub2RlLmV4cGFuZGFibGU7XG4gIH1cblxuICAvKiogR2V0IHdoZXRoZXIgdGhlIG5vZGUgaGFzIGNoaWxkcmVuIG9yIG5vdC4gKi9cbiAgaGFzQ2hpbGQoaW5kZXg6IG51bWJlciwgbm9kZTogRmxhdFRyZWVOb2RlRmlsdGVyKSB7XG4gICAgcmV0dXJuIG5vZGUuZXhwYW5kYWJsZTtcbiAgfVxuXG4gIC8qKiBHZXQgdGhlIGNoaWxkcmVuIGZvciB0aGUgbm9kZS4gKi9cbiAgZ2V0Q2hpbGRyZW4obm9kZTogVGVybU5vZGUpIHtcbiAgICByZXR1cm4gb2Yobm9kZS5jaGlsZHJlbik7XG4gIH1cblxuICAvKiogV2hldGhlciBhbGwgdGhlIGRlc2NlbmRhbnRzIG9mIHRoZSBub2RlIGFyZSBzZWxlY3RlZC4gKi9cbiAgZGVzY2VuZGFudHNBbGxTZWxlY3RlZChub2RlOiBGbGF0VHJlZU5vZGVGaWx0ZXIpOiBib29sZWFuIHtcbiAgICBjb25zdCBkZXNjZW5kYW50cyA9IHRoaXMudHJlZUNvbnRyb2wuZ2V0RGVzY2VuZGFudHMobm9kZSk7XG4gICAgY29uc3QgZGVzY0FsbFNlbGVjdGVkID0gZGVzY2VuZGFudHMuZXZlcnkoY2hpbGQgPT5cbiAgICAgIHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQoY2hpbGQpXG4gICAgKTtcbiAgICByZXR1cm4gZGVzY0FsbFNlbGVjdGVkO1xuICB9XG5cbiAgLyoqIFdoZXRoZXIgcGFydCBvZiB0aGUgZGVzY2VuZGFudHMgYXJlIHNlbGVjdGVkICovXG4gIGRlc2NlbmRhbnRzUGFydGlhbGx5U2VsZWN0ZWQobm9kZTogRmxhdFRyZWVOb2RlRmlsdGVyKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZGVzY2VuZGFudHMgPSB0aGlzLnRyZWVDb250cm9sLmdldERlc2NlbmRhbnRzKG5vZGUpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlc2NlbmRhbnRzLnNvbWUoY2hpbGQgPT4gdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChjaGlsZCkpO1xuICAgIHJldHVybiByZXN1bHQgJiYgIXRoaXMuZGVzY2VuZGFudHNBbGxTZWxlY3RlZChub2RlKTtcbiAgfVxuXG4gIC8qKiBTZWxlY3QvZGVzZWxlY3QgYWxsIHRoZSBkZXNjZW5kYW50cyBub2RlICovXG4gIGl0ZW1TZWxlY3Rpb25Ub2dnbGUobm9kZTogRmxhdFRyZWVOb2RlRmlsdGVyKTogdm9pZCB7XG4gICAgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24udG9nZ2xlKG5vZGUpO1xuICAgIGNvbnN0IGRlc2NlbmRhbnRzID0gdGhpcy50cmVlQ29udHJvbC5nZXREZXNjZW5kYW50cyhub2RlKTtcbiAgICB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5pc1NlbGVjdGVkKG5vZGUpXG4gICAgICA/IHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLnNlbGVjdCguLi5kZXNjZW5kYW50cylcbiAgICAgIDogdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uZGVzZWxlY3QoLi4uZGVzY2VuZGFudHMpO1xuXG4gICAgLy8gRm9yY2UgdXBkYXRlIGZvciB0aGUgcGFyZW50XG4gICAgZGVzY2VuZGFudHMuZXZlcnkoY2hpbGQgPT5cbiAgICAgIHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLmlzU2VsZWN0ZWQoY2hpbGQpXG4gICAgKTtcbiAgICB0aGlzLmNoZWNrQWxsUGFyZW50c1NlbGVjdGlvbihub2RlKTtcbiAgICB0aGlzLmVtaXRTZWxlY3Rpb24oKTtcblxuICB9XG5cbiAgLyoqIENoZWNrIGFsbCB0aGUgcGFyZW50cyB0byBzZWUgaWYgdGhleSBjaGFuZ2VkICovXG4gIGxlYWZJdGVtU2VsZWN0aW9uVG9nZ2xlKG5vZGU6IEZsYXRUcmVlTm9kZUZpbHRlcik6IHZvaWQge1xuICAgIHRoaXMuY2hlY2tsaXN0U2VsZWN0aW9uLnRvZ2dsZShub2RlKTtcbiAgICB0aGlzLmNoZWNrQWxsUGFyZW50c1NlbGVjdGlvbihub2RlKTtcbiAgICB0aGlzLmVtaXRTZWxlY3Rpb24oKTtcbiAgfVxuXG4gIC8qIENoZWNrcyBhbGwgdGhlIHBhcmVudHMgd2hlbiBhIGxlYWYgbm9kZSBpcyBzZWxlY3RlZC91bnNlbGVjdGVkICovXG4gIGNoZWNrQWxsUGFyZW50c1NlbGVjdGlvbihub2RlOiBGbGF0VHJlZU5vZGVGaWx0ZXIpOiB2b2lkIHtcbiAgICBsZXQgcGFyZW50OiBGbGF0VHJlZU5vZGVGaWx0ZXIgfCBudWxsID0gdGhpcy5nZXRQYXJlbnROb2RlKG5vZGUpO1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIHRoaXMuY2hlY2tSb290Tm9kZVNlbGVjdGlvbihwYXJlbnQpO1xuICAgICAgcGFyZW50ID0gdGhpcy5nZXRQYXJlbnROb2RlKHBhcmVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIENoZWNrIHJvb3Qgbm9kZSBjaGVja2VkIHN0YXRlIGFuZCBjaGFuZ2UgaXQgYWNjb3JkaW5nbHkgKi9cbiAgY2hlY2tSb290Tm9kZVNlbGVjdGlvbihub2RlOiBGbGF0VHJlZU5vZGVGaWx0ZXIpOiB2b2lkIHtcbiAgICBjb25zdCBub2RlU2VsZWN0ZWQgPSB0aGlzLmNoZWNrbGlzdFNlbGVjdGlvbi5pc1NlbGVjdGVkKG5vZGUpO1xuICAgIGNvbnN0IGRlc2NlbmRhbnRzID0gdGhpcy50cmVlQ29udHJvbC5nZXREZXNjZW5kYW50cyhub2RlKTtcbiAgICBjb25zdCBkZXNjQWxsU2VsZWN0ZWQgPSBkZXNjZW5kYW50cy5ldmVyeShjaGlsZCA9PlxuICAgICAgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uaXNTZWxlY3RlZChjaGlsZClcbiAgICApO1xuICAgIGlmIChub2RlU2VsZWN0ZWQgJiYgIWRlc2NBbGxTZWxlY3RlZCkge1xuICAgICAgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uZGVzZWxlY3Qobm9kZSk7XG4gICAgfSBlbHNlIGlmICghbm9kZVNlbGVjdGVkICYmIGRlc2NBbGxTZWxlY3RlZCkge1xuICAgICAgdGhpcy5jaGVja2xpc3RTZWxlY3Rpb24uc2VsZWN0KG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8qIEdldCB0aGUgcGFyZW50IG5vZGUgb2YgYSBub2RlICovXG4gIGdldFBhcmVudE5vZGUobm9kZTogRmxhdFRyZWVOb2RlRmlsdGVyKTogRmxhdFRyZWVOb2RlRmlsdGVyIHwgbnVsbCB7XG4gICAgY29uc3QgY3VycmVudExldmVsID0gdGhpcy5nZXRMZXZlbChub2RlKTtcblxuICAgIGlmIChjdXJyZW50TGV2ZWwgPCAxKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEluZGV4ID0gdGhpcy50cmVlQ29udHJvbC5kYXRhTm9kZXMuaW5kZXhPZihub2RlKSAtIDE7XG5cbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gdGhpcy50cmVlQ29udHJvbC5kYXRhTm9kZXNbaV07XG5cbiAgICAgIGlmICh0aGlzLmdldExldmVsKGN1cnJlbnROb2RlKSA8IGN1cnJlbnRMZXZlbCkge1xuICAgICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJlbW92ZUNoaXAoaSl7XG4gICAgY29uc29sZS5sb2coaSk7XG4gIH1cbn1cbiJdfQ==