/**
 * @fileoverview added by tsickle
 * Generated from: lib/core/services/http.interceptor.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { HttpResponse } from '@angular/common/http';
import { of } from 'rxjs';
import { tap } from 'rxjs/operators';
import { REFRESH_X_CACHE, Cachable, RequestCache } from './request-cache.service';
import * as i0 from "@angular/core";
import * as i1 from "./request-cache.service";
/* Note: When you are going to use the Interceptors, make a "Barrel" of Http Interceptors.
 * Angular applies interceptors in the order that you provide them. If you provide interceptors A,
 * then B, then C, requests will flow in A->B->C and responses will flow out C->B->A.
 * You cannot change the order or remove interceptors later. If you need to enable and disable
 * an interceptor dynamically, you'll have to build that capability into the interceptor itself. */
/**
 * A service that caches certain requests and responses to improve performance.
 * It is delegated to an interceptor without disturbing the existing data services.
 *
 * - If request is cachable (e.g., package search) and response is in cache,
 * then returns the cached response as observable.
 * - If request is cachable and has `REFRESH_X_CACHE` option header in true (or the request is not in cache),
 * then passes request to the following `HttpHandler` and makes a cache from response.
 * - If request is not cachable,
 * then passes request to the following `HttpHandler`.
 */
export class CachingInterceptor {
    /**
     * @param {?} _cachable
     * @param {?} _cache
     */
    constructor(_cachable, _cache) {
        this._cachable = _cachable;
        this._cache = _cache;
    }
    /**
     * Identifies and handles a given HTTP request.
     * @param {?} req The outgoing request object to handle.
     * @param {?} next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
     * @return {?} An observable of the event stream.
     */
    intercept(req, next) {
        /** @type {?} */
        let maxAgeInCache;
        /* Continues if not cachable. */
        if (!(maxAgeInCache = this._cachable.isCachable(req))) {
            return next.handle(req);
        }
        /* This option is triggered by the presence of a custom `REFRESH_X_CACHE` header with true value. */
        if (req.headers.get(REFRESH_X_CACHE)) {
            /* fetch. */
            return this._sendRequest(req, maxAgeInCache, true, next);
        }
        /* cache-or-fetch. */
        /** @type {?} */
        const cachedResponse = this._cache.get(req);
        return (cachedResponse
            ? of(cachedResponse)
            : this._sendRequest(req, maxAgeInCache, false, next));
    }
    /**
     * Gets server response observable by sending request to `next` argument.
     * It will add the response to the cache on the way out.
     * @private
     * @param {?} req The outgoing request object to handle.
     * @param {?} maxAgeInCache The maximum cache age in milliseconds.
     * @param {?} hasRefreshXCache It is true if the custom `REFRESH_X_CACHE` header is present; otherwise, false.
     * @param {?} next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
     * @return {?} An observable of the event stream.
     */
    _sendRequest(req, maxAgeInCache, hasRefreshXCache, next) {
        /* Removes the `REFRESH_X_CACHE` custom option from header. */
        /** @type {?} */
        let reqWithoutCustomHeader = (hasRefreshXCache)
            ? req.clone({ headers: (req.headers.delete(REFRESH_X_CACHE)) })
            : req;
        console.log('Req-2: ', reqWithoutCustomHeader.headers);
        return next.handle(reqWithoutCustomHeader).pipe(tap((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            /* There may be other events besides the response. */
            if (event instanceof HttpResponse) {
                /* Updates the cache. */
                this._cache.set(req, maxAgeInCache, event); /* Cached the original request `req`. */
            }
        })));
    }
}
CachingInterceptor.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CachingInterceptor.ctorParameters = () => [
    { type: Cachable },
    { type: RequestCache }
];
/** @nocollapse */ CachingInterceptor.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function CachingInterceptor_Factory() { return new CachingInterceptor(i0.ɵɵinject(i1.Cachable), i0.ɵɵinject(i1.RequestCache)); }, token: CachingInterceptor, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CachingInterceptor.prototype._cachable;
    /**
     * @type {?}
     * @private
     */
    CachingInterceptor.prototype._cache;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaHR0cC5pbnRlcmNlcHRvci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3RvY28tbGliLyIsInNvdXJjZXMiOlsibGliL2NvcmUvc2VydmljZXMvaHR0cC5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUF3RCxZQUFZLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUMxRyxPQUFPLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUVyQyxPQUFPLEVBQUUsZUFBZSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXVCbEYsTUFBTSxPQUFPLGtCQUFrQjs7Ozs7SUFFM0IsWUFBMkIsU0FBbUIsRUFBVSxNQUFvQjtRQUFqRCxjQUFTLEdBQVQsU0FBUyxDQUFVO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBYztJQUMxRSxDQUFDOzs7Ozs7O0lBUUksU0FBUyxDQUFDLEdBQXFCLEVBQUUsSUFBaUI7O1lBRWpELGFBQXFCO1FBRXpCLGdDQUFnQztRQUNoQyxJQUFJLENBQUMsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsRUFDckQ7WUFDSSxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDM0I7UUFFRCxvR0FBb0c7UUFDcEcsSUFBSSxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsRUFDcEM7WUFDSSxZQUFZO1lBQ1osT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzVEOzs7Y0FHSyxjQUFjLEdBQXNCLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQztRQUM5RCxPQUFPLENBQUMsY0FBYztZQUNsQixDQUFDLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQztZQUNwQixDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzlELENBQUM7Ozs7Ozs7Ozs7O0lBV08sWUFBWSxDQUFDLEdBQXFCLEVBQUUsYUFBcUIsRUFBRSxnQkFBeUIsRUFBRSxJQUFpQjs7O1lBR3ZHLHNCQUFzQixHQUFxQixDQUFDLGdCQUFnQixDQUFDO1lBQzdELENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQy9ELENBQUMsQ0FBQyxHQUFHO1FBRVQsT0FBTyxDQUFDLEdBQUcsQ0FBQyxTQUFTLEVBQUUsc0JBQXNCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdkQsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLHNCQUFzQixDQUFDLENBQUMsSUFBSSxDQUMzQyxHQUFHOzs7O1FBQUMsQ0FBQyxLQUFxQixFQUFFLEVBQUU7WUFDMUIscURBQXFEO1lBQ3JELElBQUksS0FBSyxZQUFZLFlBQVksRUFDakM7Z0JBQ0ksd0JBQXdCO2dCQUN4QixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUUsd0NBQXdDO2FBQ3hGO1FBQ0wsQ0FBQyxFQUFDLENBQ0wsQ0FBQztJQUNOLENBQUM7OztZQWxFSixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7Ozs7WUF0QnlCLFFBQVE7WUFBRSxZQUFZOzs7Ozs7OztJQXlCekIsdUNBQTJCOzs7OztJQUFFLG9DQUE0QiIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSHR0cEludGVyY2VwdG9yLCBIdHRwUmVxdWVzdCwgSHR0cEhhbmRsZXIsIEh0dHBFdmVudCwgSHR0cFJlc3BvbnNlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuaW1wb3J0IHsgUkVGUkVTSF9YX0NBQ0hFLCBDYWNoYWJsZSwgUmVxdWVzdENhY2hlIH0gZnJvbSAnLi9yZXF1ZXN0LWNhY2hlLnNlcnZpY2UnO1xuXG4vKiBOb3RlOiBXaGVuIHlvdSBhcmUgZ29pbmcgdG8gdXNlIHRoZSBJbnRlcmNlcHRvcnMsIG1ha2UgYSBcIkJhcnJlbFwiIG9mIEh0dHAgSW50ZXJjZXB0b3JzLiBcbiAqIEFuZ3VsYXIgYXBwbGllcyBpbnRlcmNlcHRvcnMgaW4gdGhlIG9yZGVyIHRoYXQgeW91IHByb3ZpZGUgdGhlbS4gSWYgeW91IHByb3ZpZGUgaW50ZXJjZXB0b3JzIEEsIFxuICogdGhlbiBCLCB0aGVuIEMsIHJlcXVlc3RzIHdpbGwgZmxvdyBpbiBBLT5CLT5DIGFuZCByZXNwb25zZXMgd2lsbCBmbG93IG91dCBDLT5CLT5BLiBcbiAqIFlvdSBjYW5ub3QgY2hhbmdlIHRoZSBvcmRlciBvciByZW1vdmUgaW50ZXJjZXB0b3JzIGxhdGVyLiBJZiB5b3UgbmVlZCB0byBlbmFibGUgYW5kIGRpc2FibGUgXG4gKiBhbiBpbnRlcmNlcHRvciBkeW5hbWljYWxseSwgeW91J2xsIGhhdmUgdG8gYnVpbGQgdGhhdCBjYXBhYmlsaXR5IGludG8gdGhlIGludGVyY2VwdG9yIGl0c2VsZi4gKi9cblxuXG4vKipcbiAqIEEgc2VydmljZSB0aGF0IGNhY2hlcyBjZXJ0YWluIHJlcXVlc3RzIGFuZCByZXNwb25zZXMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZS4gXG4gKiBJdCBpcyBkZWxlZ2F0ZWQgdG8gYW4gaW50ZXJjZXB0b3Igd2l0aG91dCBkaXN0dXJiaW5nIHRoZSBleGlzdGluZyBkYXRhIHNlcnZpY2VzLiBcbiAqIFxuICogLSBJZiByZXF1ZXN0IGlzIGNhY2hhYmxlIChlLmcuLCBwYWNrYWdlIHNlYXJjaCkgYW5kIHJlc3BvbnNlIGlzIGluIGNhY2hlLCBcbiAqIHRoZW4gcmV0dXJucyB0aGUgY2FjaGVkIHJlc3BvbnNlIGFzIG9ic2VydmFibGUuIFxuICogLSBJZiByZXF1ZXN0IGlzIGNhY2hhYmxlIGFuZCBoYXMgYFJFRlJFU0hfWF9DQUNIRWAgb3B0aW9uIGhlYWRlciBpbiB0cnVlIChvciB0aGUgcmVxdWVzdCBpcyBub3QgaW4gY2FjaGUpLCBcbiAqIHRoZW4gcGFzc2VzIHJlcXVlc3QgdG8gdGhlIGZvbGxvd2luZyBgSHR0cEhhbmRsZXJgIGFuZCBtYWtlcyBhIGNhY2hlIGZyb20gcmVzcG9uc2UuIFxuICogLSBJZiByZXF1ZXN0IGlzIG5vdCBjYWNoYWJsZSwgXG4gKiB0aGVuIHBhc3NlcyByZXF1ZXN0IHRvIHRoZSBmb2xsb3dpbmcgYEh0dHBIYW5kbGVyYC4gXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgQ2FjaGluZ0ludGVyY2VwdG9yIGltcGxlbWVudHMgSHR0cEludGVyY2VwdG9yXG57XG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgX2NhY2hhYmxlOiBDYWNoYWJsZSwgcHJpdmF0ZSBfY2FjaGU6IFJlcXVlc3RDYWNoZSlcbiAgICB7IH1cblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXMgYW5kIGhhbmRsZXMgYSBnaXZlbiBIVFRQIHJlcXVlc3QuIFxuICAgICAqIEBwYXJhbSByZXEgVGhlIG91dGdvaW5nIHJlcXVlc3Qgb2JqZWN0IHRvIGhhbmRsZS4gXG4gICAgICogQHBhcmFtIG5leHQgVGhlIG5leHQgaW50ZXJjZXB0b3IgaW4gdGhlIGNoYWluLCBvciB0aGUgYmFja2VuZCBpZiBubyBpbnRlcmNlcHRvcnMgcmVtYWluIGluIHRoZSBjaGFpbi4gXG4gICAgICogQHJldHVybnMgQW4gb2JzZXJ2YWJsZSBvZiB0aGUgZXZlbnQgc3RyZWFtLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgaW50ZXJjZXB0KHJlcTogSHR0cFJlcXVlc3Q8YW55PiwgbmV4dDogSHR0cEhhbmRsZXIpOiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PlxuICAgIHtcbiAgICAgICAgbGV0IG1heEFnZUluQ2FjaGU6IG51bWJlcjtcblxuICAgICAgICAvKiBDb250aW51ZXMgaWYgbm90IGNhY2hhYmxlLiAqL1xuICAgICAgICBpZiAoIShtYXhBZ2VJbkNhY2hlID0gdGhpcy5fY2FjaGFibGUuaXNDYWNoYWJsZShyZXEpKSlcbiAgICAgICAge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQuaGFuZGxlKHJlcSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBUaGlzIG9wdGlvbiBpcyB0cmlnZ2VyZWQgYnkgdGhlIHByZXNlbmNlIG9mIGEgY3VzdG9tIGBSRUZSRVNIX1hfQ0FDSEVgIGhlYWRlciB3aXRoIHRydWUgdmFsdWUuICovXG4gICAgICAgIGlmIChyZXEuaGVhZGVycy5nZXQoUkVGUkVTSF9YX0NBQ0hFKSlcbiAgICAgICAge1xuICAgICAgICAgICAgLyogZmV0Y2guICovXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZFJlcXVlc3QocmVxLCBtYXhBZ2VJbkNhY2hlLCB0cnVlLCBuZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGNhY2hlLW9yLWZldGNoLiAqL1xuICAgICAgICBjb25zdCBjYWNoZWRSZXNwb25zZTogSHR0cFJlc3BvbnNlPGFueT4gPSB0aGlzLl9jYWNoZS5nZXQocmVxKTtcbiAgICAgICAgcmV0dXJuIChjYWNoZWRSZXNwb25zZVxuICAgICAgICAgICAgPyBvZihjYWNoZWRSZXNwb25zZSlcbiAgICAgICAgICAgIDogdGhpcy5fc2VuZFJlcXVlc3QocmVxLCBtYXhBZ2VJbkNhY2hlLCBmYWxzZSwgbmV4dCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgc2VydmVyIHJlc3BvbnNlIG9ic2VydmFibGUgYnkgc2VuZGluZyByZXF1ZXN0IHRvIGBuZXh0YCBhcmd1bWVudC4gXG4gICAgICogSXQgd2lsbCBhZGQgdGhlIHJlc3BvbnNlIHRvIHRoZSBjYWNoZSBvbiB0aGUgd2F5IG91dC4gXG4gICAgICogQHBhcmFtIHJlcSBUaGUgb3V0Z29pbmcgcmVxdWVzdCBvYmplY3QgdG8gaGFuZGxlLiBcbiAgICAgKiBAcGFyYW0gbWF4QWdlSW5DYWNoZSBUaGUgbWF4aW11bSBjYWNoZSBhZ2UgaW4gbWlsbGlzZWNvbmRzLiBcbiAgICAgKiBAcGFyYW0gaGFzUmVmcmVzaFhDYWNoZSBJdCBpcyB0cnVlIGlmIHRoZSBjdXN0b20gYFJFRlJFU0hfWF9DQUNIRWAgaGVhZGVyIGlzIHByZXNlbnQ7IG90aGVyd2lzZSwgZmFsc2UuIFxuICAgICAqIEBwYXJhbSBuZXh0IFRoZSBuZXh0IGludGVyY2VwdG9yIGluIHRoZSBjaGFpbiwgb3IgdGhlIGJhY2tlbmQgaWYgbm8gaW50ZXJjZXB0b3JzIHJlbWFpbiBpbiB0aGUgY2hhaW4uIFxuICAgICAqIEByZXR1cm5zIEFuIG9ic2VydmFibGUgb2YgdGhlIGV2ZW50IHN0cmVhbS4gXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc2VuZFJlcXVlc3QocmVxOiBIdHRwUmVxdWVzdDxhbnk+LCBtYXhBZ2VJbkNhY2hlOiBudW1iZXIsIGhhc1JlZnJlc2hYQ2FjaGU6IGJvb2xlYW4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj5cbiAgICB7XG4gICAgICAgIC8qIFJlbW92ZXMgdGhlIGBSRUZSRVNIX1hfQ0FDSEVgIGN1c3RvbSBvcHRpb24gZnJvbSBoZWFkZXIuICovXG4gICAgICAgIGxldCByZXFXaXRob3V0Q3VzdG9tSGVhZGVyOiBIdHRwUmVxdWVzdDxhbnk+ID0gKGhhc1JlZnJlc2hYQ2FjaGUpXG4gICAgICAgICAgICA/IHJlcS5jbG9uZSh7IGhlYWRlcnM6IChyZXEuaGVhZGVycy5kZWxldGUoUkVGUkVTSF9YX0NBQ0hFKSkgfSlcbiAgICAgICAgICAgIDogcmVxO1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZXEtMjogJywgcmVxV2l0aG91dEN1c3RvbUhlYWRlci5oZWFkZXJzKTtcblxuICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxV2l0aG91dEN1c3RvbUhlYWRlcikucGlwZShcbiAgICAgICAgICAgIHRhcCgoZXZlbnQ6IEh0dHBFdmVudDxhbnk+KSA9PiB7XG4gICAgICAgICAgICAgICAgLyogVGhlcmUgbWF5IGJlIG90aGVyIGV2ZW50cyBiZXNpZGVzIHRoZSByZXNwb25zZS4gKi9cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2UpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvKiBVcGRhdGVzIHRoZSBjYWNoZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FjaGUuc2V0KHJlcSwgbWF4QWdlSW5DYWNoZSwgZXZlbnQpOyAgLyogQ2FjaGVkIHRoZSBvcmlnaW5hbCByZXF1ZXN0IGByZXFgLiAqL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgfVxufVxuIl19