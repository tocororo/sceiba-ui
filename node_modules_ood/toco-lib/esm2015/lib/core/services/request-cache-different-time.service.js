/**
 * @fileoverview added by tsickle
 * Generated from: lib/core/services/request-cache-different-time.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import { Environment } from '../env';
import { MessageService } from './message.service';
import { Cachable, RequestCache } from './request-cache.service';
import * as i0 from "@angular/core";
import * as i1 from "../env";
import * as i2 from "./message.service";
/**
 * A service that implements the cachable URL request.
 */
export class CachableUrl {
    /**
     * @param {?} _env
     */
    constructor(_env) {
        this._env = _env;
    }
    /**
     * Returns a number greater than zero if the specified request is cachable;
     * that number represents the maximum cache age in milliseconds.
     * Return zero if the specified request is NOT cachable.
     * @param {?} req The outgoing request object to handle.
     * @return {?}
     */
    isCachable(req) {
        /* Only GET requests are cachable. */
        if (req.method != 'GET')
            return 0;
        Object.keys(this._env.cachableUrls).forEach((/**
         * @param {?} url
         * @return {?}
         */
        (url) => {
            /* Verifies if the request cache is cachable. */
            if (req.url.indexOf(url) > -1)
                return this._env.cachableUrls[url];
        }));
        /* It is not cachable. */
        return 0;
    }
}
CachableUrl.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CachableUrl.ctorParameters = () => [
    { type: Environment }
];
/** @nocollapse */ CachableUrl.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function CachableUrl_Factory() { return new CachableUrl(i0.ɵɵinject(i1.Environment)); }, token: CachableUrl, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    CachableUrl.prototype._env;
}
/**
 * Represents the request cache entry.
 * @record
 */
export function RequestCacheEntry() { }
if (false) {
    /**
     * Returns the request URL.
     * @type {?}
     */
    RequestCacheEntry.prototype.url;
    /**
     * Returns the request cache.
     * @type {?}
     */
    RequestCacheEntry.prototype.response;
    /**
     * Returns the maximum cache age in milliseconds.
     * @type {?}
     */
    RequestCacheEntry.prototype.maxAgeInCache;
    /**
     * Returns the last read of the request URL.
     * @type {?}
     */
    RequestCacheEntry.prototype.lastRead;
}
/**
 * A service that implements the request cache with the different time using `Map` collection.
 */
export class RequestCacheDifferentTimeWithMap {
    /**
     * @param {?} _messageService
     */
    constructor(_messageService) {
        this._messageService = _messageService;
        this._cache = new Map();
    }
    /**
     * @param {?} req
     * @return {?}
     */
    get(req) {
        /** @type {?} */
        const cached = this._cache.get(req.urlWithParams);
        if (!cached) {
            return undefined;
        }
        if ((cached.lastRead + cached.maxAgeInCache) < Date.now()) /* Found expired cached. */ {
            this._messageService.add(`Found expired cached response for '${req.urlWithParams}'.`);
            return undefined;
        }
        else {
            this._messageService.add(`Found cached response for '${req.urlWithParams}'.`);
            return cached.response;
        }
    }
    /**
     * @param {?} req
     * @param {?} maxAgeInCache
     * @param {?} response
     * @return {?}
     */
    set(req, maxAgeInCache, response) {
        /** @type {?} */
        const url = req.urlWithParams;
        this._messageService.add(`Caching response from '${url}'.`);
        this._cache.set(url, { url, response, maxAgeInCache, lastRead: Date.now() });
        /* Removes expired cache entries. */
        this._cache.forEach((/**
         * @param {?} entry
         * @return {?}
         */
        (entry) => {
            if (entry.lastRead < Date.now() - entry.maxAgeInCache) {
                this._cache.delete(entry.url);
            }
        }));
        this._messageService.add(`Request cache size: ${this._cache.size}.`);
    }
}
RequestCacheDifferentTimeWithMap.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
RequestCacheDifferentTimeWithMap.ctorParameters = () => [
    { type: MessageService }
];
/** @nocollapse */ RequestCacheDifferentTimeWithMap.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function RequestCacheDifferentTimeWithMap_Factory() { return new RequestCacheDifferentTimeWithMap(i0.ɵɵinject(i2.MessageService)); }, token: RequestCacheDifferentTimeWithMap, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    RequestCacheDifferentTimeWithMap.prototype._cache;
    /**
     * @type {?}
     * @private
     */
    RequestCacheDifferentTimeWithMap.prototype._messageService;
}
/**
 * A provider for the cachable URL request.
 * @type {?}
 */
export const CACHABLE_URL_PROVIDER = [
    { 'provide': Cachable, 'useClass': CachableUrl, 'multi': false }
];
/**
 * A provider for the request cache with the different time using `Map` collection.
 * @type {?}
 */
export const REQUEST_CACHE_DIFFERENT_TIME_WITH_MAP_PROVIDER = [
    { 'provide': RequestCache, 'useClass': RequestCacheDifferentTimeWithMap, 'multi': false }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVxdWVzdC1jYWNoZS1kaWZmZXJlbnQtdGltZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vdG9jby1saWIvIiwic291cmNlcyI6WyJsaWIvY29yZS9zZXJ2aWNlcy9yZXF1ZXN0LWNhY2hlLWRpZmZlcmVudC10aW1lLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRzNDLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFFckMsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ25ELE9BQU8sRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLE1BQU0seUJBQXlCLENBQUM7Ozs7Ozs7QUFRakUsTUFBTSxPQUFPLFdBQVc7Ozs7SUFFdkIsWUFBMkIsSUFBaUI7UUFBakIsU0FBSSxHQUFKLElBQUksQ0FBYTtJQUMxQyxDQUFDOzs7Ozs7OztJQVFPLFVBQVUsQ0FBQyxHQUFxQjtRQUVuQyxxQ0FBcUM7UUFDM0MsSUFBSSxHQUFHLENBQUMsTUFBTSxJQUFJLEtBQUs7WUFBRSxPQUFPLENBQUMsQ0FBQztRQUVsQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTzs7OztRQUMxQyxDQUFDLEdBQVcsRUFBRSxFQUFFO1lBQ2YsZ0RBQWdEO1lBQ2hELElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUFFLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbkUsQ0FBQyxFQUNELENBQUM7UUFFRix5QkFBeUI7UUFDekIsT0FBTyxDQUFDLENBQUM7SUFDUCxDQUFDOzs7WUE1QkosVUFBVSxTQUFDO2dCQUNYLFVBQVUsRUFBRSxNQUFNO2FBQ2xCOzs7O1lBVlEsV0FBVzs7Ozs7Ozs7SUFhQSwyQkFBeUI7Ozs7OztBQTZCN0MsdUNBcUJDOzs7Ozs7SUFoQkEsZ0NBQVk7Ozs7O0lBS1oscUNBQTRCOzs7OztJQUs1QiwwQ0FBc0I7Ozs7O0lBS3RCLHFDQUFpQjs7Ozs7QUFTbEIsTUFBTSxPQUFPLGdDQUFnQzs7OztJQUk1QyxZQUEyQixlQUErQjtRQUEvQixvQkFBZSxHQUFmLGVBQWUsQ0FBZ0I7UUFFekQsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLEdBQUcsRUFBNkIsQ0FBQztJQUNwRCxDQUFDOzs7OztJQUVNLEdBQUcsQ0FBQyxHQUFxQjs7Y0FFekIsTUFBTSxHQUFzQixJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDO1FBRXBFLElBQUksQ0FBQyxNQUFNLEVBQ1g7WUFDQyxPQUFPLFNBQVMsQ0FBQztTQUNqQjtRQUVELElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEVBQUcsMkJBQTJCLENBQ3ZGO1lBQ0MsSUFBSSxDQUFDLGVBQWUsQ0FBQyxHQUFHLENBQUMsc0NBQXVDLEdBQUcsQ0FBQyxhQUFjLElBQUksQ0FBQyxDQUFDO1lBQ3hGLE9BQU8sU0FBUyxDQUFDO1NBQ2pCO2FBRUQ7WUFDQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyw4QkFBK0IsR0FBRyxDQUFDLGFBQWMsSUFBSSxDQUFDLENBQUM7WUFDaEYsT0FBTyxNQUFNLENBQUMsUUFBUSxDQUFDO1NBQ3ZCO0lBQ0YsQ0FBQzs7Ozs7OztJQUVNLEdBQUcsQ0FBQyxHQUFxQixFQUFFLGFBQXFCLEVBQUUsUUFBMkI7O2NBRTdFLEdBQUcsR0FBVyxHQUFHLENBQUMsYUFBYTtRQUNyQyxJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQywwQkFBMkIsR0FBSSxJQUFJLENBQUMsQ0FBQztRQUU5RCxJQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsRUFBRSxHQUFHLEVBQUUsUUFBUSxFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQUUsSUFBSSxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUU3RSxvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPOzs7O1FBQ2xCLENBQUMsS0FBd0IsRUFBRSxFQUFFO1lBQzVCLElBQUksS0FBSyxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsS0FBSyxDQUFDLGFBQWEsRUFDckQ7Z0JBQ0MsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2FBQzlCO1FBQ0YsQ0FBQyxFQUNELENBQUM7UUFFRixJQUFJLENBQUMsZUFBZSxDQUFDLEdBQUcsQ0FBQyx1QkFBd0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7OztZQW5ERCxVQUFVLFNBQUM7Z0JBQ1gsVUFBVSxFQUFFLE1BQU07YUFDbEI7Ozs7WUFwRVEsY0FBYzs7Ozs7Ozs7SUF1RXRCLGtEQUErQzs7Ozs7SUFFNUIsMkRBQXVDOzs7Ozs7QUFrRDNELE1BQU0sT0FBTyxxQkFBcUIsR0FBRztJQUNqQyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFO0NBQ25FOzs7OztBQUtELE1BQU0sT0FBTyw4Q0FBOEMsR0FBRztJQUMxRCxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLGdDQUFnQyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUU7Q0FDNUYiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBSZXF1ZXN0LCBIdHRwUmVzcG9uc2UgfSBmcm9tICdAYW5ndWxhci9jb21tb24vaHR0cCc7XG5cbmltcG9ydCB7IEVudmlyb25tZW50IH0gZnJvbSAnLi4vZW52JztcblxuaW1wb3J0IHsgTWVzc2FnZVNlcnZpY2UgfSBmcm9tICcuL21lc3NhZ2Uuc2VydmljZSc7XG5pbXBvcnQgeyBDYWNoYWJsZSwgUmVxdWVzdENhY2hlIH0gZnJvbSAnLi9yZXF1ZXN0LWNhY2hlLnNlcnZpY2UnO1xuXG4vKipcbiAqIEEgc2VydmljZSB0aGF0IGltcGxlbWVudHMgdGhlIGNhY2hhYmxlIFVSTCByZXF1ZXN0LlxuICovXG5ASW5qZWN0YWJsZSh7XG5cdHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBDYWNoYWJsZVVybCBpbXBsZW1lbnRzIENhY2hhYmxlXG57XG5cdHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbnY6IEVudmlyb25tZW50KVxuXHR7IH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBudW1iZXIgZ3JlYXRlciB0aGFuIHplcm8gaWYgdGhlIHNwZWNpZmllZCByZXF1ZXN0IGlzIGNhY2hhYmxlO1xuXHQgKiB0aGF0IG51bWJlciByZXByZXNlbnRzIHRoZSBtYXhpbXVtIGNhY2hlIGFnZSBpbiBtaWxsaXNlY29uZHMuXG5cdCAqIFJldHVybiB6ZXJvIGlmIHRoZSBzcGVjaWZpZWQgcmVxdWVzdCBpcyBOT1QgY2FjaGFibGUuXG4gICAgICogQHBhcmFtIHJlcSBUaGUgb3V0Z29pbmcgcmVxdWVzdCBvYmplY3QgdG8gaGFuZGxlLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc0NhY2hhYmxlKHJlcTogSHR0cFJlcXVlc3Q8YW55Pik6IG51bWJlclxuICAgIHtcbiAgICAgICAgLyogT25seSBHRVQgcmVxdWVzdHMgYXJlIGNhY2hhYmxlLiAqL1xuXHRcdGlmIChyZXEubWV0aG9kICE9ICdHRVQnKSByZXR1cm4gMDtcblxuXHRcdE9iamVjdC5rZXlzKHRoaXMuX2Vudi5jYWNoYWJsZVVybHMpLmZvckVhY2goXG5cdFx0XHQodXJsOiBzdHJpbmcpID0+IHtcblx0XHRcdFx0LyogVmVyaWZpZXMgaWYgdGhlIHJlcXVlc3QgY2FjaGUgaXMgY2FjaGFibGUuICovXG5cdFx0XHRcdGlmIChyZXEudXJsLmluZGV4T2YodXJsKSA+IC0xKSByZXR1cm4gdGhpcy5fZW52LmNhY2hhYmxlVXJsc1t1cmxdO1xuXHRcdFx0fVxuXHRcdCk7XG5cblx0XHQvKiBJdCBpcyBub3QgY2FjaGFibGUuICovXG5cdFx0cmV0dXJuIDA7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIHJlcXVlc3QgY2FjaGUgZW50cnkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdENhY2hlRW50cnlcbntcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJlcXVlc3QgVVJMLlxuXHQgKi9cblx0dXJsOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJlcXVlc3QgY2FjaGUuXG5cdCAqL1xuXHRyZXNwb25zZTogSHR0cFJlc3BvbnNlPGFueT47XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG1heGltdW0gY2FjaGUgYWdlIGluIG1pbGxpc2Vjb25kcy5cblx0ICovXG5cdG1heEFnZUluQ2FjaGU6IG51bWJlcjtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbGFzdCByZWFkIG9mIHRoZSByZXF1ZXN0IFVSTC5cblx0ICovXG5cdGxhc3RSZWFkOiBudW1iZXI7XG59XG5cbi8qKlxuICogQSBzZXJ2aWNlIHRoYXQgaW1wbGVtZW50cyB0aGUgcmVxdWVzdCBjYWNoZSB3aXRoIHRoZSBkaWZmZXJlbnQgdGltZSB1c2luZyBgTWFwYCBjb2xsZWN0aW9uLlxuICovXG5ASW5qZWN0YWJsZSh7XG5cdHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBSZXF1ZXN0Q2FjaGVEaWZmZXJlbnRUaW1lV2l0aE1hcCBpbXBsZW1lbnRzIFJlcXVlc3RDYWNoZVxue1xuXHRwcml2YXRlIF9jYWNoZTogTWFwPHN0cmluZywgUmVxdWVzdENhY2hlRW50cnk+O1xuXG5cdHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIF9tZXNzYWdlU2VydmljZTogTWVzc2FnZVNlcnZpY2UpXG5cdHtcblx0XHR0aGlzLl9jYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBSZXF1ZXN0Q2FjaGVFbnRyeT4oKTtcblx0fVxuXG5cdHB1YmxpYyBnZXQocmVxOiBIdHRwUmVxdWVzdDxhbnk+KTogSHR0cFJlc3BvbnNlPGFueT4gfCB1bmRlZmluZWRcblx0e1xuXHRcdGNvbnN0IGNhY2hlZDogUmVxdWVzdENhY2hlRW50cnkgPSB0aGlzLl9jYWNoZS5nZXQocmVxLnVybFdpdGhQYXJhbXMpO1xuXG5cdFx0aWYgKCFjYWNoZWQpXG5cdFx0e1xuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpZiAoKGNhY2hlZC5sYXN0UmVhZCArIGNhY2hlZC5tYXhBZ2VJbkNhY2hlKSA8IERhdGUubm93KCkpICAvKiBGb3VuZCBleHBpcmVkIGNhY2hlZC4gKi9cblx0XHR7XG5cdFx0XHR0aGlzLl9tZXNzYWdlU2VydmljZS5hZGQoYEZvdW5kIGV4cGlyZWQgY2FjaGVkIHJlc3BvbnNlIGZvciAnJHsgcmVxLnVybFdpdGhQYXJhbXMgfScuYCk7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0dGhpcy5fbWVzc2FnZVNlcnZpY2UuYWRkKGBGb3VuZCBjYWNoZWQgcmVzcG9uc2UgZm9yICckeyByZXEudXJsV2l0aFBhcmFtcyB9Jy5gKTtcblx0XHRcdHJldHVybiBjYWNoZWQucmVzcG9uc2U7XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIHNldChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG1heEFnZUluQ2FjaGU6IG51bWJlciwgcmVzcG9uc2U6IEh0dHBSZXNwb25zZTxhbnk+KTogdm9pZFxuXHR7XG5cdFx0Y29uc3QgdXJsOiBzdHJpbmcgPSByZXEudXJsV2l0aFBhcmFtcztcblx0XHR0aGlzLl9tZXNzYWdlU2VydmljZS5hZGQoYENhY2hpbmcgcmVzcG9uc2UgZnJvbSAnJHsgdXJsIH0nLmApO1xuXG5cdFx0dGhpcy5fY2FjaGUuc2V0KHVybCwgeyB1cmwsIHJlc3BvbnNlLCBtYXhBZ2VJbkNhY2hlLCBsYXN0UmVhZDogRGF0ZS5ub3coKSB9KTtcblxuXHRcdC8qIFJlbW92ZXMgZXhwaXJlZCBjYWNoZSBlbnRyaWVzLiAqL1xuXHRcdHRoaXMuX2NhY2hlLmZvckVhY2goXG5cdFx0XHQoZW50cnk6IFJlcXVlc3RDYWNoZUVudHJ5KSA9PiB7XG5cdFx0XHRcdGlmIChlbnRyeS5sYXN0UmVhZCA8IERhdGUubm93KCkgLSBlbnRyeS5tYXhBZ2VJbkNhY2hlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5fY2FjaGUuZGVsZXRlKGVudHJ5LnVybCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0dGhpcy5fbWVzc2FnZVNlcnZpY2UuYWRkKGBSZXF1ZXN0IGNhY2hlIHNpemU6ICR7IHRoaXMuX2NhY2hlLnNpemUgfS5gKTtcblx0fVxufVxuXG4vKipcbiAqIEEgcHJvdmlkZXIgZm9yIHRoZSBjYWNoYWJsZSBVUkwgcmVxdWVzdC5cbiAqL1xuZXhwb3J0IGNvbnN0IENBQ0hBQkxFX1VSTF9QUk9WSURFUiA9IFtcbiAgICB7ICdwcm92aWRlJzogQ2FjaGFibGUsICd1c2VDbGFzcyc6IENhY2hhYmxlVXJsLCAnbXVsdGknOiBmYWxzZSB9XG5dO1xuXG4vKipcbiAqIEEgcHJvdmlkZXIgZm9yIHRoZSByZXF1ZXN0IGNhY2hlIHdpdGggdGhlIGRpZmZlcmVudCB0aW1lIHVzaW5nIGBNYXBgIGNvbGxlY3Rpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBSRVFVRVNUX0NBQ0hFX0RJRkZFUkVOVF9USU1FX1dJVEhfTUFQX1BST1ZJREVSID0gW1xuICAgIHsgJ3Byb3ZpZGUnOiBSZXF1ZXN0Q2FjaGUsICd1c2VDbGFzcyc6IFJlcXVlc3RDYWNoZURpZmZlcmVudFRpbWVXaXRoTWFwLCAnbXVsdGknOiBmYWxzZSB9XG5dO1xuIl19