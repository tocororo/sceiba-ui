/**
 * @fileoverview added by tsickle
 * Generated from: lib/core/services/backend-data-source.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { _isNumberValue } from '@angular/cdk/coercion';
import { MAX_SAFE_INTEGER } from '../utils/helpers';
/** @enum {string} */
const SortDirection = {
    /**
     * Sorts the data in the ascending order.
     */
    asc: "asc",
    /**
     * Sorts the data in the descending order.
     */
    desc: "desc",
    /**
     * Sorts the data in the original order or does not sort them.
     */
    orig: "",
};
export { SortDirection };
/**
 * An interface that represents the input data that are used to make a page request.
 * It is the input of `BackendDataSourceFunction` function.
 * @record
 */
export function PageRequest() { }
if (false) {
    /**
     * The current filter state.
     * @type {?|undefined}
     */
    PageRequest.prototype.filter;
    /**
     * The current sort state.
     * @type {?}
     */
    PageRequest.prototype.sort;
    /**
     * The current paginator state.
     * @type {?}
     */
    PageRequest.prototype.paginator;
}
/**
 * An interface that represents the requested page.
 * It is the output of `BackendDataSourceFunction` function.
 * The generic parameter T always refers to the type of data that it is dealing with.
 * @record
 * @template T
 */
export function Page() { }
if (false) {
    /**
     * Returns the list of items.
     * By default, its value is `[]`.
     * @type {?}
     */
    Page.prototype.data;
    /**
     * Returns the total number of items being paged.
     * By default, its value is `0`.
     * @type {?}
     */
    Page.prototype.totalData;
    /**
     * Returns the zero-based page index of the displayed list of items.
     * By default, its value is `0`.
     * @type {?}
     */
    Page.prototype.pageIndex;
    /**
     * Returns the number of items to display on a page.
     * By default, its value is `50`.
     * @type {?}
     */
    Page.prototype.pageSize;
}
/**
 * An interface that represents the function that is used to get the data source from backend.
 * The generic parameter T always refers to the type of data that it is dealing with.
 * @record
 * @template T
 */
export function BackendDataSourceFunction() { }
/**
 * Checks if a data object matches the data source's filter string. By default, each data object
 * is converted to a string of its properties and returns true if the filter has
 * at least one occurrence in that string. By default, the filter string has its whitespace
 * trimmed and the match is case-insensitive.
 * May be overridden for a custom implementation of filter matching.
 * @template T
 * @param {?} data Data object used to check against the filter.
 * @param {?} filter Filter string that has been set on the data source.
 * @return {?} Returns true whether the filter matches against the data; otherwise, false.
 */
export function filterPredicate(data, filter) {
    /* Transforms the data into a lowercase string of all property values. */
    /** @type {?} */
    const dataStr = Object.keys(data).reduce(((/**
     * @param {?} currentTerm
     * @param {?} key
     * @return {?}
     */
    (currentTerm, key) => {
        /* Use an obscure Unicode character to delimit the words in the concatenated string.
         * This avoids matches where the values of two columns combined will match the user's query
         * (e.g. `Flute` and `Stop` will match `Test`). The character is intended to be something
         * that has a very low chance of being typed in by somebody in a text field. This one in
         * particular is "White up-pointing triangle with dot" from
         * https://en.wikipedia.org/wiki/List_of_Unicode_characters. */
        return currentTerm + data[key] + 'â—¬';
    })), '').toLowerCase();
    /* Transforms the filter by converting it to lowercase and removing whitespace. */
    /** @type {?} */
    const transformedFilter = filter.trim().toLowerCase();
    return (dataStr.indexOf(transformedFilter) != -1);
}
/**
 * Data accessor function that is used for accessing data properties for sorting through
 * the default `sortData` function.
 * This default function assumes that the sort header IDs (which defaults to the column name)
 * matches the data's properties (e.g. column Xyz represents data['Xyz']).
 * May be overridden for a custom implementation of different behavior.
 * @template T
 * @param {?} data Data object that is being accessed.
 * @param {?} sortHeaderId The name of the column that represents the data.
 * @return {?}
 */
export function sortingDataAccessor(data, sortHeaderId) {
    /** @type {?} */
    const value = data[sortHeaderId];
    if (_isNumberValue(value)) {
        /** @type {?} */
        const numberValue = Number(value);
        /* Numbers beyond `MAX_SAFE_INTEGER` can't be compared reliably so we
         * leave them as strings. For more info: https://goo.gl/y5vbSg. */
        return (numberValue < MAX_SAFE_INTEGER ? numberValue : value);
    }
    return value;
}
/**
 * Gets a sorted copy of the data array based on the state of the `MatSort`. Called
 * after changes are made to the filtered data or when sort changes are emitted from `MatSort`.
 * By default, the function retrieves the active sort and its direction and compares data
 * by retrieving data using the `sortingDataAccessor`.
 * May be overridden for a custom implementation of data ordering.
 * @template T
 * @param {?} data The array of data that should be sorted.
 * @param {?} sort The connected `MatSort` that holds the current sort state.
 * @return {?}
 */
export function sortData(data, sort) {
    /** @type {?} */
    const active = sort.active;
    /** @type {?} */
    const direction = (/** @type {?} */ (sort.direction));
    if ((!active) || (direction == SortDirection.orig))
        return data;
    return data.sort((/**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    (a, b) => {
        /** @type {?} */
        let valueA = sortingDataAccessor(a, active);
        /** @type {?} */
        let valueB = sortingDataAccessor(b, active);
        /**
         * If both `valueA` and `valueB` exist (truthy), then compare the two. Otherwise, checks if
         * one value exists while the other doesn't. In this case, existing value should come last.
         * This avoids inconsistent results when comparing values to undefined/null.
         * If neither value exists, returns 0 (equal).
         * @type {?}
         */
        let comparatorResult = 0;
        if ((valueA != null) && (valueB != null)) {
            /* Checks if one value is greater than the other one; if equal, `comparatorResult` should remain 0. */
            if (valueA > valueB)
                comparatorResult = 1;
            else if (valueA < valueB)
                comparatorResult = -1;
        }
        else if (valueA != null)
            comparatorResult = 1;
        else if (valueB != null)
            comparatorResult = -1;
        return comparatorResult * ((direction == SortDirection.asc) ? 1 : -1);
    }));
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFja2VuZC1kYXRhLXNvdXJjZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3RvY28tbGliLyIsInNvdXJjZXMiOlsibGliL2NvcmUvc2VydmljZXMvYmFja2VuZC1kYXRhLXNvdXJjZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQU12RCxPQUFPLEVBQUUsZ0JBQWdCLEVBQVUsTUFBTSxrQkFBa0IsQ0FBQzs7QUFLNUQsTUFBWSxhQUFhO0lBRXJCOztPQUVHO0lBQ0gsR0FBRyxPQUFRO0lBRVg7O09BRUc7SUFDSCxJQUFJLFFBQVM7SUFFYjs7T0FFRztJQUNILElBQUksSUFBSztFQUNaOzs7Ozs7O0FBbUJELGlDQWdCQzs7Ozs7O0lBWEcsNkJBQXNCOzs7OztJQUt0QiwyQkFBVzs7Ozs7SUFLWCxnQ0FBcUI7Ozs7Ozs7OztBQVF6QiwwQkF5QkM7Ozs7Ozs7SUFuQkcsb0JBQVU7Ozs7OztJQU1WLHlCQUFrQjs7Ozs7O0lBTWxCLHlCQUFrQjs7Ozs7O0lBTWxCLHdCQUFpQjs7Ozs7Ozs7QUFPckIsK0NBR0M7Ozs7Ozs7Ozs7OztBQVlELE1BQU0sVUFBVSxlQUFlLENBQUksSUFBTyxFQUFFLE1BQWM7OztVQUdoRCxPQUFPLEdBQVcsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxNQUFNLENBQUM7Ozs7O0lBQzdDLENBQUMsV0FBVyxFQUFFLEdBQUcsRUFBVSxFQUFFO1FBQ3pCOzs7Ozt1RUFLK0Q7UUFDL0QsT0FBTyxXQUFXLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUN6QyxDQUFDLEVBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxXQUFXLEVBQUU7OztVQUduQixpQkFBaUIsR0FBVyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsV0FBVyxFQUFFO0lBRTdELE9BQU8sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0RCxDQUFDOzs7Ozs7Ozs7Ozs7QUFXRCxNQUFNLFVBQVUsbUJBQW1CLENBQUksSUFBTyxFQUFFLFlBQW9COztVQUUxRCxLQUFLLEdBQVEsSUFBSSxDQUFDLFlBQVksQ0FBQztJQUVyQyxJQUFJLGNBQWMsQ0FBQyxLQUFLLENBQUMsRUFDekI7O2NBQ1UsV0FBVyxHQUFXLE1BQU0sQ0FBQyxLQUFLLENBQUM7UUFFekM7MEVBQ2tFO1FBQ2xFLE9BQU8sQ0FBQyxXQUFXLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDakU7SUFFRCxPQUFPLEtBQUssQ0FBQztBQUNqQixDQUFDOzs7Ozs7Ozs7Ozs7QUFXRCxNQUFNLFVBQVUsUUFBUSxDQUFJLElBQVMsRUFBRSxJQUFVOztVQUV2QyxNQUFNLEdBQVcsSUFBSSxDQUFDLE1BQU07O1VBQzVCLFNBQVMsR0FBa0IsbUJBQUEsSUFBSSxDQUFDLFNBQVMsRUFBaUI7SUFFaEUsSUFBSSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLElBQUksYUFBYSxDQUFDLElBQUksQ0FBQztRQUFFLE9BQU8sSUFBSSxDQUFDO0lBRWhFLE9BQU8sSUFBSSxDQUFDLElBQUk7Ozs7O0lBQUMsQ0FBQyxDQUFJLEVBQUUsQ0FBSSxFQUFVLEVBQUU7O1lBQ2hDLE1BQU0sR0FBb0IsbUJBQW1CLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQzs7WUFDeEQsTUFBTSxHQUFvQixtQkFBbUIsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDOzs7Ozs7OztZQVN4RCxnQkFBZ0IsR0FBVyxDQUFDO1FBRWhDLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLEVBQ3hDO1lBQ0ksc0dBQXNHO1lBRXRHLElBQUksTUFBTSxHQUFHLE1BQU07Z0JBQUUsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDO2lCQUNyQyxJQUFJLE1BQU0sR0FBRyxNQUFNO2dCQUFFLGdCQUFnQixHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ25EO2FBQ0ksSUFBSSxNQUFNLElBQUksSUFBSTtZQUFFLGdCQUFnQixHQUFHLENBQUMsQ0FBQzthQUN6QyxJQUFJLE1BQU0sSUFBSSxJQUFJO1lBQUUsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFL0MsT0FBTyxnQkFBZ0IsR0FBRyxDQUFDLENBQUMsU0FBUyxJQUFJLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzFFLENBQUMsRUFBQyxDQUFDO0FBQ1AsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgX2lzTnVtYmVyVmFsdWUgfSBmcm9tICdAYW5ndWxhci9jZGsvY29lcmNpb24nO1xuaW1wb3J0IHsgU29ydCwgUGFnZUV2ZW50IH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgeyBJbnB1dENvbnRyb2wgfSBmcm9tICcuLi8uLi9mb3Jtcy9wdWJsaWMtYXBpJztcblxuaW1wb3J0IHsgTUFYX1NBRkVfSU5URUdFUiwgUGFyYW1zIH0gZnJvbSAnLi4vdXRpbHMvaGVscGVycyc7XG5cbi8qKlxuICogVGhlIGRhdGEgc29ydCBkaXJlY3Rpb24uIFxuICovXG5leHBvcnQgZW51bSBTb3J0RGlyZWN0aW9uXG57XG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIGRhdGEgaW4gdGhlIGFzY2VuZGluZyBvcmRlci4gXG4gICAgICovXG4gICAgYXNjID0gJ2FzYycsXG5cbiAgICAvKipcbiAgICAgKiBTb3J0cyB0aGUgZGF0YSBpbiB0aGUgZGVzY2VuZGluZyBvcmRlci4gXG4gICAgICovXG4gICAgZGVzYyA9ICdkZXNjJyxcblxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBkYXRhIGluIHRoZSBvcmlnaW5hbCBvcmRlciBvciBkb2VzIG5vdCBzb3J0IHRoZW0uIFxuICAgICAqL1xuICAgIG9yaWcgPSAnJ1xufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBrZXkvdmFsdWUgZWxlbWVudHMsIHdoZXJlIHRoZSBrZXkgaXMgdGhlIGZpbHRlciBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIGNvbnRyb2wgXG4gKiB0aGF0IGNvbnRhaW5zIHRoZSBmaWx0ZXIgdmFsdWUuIFxuICogQm90aCB0aGUgYEZpbHRlckNvbnRyb2xzYCBrZXlzIGFuZCBgRmlsdGVyVmFsdWVzYCBrZXlzIGFyZSB0aGUgc2FtZS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsdGVyQ29udHJvbHMgPSBQYXJhbXM8SW5wdXRDb250cm9sPjtcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Yga2V5L3ZhbHVlIGVsZW1lbnRzLCB3aGVyZSB0aGUga2V5IGlzIHRoZSBmaWx0ZXIgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIHRoZSBmaWx0ZXIgdmFsdWUuIFxuICogQm90aCB0aGUgYEZpbHRlckNvbnRyb2xzYCBrZXlzIGFuZCBgRmlsdGVyVmFsdWVzYCBrZXlzIGFyZSB0aGUgc2FtZS5cbiAqL1xuZXhwb3J0IHR5cGUgRmlsdGVyVmFsdWVzID0gUGFyYW1zPGFueT47XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5wdXQgZGF0YSB0aGF0IGFyZSB1c2VkIHRvIG1ha2UgYSBwYWdlIHJlcXVlc3QuIFxuICogSXQgaXMgdGhlIGlucHV0IG9mIGBCYWNrZW5kRGF0YVNvdXJjZUZ1bmN0aW9uYCBmdW5jdGlvbi4gXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZVJlcXVlc3RcbntcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBmaWx0ZXIgc3RhdGUuIFxuICAgICAqL1xuICAgIGZpbHRlcj86IEZpbHRlclZhbHVlcztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IHNvcnQgc3RhdGUuIFxuICAgICAqL1xuICAgIHNvcnQ6IFNvcnQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwYWdpbmF0b3Igc3RhdGUuIFxuICAgICAqL1xuICAgIHBhZ2luYXRvcjogUGFnZUV2ZW50O1xufVxuXG4vKipcbiAqIEFuIGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIHJlcXVlc3RlZCBwYWdlLiBcbiAqIEl0IGlzIHRoZSBvdXRwdXQgb2YgYEJhY2tlbmREYXRhU291cmNlRnVuY3Rpb25gIGZ1bmN0aW9uLiBcbiAqIFRoZSBnZW5lcmljIHBhcmFtZXRlciBUIGFsd2F5cyByZWZlcnMgdG8gdGhlIHR5cGUgb2YgZGF0YSB0aGF0IGl0IGlzIGRlYWxpbmcgd2l0aC4gXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUGFnZTxUPlxue1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgaXRlbXMuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgW11gLiBcbiAgICAgKi9cbiAgICBkYXRhOiBUW107XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgYmVpbmcgcGFnZWQuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgMGAuIFxuICAgICAqL1xuICAgIHRvdGFsRGF0YTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgemVyby1iYXNlZCBwYWdlIGluZGV4IG9mIHRoZSBkaXNwbGF5ZWQgbGlzdCBvZiBpdGVtcy4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGAwYC4gXG4gICAgICovXG4gICAgcGFnZUluZGV4OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gZGlzcGxheSBvbiBhIHBhZ2UuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgNTBgLiBcbiAgICAgKi9cbiAgICBwYWdlU2l6ZTogbnVtYmVyO1xufVxuXG4vKipcbiAqIEFuIGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBnZXQgdGhlIGRhdGEgc291cmNlIGZyb20gYmFja2VuZC4gXG4gKiBUaGUgZ2VuZXJpYyBwYXJhbWV0ZXIgVCBhbHdheXMgcmVmZXJzIHRvIHRoZSB0eXBlIG9mIGRhdGEgdGhhdCBpdCBpcyBkZWFsaW5nIHdpdGguIFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tlbmREYXRhU291cmNlRnVuY3Rpb248VD5cbntcbiAgICAocGFnZVJlcXVlc3Q6IFBhZ2VSZXF1ZXN0KTogT2JzZXJ2YWJsZTxQYWdlPFQ+Pjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBkYXRhIG9iamVjdCBtYXRjaGVzIHRoZSBkYXRhIHNvdXJjZSdzIGZpbHRlciBzdHJpbmcuIEJ5IGRlZmF1bHQsIGVhY2ggZGF0YSBvYmplY3QgXG4gKiBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgb2YgaXRzIHByb3BlcnRpZXMgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsdGVyIGhhcyBcbiAqIGF0IGxlYXN0IG9uZSBvY2N1cnJlbmNlIGluIHRoYXQgc3RyaW5nLiBCeSBkZWZhdWx0LCB0aGUgZmlsdGVyIHN0cmluZyBoYXMgaXRzIHdoaXRlc3BhY2UgXG4gKiB0cmltbWVkIGFuZCB0aGUgbWF0Y2ggaXMgY2FzZS1pbnNlbnNpdGl2ZS4gXG4gKiBNYXkgYmUgb3ZlcnJpZGRlbiBmb3IgYSBjdXN0b20gaW1wbGVtZW50YXRpb24gb2YgZmlsdGVyIG1hdGNoaW5nLiBcbiAqIEBwYXJhbSBkYXRhIERhdGEgb2JqZWN0IHVzZWQgdG8gY2hlY2sgYWdhaW5zdCB0aGUgZmlsdGVyLiBcbiAqIEBwYXJhbSBmaWx0ZXIgRmlsdGVyIHN0cmluZyB0aGF0IGhhcyBiZWVuIHNldCBvbiB0aGUgZGF0YSBzb3VyY2UuIFxuICogQHJldHVybiBSZXR1cm5zIHRydWUgd2hldGhlciB0aGUgZmlsdGVyIG1hdGNoZXMgYWdhaW5zdCB0aGUgZGF0YTsgb3RoZXJ3aXNlLCBmYWxzZS4gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJQcmVkaWNhdGU8VD4oZGF0YTogVCwgZmlsdGVyOiBzdHJpbmcpOiBib29sZWFuXG57XG4gICAgLyogVHJhbnNmb3JtcyB0aGUgZGF0YSBpbnRvIGEgbG93ZXJjYXNlIHN0cmluZyBvZiBhbGwgcHJvcGVydHkgdmFsdWVzLiAqL1xuICAgIGNvbnN0IGRhdGFTdHI6IHN0cmluZyA9IE9iamVjdC5rZXlzKGRhdGEpLnJlZHVjZSgoXG4gICAgICAgIChjdXJyZW50VGVybSwga2V5KTogc3RyaW5nID0+IHtcbiAgICAgICAgICAgIC8qIFVzZSBhbiBvYnNjdXJlIFVuaWNvZGUgY2hhcmFjdGVyIHRvIGRlbGltaXQgdGhlIHdvcmRzIGluIHRoZSBjb25jYXRlbmF0ZWQgc3RyaW5nLiBcbiAgICAgICAgICAgICAqIFRoaXMgYXZvaWRzIG1hdGNoZXMgd2hlcmUgdGhlIHZhbHVlcyBvZiB0d28gY29sdW1ucyBjb21iaW5lZCB3aWxsIG1hdGNoIHRoZSB1c2VyJ3MgcXVlcnkgXG4gICAgICAgICAgICAgKiAoZS5nLiBgRmx1dGVgIGFuZCBgU3RvcGAgd2lsbCBtYXRjaCBgVGVzdGApLiBUaGUgY2hhcmFjdGVyIGlzIGludGVuZGVkIHRvIGJlIHNvbWV0aGluZyBcbiAgICAgICAgICAgICAqIHRoYXQgaGFzIGEgdmVyeSBsb3cgY2hhbmNlIG9mIGJlaW5nIHR5cGVkIGluIGJ5IHNvbWVib2R5IGluIGEgdGV4dCBmaWVsZC4gVGhpcyBvbmUgaW4gXG4gICAgICAgICAgICAgKiBwYXJ0aWN1bGFyIGlzIFwiV2hpdGUgdXAtcG9pbnRpbmcgdHJpYW5nbGUgd2l0aCBkb3RcIiBmcm9tIFxuICAgICAgICAgICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9Vbmljb2RlX2NoYXJhY3RlcnMuICovXG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFRlcm0gKyBkYXRhW2tleV0gKyAn4pesJztcbiAgICAgICAgfSksICcnKS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgLyogVHJhbnNmb3JtcyB0aGUgZmlsdGVyIGJ5IGNvbnZlcnRpbmcgaXQgdG8gbG93ZXJjYXNlIGFuZCByZW1vdmluZyB3aGl0ZXNwYWNlLiAqL1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkRmlsdGVyOiBzdHJpbmcgPSBmaWx0ZXIudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgICByZXR1cm4gKGRhdGFTdHIuaW5kZXhPZih0cmFuc2Zvcm1lZEZpbHRlcikgIT0gLTEpO1xufVxuXG4vKipcbiAqIERhdGEgYWNjZXNzb3IgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIGZvciBhY2Nlc3NpbmcgZGF0YSBwcm9wZXJ0aWVzIGZvciBzb3J0aW5nIHRocm91Z2ggXG4gKiB0aGUgZGVmYXVsdCBgc29ydERhdGFgIGZ1bmN0aW9uLiBcbiAqIFRoaXMgZGVmYXVsdCBmdW5jdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHNvcnQgaGVhZGVyIElEcyAod2hpY2ggZGVmYXVsdHMgdG8gdGhlIGNvbHVtbiBuYW1lKSBcbiAqIG1hdGNoZXMgdGhlIGRhdGEncyBwcm9wZXJ0aWVzIChlLmcuIGNvbHVtbiBYeXogcmVwcmVzZW50cyBkYXRhWydYeXonXSkuIFxuICogTWF5IGJlIG92ZXJyaWRkZW4gZm9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIG9mIGRpZmZlcmVudCBiZWhhdmlvci4gXG4gKiBAcGFyYW0gZGF0YSBEYXRhIG9iamVjdCB0aGF0IGlzIGJlaW5nIGFjY2Vzc2VkLiBcbiAqIEBwYXJhbSBzb3J0SGVhZGVySWQgVGhlIG5hbWUgb2YgdGhlIGNvbHVtbiB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGEuIFxuICovXG5leHBvcnQgZnVuY3Rpb24gc29ydGluZ0RhdGFBY2Nlc3NvcjxUPihkYXRhOiBULCBzb3J0SGVhZGVySWQ6IHN0cmluZyk6IHN0cmluZyB8IG51bWJlclxue1xuICAgIGNvbnN0IHZhbHVlOiBhbnkgPSBkYXRhW3NvcnRIZWFkZXJJZF07XG5cbiAgICBpZiAoX2lzTnVtYmVyVmFsdWUodmFsdWUpKVxuICAgIHtcbiAgICAgICAgY29uc3QgbnVtYmVyVmFsdWU6IG51bWJlciA9IE51bWJlcih2YWx1ZSk7XG5cbiAgICAgICAgLyogTnVtYmVycyBiZXlvbmQgYE1BWF9TQUZFX0lOVEVHRVJgIGNhbid0IGJlIGNvbXBhcmVkIHJlbGlhYmx5IHNvIHdlIFxuICAgICAgICAgKiBsZWF2ZSB0aGVtIGFzIHN0cmluZ3MuIEZvciBtb3JlIGluZm86IGh0dHBzOi8vZ29vLmdsL3k1dmJTZy4gKi9cbiAgICAgICAgcmV0dXJuIChudW1iZXJWYWx1ZSA8IE1BWF9TQUZFX0lOVEVHRVIgPyBudW1iZXJWYWx1ZSA6IHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogR2V0cyBhIHNvcnRlZCBjb3B5IG9mIHRoZSBkYXRhIGFycmF5IGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGUgYE1hdFNvcnRgLiBDYWxsZWQgXG4gKiBhZnRlciBjaGFuZ2VzIGFyZSBtYWRlIHRvIHRoZSBmaWx0ZXJlZCBkYXRhIG9yIHdoZW4gc29ydCBjaGFuZ2VzIGFyZSBlbWl0dGVkIGZyb20gYE1hdFNvcnRgLiBcbiAqIEJ5IGRlZmF1bHQsIHRoZSBmdW5jdGlvbiByZXRyaWV2ZXMgdGhlIGFjdGl2ZSBzb3J0IGFuZCBpdHMgZGlyZWN0aW9uIGFuZCBjb21wYXJlcyBkYXRhIFxuICogYnkgcmV0cmlldmluZyBkYXRhIHVzaW5nIHRoZSBgc29ydGluZ0RhdGFBY2Nlc3NvcmAuIFxuICogTWF5IGJlIG92ZXJyaWRkZW4gZm9yIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uIG9mIGRhdGEgb3JkZXJpbmcuIFxuICogQHBhcmFtIGRhdGEgVGhlIGFycmF5IG9mIGRhdGEgdGhhdCBzaG91bGQgYmUgc29ydGVkLiBcbiAqIEBwYXJhbSBzb3J0IFRoZSBjb25uZWN0ZWQgYE1hdFNvcnRgIHRoYXQgaG9sZHMgdGhlIGN1cnJlbnQgc29ydCBzdGF0ZS4gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzb3J0RGF0YTxUPihkYXRhOiBUW10sIHNvcnQ6IFNvcnQpOiBUW11cbntcbiAgICBjb25zdCBhY3RpdmU6IHN0cmluZyA9IHNvcnQuYWN0aXZlO1xuICAgIGNvbnN0IGRpcmVjdGlvbjogU29ydERpcmVjdGlvbiA9IHNvcnQuZGlyZWN0aW9uIGFzIFNvcnREaXJlY3Rpb247XG5cbiAgICBpZiAoKCFhY3RpdmUpIHx8IChkaXJlY3Rpb24gPT0gU29ydERpcmVjdGlvbi5vcmlnKSkgcmV0dXJuIGRhdGE7XG5cbiAgICByZXR1cm4gZGF0YS5zb3J0KChhOiBULCBiOiBUKTogbnVtYmVyID0+IHtcbiAgICAgICAgbGV0IHZhbHVlQTogc3RyaW5nIHwgbnVtYmVyID0gc29ydGluZ0RhdGFBY2Nlc3NvcihhLCBhY3RpdmUpO1xuICAgICAgICBsZXQgdmFsdWVCOiBzdHJpbmcgfCBudW1iZXIgPSBzb3J0aW5nRGF0YUFjY2Vzc29yKGIsIGFjdGl2ZSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGJvdGggYHZhbHVlQWAgYW5kIGB2YWx1ZUJgIGV4aXN0ICh0cnV0aHkpLCB0aGVuIGNvbXBhcmUgdGhlIHR3by4gT3RoZXJ3aXNlLCBjaGVja3MgaWYgXG4gICAgICAgICAqIG9uZSB2YWx1ZSBleGlzdHMgd2hpbGUgdGhlIG90aGVyIGRvZXNuJ3QuIEluIHRoaXMgY2FzZSwgZXhpc3RpbmcgdmFsdWUgc2hvdWxkIGNvbWUgbGFzdC4gXG4gICAgICAgICAqIFRoaXMgYXZvaWRzIGluY29uc2lzdGVudCByZXN1bHRzIHdoZW4gY29tcGFyaW5nIHZhbHVlcyB0byB1bmRlZmluZWQvbnVsbC4gXG4gICAgICAgICAqIElmIG5laXRoZXIgdmFsdWUgZXhpc3RzLCByZXR1cm5zIDAgKGVxdWFsKS4gXG4gICAgICAgICAqL1xuXG4gICAgICAgIGxldCBjb21wYXJhdG9yUmVzdWx0OiBudW1iZXIgPSAwO1xuXG4gICAgICAgIGlmICgodmFsdWVBICE9IG51bGwpICYmICh2YWx1ZUIgIT0gbnVsbCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIC8qIENoZWNrcyBpZiBvbmUgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBvdGhlciBvbmU7IGlmIGVxdWFsLCBgY29tcGFyYXRvclJlc3VsdGAgc2hvdWxkIHJlbWFpbiAwLiAqL1xuXG4gICAgICAgICAgICBpZiAodmFsdWVBID4gdmFsdWVCKSBjb21wYXJhdG9yUmVzdWx0ID0gMTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlQSA8IHZhbHVlQikgY29tcGFyYXRvclJlc3VsdCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlQSAhPSBudWxsKSBjb21wYXJhdG9yUmVzdWx0ID0gMTtcbiAgICAgICAgZWxzZSBpZiAodmFsdWVCICE9IG51bGwpIGNvbXBhcmF0b3JSZXN1bHQgPSAtMTtcblxuICAgICAgICByZXR1cm4gY29tcGFyYXRvclJlc3VsdCAqICgoZGlyZWN0aW9uID09IFNvcnREaXJlY3Rpb24uYXNjKSA/IDEgOiAtMSk7XG4gICAgfSk7XG59XG4iXX0=