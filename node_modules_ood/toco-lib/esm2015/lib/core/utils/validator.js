/**
 * @fileoverview added by tsickle
 * Generated from: lib/core/utils/validator.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, Input } from '@angular/core';
import { NG_VALIDATORS } from '@angular/forms';
/**
 * Represents a class that contains a boolean property named `required`.
 * @record
 */
export function RequiredProperty() { }
if (false) {
    /**
     * Returns true if the control is required; otherwise, false.
     * @type {?}
     */
    RequiredProperty.prototype.required;
}
/**
 * \@description
 * Provides a set of extra validators that can be used by form controls.
 *
 * A validator is a function that processes a `FormControl` or collection of
 * controls and returns an error map or `null`. A `null` map means that validation has passed.
 *
 * @see [Form Validation](/guide/form-validation)
 */
export class ExtraValidators {
    /**
     * \@description
     * Validator that requires the length of the control's value to be equal to the
     * provided length. It assumes that the control's value is of string type.
     * This validator is used with Reactive Forms; if you want to use
     * an equivalent validator with Template-driven Form you must use the `equalLength` attribute.
     *
     * \@usageNotes
     *
     * ### Validates that the field has a length of 4 characters:
     *
     * ```typescript
     * const control = new FormControl('ng', ExtraValidators.equalLength(4));
     *
     * console.log(control.errors); // { equalLength: { requiredLength: 4, actualLength: 2 } }
     * ```
     *
     * ```html
     * <input name="firstName" ngModel equallength="4">
     * ```
     *
     * @param {?} equalLength
     * @return {?} A validator function that returns an error map with the `equalLength`
     * if the validation check fails, otherwise `null`.
     */
    static equalLength(equalLength) {
        /** @type {?} */
        const res = (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            /** @type {?} */
            const len = control.value ? control.value.length : 0;
            return ((len != 0) && (len != equalLength))
                ? { 'equalLength': { 'requiredLength': equalLength, 'actualLength': len } }
                : null;
        });
        return res;
    }
    /**
     * \@description
     * Validator that is applied to `FormArray` controls. It requires that the amount of
     * `FormArray`'s child controls to be greater than or equal to the provided minimum length.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the `FormArray` field has a minimum of 2 child controls:
     *
     * ```typescript
     * const formArrayControl = new FormArray([new FormControl('ng')], ExtraValidators.minLength(2));
     *
     * console.log(formArrayControl.errors); // { minLength: { requiredLength: 2, actualLength: 1 } }
     * ```
     *
     * @param {?} minLength
     * @return {?} A validator function that returns an error map with the
     * `minLength` if the validation check fails, otherwise `null`.
     */
    static minLength(minLength) {
        /** @type {?} */
        const res = (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            /** @type {?} */
            const len = control.controls.length;
            return (len < minLength)
                ? { 'minLength': { 'requiredLength': minLength, 'actualLength': len } }
                : null;
        });
        return res;
    }
    /**
     * \@description
     * Validator that is applied to a control that has an array of child controls.
     * It receives an object that fits the `RequiredProperty` interface and an array of child controls.
     * The behavior of the validator is the following:
     * If the control's value is required, then
     *   - all child controls must be different of empty.
     * If the control's value is not required, then
     *   - all child controls can be empty.
     *   - if there is at least one child control not empty, then all child controls must be different of empty.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the control does not have an empty child control:
     *
     * ```typescript
     * const control = new FormGroup({
     *     'fg': (firstGroup = new FormControl('2049')),
     *     'sg': (secondGroup = new FormControl(''))},
     *     ExtraValidators.requiredAndNotEmpty(this, [firstGroup, secondGroup]));
     *
     * console.log(control.errors); // { requiredAndNotEmpty: { required: true, pos: 1 } }
     * ```
     *
     * @param {?} requiredProperty
     * @param {?} childControls
     * @return {?} A validator function that returns an error map with the `requiredAndNotEmpty`
     * if the validation check fails, otherwise `null`.
     */
    static requiredAndNotEmpty(requiredProperty, childControls) {
        /** @type {?} */
        const res = (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            /** @type {?} */
            let i = 0;
            /** @type {?} */
            let controlsGroupLength = childControls.length;
            if (requiredProperty.required) {
                /* Only iterates to the first empty element. */
                for (; i < controlsGroupLength; i++) {
                    if (!childControls[i].value)
                        break;
                }
                return (i == controlsGroupLength)
                    ? null
                    : { 'requiredAndNotEmpty': { 'required': true, 'pos': i } };
            }
            else {
                /** @type {?} */
                let hasControlNotEmpty = false;
                /** @type {?} */
                let minEmptyPos = -1;
                /* Iterates to the first empty element. */
                for (; i < controlsGroupLength; i++) {
                    if (childControls[i].value) {
                        if (minEmptyPos != -1)
                            break;
                        hasControlNotEmpty = true;
                    }
                    else {
                        if (minEmptyPos == -1)
                            minEmptyPos = i;
                        if (hasControlNotEmpty)
                            break;
                    }
                }
                return (i == controlsGroupLength)
                    ? null
                    : { 'requiredAndNotEmpty': { 'required': true, 'pos': minEmptyPos } };
            }
        });
        return res;
    }
    /**
     * \@description
     * Validator that requires the control's value pass an ISSN validation test (confirm the check digit).
     * Assumes that the code (control's value) is a string of length 11, with the form 'XXXX – XXXX'.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
     *
     * ```typescript
     * const control = new FormControl('2049 – 3635', ExtraValidators.issnConfirmCheckDigitOneField(11));
     *
     * console.log(control.errors); // { issnConfirmCheckDigitOneField: true }
     * ```
     *
     * @param {?} codeLength
     * @return {?} A validator function that returns an error map with the `issnConfirmCheckDigitOneField`
     * if the validation check fails, otherwise `null`.
     */
    static issnConfirmCheckDigitOneField(codeLength) {
        /** @type {?} */
        const res = (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            if (control.value.length == codeLength) {
                /** @type {?} */
                let code = control.value;
                /** @type {?} */
                let result = (code.charCodeAt(0) - 48) * 8;
                result += (code.charCodeAt(1) - 48) * 7;
                result += (code.charCodeAt(2) - 48) * 6;
                result += (code.charCodeAt(3) - 48) * 5;
                /* code[4] = ' ', code[5] = '–', code[6] = ' '. */
                result += (code.charCodeAt(7) - 48) * 4;
                result += (code.charCodeAt(8) - 48) * 3;
                result += (code.charCodeAt(9) - 48) * 2;
                result += ((code[10] == 'x') || (code[10] == 'X')) ? 10 : code.charCodeAt(10) - 48;
                return (result % 11)
                    ? { 'issnConfirmCheckDigitOneField': true }
                    : null;
            }
            return null;
        });
        return res;
    }
    /**
     * \@description
     * Validator that requires the control's value passes an ISSN validation test (confirms the check digit).
     * The ISSN value is divided in two groups, therefore the control has two child controls and they are
     * arguments of the validator method. It assumes that the control's value is of string type.
     * The validator exists only as a function and not as a directive.
     *
     * \@usageNotes
     *
     * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
     *
     * ```typescript
     * const control = new FormGroup({
     *     'fg': (firstGroup = new FormControl('2049')),
     *     'sg': (secondGroup = new FormControl('3635'))},
     *     ExtraValidators.issnConfirmCheckDigitTwoField(firstGroup, secondGroup, 4));
     *
     * console.log(control.errors); // { issnConfirmCheckDigitTwoField: true }
     * ```
     *
     * @param {?} firstGroup
     * @param {?} secondGroup
     * @param {?} groupLength
     * @return {?} A validator function that returns an error map with the `issnConfirmCheckDigitTwoField`
     * if the validation check fails, otherwise `null`.
     */
    static issnConfirmCheckDigitTwoField(firstGroup, secondGroup, groupLength) {
        /** @type {?} */
        const res = (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            if ((firstGroup.value.length == groupLength) && (secondGroup.value.length == groupLength)) {
                /** @type {?} */
                let groupValue = firstGroup.value;
                /** @type {?} */
                let result = (groupValue.charCodeAt(0) - 48) * 8;
                result += (groupValue.charCodeAt(1) - 48) * 7;
                result += (groupValue.charCodeAt(2) - 48) * 6;
                result += (groupValue.charCodeAt(3) - 48) * 5;
                result += ((groupValue = secondGroup.value).charCodeAt(0) - 48) * 4;
                result += (groupValue.charCodeAt(1) - 48) * 3;
                result += (groupValue.charCodeAt(2) - 48) * 2;
                result += ((groupValue[3] == 'x') || (groupValue[3] == 'X')) ? 10 : groupValue.charCodeAt(3) - 48;
                return (result % 11)
                    ? { 'issnConfirmCheckDigitTwoField': true }
                    : null;
            }
            return null;
        });
        return res;
    }
    /**
     * @param {?} internalFormGroup
     * @return {?}
     */
    static issnValidator(internalFormGroup) {
        /** @type {?} */
        const res = (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            return (!internalFormGroup.valid)
                ? { 'issnValidator': { 'requiredValid': internalFormGroup.valid } }
                : null;
        });
        return res;
    }
}
/**
 * \@description
 * A directive that represents a validator that requires the length of the control's value
 * to be equal to the provided length. The control must be marked with the `equalLength` attribute.
 * The directive is provided with the `NG_VALIDATORS` mult-provider list.
 * This validator is used with Template-driven Form; if you want to use an equivalent validator
 * with Reactive Forms you must use the `ExtraValidators.equalLength` method.
 *
 * \@usageNotes
 *
 * ### Validates that the field has a length of 4 characters:
 *
 * The following example shows how to add an equal length validator to an input attached to an
 * ngModel binding.
 *
 * ```html
 * <input name="firstName" ngModel equallength="4">
 * ```
 */
export class EqualLengthDirective {
    /**
     * \@description
     * A lifecycle hook method that is called when the directive's inputs change. For internal use only.
     *
     * @param {?} changes An object of key/value pairs for the set of changed inputs.
     * @return {?}
     */
    ngOnChanges(changes) {
        if ('equalLength' in changes) {
            this._validator = ExtraValidators.equalLength(parseInt(this.equalLength, 10));
            if (this._onChange)
                this._onChange();
        }
    }
    /**
     * \@description
     * Method that performs synchronous validation against the provided control. It requires the length
     * of the control's value to be equal to the provided `equalLength`.
     *
     * @param {?} control The control to validate against.
     *
     * @return {?} A map of validation errors if validation fails; otherwise, `null`.
     */
    validate(control) {
        return (this.equalLength)
            ? this._validator(control)
            : null;
    }
    /**
     * \@description
     * Registers a callback function to call when the validator inputs change.
     *
     * @param {?} fn The callback function to register.
     * @return {?}
     */
    registerOnValidatorChange(fn) {
        this._onChange = fn;
    }
}
EqualLengthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[equalLength]',
                providers: [{
                        provide: NG_VALIDATORS,
                        useExisting: EqualLengthDirective,
                        multi: true
                    }]
            },] }
];
EqualLengthDirective.propDecorators = {
    equalLength: [{ type: Input }]
};
if (false) {
    /**
     * \@description
     * Input variable that contains the length to check.
     * @type {?}
     */
    EqualLengthDirective.prototype.equalLength;
    /**
     * @type {?}
     * @private
     */
    EqualLengthDirective.prototype._validator;
    /**
     * @type {?}
     * @private
     */
    EqualLengthDirective.prototype._onChange;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdG9yLmpzIiwic291cmNlUm9vdCI6Im5nOi8vdG9jby1saWIvIiwic291cmNlcyI6WyJsaWIvY29yZS91dGlscy92YWxpZGF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQSxPQUFPLEVBQUUsU0FBUyxFQUFhLEtBQUssRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDM0UsT0FBTyxFQUEwRSxhQUFhLEVBQXdCLE1BQU0sZ0JBQWdCLENBQUM7Ozs7O0FBSzdJLHNDQU1DOzs7Ozs7SUFERyxvQ0FBMkI7Ozs7Ozs7Ozs7O0FBWS9CLE1BQU0sT0FBTyxlQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTBCakIsTUFBTSxDQUFDLFdBQVcsQ0FBQyxXQUFtQjs7Y0FFbkMsR0FBRzs7OztRQUFHLENBQUMsT0FBd0IsRUFBMkIsRUFBRTs7a0JBQ3hELEdBQUcsR0FBVyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUU1RCxPQUFPLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksV0FBVyxDQUFDLENBQUM7Z0JBQ3ZDLENBQUMsQ0FBQyxFQUFFLGFBQWEsRUFBRSxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxjQUFjLEVBQUUsR0FBRyxFQUFFLEVBQUU7Z0JBQzNFLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFDZixDQUFDLENBQUE7UUFFRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXFCTSxNQUFNLENBQUMsU0FBUyxDQUFDLFNBQWlCOztjQUUvQixHQUFHOzs7O1FBQUcsQ0FBQyxPQUFrQixFQUEyQixFQUFFOztrQkFDbEQsR0FBRyxHQUFXLE9BQU8sQ0FBQyxRQUFRLENBQUMsTUFBTTtZQUUzQyxPQUFPLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQztnQkFDcEIs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TiwyQ0FDMkI7Ozs7O0lBRTNCLDBDQUFnQzs7Ozs7SUFDaEMseUNBQThCIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBEaXJlY3RpdmUsIE9uQ2hhbmdlcywgSW5wdXQsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgRm9ybUNvbnRyb2wsIFZhbGlkYXRvckZuLCBWYWxpZGF0aW9uRXJyb3JzLCBWYWxpZGF0b3IsIE5HX1ZBTElEQVRPUlMsIEZvcm1Hcm91cCwgRm9ybUFycmF5IH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjbGFzcyB0aGF0IGNvbnRhaW5zIGEgYm9vbGVhbiBwcm9wZXJ0eSBuYW1lZCBgcmVxdWlyZWRgLiBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXF1aXJlZFByb3BlcnR5XG57XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb250cm9sIGlzIHJlcXVpcmVkOyBvdGhlcndpc2UsIGZhbHNlLiBcbiAgICAgKi9cbiAgICByZWFkb25seSByZXF1aXJlZDogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFByb3ZpZGVzIGEgc2V0IG9mIGV4dHJhIHZhbGlkYXRvcnMgdGhhdCBjYW4gYmUgdXNlZCBieSBmb3JtIGNvbnRyb2xzLiBcbiAqXG4gKiBBIHZhbGlkYXRvciBpcyBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEgYEZvcm1Db250cm9sYCBvciBjb2xsZWN0aW9uIG9mIFxuICogY29udHJvbHMgYW5kIHJldHVybnMgYW4gZXJyb3IgbWFwIG9yIGBudWxsYC4gQSBgbnVsbGAgbWFwIG1lYW5zIHRoYXQgdmFsaWRhdGlvbiBoYXMgcGFzc2VkLiBcbiAqXG4gKiBAc2VlIFtGb3JtIFZhbGlkYXRpb25dKC9ndWlkZS9mb3JtLXZhbGlkYXRpb24pXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHRyYVZhbGlkYXRvcnNcbntcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgbGVuZ3RoIG9mIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgZXF1YWwgdG8gdGhlIFxuICAgICAqIHByb3ZpZGVkIGxlbmd0aC4gSXQgYXNzdW1lcyB0aGF0IHRoZSBjb250cm9sJ3MgdmFsdWUgaXMgb2Ygc3RyaW5nIHR5cGUuIFxuICAgICAqIFRoaXMgdmFsaWRhdG9yIGlzIHVzZWQgd2l0aCBSZWFjdGl2ZSBGb3JtczsgaWYgeW91IHdhbnQgdG8gdXNlIFxuICAgICAqIGFuIGVxdWl2YWxlbnQgdmFsaWRhdG9yIHdpdGggVGVtcGxhdGUtZHJpdmVuIEZvcm0geW91IG11c3QgdXNlIHRoZSBgZXF1YWxMZW5ndGhgIGF0dHJpYnV0ZS4gXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlcyB0aGF0IHRoZSBmaWVsZCBoYXMgYSBsZW5ndGggb2YgNCBjaGFyYWN0ZXJzOiBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHQgXG4gICAgICogY29uc3QgY29udHJvbCA9IG5ldyBGb3JtQ29udHJvbCgnbmcnLCBFeHRyYVZhbGlkYXRvcnMuZXF1YWxMZW5ndGgoNCkpOyBcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGNvbnRyb2wuZXJyb3JzKTsgLy8geyBlcXVhbExlbmd0aDogeyByZXF1aXJlZExlbmd0aDogNCwgYWN0dWFsTGVuZ3RoOiAyIH0gfSBcbiAgICAgKiBgYGAgXG4gICAgICpcbiAgICAgKiBgYGBodG1sIFxuICAgICAqIDxpbnB1dCBuYW1lPVwiZmlyc3ROYW1lXCIgbmdNb2RlbCBlcXVhbGxlbmd0aD1cIjRcIj4gXG4gICAgICogYGBgIFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZSBgZXF1YWxMZW5ndGhgIFxuICAgICAqIGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGVxdWFsTGVuZ3RoKGVxdWFsTGVuZ3RoOiBudW1iZXIpOiBWYWxpZGF0b3JGblxuICAgIHtcbiAgICAgICAgY29uc3QgcmVzID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbjogbnVtYmVyID0gY29udHJvbC52YWx1ZSA/IGNvbnRyb2wudmFsdWUubGVuZ3RoIDogMDtcblxuICAgICAgICAgICAgcmV0dXJuICgobGVuICE9IDApICYmIChsZW4gIT0gZXF1YWxMZW5ndGgpKSBcbiAgICAgICAgICAgICAgICA/IHsgJ2VxdWFsTGVuZ3RoJzogeyAncmVxdWlyZWRMZW5ndGgnOiBlcXVhbExlbmd0aCwgJ2FjdHVhbExlbmd0aCc6IGxlbiB9IH0gXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVmFsaWRhdG9yIHRoYXQgaXMgYXBwbGllZCB0byBgRm9ybUFycmF5YCBjb250cm9scy4gSXQgcmVxdWlyZXMgdGhhdCB0aGUgYW1vdW50IG9mIFxuXHQgKiBgRm9ybUFycmF5YCdzIGNoaWxkIGNvbnRyb2xzIHRvIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgcHJvdmlkZWQgbWluaW11bSBsZW5ndGguIFxuXHQgKiBUaGUgdmFsaWRhdG9yIGV4aXN0cyBvbmx5IGFzIGEgZnVuY3Rpb24gYW5kIG5vdCBhcyBhIGRpcmVjdGl2ZS4gXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlcyB0aGF0IHRoZSBgRm9ybUFycmF5YCBmaWVsZCBoYXMgYSBtaW5pbXVtIG9mIDIgY2hpbGQgY29udHJvbHM6IFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdCBcbiAgICAgKiBjb25zdCBmb3JtQXJyYXlDb250cm9sID0gbmV3IEZvcm1BcnJheShbbmV3IEZvcm1Db250cm9sKCduZycpXSwgRXh0cmFWYWxpZGF0b3JzLm1pbkxlbmd0aCgyKSk7IFxuICAgICAqXG5cdCAqIGNvbnNvbGUubG9nKGZvcm1BcnJheUNvbnRyb2wuZXJyb3JzKTsgLy8geyBtaW5MZW5ndGg6IHsgcmVxdWlyZWRMZW5ndGg6IDIsIGFjdHVhbExlbmd0aDogMSB9IH0gXG4gICAgICogYGBgIFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZSBcbiAgICAgKiBgbWluTGVuZ3RoYCBpZiB0aGUgdmFsaWRhdGlvbiBjaGVjayBmYWlscywgb3RoZXJ3aXNlIGBudWxsYC4gXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBtaW5MZW5ndGgobWluTGVuZ3RoOiBudW1iZXIpOiBWYWxpZGF0b3JGblxuICAgIHtcbiAgICAgICAgY29uc3QgcmVzID0gKGNvbnRyb2w6IEZvcm1BcnJheSk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbjogbnVtYmVyID0gY29udHJvbC5jb250cm9scy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHJldHVybiAobGVuIDwgbWluTGVuZ3RoKSBcbiAgICAgICAgICAgICAgICA/IHsgJ21pbkxlbmd0aCc6IHsgJ3JlcXVpcmVkTGVuZ3RoJzogbWluTGVuZ3RoLCAnYWN0dWFsTGVuZ3RoJzogbGVuIH0gfSBcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCBpcyBhcHBsaWVkIHRvIGEgY29udHJvbCB0aGF0IGhhcyBhbiBhcnJheSBvZiBjaGlsZCBjb250cm9scy4gXG4gICAgICogSXQgcmVjZWl2ZXMgYW4gb2JqZWN0IHRoYXQgZml0cyB0aGUgYFJlcXVpcmVkUHJvcGVydHlgIGludGVyZmFjZSBhbmQgYW4gYXJyYXkgb2YgY2hpbGQgY29udHJvbHMuIFxuICAgICAqIFRoZSBiZWhhdmlvciBvZiB0aGUgdmFsaWRhdG9yIGlzIHRoZSBmb2xsb3dpbmc6IFxuICAgICAqIElmIHRoZSBjb250cm9sJ3MgdmFsdWUgaXMgcmVxdWlyZWQsIHRoZW4gXG4gICAgICogICAtIGFsbCBjaGlsZCBjb250cm9scyBtdXN0IGJlIGRpZmZlcmVudCBvZiBlbXB0eS4gXG4gICAgICogSWYgdGhlIGNvbnRyb2wncyB2YWx1ZSBpcyBub3QgcmVxdWlyZWQsIHRoZW4gXG4gICAgICogICAtIGFsbCBjaGlsZCBjb250cm9scyBjYW4gYmUgZW1wdHkuIFxuICAgICAqICAgLSBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgY2hpbGQgY29udHJvbCBub3QgZW1wdHksIHRoZW4gYWxsIGNoaWxkIGNvbnRyb2xzIG11c3QgYmUgZGlmZmVyZW50IG9mIGVtcHR5LiBcbiAgICAgKiBUaGUgdmFsaWRhdG9yIGV4aXN0cyBvbmx5IGFzIGEgZnVuY3Rpb24gYW5kIG5vdCBhcyBhIGRpcmVjdGl2ZS4gXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlcyB0aGF0IHRoZSBjb250cm9sIGRvZXMgbm90IGhhdmUgYW4gZW1wdHkgY2hpbGQgY29udHJvbDogXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0IFxuICAgICAqIGNvbnN0IGNvbnRyb2wgPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgKiAgICAgJ2ZnJzogKGZpcnN0R3JvdXAgPSBuZXcgRm9ybUNvbnRyb2woJzIwNDknKSksIFxuICAgICAqICAgICAnc2cnOiAoc2Vjb25kR3JvdXAgPSBuZXcgRm9ybUNvbnRyb2woJycpKX0sIFxuICAgICAqICAgICBFeHRyYVZhbGlkYXRvcnMucmVxdWlyZWRBbmROb3RFbXB0eSh0aGlzLCBbZmlyc3RHcm91cCwgc2Vjb25kR3JvdXBdKSk7IFxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7IHJlcXVpcmVkQW5kTm90RW1wdHk6IHsgcmVxdWlyZWQ6IHRydWUsIHBvczogMSB9IH0gXG4gICAgICogYGBgIFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZSBgcmVxdWlyZWRBbmROb3RFbXB0eWAgXG4gICAgICogaWYgdGhlIHZhbGlkYXRpb24gY2hlY2sgZmFpbHMsIG90aGVyd2lzZSBgbnVsbGAuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgcmVxdWlyZWRBbmROb3RFbXB0eShyZXF1aXJlZFByb3BlcnR5OiBSZXF1aXJlZFByb3BlcnR5LCBjaGlsZENvbnRyb2xzOiBGb3JtQ29udHJvbFtdKTogVmFsaWRhdG9yRm5cbiAgICB7XG4gICAgICAgIGNvbnN0IHJlcyA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgICAgICAgICBsZXQgaTogbnVtYmVyID0gMDtcbiAgICAgICAgICAgIGxldCBjb250cm9sc0dyb3VwTGVuZ3RoOiBudW1iZXIgPSBjaGlsZENvbnRyb2xzLmxlbmd0aDtcblxuICAgICAgICAgICAgaWYgKHJlcXVpcmVkUHJvcGVydHkucmVxdWlyZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLyogT25seSBpdGVyYXRlcyB0byB0aGUgZmlyc3QgZW1wdHkgZWxlbWVudC4gKi9cbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGNvbnRyb2xzR3JvdXBMZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRDb250cm9sc1tpXS52YWx1ZSkgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChpID09IGNvbnRyb2xzR3JvdXBMZW5ndGgpIFxuICAgICAgICAgICAgICAgICAgICA/IG51bGwgXG4gICAgICAgICAgICAgICAgICAgIDogeyAncmVxdWlyZWRBbmROb3RFbXB0eSc6IHsgJ3JlcXVpcmVkJzogdHJ1ZSwgJ3Bvcyc6IGkgfSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxldCBoYXNDb250cm9sTm90RW1wdHk6IGJvb2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBsZXQgbWluRW1wdHlQb3M6IG51bWJlciA9IC0xO1xuXG4gICAgICAgICAgICAgICAgLyogSXRlcmF0ZXMgdG8gdGhlIGZpcnN0IGVtcHR5IGVsZW1lbnQuICovXG4gICAgICAgICAgICAgICAgZm9yICg7IGkgPCBjb250cm9sc0dyb3VwTGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRDb250cm9sc1tpXS52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pbkVtcHR5UG9zICE9IC0xKSBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NvbnRyb2xOb3RFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluRW1wdHlQb3MgPT0gLTEpIG1pbkVtcHR5UG9zID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNDb250cm9sTm90RW1wdHkpIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChpID09IGNvbnRyb2xzR3JvdXBMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgICAgICAgICA6IHsgJ3JlcXVpcmVkQW5kTm90RW1wdHknOiB7ICdyZXF1aXJlZCc6IHRydWUsICdwb3MnOiBtaW5FbXB0eVBvcyB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWYWxpZGF0b3IgdGhhdCByZXF1aXJlcyB0aGUgY29udHJvbCdzIHZhbHVlIHBhc3MgYW4gSVNTTiB2YWxpZGF0aW9uIHRlc3QgKGNvbmZpcm0gdGhlIGNoZWNrIGRpZ2l0KS4gXG4gICAgICogQXNzdW1lcyB0aGF0IHRoZSBjb2RlIChjb250cm9sJ3MgdmFsdWUpIGlzIGEgc3RyaW5nIG9mIGxlbmd0aCAxMSwgd2l0aCB0aGUgZm9ybSAnWFhYWCDigJMgWFhYWCcuIFxuICAgICAqIFRoZSB2YWxpZGF0b3IgZXhpc3RzIG9ubHkgYXMgYSBmdW5jdGlvbiBhbmQgbm90IGFzIGEgZGlyZWN0aXZlLiBcbiAgICAgKlxuICAgICAqIEB1c2FnZU5vdGVzXG4gICAgICpcbiAgICAgKiAjIyMgVmFsaWRhdGVzIHRoYXQgdGhlIGZpZWxkIG1hdGNoZXMgYSB2YWxpZCBJU1NOIHBhdHRlcm4gKGNvbmZpcm1zIHRoZSBjaGVjayBkaWdpdCk6IFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdCBcbiAgICAgKiBjb25zdCBjb250cm9sID0gbmV3IEZvcm1Db250cm9sKCcyMDQ5IOKAkyAzNjM1JywgRXh0cmFWYWxpZGF0b3JzLmlzc25Db25maXJtQ2hlY2tEaWdpdE9uZUZpZWxkKDExKSk7IFxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coY29udHJvbC5lcnJvcnMpOyAvLyB7IGlzc25Db25maXJtQ2hlY2tEaWdpdE9uZUZpZWxkOiB0cnVlIH0gXG4gICAgICogYGBgIFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB2YWxpZGF0b3IgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVycm9yIG1hcCB3aXRoIHRoZSBgaXNzbkNvbmZpcm1DaGVja0RpZ2l0T25lRmllbGRgIFxuICAgICAqIGlmIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZhaWxzLCBvdGhlcndpc2UgYG51bGxgLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGlzc25Db25maXJtQ2hlY2tEaWdpdE9uZUZpZWxkKGNvZGVMZW5ndGg6IG51bWJlcik6IFZhbGlkYXRvckZuXG4gICAge1xuICAgICAgICBjb25zdCByZXMgPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wudmFsdWUubGVuZ3RoID09IGNvZGVMZW5ndGgpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGNvZGU6IHN0cmluZyA9IGNvbnRyb2wudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0OiBudW1iZXIgPSAoY29kZS5jaGFyQ29kZUF0KDApIC0gNDgpICogODtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gKGNvZGUuY2hhckNvZGVBdCgxKSAtIDQ4KSAqIDc7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IChjb2RlLmNoYXJDb2RlQXQoMikgLSA0OCkgKiA2O1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoY29kZS5jaGFyQ29kZUF0KDMpIC0gNDgpICogNTtcblxuICAgICAgICAgICAgICAgIC8qIGNvZGVbNF0gPSAnICcsIGNvZGVbNV0gPSAn4oCTJywgY29kZVs2XSA9ICcgJy4gKi9cblxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoY29kZS5jaGFyQ29kZUF0KDcpIC0gNDgpICogNDtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gKGNvZGUuY2hhckNvZGVBdCg4KSAtIDQ4KSAqIDM7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IChjb2RlLmNoYXJDb2RlQXQoOSkgLSA0OCkgKiAyO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoKGNvZGVbMTBdID09ICd4JykgfHwgKGNvZGVbMTBdID09ICdYJykpID8gMTAgOiBjb2RlLmNoYXJDb2RlQXQoMTApIC0gNDg7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlc3VsdCAlIDExKSBcbiAgICAgICAgICAgICAgICAgICAgPyB7ICdpc3NuQ29uZmlybUNoZWNrRGlnaXRPbmVGaWVsZCc6IHRydWUgfSBcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZhbGlkYXRvciB0aGF0IHJlcXVpcmVzIHRoZSBjb250cm9sJ3MgdmFsdWUgcGFzc2VzIGFuIElTU04gdmFsaWRhdGlvbiB0ZXN0IChjb25maXJtcyB0aGUgY2hlY2sgZGlnaXQpLiBcbiAgICAgKiBUaGUgSVNTTiB2YWx1ZSBpcyBkaXZpZGVkIGluIHR3byBncm91cHMsIHRoZXJlZm9yZSB0aGUgY29udHJvbCBoYXMgdHdvIGNoaWxkIGNvbnRyb2xzIGFuZCB0aGV5IGFyZSBcbiAgICAgKiBhcmd1bWVudHMgb2YgdGhlIHZhbGlkYXRvciBtZXRob2QuIEl0IGFzc3VtZXMgdGhhdCB0aGUgY29udHJvbCdzIHZhbHVlIGlzIG9mIHN0cmluZyB0eXBlLiBcbiAgICAgKiBUaGUgdmFsaWRhdG9yIGV4aXN0cyBvbmx5IGFzIGEgZnVuY3Rpb24gYW5kIG5vdCBhcyBhIGRpcmVjdGl2ZS4gXG4gICAgICpcbiAgICAgKiBAdXNhZ2VOb3Rlc1xuICAgICAqXG4gICAgICogIyMjIFZhbGlkYXRlcyB0aGF0IHRoZSBmaWVsZCBtYXRjaGVzIGEgdmFsaWQgSVNTTiBwYXR0ZXJuIChjb25maXJtcyB0aGUgY2hlY2sgZGlnaXQpOiBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHQgXG4gICAgICogY29uc3QgY29udHJvbCA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAqICAgICAnZmcnOiAoZmlyc3RHcm91cCA9IG5ldyBGb3JtQ29udHJvbCgnMjA0OScpKSwgXG4gICAgICogICAgICdzZyc6IChzZWNvbmRHcm91cCA9IG5ldyBGb3JtQ29udHJvbCgnMzYzNScpKX0sIFxuICAgICAqICAgICBFeHRyYVZhbGlkYXRvcnMuaXNzbkNvbmZpcm1DaGVja0RpZ2l0VHdvRmllbGQoZmlyc3RHcm91cCwgc2Vjb25kR3JvdXAsIDQpKTsgXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhjb250cm9sLmVycm9ycyk7IC8vIHsgaXNzbkNvbmZpcm1DaGVja0RpZ2l0VHdvRmllbGQ6IHRydWUgfSBcbiAgICAgKiBgYGAgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHZhbGlkYXRvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gZXJyb3IgbWFwIHdpdGggdGhlIGBpc3NuQ29uZmlybUNoZWNrRGlnaXRUd29GaWVsZGAgXG4gICAgICogaWYgdGhlIHZhbGlkYXRpb24gY2hlY2sgZmFpbHMsIG90aGVyd2lzZSBgbnVsbGAuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgaXNzbkNvbmZpcm1DaGVja0RpZ2l0VHdvRmllbGQoZmlyc3RHcm91cDogRm9ybUNvbnRyb2wsIHNlY29uZEdyb3VwOiBGb3JtQ29udHJvbCwgZ3JvdXBMZW5ndGg6IG51bWJlcik6IFZhbGlkYXRvckZuXG4gICAge1xuICAgICAgICBjb25zdCByZXMgPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgICAgICAgaWYgKChmaXJzdEdyb3VwLnZhbHVlLmxlbmd0aCA9PSBncm91cExlbmd0aCkgJiYgKHNlY29uZEdyb3VwLnZhbHVlLmxlbmd0aCA9PSBncm91cExlbmd0aCkpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGV0IGdyb3VwVmFsdWU6IHN0cmluZyA9IGZpcnN0R3JvdXAudmFsdWU7XG5cbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0OiBudW1iZXIgPSAoZ3JvdXBWYWx1ZS5jaGFyQ29kZUF0KDApIC0gNDgpICogODtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gKGdyb3VwVmFsdWUuY2hhckNvZGVBdCgxKSAtIDQ4KSAqIDc7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IChncm91cFZhbHVlLmNoYXJDb2RlQXQoMikgLSA0OCkgKiA2O1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoZ3JvdXBWYWx1ZS5jaGFyQ29kZUF0KDMpIC0gNDgpICogNTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoKGdyb3VwVmFsdWUgPSBzZWNvbmRHcm91cC52YWx1ZSkuY2hhckNvZGVBdCgwKSAtIDQ4KSAqIDQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IChncm91cFZhbHVlLmNoYXJDb2RlQXQoMSkgLSA0OCkgKiAzO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAoZ3JvdXBWYWx1ZS5jaGFyQ29kZUF0KDIpIC0gNDgpICogMjtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gKChncm91cFZhbHVlWzNdID09ICd4JykgfHwgKGdyb3VwVmFsdWVbM10gPT0gJ1gnKSkgPyAxMCA6IGdyb3VwVmFsdWUuY2hhckNvZGVBdCgzKSAtIDQ4O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZXN1bHQgJSAxMSkgXG4gICAgICAgICAgICAgICAgICAgID8geyAnaXNzbkNvbmZpcm1DaGVja0RpZ2l0VHdvRmllbGQnOiB0cnVlIH0gXG4gICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGlzc25WYWxpZGF0b3IoaW50ZXJuYWxGb3JtR3JvdXA6IEZvcm1Hcm91cCk6IFZhbGlkYXRvckZuXG4gICAge1xuICAgICAgICBjb25zdCByZXMgPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICghaW50ZXJuYWxGb3JtR3JvdXAudmFsaWQpIFxuICAgICAgICAgICAgICAgID8geyAnaXNzblZhbGlkYXRvcic6IHsgJ3JlcXVpcmVkVmFsaWQnOiBpbnRlcm5hbEZvcm1Hcm91cC52YWxpZCB9IH0gXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvblxuICogQSBkaXJlY3RpdmUgdGhhdCByZXByZXNlbnRzIGEgdmFsaWRhdG9yIHRoYXQgcmVxdWlyZXMgdGhlIGxlbmd0aCBvZiB0aGUgY29udHJvbCdzIHZhbHVlIFxuICogdG8gYmUgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIGxlbmd0aC4gVGhlIGNvbnRyb2wgbXVzdCBiZSBtYXJrZWQgd2l0aCB0aGUgYGVxdWFsTGVuZ3RoYCBhdHRyaWJ1dGUuIFxuICogVGhlIGRpcmVjdGl2ZSBpcyBwcm92aWRlZCB3aXRoIHRoZSBgTkdfVkFMSURBVE9SU2AgbXVsdC1wcm92aWRlciBsaXN0LiBcbiAqIFRoaXMgdmFsaWRhdG9yIGlzIHVzZWQgd2l0aCBUZW1wbGF0ZS1kcml2ZW4gRm9ybTsgaWYgeW91IHdhbnQgdG8gdXNlIGFuIGVxdWl2YWxlbnQgdmFsaWRhdG9yIFxuICogd2l0aCBSZWFjdGl2ZSBGb3JtcyB5b3UgbXVzdCB1c2UgdGhlIGBFeHRyYVZhbGlkYXRvcnMuZXF1YWxMZW5ndGhgIG1ldGhvZC4gXG4gKlxuICogQHVzYWdlTm90ZXNcbiAqXG4gKiAjIyMgVmFsaWRhdGVzIHRoYXQgdGhlIGZpZWxkIGhhcyBhIGxlbmd0aCBvZiA0IGNoYXJhY3RlcnM6IFxuICpcbiAqIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSBzaG93cyBob3cgdG8gYWRkIGFuIGVxdWFsIGxlbmd0aCB2YWxpZGF0b3IgdG8gYW4gaW5wdXQgYXR0YWNoZWQgdG8gYW4gXG4gKiBuZ01vZGVsIGJpbmRpbmcuIFxuICpcbiAqIGBgYGh0bWwgXG4gKiA8aW5wdXQgbmFtZT1cImZpcnN0TmFtZVwiIG5nTW9kZWwgZXF1YWxsZW5ndGg9XCI0XCI+IFxuICogYGBgIFxuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tlcXVhbExlbmd0aF0nLFxuICAgIHByb3ZpZGVyczogW3sgXG4gICAgICAgIHByb3ZpZGU6IE5HX1ZBTElEQVRPUlMsIFxuICAgICAgICB1c2VFeGlzdGluZzogRXF1YWxMZW5ndGhEaXJlY3RpdmUsIFxuICAgICAgICBtdWx0aTogdHJ1ZVxuICAgIH1dXG59KVxuZXhwb3J0IGNsYXNzIEVxdWFsTGVuZ3RoRGlyZWN0aXZlIGltcGxlbWVudHMgT25DaGFuZ2VzLCBWYWxpZGF0b3JcbntcbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJbnB1dCB2YXJpYWJsZSB0aGF0IGNvbnRhaW5zIHRoZSBsZW5ndGggdG8gY2hlY2suIFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGVxdWFsTGVuZ3RoOiBzdHJpbmc7XG5cbiAgICBwcml2YXRlIF92YWxpZGF0b3I6IFZhbGlkYXRvckZuO1xuICAgIHByaXZhdGUgX29uQ2hhbmdlOiAoKSA9PiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQSBsaWZlY3ljbGUgaG9vayBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgZGlyZWN0aXZlJ3MgaW5wdXRzIGNoYW5nZS4gRm9yIGludGVybmFsIHVzZSBvbmx5LiBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIEFuIG9iamVjdCBvZiBrZXkvdmFsdWUgcGFpcnMgZm9yIHRoZSBzZXQgb2YgY2hhbmdlZCBpbnB1dHMuIFxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZFxuICAgIHtcbiAgICAgICAgaWYoJ2VxdWFsTGVuZ3RoJyBpbiBjaGFuZ2VzKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl92YWxpZGF0b3IgPSBFeHRyYVZhbGlkYXRvcnMuZXF1YWxMZW5ndGgocGFyc2VJbnQodGhpcy5lcXVhbExlbmd0aCwgMTApKTtcblxuICAgICAgICAgICAgaWYodGhpcy5fb25DaGFuZ2UpIHRoaXMuX29uQ2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICB9ICAgIFxuXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTWV0aG9kIHRoYXQgcGVyZm9ybXMgc3luY2hyb25vdXMgdmFsaWRhdGlvbiBhZ2FpbnN0IHRoZSBwcm92aWRlZCBjb250cm9sLiBJdCByZXF1aXJlcyB0aGUgbGVuZ3RoIFxuICAgICAqIG9mIHRoZSBjb250cm9sJ3MgdmFsdWUgdG8gYmUgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIGBlcXVhbExlbmd0aGAuIFxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyb2wgVGhlIGNvbnRyb2wgdG8gdmFsaWRhdGUgYWdhaW5zdC4gXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG1hcCBvZiB2YWxpZGF0aW9uIGVycm9ycyBpZiB2YWxpZGF0aW9uIGZhaWxzOyBvdGhlcndpc2UsIGBudWxsYC4gXG4gICAgICovICAgIFxuICAgIHB1YmxpYyB2YWxpZGF0ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbFxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmVxdWFsTGVuZ3RoKSBcbiAgICAgICAgICAgID8gdGhpcy5fdmFsaWRhdG9yKGNvbnRyb2wpIFxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGNhbGwgd2hlbiB0aGUgdmFsaWRhdG9yIGlucHV0cyBjaGFuZ2UuIFxuICAgICAqXG4gICAgICogQHBhcmFtIGZuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byByZWdpc3Rlci4gXG4gICAgICovXG4gICAgcHVibGljIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UoZm46ICgpID0+IHZvaWQpOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZSA9IGZuO1xuICAgIH1cbn1cbiJdfQ==