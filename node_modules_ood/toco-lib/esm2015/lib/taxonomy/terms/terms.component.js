/**
 * @fileoverview added by tsickle
 * Generated from: lib/taxonomy/terms/terms.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input } from '@angular/core';
import { of as observableOf, of } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { FlatTreeControl } from '@angular/cdk/tree';
import { MatDialog } from '@angular/material/dialog';
import { MatTreeFlatDataSource, MatTreeFlattener } from '@angular/material/tree';
import { MatSnackBar } from '@angular/material/snack-bar';
import { MessageHandler, StatusCode } from '../../core/public-api';
import { Vocabulary } from '../../entities/public-api';
import { TaxonomyService } from '../../backend/public-api';
import { TermGenericComponent } from '../term-generic/term-generic.component';
import { OAuthStorage } from 'angular-oauth2-oidc';
/**
 * Flattened tree node that has been created from a TermNode through the flattener. Flattened
 * nodes include level index and whether they can be expanded or not.
 * @record
 */
export function FlatTreeNode() { }
if (false) {
    /** @type {?} */
    FlatTreeNode.prototype.name;
    /** @type {?} */
    FlatTreeNode.prototype.level;
    /** @type {?} */
    FlatTreeNode.prototype.expandable;
}
export class TermsComponent {
    /**
     * @param {?} service
     * @param {?} oautheStorage
     * @param {?} dialog
     * @param {?} _snackBar
     */
    constructor(service, oautheStorage, dialog, _snackBar) {
        this.service = service;
        this.oautheStorage = oautheStorage;
        this.dialog = dialog;
        this._snackBar = _snackBar;
        this.loading = false;
        this.termsTreeObserver = {
            next: (/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.dataSource.data = response.data.tree.term_node;
                this.loading = !this.loading;
            }),
            error: (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                console.log('error: ' + err + '.');
            }),
            complete: (/**
             * @return {?}
             */
            () => {
                console.log('complete');
            })
        };
        this.termChangeObserver = {
            next: (/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.loading = !this.loading;
                this.service.getTermsTreeByVocab(this.currentVocab.id).subscribe(this.termsTreeObserver);
                this.dialog.closeAll();
                /** @type {?} */
                const m = new MessageHandler(this._snackBar);
                m.showMessage(StatusCode.OK, response.message);
            }),
            error: (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                console.log('error: ' + err + '.');
            }),
            complete: (/**
             * @return {?}
             */
            () => {
                console.log('complete');
            })
        };
        this.currentVocab = null;
        this.treeFlattener = new MatTreeFlattener(this.transformer, this.getLevel, this.isExpandable, this.getChildren);
        this.treeControl = new FlatTreeControl(this.getLevel, this.isExpandable);
        this.dataSource = new MatTreeFlatDataSource(this.treeControl, this.treeFlattener);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.oautheStorage.getItem('user_permission')) {
            this.getAuthenticatedUserPermissions();
        }
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.currentVocab != null) {
            this.loading = true;
            this.service.getTermsTreeByVocab(this.currentVocab.id)
                .subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.dataSource.data = response.data.tree.term_node;
            }), (/**
             * @param {?} err
             * @return {?}
             */
            (err) => {
                console.log('error: ' + err + '.');
            }), (/**
             * @return {?}
             */
            () => {
                this.loading = false;
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
    }
    /**
     * Transform the data to something the tree can read.
     * @param {?} node
     * @param {?} level
     * @return {?}
     */
    transformer(node, level) {
        return {
            name: node.term.identifier,
            term: node.term,
            level: level,
            expandable: (node.children.length > 0)
        };
    }
    /**
     * Get the level of the node
     * @param {?} node
     * @return {?}
     */
    getLevel(node) {
        return node.level;
    }
    /**
     * Get whether the node is expanded or not.
     * @param {?} node
     * @return {?}
     */
    isExpandable(node) {
        return node.expandable;
    }
    /**
     * Get whether the node has children or not.
     * @param {?} index
     * @param {?} node
     * @return {?}
     */
    hasChild(index, node) {
        return node.expandable;
    }
    /**
     * Get the children for the node.
     * @param {?} node
     * @return {?}
     */
    getChildren(node) {
        return observableOf(node.children);
    }
    /**
     * @return {?}
     */
    addTerm() {
        this.openTermDialog(null);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    editTerm(node) {
        this.openTermDialog(node.term);
    }
    /**
     * @private
     * @param {?} term
     * @return {?}
     */
    openTermDialog(term) {
        /** @type {?} */
        const dialogRef = this.dialog.open(TermGenericComponent, {
            data: {
                term: term,
                terms: this.dataSource.data,
                currentVocab: this.currentVocab,
                accept: (/**
                 * @param {?} term
                 * @return {?}
                 */
                (term) => {
                    this.dialog.closeAll();
                    if (term.isNew) {
                        this.service.newTerm(term).pipe().subscribe(this.termChangeObserver);
                    }
                    else {
                        this.service.editTerm(term).pipe().subscribe(this.termChangeObserver);
                    }
                })
            }
        });
        dialogRef.afterClosed().subscribe((/**
         * @param {?} result
         * @return {?}
         */
        result => {
            console.log('dialog closed');
        }));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    deleteTerm(node) {
        console.log(node);
    }
    /**
     * @return {?}
     */
    getAuthenticatedUserPermissions() {
        this.service.getCurrentUserPermissions().pipe(catchError((/**
         * @param {?} err
         * @return {?}
         */
        err => {
            /** @type {?} */
            const m = new MessageHandler(this._snackBar);
            m.showMessage(StatusCode.serverError, err.message);
            // TODO: Maybe you must set a better return.
            return of(null);
        })))
            .subscribe((/**
         * @param {?} request
         * @return {?}
         */
        request => {
            if (request.status == 'success') {
                /** @type {?} */
                var permJson = JSON.stringify(request.data.permissions.actions);
                this.oautheStorage.setItem('user_permissions', permJson);
            }
        }));
    }
    /**
     * @param {?} permission
     * @param {?=} id
     * @return {?}
     */
    hasPermission(permission, id) {
        /** @type {?} */
        const userPermission = JSON.parse(this.oautheStorage.getItem('user_permissions'));
        if (!userPermission) {
            return false;
        }
        switch (permission) {
            case 'add':
                if (userPermission.taxonomy_full_editor_actions === null)
                    return true;
                return false;
            case 'edit':
                if (userPermission.taxonomy_full_editor_actions === null)
                    return true;
                if (userPermission.vocabulary_editor_actions) {
                    /** @type {?} */
                    const arr = userPermission.vocabulary_editor_actions;
                    if (arr.includes(id)) {
                        return true;
                    }
                }
                else if (userPermission.taxonomy_full_editor_actions) {
                    return true;
                }
                return false;
            default:
                return false;
        }
    }
}
TermsComponent.decorators = [
    { type: Component, args: [{
                selector: 'toco-terms',
                template: "<mat-card>\n    <mat-card-header>\n        <mat-card-title>\n            <div fxLayout=\"row\" fxLayoutAlign=\"space-between none\">\n                T\u00E9rminos\n                <ng-container *ngIf=\"currentVocab\"> de {{ currentVocab.human_name}} </ng-container>\n\n                <button mat-icon-button *ngIf=\"currentVocab && hasPermission('add')\" (click)=\"addTerm()\"\n                    matTooltip=\"Adicionar T\u00E9rmino\">\n                    <mat-icon>library_add</mat-icon>\n                </button>\n\n            </div>\n        </mat-card-title>\n    </mat-card-header>\n    <mat-card-content [style.overflow]=\"'auto'\" [style.height]=\"'25em'\">\n        <mat-spinner *ngIf=\"loading; else elseTemplate\"></mat-spinner>\n\n        <ng-template #elseTemplate>\n            <mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" class=\"padd\">\n                <mat-tree-node class=\"hover\" *matTreeNodeDef=\"let node\" matTreeNodeToggle matTreeNodePadding\n                    fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n                    <div fxLayout=\"row\" fxLayoutAlign=\"start center\">\n                        <button mat-icon-button disabled></button>\n                        {{ node.name }}\n                    </div> \n                    <button mat-icon-button *ngIf=\"currentVocab && hasPermission('edit', currentVocab.id)\" (click)=\"editTerm(node)\" matTooltip=\"Editar\">\n                    <mat-icon>edit</mat-icon>\n                    </button>\n                </mat-tree-node>\n\n                <mat-tree-node class=\"hover\" *matTreeNodeDef=\"let node; when: hasChild\" matTreeNodePadding>\n                    <button mat-icon-button matTreeNodeToggle [attr.aria-label]=\"'toggle ' + node.name\">\n                        <mat-icon class=\"mat-icon-rtl-mirror\">\n                            {{treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right'}}\n                        </mat-icon>\n                    </button>\n                    <div class=\"item-width\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n                        {{ node.name }}\n                        <div>\n                            <button mat-icon-button *ngIf=\"currentVocab && hasPermission('edit', currentVocab.id)\" (click)=\"editTerm(node)\" matTooltip=\"Editar\">\n                                <mat-icon>edit</mat-icon>\n                            </button>\n                            <!-- <button mat-icon-button (click)=\"deleteTerm(node)\" matTooltip=\"Eliminar\">\n                                <mat-icon>delete</mat-icon>\n                            </button> -->\n                        </div>\n                    </div>\n\n                </mat-tree-node>\n            </mat-tree>\n        </ng-template>\n    </mat-card-content>\n</mat-card>",
                styles: [".type-icon{color:#757575;margin-right:5px}.item-width{width:100%}.padd{padding:.7em}.hover:hover{transform:scale(1.02);box-shadow:0 0 10px 0 rgba(0,0,0,.4);border-radius:3px}"]
            }] }
];
/** @nocollapse */
TermsComponent.ctorParameters = () => [
    { type: TaxonomyService },
    { type: OAuthStorage },
    { type: MatDialog },
    { type: MatSnackBar }
];
TermsComponent.propDecorators = {
    currentVocab: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    TermsComponent.prototype.loading;
    /**
     * The TreeControl controls the expand/collapse state of tree nodes.
     * @type {?}
     */
    TermsComponent.prototype.treeControl;
    /**
     * The TreeFlattener is used to generate the flat list of items from hierarchical data.
     * @type {?}
     */
    TermsComponent.prototype.treeFlattener;
    /**
     * The MatTreeFlatDataSource connects the control and flattener to provide data.
     * @type {?}
     */
    TermsComponent.prototype.dataSource;
    /**
     * @type {?}
     * @private
     */
    TermsComponent.prototype.termsTreeObserver;
    /**
     * @type {?}
     * @private
     */
    TermsComponent.prototype.termChangeObserver;
    /** @type {?} */
    TermsComponent.prototype.currentVocab;
    /**
     * @type {?}
     * @private
     */
    TermsComponent.prototype.service;
    /**
     * @type {?}
     * @private
     */
    TermsComponent.prototype.oautheStorage;
    /** @type {?} */
    TermsComponent.prototype.dialog;
    /**
     * @type {?}
     * @private
     */
    TermsComponent.prototype._snackBar;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVybXMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vdG9jby1saWIvIiwic291cmNlcyI6WyJsaWIvdGF4b25vbXkvdGVybXMvdGVybXMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBcUIsS0FBSyxFQUFhLE1BQU0sZUFBZSxDQUFDO0FBQy9FLE9BQU8sRUFBRSxFQUFFLElBQUksWUFBWSxFQUFpQyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDN0UsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzVDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDckQsT0FBTyxFQUFFLHFCQUFxQixFQUFFLGdCQUFnQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDakYsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBRTFELE9BQU8sRUFBRSxjQUFjLEVBQUUsVUFBVSxFQUFZLE1BQU0sdUJBQXVCLENBQUM7QUFDN0UsT0FBTyxFQUFFLFVBQVUsRUFBa0IsTUFBTSwyQkFBMkIsQ0FBQztBQUV2RSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDM0QsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFFOUUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7Ozs7QUFNbkQsa0NBSUM7OztJQUhHLDRCQUFhOztJQUNiLDZCQUFjOztJQUNkLGtDQUFvQjs7QUFReEIsTUFBTSxPQUFPLGNBQWM7Ozs7Ozs7SUFrRHZCLFlBQW9CLE9BQXdCLEVBQ2hDLGFBQTJCLEVBQzVCLE1BQWlCLEVBQ2hCLFNBQXNCO1FBSGQsWUFBTyxHQUFQLE9BQU8sQ0FBaUI7UUFDaEMsa0JBQWEsR0FB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QkFFbkUsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxFQUFFO3dCQUNsQixPQUFPLElBQUksQ0FBQTtxQkFDZDtpQkFFSjtxQkFDSSxJQUFJLGNBQWMsQ0FBQyw0QkFBNEIsRUFBRTtvQkFDbEQsT0FBTyxJQUFJLENBQUM7aUJBQ2Y7Z0JBRUQsT0FBTyxLQUFLLENBQUM7WUFFakI7Z0JBQ0ksT0FBTyxLQUFLLENBQUM7U0FDcEI7SUFDTCxDQUFDOzs7WUFuTkosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxZQUFZO2dCQUN0QiwreUZBQXFDOzthQUV4Qzs7OztZQW5CUSxlQUFlO1lBR2YsWUFBWTtZQVZaLFNBQVM7WUFFVCxXQUFXOzs7MkJBd0VmLEtBQUs7Ozs7SUE1Q04saUNBQXlCOzs7OztJQUd6QixxQ0FBMkM7Ozs7O0lBRzNDLHVDQUF3RDs7Ozs7SUFHeEQsb0NBQTBEOzs7OztJQUUxRCwyQ0FhRTs7Ozs7SUFFRiw0Q0FnQkU7O0lBRUYsc0NBQ2dDOzs7OztJQUVwQixpQ0FBZ0M7Ozs7O0lBQ3hDLHVDQUFtQzs7SUFDbkMsZ0NBQXdCOzs7OztJQUN4QixtQ0FBOEIiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBPbkRlc3Ryb3ksIElucHV0LCBPbkNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IG9mIGFzIG9ic2VydmFibGVPZiwgUGFydGlhbE9ic2VydmVyLCBTdWJzY3JpcHRpb24sIG9mIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBjYXRjaEVycm9yIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRmxhdFRyZWVDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL3RyZWUnO1xuaW1wb3J0IHsgTWF0RGlhbG9nIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZGlhbG9nJztcbmltcG9ydCB7IE1hdFRyZWVGbGF0RGF0YVNvdXJjZSwgTWF0VHJlZUZsYXR0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3RyZWUnO1xuaW1wb3J0IHsgTWF0U25hY2tCYXIgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9zbmFjay1iYXInO1xuXG5pbXBvcnQgeyBNZXNzYWdlSGFuZGxlciwgU3RhdHVzQ29kZSwgUmVzcG9uc2UgfSBmcm9tICcuLi8uLi9jb3JlL3B1YmxpYy1hcGknO1xuaW1wb3J0IHsgVm9jYWJ1bGFyeSwgVGVybSwgVGVybU5vZGUgfSBmcm9tICcuLi8uLi9lbnRpdGllcy9wdWJsaWMtYXBpJztcblxuaW1wb3J0IHsgVGF4b25vbXlTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vYmFja2VuZC9wdWJsaWMtYXBpJztcbmltcG9ydCB7IFRlcm1HZW5lcmljQ29tcG9uZW50IH0gZnJvbSAnLi4vdGVybS1nZW5lcmljL3Rlcm0tZ2VuZXJpYy5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBPQXV0aFN0b3JhZ2UgfSBmcm9tICdhbmd1bGFyLW9hdXRoMi1vaWRjJztcblxuLyoqXG4gKiBGbGF0dGVuZWQgdHJlZSBub2RlIHRoYXQgaGFzIGJlZW4gY3JlYXRlZCBmcm9tIGEgVGVybU5vZGUgdGhyb3VnaCB0aGUgZmxhdHRlbmVyLiBGbGF0dGVuZWRcbiAqIG5vZGVzIGluY2x1ZGUgbGV2ZWwgaW5kZXggYW5kIHdoZXRoZXIgdGhleSBjYW4gYmUgZXhwYW5kZWQgb3Igbm90LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZsYXRUcmVlTm9kZSB7XG4gICAgbmFtZTogc3RyaW5nO1xuICAgIGxldmVsOiBudW1iZXI7XG4gICAgZXhwYW5kYWJsZTogYm9vbGVhbjtcbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd0b2NvLXRlcm1zJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdGVybXMuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3Rlcm1zLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgVGVybXNDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblxuXG4gICAgbG9hZGluZzogQm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIFRoZSBUcmVlQ29udHJvbCBjb250cm9scyB0aGUgZXhwYW5kL2NvbGxhcHNlIHN0YXRlIG9mIHRyZWUgbm9kZXMuICAqL1xuICAgIHRyZWVDb250cm9sOiBGbGF0VHJlZUNvbnRyb2w8RmxhdFRyZWVOb2RlPjtcblxuICAgIC8qKiBUaGUgVHJlZUZsYXR0ZW5lciBpcyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBmbGF0IGxpc3Qgb2YgaXRlbXMgZnJvbSBoaWVyYXJjaGljYWwgZGF0YS4gKi9cbiAgICB0cmVlRmxhdHRlbmVyOiBNYXRUcmVlRmxhdHRlbmVyPFRlcm1Ob2RlLCBGbGF0VHJlZU5vZGU+O1xuXG4gICAgLyoqIFRoZSBNYXRUcmVlRmxhdERhdGFTb3VyY2UgY29ubmVjdHMgdGhlIGNvbnRyb2wgYW5kIGZsYXR0ZW5lciB0byBwcm92aWRlIGRhdGEuICovXG4gICAgZGF0YVNvdXJjZTogTWF0VHJlZUZsYXREYXRhU291cmNlPFRlcm1Ob2RlLCBGbGF0VHJlZU5vZGU+O1xuXG4gICAgcHJpdmF0ZSB0ZXJtc1RyZWVPYnNlcnZlcjogUGFydGlhbE9ic2VydmVyPFJlc3BvbnNlPGFueT4+ID0ge1xuICAgICAgICBuZXh0OiAocmVzcG9uc2U6IFJlc3BvbnNlPGFueT4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5kYXRhID0gcmVzcG9uc2UuZGF0YS50cmVlLnRlcm1fbm9kZTtcbiAgICAgICAgICAgIHRoaXMubG9hZGluZyA9ICF0aGlzLmxvYWRpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXJyb3I6IChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yOiAnICsgZXJyICsgJy4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvbXBsZXRlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcHJpdmF0ZSB0ZXJtQ2hhbmdlT2JzZXJ2ZXI6IFBhcnRpYWxPYnNlcnZlcjxSZXNwb25zZTxhbnk+PiA9IHtcbiAgICAgICAgbmV4dDogKHJlc3BvbnNlOiBSZXNwb25zZTxhbnk+KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSAhdGhpcy5sb2FkaW5nO1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLmdldFRlcm1zVHJlZUJ5Vm9jYWIodGhpcy5jdXJyZW50Vm9jYWIuaWQpLnN1YnNjcmliZSh0aGlzLnRlcm1zVHJlZU9ic2VydmVyKTtcbiAgICAgICAgICAgIHRoaXMuZGlhbG9nLmNsb3NlQWxsKCk7XG4gICAgICAgICAgICBjb25zdCBtID0gbmV3IE1lc3NhZ2VIYW5kbGVyKHRoaXMuX3NuYWNrQmFyKTtcbiAgICAgICAgICAgIG0uc2hvd01lc3NhZ2UoU3RhdHVzQ29kZS5PSywgcmVzcG9uc2UubWVzc2FnZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXJyb3I6IChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yOiAnICsgZXJyICsgJy4nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvbXBsZXRlJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQElucHV0KClcbiAgICBjdXJyZW50Vm9jYWI6IFZvY2FidWxhcnkgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBzZXJ2aWNlOiBUYXhvbm9teVNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgb2F1dGhlU3RvcmFnZTogT0F1dGhTdG9yYWdlLFxuICAgICAgICBwdWJsaWMgZGlhbG9nOiBNYXREaWFsb2csXG4gICAgICAgIHByaXZhdGUgX3NuYWNrQmFyOiBNYXRTbmFja0Jhcikge1xuICAgICAgICB0aGlzLnRyZWVGbGF0dGVuZXIgPSBuZXcgTWF0VHJlZUZsYXR0ZW5lcihcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtZXIsXG4gICAgICAgICAgICB0aGlzLmdldExldmVsLFxuICAgICAgICAgICAgdGhpcy5pc0V4cGFuZGFibGUsXG4gICAgICAgICAgICB0aGlzLmdldENoaWxkcmVuKTtcblxuICAgICAgICB0aGlzLnRyZWVDb250cm9sID0gbmV3IEZsYXRUcmVlQ29udHJvbCh0aGlzLmdldExldmVsLCB0aGlzLmlzRXhwYW5kYWJsZSk7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZSA9IG5ldyBNYXRUcmVlRmxhdERhdGFTb3VyY2UodGhpcy50cmVlQ29udHJvbCwgdGhpcy50cmVlRmxhdHRlbmVyKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcblxuICAgICAgICBpZiAoIXRoaXMub2F1dGhlU3RvcmFnZS5nZXRJdGVtKCd1c2VyX3Blcm1pc3Npb24nKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRBdXRoZW50aWNhdGVkVXNlclBlcm1pc3Npb25zKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRWb2NhYiAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLmdldFRlcm1zVHJlZUJ5Vm9jYWIodGhpcy5jdXJyZW50Vm9jYWIuaWQpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICAgICAgKHJlc3BvbnNlOiBSZXNwb25zZTxhbnk+KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YSA9IHJlc3BvbnNlLmRhdGEudHJlZS50ZXJtX25vZGU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIChlcnI6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Vycm9yOiAnICsgZXJyICsgJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuXG4gICAgfVxuXG4gICAgLyoqIFRyYW5zZm9ybSB0aGUgZGF0YSB0byBzb21ldGhpbmcgdGhlIHRyZWUgY2FuIHJlYWQuICovXG4gICAgdHJhbnNmb3JtZXIobm9kZTogVGVybU5vZGUsIGxldmVsOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IG5vZGUudGVybS5pZGVudGlmaWVyLFxuICAgICAgICAgICAgdGVybTogbm9kZS50ZXJtLFxuICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgZXhwYW5kYWJsZTogKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBsZXZlbCBvZiB0aGUgbm9kZSAqL1xuICAgIGdldExldmVsKG5vZGU6IEZsYXRUcmVlTm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5sZXZlbDtcbiAgICB9XG5cbiAgICAvKiogR2V0IHdoZXRoZXIgdGhlIG5vZGUgaXMgZXhwYW5kZWQgb3Igbm90LiAqL1xuICAgIGlzRXhwYW5kYWJsZShub2RlOiBGbGF0VHJlZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZXhwYW5kYWJsZTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHdoZXRoZXIgdGhlIG5vZGUgaGFzIGNoaWxkcmVuIG9yIG5vdC4gKi9cbiAgICBoYXNDaGlsZChpbmRleDogbnVtYmVyLCBub2RlOiBGbGF0VHJlZU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZXhwYW5kYWJsZTtcbiAgICB9XG5cbiAgICAvKiogR2V0IHRoZSBjaGlsZHJlbiBmb3IgdGhlIG5vZGUuICovXG4gICAgZ2V0Q2hpbGRyZW4obm9kZTogVGVybU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG9ic2VydmFibGVPZihub2RlLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBhZGRUZXJtKCkge1xuICAgICAgICB0aGlzLm9wZW5UZXJtRGlhbG9nKG51bGwpO1xuICAgIH1cbiAgICBlZGl0VGVybShub2RlOiBhbnkpIHtcbiAgICAgICAgdGhpcy5vcGVuVGVybURpYWxvZyhub2RlLnRlcm0pO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBvcGVuVGVybURpYWxvZyh0ZXJtOiBUZXJtKSB7XG5cbiAgICAgICAgY29uc3QgZGlhbG9nUmVmID0gdGhpcy5kaWFsb2cub3BlbihUZXJtR2VuZXJpY0NvbXBvbmVudCwge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHRlcm06IHRlcm0sXG4gICAgICAgICAgICAgICAgdGVybXM6IHRoaXMuZGF0YVNvdXJjZS5kYXRhLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRWb2NhYjogdGhpcy5jdXJyZW50Vm9jYWIsXG4gICAgICAgICAgICAgICAgYWNjZXB0OiAodGVybTogVGVybSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpYWxvZy5jbG9zZUFsbCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVybS5pc05ldyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2UubmV3VGVybSh0ZXJtKS5waXBlKCkuc3Vic2NyaWJlKHRoaXMudGVybUNoYW5nZU9ic2VydmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VydmljZS5lZGl0VGVybSh0ZXJtKS5waXBlKCkuc3Vic2NyaWJlKHRoaXMudGVybUNoYW5nZU9ic2VydmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRpYWxvZ1JlZi5hZnRlckNsb3NlZCgpLnN1YnNjcmliZShyZXN1bHQgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2RpYWxvZyBjbG9zZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGVsZXRlVGVybShub2RlOiBUZXJtTm9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhub2RlKTtcbiAgICB9XG5cbiAgICBnZXRBdXRoZW50aWNhdGVkVXNlclBlcm1pc3Npb25zKCkge1xuICAgICAgICB0aGlzLnNlcnZpY2UuZ2V0Q3VycmVudFVzZXJQZXJtaXNzaW9ucygpLnBpcGUoXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbSA9IG5ldyBNZXNzYWdlSGFuZGxlcih0aGlzLl9zbmFja0Jhcik7XG4gICAgICAgICAgICAgICAgbS5zaG93TWVzc2FnZShTdGF0dXNDb2RlLnNlcnZlckVycm9yLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgeW91IG11c3Qgc2V0IGEgYmV0dGVyIHJldHVybi5cbiAgICAgICAgICAgICAgICByZXR1cm4gb2YobnVsbCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHJlcXVlc3QgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PSAnc3VjY2VzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBlcm1Kc29uID0gSlNPTi5zdHJpbmdpZnkocmVxdWVzdC5kYXRhLnBlcm1pc3Npb25zLmFjdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9hdXRoZVN0b3JhZ2Uuc2V0SXRlbSgndXNlcl9wZXJtaXNzaW9ucycsIHBlcm1Kc29uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBoYXNQZXJtaXNzaW9uKHBlcm1pc3Npb246IHN0cmluZywgaWQ/OiBzdHJpbmcpOiBib29sZWFuIHtcblxuICAgICAgICBjb25zdCB1c2VyUGVybWlzc2lvbiA9IEpTT04ucGFyc2UodGhpcy5vYXV0aGVTdG9yYWdlLmdldEl0ZW0oJ3VzZXJfcGVybWlzc2lvbnMnKSk7XG4gICAgICAgIGlmICghdXNlclBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHBlcm1pc3Npb24pIHtcbiAgICAgICAgICAgIGNhc2UgJ2FkZCc6XG4gICAgICAgICAgICAgICAgaWYgKHVzZXJQZXJtaXNzaW9uLnRheG9ub215X2Z1bGxfZWRpdG9yX2FjdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBjYXNlICdlZGl0JzpcbiAgICAgICAgICAgICAgICBpZiAodXNlclBlcm1pc3Npb24udGF4b25vbXlfZnVsbF9lZGl0b3JfYWN0aW9ucyA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodXNlclBlcm1pc3Npb24udm9jYWJ1bGFyeV9lZGl0b3JfYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnI6IEFycmF5PHN0cmluZz4gPSB1c2VyUGVybWlzc2lvbi52b2NhYnVsYXJ5X2VkaXRvcl9hY3Rpb25zO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnIuaW5jbHVkZXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXNlclBlcm1pc3Npb24udGF4b25vbXlfZnVsbF9lZGl0b3JfYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19