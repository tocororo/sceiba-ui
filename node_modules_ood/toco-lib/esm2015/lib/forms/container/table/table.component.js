/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/container/table/table.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ViewChild, Input } from '@angular/core';
import { Router, ActivatedRoute } from '@angular/router';
import { MatTableDataSource, MatSort, MatPaginator } from '@angular/material';
import { Subscription, Subject, combineLatest } from 'rxjs';
import { startWith, switchMap, finalize, debounceTime, distinctUntilChanged } from 'rxjs/operators';
import { SortDirection } from '../../../core/public-api';
/** @enum {number} */
const CellContentWrap = {
    /**
     * The `break` wrap breaks the content when reaching the end of a line.
     */
    break: 0,
    /**
     * The `ellipsis` wrap clips the remaining content and renders an ellipsis ("...")
     * to represent the clipped content.
     */
    ellipsis: 1,
    /**
     * The `responsible` wrap is the default style. It only applies the responsible styles
     * that are defined in the table.
     */
    responsible: 2,
};
export { CellContentWrap };
CellContentWrap[CellContentWrap.break] = 'break';
CellContentWrap[CellContentWrap.ellipsis] = 'ellipsis';
CellContentWrap[CellContentWrap.responsible] = 'responsible';
/**
 * @record
 */
export function TableAction() { }
if (false) {
    /** @type {?} */
    TableAction.prototype.icon;
    /** @type {?} */
    TableAction.prototype.route;
    /** @type {?} */
    TableAction.prototype.tooltip;
}
/**
 * A interface that represents the content of a table control.
 * The generic parameter T always refers to the type of data that it is dealing with.
 * @record
 * @template T
 */
export function TableContent() { }
if (false) {
    /**
     * Returns the array of strings that indicates the object property name of the columns.
     * By default, its value is `[]`.
     * @type {?|undefined}
     */
    TableContent.prototype.columnsObjectProperty;
    /**
     * Returns the array of strings that indicates the header text of the columns.
     * By default, its value is `[]`.
     * @type {?|undefined}
     */
    TableContent.prototype.columnsHeaderText;
    /**
     * Returns the array of strings that indicates the width of the columns.
     * By default, its value is `[]`.
     * @type {?|undefined}
     */
    TableContent.prototype.columnsWidth;
    /**
     * Returns the array of `CellContentWrap` that indicates how to wrap the content of the columns.
     * By default, its value is `[]`.
     * @type {?|undefined}
     */
    TableContent.prototype.columnContentWrap;
    /**
     * Returns a function that creates the list of CSS classes to apply to the table rows.
     * In order to take effect these classes, the table CSS file must have defined these classes.
     * By default, its value is `undefined`.
     * \@param rowData The data that is contained in the row.
     * @type {?|undefined}
     */
    TableContent.prototype.createCssClassesForRow;
    /**
     * Returns the property name of the data contained in `page` that is used to identify that data.
     * By default, its value is `''`.
     * @type {?|undefined}
     */
    TableContent.prototype.propertyNameToIdentify;
    /**
     * The current filter state.
     * By default, its value is `{}`.
     * @type {?|undefined}
     */
    TableContent.prototype.filter;
    /**
     * The current sort state.
     * By default, its value is `{ 'active': propertyNameToIdentify, 'direction': SortDirection.asc }`.
     * @type {?|undefined}
     */
    TableContent.prototype.sort;
    /**
     * Returns the length of the total number of items that are being paginated.
     * By default, its value is `0`.
     * @type {?|undefined}
     */
    TableContent.prototype.length;
    /**
     * Returns the zero-based page index of the displayed list of items.
     * By default, its value is `0`.
     * @type {?|undefined}
     */
    TableContent.prototype.pageIndex;
    /**
     * Returns the number of items to display on a page.
     * By default, its value is `50`.
     * @type {?|undefined}
     */
    TableContent.prototype.pageSize;
    /**
     * Returns the set of provided page size options to display to the user.
     * By default, its value is `[10, 20, 50]`.
     * @type {?|undefined}
     */
    TableContent.prototype.pageSizeOptions;
    /**
     * Returns true if it hides the page size selection UI from the user; otherwise, false.
     * By default, its value is `false`.
     * @type {?|undefined}
     */
    TableContent.prototype.hidePageSize;
    /**
     * Returns true if it shows the first/last buttons UI to the user; otherwise, false.
     * By default, its value is `false`.
     * @type {?|undefined}
     */
    TableContent.prototype.showFirstLastButtons;
    /**
     * Returns the function that is used to get the data source from backend.
     * The generic parameter T always refers to the type of data that it is dealing with.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    TableContent.prototype.endpoint;
    /** @type {?|undefined} */
    TableContent.prototype.actions;
}
/**
 * Returns a new object that represents the default `TableContent`.
 * @return {?}
 */
export function defaultTableContent() {
    return {
        'columnsObjectProperty': [],
        'columnsHeaderText': [],
        'columnsWidth': [],
        'columnContentWrap': [],
        'createCssClassesForRow': undefined,
        'propertyNameToIdentify': '',
        'filter': {},
        'sort': {
            'active': this._content.propertyNameToIdentify,
            'direction': SortDirection.asc
        },
        'length': 0,
        'pageIndex': 0,
        'pageSize': 50,
        'pageSizeOptions': [10, 20, 50],
        'hidePageSize': false,
        'showFirstLastButtons': false,
        'endpoint': undefined
    };
}
/**
 * \@description
 * Represents a table control.
 */
export class TableComponent {
    /**
     * @param {?} _router
     * @param {?} _activatedRoute
     */
    constructor(_router, _activatedRoute) {
        this._router = _router;
        this._activatedRoute = _activatedRoute;
        /* By default, its value is `0`, means the component is NOT loading the data source. */
        this._countBackendSubscriptions = 0;
        this._page = new Subject();
        this._pageAsObservable = this._page.asObservable();
        this._dataSource = new MatTableDataSource();
        this._selectedRow = undefined;
        this._filterValuesChange = new Subject();
        this._filterValues = {};
        this._filterValuesSubscription = {};
        this._renderChangesSubscription = Subscription.EMPTY;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /* Sets the default values only if the `_content` has not been set yet. */
        if (this._content == undefined) {
            this.init();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        /* Disposes the resources held by the subscription. */
        Object.keys(this._filterValuesSubscription).forEach((/**
         * @param {?} name
         * @return {?}
         */
        (name) => {
            this._filterValuesSubscription[name].unsubscribe();
        }));
        /* Disposes the resources held by the subscription. */
        this._renderChangesSubscription.unsubscribe();
    }
    /**
     * Returns true if the data source is empty; otherwise, false.
     * @return {?}
     */
    get isEmpty() {
        return (this._dataSource.data.length == 0);
    }
    /**
     * Initializes the component.
     * @protected
     * @return {?}
     */
    init() {
        this._initContent();
        this._updateChangeSubscription();
    }
    /**
     * Initializes the `content` input property.
     * @private
     * @return {?}
     */
    _initContent() {
        /* Sets the default values. */
        if (this._content == undefined)
            this._content = {}; /* This code line must be here. */
        /**************************** `mat-cell` properties. ******************************/
        if (this._content.columnsObjectProperty == undefined)
            this._content.columnsObjectProperty = [];
        if (this._content.columnsHeaderText == undefined)
            this._content.columnsHeaderText = [];
        if (this._content.columnsWidth == undefined)
            this._content.columnsWidth = [];
        if (this._content.columnContentWrap == undefined)
            this._content.columnContentWrap = [];
        if (this._content.createCssClassesForRow == undefined)
            this._content.createCssClassesForRow = this.defaultCreateCssClassesForRow.bind(this);
        /**************************** `mat-row` properties. *******************************/
        if (this._content.propertyNameToIdentify == undefined)
            this._content.propertyNameToIdentify = '';
        /**************************** `filter` properties. ********************************/
        if (this._content.filter == undefined)
            this._content.filter = {};
        /***************************** `sort` properties. *********************************/
        if (this._content.sort == undefined)
            this._content.sort = {
                'active': this._content.propertyNameToIdentify,
                'direction': SortDirection.asc
            };
        /************************* `mat-paginator` properties. ****************************/
        if (this._content.length == undefined)
            this._content.length = 0;
        if (this._content.pageIndex == undefined)
            this._content.pageIndex = 0;
        if (this._content.pageSize == undefined)
            this._content.pageSize = 50;
        if (this._content.pageSizeOptions == undefined)
            this._content.pageSizeOptions = [10, 20, 50];
        if (this._content.hidePageSize == undefined)
            this._content.hidePageSize = false;
        if (this._content.showFirstLastButtons == undefined)
            this._content.showFirstLastButtons = false;
        /************************** Internal control properties. **************************/
        /******************************* Other properties. ********************************/
        /* The `_content.endpoint` field is `undefined` by default. */
        /************************ Must be the last initialization. ************************/
        this.checkColumn();
    }
    /**
     * Updates the fields related to the filter component.
     * @private
     * @return {?}
     */
    _updateFilter() {
        /* For each filter property. */
        Object.keys(this._content.filter).forEach((/**
         * @param {?} filterName
         * @return {?}
         */
        (filterName) => {
            /* Saves the initial values. */
            this._filterValues[filterName] = this._content.filter[filterName].content.formControl.value;
            /* Disposes the resources held by the subscription. */
            if (this._filterValuesSubscription[filterName] != undefined)
                this._filterValuesSubscription[filterName].unsubscribe();
            /* Subscribes to observe the changes in the control value when there is an external change. */
            this._filterValuesSubscription[filterName] = this._content.filter[filterName].content.formControl.valueChanges.pipe(
            /* Waits 500ms after each keystroke before considering the term. */
            debounceTime(500), 
            /* Ignores new term if same as previous term. */
            distinctUntilChanged())
                .subscribe((/**
             * @param {?} value
             * @return {?}
             */
            (value) => {
                this.applyFilter(filterName, value);
            }));
        }));
    }
    /**
     * Updates the fields related to sorting.
     * @private
     * @param {?} sortEvent The new sorting to set.
     * @return {?}
     */
    _updateSort(sortEvent) {
        /* In this case, `_content` is updated with the new values; the `MatSort` already has them. */
        this._content.sort.active = sortEvent.active;
        this._content.sort.direction = sortEvent.direction;
    }
    /**
     * Sets the `MatSort` initial values.
     * The filter component and `MatPaginator` are initialized in a different way.
     * @private
     * @return {?}
     */
    _setMatSortInitialValue() {
        /* Saves the initial values. */
        this._sort.active = this._content.sort.active;
        this._sort.direction = this._content.sort.direction;
    }
    /**
     * Updates the fields related to pagination.
     * @private
     * @param {?} newPage The new page to set. Its type is `Page<any>` or `PageEvent`.
     * @return {?}
     */
    _updatePaginator(newPage) {
        /* In this case, `_content` is updated with the new values, then the `MatPaginator`
         * takes the values via property binding from `_content` (through the template). */
        this._content.length = (newPage.totalData || newPage.length);
        this._content.pageIndex = newPage.pageIndex;
        this._content.pageSize = newPage.pageSize;
    }
    /**
     * Sets the `MatSort` and `MatPaginator` disabled or not.
     * @private
     * @param {?} disabled Whether the `MatSort` and `MatPaginator` are disabled.
     * @return {?}
     */
    _disabledSortPaginator(disabled) {
        this._sort.disabled = disabled;
        this._paginator.disabled = disabled;
    }
    /**
     * Subscribes to changes that should trigger an update to the table's rendered rows. When the
     * changes occur, process the current state of the filter, sort, and pagination along with
     * the provided base data and send it to the table for rendering.
     * @private
     * @return {?}
     */
    _updateChangeSubscription() {
        if (this._content.endpoint == undefined)
            return;
        /* Disposes the resources held by the subscription. */
        this._renderChangesSubscription.unsubscribe();
        /* Updates the fields related to the filter component; the `MatSort` and `MatPaginator` are updated later. */
        this._updateFilter();
        /* Sets the `MatSort` initial values; the filter component and `MatPaginator` are initialized in a different way. */
        this._setMatSortInitialValue();
        /* The `_filterValuesChange` is always present; although the user decides if it is used or not.
         * Also, `MatSort` and `MatPaginator` are always present because they are managed by the component completely.
         * Subscribes to get the values when there is a change in the filtering, sorting, or pagination of the data. */
        this._renderChangesSubscription = combineLatest([
            this._filterValuesChange.pipe(
            /* Emits the first value. Filters using the initial values. The operators must be called in this order. */
            startWith(this._filterValues)),
            this._sort.sortChange.pipe(
            /* Emits the first value. Sorts using the initial values. The operators must be called in this order. */
            startWith(this._content.sort)),
            this._paginator.page.pipe(
            /* Emits the first value. Paginates using the initial values. */
            startWith({
                'pageIndex': this._content.pageIndex,
                'pageSize': this._content.pageSize,
                'length': 0 /* In the first value, it is not important. */
            }))
        ]).pipe(
        /* Switches to new search observable each time the term changes. */
        switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([filterEvent, sortEvent, pageEvent]) => {
            /* Adds the new backend subscription. It begins/continues the loading of the data.
             * In this way, it shows the loading progress control. */
            this._countBackendSubscriptions++;
            console.log('Call _countBackendSubscriptions: ', this._countBackendSubscriptions);
            /* Erases the data from the table. */
            this._setDataBeforeCallEndpoint(sortEvent, pageEvent);
            return this._content.endpoint({
                'filter': filterEvent,
                'sort': sortEvent,
                'paginator': pageEvent
            }).pipe(finalize((/**
             * @return {?}
             */
            () => {
                /* Removes the last backend subscription. In this way, when its value is `0`,
                 * means the component is NOT loading the data source; it then hides the loading progress control. */
                this._countBackendSubscriptions--;
            })));
        }))).subscribe((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            //console.log('Endpoint Response: ', response);
            /* Sets the new data on the table. */
            this._setDataAfterCallEndpoint(response);
            /* Emits the new page for someone that wants to know it. */
            this._page.next(response);
        }));
    }
    /**
     * Returns the list of CSS classes to apply to the table rows. This method must be only overwrite,
     * but must never be called for performance reason; it is called in the correct places internally.
     * In order to take effect these classes, the table CSS file must have defined these classes.
     * @protected
     * @param {?} rowData The data that is contained in the row.
     * @return {?}
     */
    defaultCreateCssClassesForRow(rowData) {
        return {
            'selected-row': (rowData[this._content.propertyNameToIdentify]) == this._selectedRow
        };
    }
    /**
     * Returns the list of CSS styles to apply to the table headers. This method must never be called
     * because it is for internal use only; it is called in the correct places internally.
     * @param {?} pos The column position.
     * @return {?}
     */
    _createCssStylesForHeader(pos) {
        /** @type {?} */
        let result = {};
        this._addCssStyles_CellWidth(result, pos);
        return result;
    }
    /**
     * Returns the list of CSS styles to apply to the table cells. This method must never be called
     * because it is for internal use only; it is called in the correct places internally.
     * @param {?} pos The column position.
     * @return {?}
     */
    _createCssStylesForCell(pos) {
        /** @type {?} */
        let result = {};
        this._addCssStyles_CellWidth(result, pos);
        this._addCssStyles_CellContentWrap(result, pos);
        return result;
    }
    /**
     * @private
     * @param {?} cssStyles
     * @param {?} pos
     * @return {?}
     */
    _addCssStyles_CellWidth(cssStyles, pos) {
        cssStyles['flex'] = '0 0 ' + this._content.columnsWidth[pos];
        cssStyles['width'] = this._content.columnsWidth[pos];
    }
    /**
     * @private
     * @param {?} cssStyles
     * @param {?} pos
     * @return {?}
     */
    _addCssStyles_CellContentWrap(cssStyles, pos) {
        switch (this._content.columnContentWrap[pos]) {
            case CellContentWrap.break:
                {
                    cssStyles['word-wrap'] = 'break-word' /*!important*/;
                    cssStyles['white-space'] = 'unset' /*!important*/;
                    cssStyles['overflow-wrap'] = 'break-word';
                    cssStyles['word-break'] = 'break-word';
                    cssStyles['-ms-hyphens'] = 'auto';
                    cssStyles['-moz-hyphens'] = 'auto';
                    cssStyles['-webkit-hyphens'] = 'auto';
                    cssStyles['hyphens'] = 'auto';
                    break;
                }
            case CellContentWrap.ellipsis:
                {
                    cssStyles['overflow'] = 'hidden';
                    cssStyles['text-overflow'] = 'ellipsis';
                    cssStyles['white-space'] = 'nowrap';
                    break;
                }
            default: /* CellContentWrap.responsible */
                {
                    /* The `responsible` wrap is the default style. It only applies the responsible styles
                     * that are defined in the table. */
                    break;
                }
        }
    }
    /**
     * Returns true if it is loading the data source; otherwise, false.
     * @return {?}
     */
    get isLoading() {
        /* When the `_countBackendSubscriptions` value is different of 0,
         * means the component is loading the data source. */
        return (this._countBackendSubscriptions != 0);
    }
    /**
     * Returns the selected row.
     * @return {?}
     */
    get selectedRow() {
        return this._selectedRow;
    }
    /**
     * Returns the input field that contains the content of this class (the table control content to show).
     * @return {?}
     */
    get content() {
        return this._content;
    }
    /**
     * Sets the input field that contains the content of this class (the table control content to show).
     * In this way, the component is updated correctly.
     * @param {?} newContent The new content to set.
     * If the value is null, sets to `defaultTableContent`.
     * @return {?}
     */
    set content(newContent) {
        this._content = newContent;
        this.init();
    }
    /**
     * Returns the stream that emits the page that should be rendered by the table,
     * when there is a change in the filtering, sorting, or pagination of the data. Each object
     * in the `data` field represents one row. This is made for someone that wants to know it.
     * @return {?}
     */
    get page() {
        return this._pageAsObservable;
    }
    /**
     * Sets the page that should be rendered by the table, it erases the data. For internal use only.
     * @private
     * @param {?} sortEvent The current sort state.
     * @param {?} pageEvent The current paginator state.
     * @return {?}
     */
    _setDataBeforeCallEndpoint(sortEvent, pageEvent) {
        /* Erases the data from the table. */
        this._dataSource.data = [];
        /* Updates the fields related to sorting and pagination; the filter component is updated in a different way. */
        this._updateSort(sortEvent);
        this._updatePaginator(pageEvent);
        /* The `MatSort` and `MatPaginator` are always enabled. */
        this._disabledSortPaginator(false);
    }
    /**
     * Sets the page that should be rendered by the table, where each object in the `newPage.data`
     * represents one row. For internal use only.
     * @private
     * @param {?} newPage The new page to set.
     * @return {?}
     */
    _setDataAfterCallEndpoint(newPage) {
        /* In `_dataSource`, needs to update the data only. */
        this._dataSource.data = newPage.data;
        /* Updates the fields related to pagination; the filter component and sorting do not need to update. */
        this._updatePaginator(newPage);
        /* The `MatSort` and `MatPaginator` are disabled if the table is empty. */
        this._disabledSortPaginator(this.isEmpty);
    }
    /**
     * Returns the data source to render. If the data source is empty, then returns the default data source
     * that contains only one empty element (it is used to show one row that contains the empty
     * table information). For internal use only.
     * @return {?}
     */
    get _getDataSource() {
        if (this.isEmpty)
            return TableComponent._defaultDataSource;
        return this._dataSource;
    }
    /**
     * Checks column. Logs a warn to the console is the array of columns is empty.
     * @return {?}
     */
    checkColumn() {
        /** @type {?} */
        const len = this._content.columnsObjectProperty.length;
        if ((len == 0)
            || (len != this._content.columnsHeaderText.length)
            || (len != this._content.columnsWidth.length)
            || (len != this._content.columnContentWrap.length)) {
            console.warn("The 'columnsObjectProperty', 'columnsHeaderText', 'columnsWidth' and 'columnContentWrap' arrays must be different of empty, and must have the same amount of elements.");
        }
    }
    /**
     * Navigates to the view that shows information about the specified `rowData`.
     * @param {?} relativeUrl The relative URL to navigate.
     * @param {?} rowData The data that is contained in the row.
     * @return {?}
     */
    navigateTo(relativeUrl, rowData) {
        /* Selects the specified row. */
        this.selectRow(rowData);
        /* Navigates to the specified view. */
        this._router.navigate([rowData[this._content.propertyNameToIdentify], relativeUrl], { relativeTo: this._activatedRoute });
    }
    /**
     * Selects the specified row.
     * @param {?} rowData The data that is contained in the row.
     * @return {?}
     */
    selectRow(rowData) {
        /* Saves the selected row. */
        this._selectedRow = rowData[this._content.propertyNameToIdentify];
    }
    /**
     * Applies the filter model that should be used to filter out objects from the data source.
     * Assumes that the backend will call the `trim()` method over its properties.
     * This method is accepting a partial representation of the filter model.
     * It combines the specified filter with the last one. This way old filter properties
     * won't be overridden when only one property is updated.
     * @param {?} filter The partial representation of the filter model to combine.
     * @return {?}
     */
    applyFilters(filter) {
        /* This method is accepting a partial representation of the filter model.
         * It combines the specified filter with the last one by merging both filters
         * via the spread operator. This way old filter properties won't be overridden
         * when only one property is updated.
         * It is not necessary to call the `trim()` method over its properties because it is called
         * in the backend internally. */
        this._filterValues = Object.assign({}, this._filterValues, filter);
        this._filterValuesChange.next(this._filterValues);
    }
    /**
     * Applies the filter model that should be used to filter out objects from the data source.
     * Assumes that the backend will call the `trim()` method over its properties.
     * It combines the specified filter property with the last one. This way old filter properties
     * won't be overridden when only one property is updated.
     * @param {?} name The filter name.
     * @param {?} value The filter value.
     * @return {?}
     */
    applyFilter(name, value) {
        /* It combines the specified filter property with the last one by merging both filters
         * via the spread operator. This way old filter properties won't be overridden
         * when only one property is updated.
         * It is not necessary to call the `trim()` method over its properties because it is called
         * in the backend internally. */
        this._filterValues = Object.assign({}, this._filterValues);
        this._filterValues[name] = value;
        this._filterValuesChange.next(this._filterValues);
    }
}
/* Returns a data source with only one empty element. */
TableComponent._defaultDataSource = new MatTableDataSource([{}]);
TableComponent.decorators = [
    { type: Component, args: [{
                selector: 'toco-table',
                template: "\n<table mat-table matSort class=\"mat-elevation-z8\" [dataSource]=\"_getDataSource\" multiTemplateDataRows>\n\n    <!-- The content that is showed when the `dataSource` is not empty. -->\n    <ng-container *ngFor=\"let column of content.columnsObjectProperty; let pos = index\" [matColumnDef]=\"column\">\n        <th mat-header-cell *matHeaderCellDef mat-sort-header [ngStyle]=\"_createCssStylesForHeader(pos)\">\n            {{ content.columnsHeaderText[pos] }}\n        </th>\n\n        <td mat-cell [ngClass]=\"content.createCssClassesForRow(element)\" *matCellDef=\"let element\" [ngStyle]=\"_createCssStylesForCell(pos)\">\n            <!-- Adds the notification icon in the first column if there is 'version to review'. -->\n            <mat-icon *ngIf=\"pos == 0 && element[content.columnsObjectProperty[2]]\" class=\"mat-cell-mat-icon\">new_releases</mat-icon>\n            <!-- Adds the cell text if is not the third column. -->\n            <ng-container *ngIf=\"pos != 2\">{{ element[column] }}</ng-container>\n            <!-- Adds the view and edit buttons in the third column. -->\n            <div *ngIf=\"pos == 2\" class=\"div-mat-button-actions\">\n                <ng-container *ngIf=\"content.actions\">\n                    <button \n                        *ngFor=\"let action of content.actions\"\n                        mat-icon-button class=\"div-mat-button\" \n                        [attr.aria-label]=\"action.tooltip\" \n                        (click)=\"navigateTo(action.route, element)\"\n                        matTooltip=\"{{ action.tooltip }}\"\n                    >\n                        <mat-icon>{{ action.icon }}</mat-icon>\n                    </button>\n                </ng-container>\n                 \n                <!-- <button mat-icon-button class=\"div-mat-button\" [attr.aria-label]=\"'Show the data'\" (click)=\"navigateTo(element[content.propertyNameToIdentify], element)\">\n                    <mat-icon>description</mat-icon>\n                </button>\n                <button mat-icon-button class=\"div-mat-button\" [attr.aria-label]=\"'Edit the data'\" (click)=\"navigateTo('edit', element)\">\n                    <mat-icon>edit</mat-icon>\n                </button> -->\n\n            </div>\n        </td>\n    </ng-container>\n\n    <!-- The `otherInformation` represents the content that is showed when the `dataSource` is empty \n         or the `dataSource` is loading. The information row is made up of this one column that spans \n         across all columns. -->\n    <ng-container [matColumnDef]=\"'otherInformation'\">\n        <td mat-cell *matCellDef=\"let element\" [attr.colspan]=\"content.columnsObjectProperty.length\">\n            <ng-container *ngIf=\"isLoading; then thenTemplate_IsLoading; else elseTemplate_IsEmpty\"></ng-container>\n            \n            <ng-template #thenTemplate_IsLoading>\n                <mat-progress-spinner class=\"loading-table-information\" mode=\"indeterminate\"></mat-progress-spinner>\n            </ng-template>\n\n            <ng-template #elseTemplate_IsEmpty>\n                <div class=\"empty-table-information\">There is not any data source!</div>\n            </ng-template>\n        </td>\n    </ng-container>\n\n    <tr mat-header-row *matHeaderRowDef=\"content.columnsObjectProperty; sticky: true\"></tr>\n    <!-- When it is `loading`, it is `empty`, too. -->\n    <ng-container *ngIf=\"isEmpty; then thenTemplate_OtherInformation; else elseTemplate_IsNotEmpty\"></ng-container>\n\n    <ng-template #thenTemplate_OtherInformation>\n        <tr mat-row class=\"row-other-information\" *matRowDef=\"let row; columns: ['otherInformation']\"></tr>\n    </ng-template>\n\n    <ng-template #elseTemplate_IsNotEmpty>\n        <tr mat-row class=\"row-data\" *matRowDef=\"let row; columns: content.columnsObjectProperty;\" (click)=\"selectRow(row)\"></tr>\n    </ng-template>\n\n</table>\n\n<mat-paginator\n    [length]=\"content.length\"\n    [pageIndex]=\"content.pageIndex\"\n    [pageSize]=\"content.pageSize\"\n    [pageSizeOptions]=\"content.pageSizeOptions\"\n    [hidePageSize]=\"content.hidePageSize\"\n    [showFirstLastButtons]=\"content.showFirstLastButtons\">\n</mat-paginator>\n",
                styles: ["table{table-layout:fixed;width:100%;padding:2em 1em 0}tr.mat-header-row{height:54px}tr.mat-footer-row,tr.mat-row{height:46px}.div-mat-button-actions{display:inline-block;margin-bottom:5px}.div-mat-button{margin-top:5px;margin-right:5px;vertical-align:middle;box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.mat-cell-mat-icon{margin-top:5px;margin-right:5px;margin-bottom:5px;vertical-align:middle}th{padding-right:10px!important;padding-left:10px!important;background-color:#f5f7f7!important;border-top:1px solid #bdc3c7;border-bottom:1px solid transparent}td:first-of-type,th:first-of-type{border-left:1px solid #bdc3c7}td:last-of-type,th:last-of-type{border-right:1px solid #bdc3c7}th:not(:last-of-type)::before{content:\" \";position:absolute;top:0;right:0;height:28px;margin-top:12px;text-indent:-2000px;border-right:1px solid #bdc3c7;outline:0}td{padding-right:10px!important;padding-left:10px!important;border-top:1px solid transparent;border-right:1px solid transparent;border-left:1px solid transparent;border-bottom:1px solid #d9dcde;transition:.3s ease-out}tr:first-of-type td{border-top:1px solid #bdc3c7}tr:last-of-type td{border-bottom:1px solid #bdc3c7}td.new-release{color:#f83821}td.selected-row{background-color:#d7d7d7!important;color:#10f!important;border-top:1px solid #10f!important;border-right:1px solid #10f!important;border-bottom:1px solid #10f!important}td.selected-row:first-of-type{border-left:1px solid #10f!important}.loading-table-information{margin:3em auto;cursor:default}.empty-table-information{margin:6em 0;text-align:center;cursor:default}tr.row-data{cursor:pointer}tr.row-data:hover td{background-color:#eee;border-top:1px solid #10f;border-right:1px solid #10f;border-bottom:1px solid #10f}tr.row-data:hover td:first-of-type{border-left:1px solid #10f}tr.row-data:active{background-color:#eee}:host ::ng-deep .mat-sort-header-container{justify-content:center}th.mat-sort-header-sorted{color:#f01}"]
            }] }
];
/** @nocollapse */
TableComponent.ctorParameters = () => [
    { type: Router },
    { type: ActivatedRoute }
];
TableComponent.propDecorators = {
    _sort: [{ type: ViewChild, args: [MatSort, { static: true },] }],
    _paginator: [{ type: ViewChild, args: [MatPaginator, { static: true },] }],
    content: [{ type: Input }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    TableComponent._defaultDataSource;
    /**
     * Returns the amount of backend subscriptions.
     * When its value is different of 0, means the component is loading the data source.
     * In this way, it shows/hides the loading progress control.
     * By default, its value is `0`.
     * @type {?}
     * @private
     */
    TableComponent.prototype._countBackendSubscriptions;
    /**
     * @type {?}
     * @private
     */
    TableComponent.prototype._content;
    /**
     * Returns the stream that emits the page that should be rendered by the table,
     * when there is a change in the filtering, sorting, or pagination of the data. Each object
     * in the `data` field represents one row. This is made for someone that wants to know it.
     * @type {?}
     * @private
     */
    TableComponent.prototype._page;
    /**
     * @type {?}
     * @private
     */
    TableComponent.prototype._pageAsObservable;
    /**
     * @type {?}
     * @private
     */
    TableComponent.prototype._dataSource;
    /**
     * @type {?}
     * @private
     */
    TableComponent.prototype._selectedRow;
    /**
     * Stream that emits when a new filter is set on the data source.
     * Because of the behavior and appearance of the component, it is necessary to use
     * `Subject` instead of `BehaviorSubject` to represent the `_filterValuesChange`.
     * @type {?}
     * @private
     */
    TableComponent.prototype._filterValuesChange;
    /**
     * @type {?}
     * @private
     */
    TableComponent.prototype._filterValues;
    /**
     * @type {?}
     * @private
     */
    TableComponent.prototype._filterValuesSubscription;
    /**
     * @type {?}
     * @private
     */
    TableComponent.prototype._sort;
    /**
     * @type {?}
     * @private
     */
    TableComponent.prototype._paginator;
    /**
     * Subscription to the changes that should trigger an update to the table's rendered rows, such
     * as filtering, sorting, or pagination.
     * @type {?}
     * @private
     */
    TableComponent.prototype._renderChangesSubscription;
    /**
     * @type {?}
     * @private
     */
    TableComponent.prototype._router;
    /**
     * @type {?}
     * @private
     */
    TableComponent.prototype._activatedRoute;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFibGUuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vdG9jby1saWIvIiwic291cmNlcyI6WyJsaWIvZm9ybXMvY29udGFpbmVyL3RhYmxlL3RhYmxlLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUNBLE9BQU8sRUFBRSxTQUFTLEVBQXFCLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDL0UsT0FBTyxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUN6RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBbUIsTUFBTSxtQkFBbUIsQ0FBQztBQUMvRixPQUFPLEVBQWMsWUFBWSxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDeEUsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFlBQVksRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXBHLE9BQU8sRUFBRSxhQUFhLEVBQXlFLE1BQU0sMEJBQTBCLENBQUM7O0FBVWhJLE1BQVksZUFBZTtJQUV2Qjs7T0FFRztJQUNILEtBQUssR0FBQTtJQUVMOzs7T0FHRztJQUNILFFBQVEsR0FBQTtJQUVSOzs7T0FHRztJQUNILFdBQVcsR0FBQTtFQUNkOzs7Ozs7OztBQUVELGlDQUlDOzs7SUFIRywyQkFBYTs7SUFDYiw0QkFBYzs7SUFDZCw4QkFBZ0I7Ozs7Ozs7O0FBT3BCLGtDQXNHQzs7Ozs7OztJQWhHRyw2Q0FBaUM7Ozs7OztJQU1qQyx5Q0FBNkI7Ozs7OztJQU03QixvQ0FBd0I7Ozs7OztJQU14Qix5Q0FBc0M7Ozs7Ozs7O0lBUXRDLDhDQUE2RTs7Ozs7O0lBUTdFLDhDQUFnQzs7Ozs7O0lBUWhDLDhCQUF3Qjs7Ozs7O0lBTXhCLDRCQUFZOzs7Ozs7SUFNWiw4QkFBZ0I7Ozs7OztJQU1oQixpQ0FBbUI7Ozs7OztJQU1uQixn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Q0FBQyxDQUFFLEVBQUcsQ0FBRSxDQUFDLENBQUM7O1lBMUJ6RyxTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLFlBQVk7Z0JBQ3RCLDRvSUFBcUM7O2FBRXhDOzs7O1lBM0xRLE1BQU07WUFBRSxjQUFjOzs7b0JBK04xQixTQUFTLFNBQUMsT0FBTyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTt5QkFHbkMsU0FBUyxTQUFDLFlBQVksRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7c0JBdVd4QyxLQUFLOzs7Ozs7O0lBeFhOLGtDQUFzRzs7Ozs7Ozs7O0lBYnRHLG9EQUEyQzs7Ozs7SUFFM0Msa0NBQW9DOzs7Ozs7OztJQU9wQywrQkFBMkM7Ozs7O0lBQzNDLDJDQUFpRDs7Ozs7SUFDakQscUNBQTZDOzs7OztJQUc3QyxzQ0FBNkI7Ozs7Ozs7O0lBTzdCLDZDQUE0RDs7Ozs7SUFFNUQsdUNBQW9DOzs7OztJQUVwQyxtREFBd0Q7Ozs7O0lBRXhELCtCQUN1Qjs7Ozs7SUFFdkIsb0NBQ2lDOzs7Ozs7O0lBTWpDLG9EQUFpRDs7Ozs7SUFFOUIsaUNBQXVCOzs7OztJQUFFLHlDQUF1QyIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQsIE9uRGVzdHJveSwgVmlld0NoaWxkLCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyLCBBY3RpdmF0ZWRSb3V0ZSB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XG5pbXBvcnQgeyBNYXRUYWJsZURhdGFTb3VyY2UsIE1hdFNvcnQsIE1hdFBhZ2luYXRvciwgU29ydCwgUGFnZUV2ZW50IH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uLCBTdWJqZWN0LCBjb21iaW5lTGF0ZXN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBzdGFydFdpdGgsIHN3aXRjaE1hcCwgZmluYWxpemUsIGRlYm91bmNlVGltZSwgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmltcG9ydCB7IFNvcnREaXJlY3Rpb24sIEZpbHRlckNvbnRyb2xzLCBGaWx0ZXJWYWx1ZXMsIFBhZ2UsIFBhcmFtcywgQmFja2VuZERhdGFTb3VyY2VGdW5jdGlvbiB9IGZyb20gJy4uLy4uLy4uL2NvcmUvcHVibGljLWFwaSc7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIENTUyBzdHlsZXMuIFxuICovXG5leHBvcnQgdHlwZSBDc3NTdHlsZXMgPSBQYXJhbXM8c3RyaW5nPjtcblxuLyoqXG4gKiBBbiBlbnVtIHRoYXQgcmVwcmVzZW50cyBob3cgdG8gd3JhcCB0aGUgY29udGVudCBvZiBhIHRhYmxlIGNlbGwuIFxuICovXG5leHBvcnQgZW51bSBDZWxsQ29udGVudFdyYXBcbntcbiAgICAvKipcbiAgICAgKiBUaGUgYGJyZWFrYCB3cmFwIGJyZWFrcyB0aGUgY29udGVudCB3aGVuIHJlYWNoaW5nIHRoZSBlbmQgb2YgYSBsaW5lLiBcbiAgICAgKi9cbiAgICBicmVhayxcblxuICAgIC8qKlxuICAgICAqIFRoZSBgZWxsaXBzaXNgIHdyYXAgY2xpcHMgdGhlIHJlbWFpbmluZyBjb250ZW50IGFuZCByZW5kZXJzIGFuIGVsbGlwc2lzIChcIi4uLlwiKSBcbiAgICAgKiB0byByZXByZXNlbnQgdGhlIGNsaXBwZWQgY29udGVudC4gXG4gICAgICovXG4gICAgZWxsaXBzaXMsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYHJlc3BvbnNpYmxlYCB3cmFwIGlzIHRoZSBkZWZhdWx0IHN0eWxlLiBJdCBvbmx5IGFwcGxpZXMgdGhlIHJlc3BvbnNpYmxlIHN0eWxlcyBcbiAgICAgKiB0aGF0IGFyZSBkZWZpbmVkIGluIHRoZSB0YWJsZS4gXG4gICAgICovXG4gICAgcmVzcG9uc2libGVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUYWJsZUFjdGlvbiB7XG4gICAgaWNvbjogc3RyaW5nO1xuICAgIHJvdXRlOiBzdHJpbmc7XG4gICAgdG9vbHRpcDogc3RyaW5nO1xufVxuXG4vKipcbiAqIEEgaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY29udGVudCBvZiBhIHRhYmxlIGNvbnRyb2wuIFxuICogVGhlIGdlbmVyaWMgcGFyYW1ldGVyIFQgYWx3YXlzIHJlZmVycyB0byB0aGUgdHlwZSBvZiBkYXRhIHRoYXQgaXQgaXMgZGVhbGluZyB3aXRoLiBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUYWJsZUNvbnRlbnQ8VD5cbntcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhcnJheSBvZiBzdHJpbmdzIHRoYXQgaW5kaWNhdGVzIHRoZSBvYmplY3QgcHJvcGVydHkgbmFtZSBvZiB0aGUgY29sdW1ucy4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBbXWAuIFxuICAgICAqL1xuICAgIGNvbHVtbnNPYmplY3RQcm9wZXJ0eT86IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGluZGljYXRlcyB0aGUgaGVhZGVyIHRleHQgb2YgdGhlIGNvbHVtbnMuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgW11gLiBcbiAgICAgKi9cbiAgICBjb2x1bW5zSGVhZGVyVGV4dD86IHN0cmluZ1tdO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGluZGljYXRlcyB0aGUgd2lkdGggb2YgdGhlIGNvbHVtbnMuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgW11gLiBcbiAgICAgKi9cbiAgICBjb2x1bW5zV2lkdGg/OiBzdHJpbmdbXTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFycmF5IG9mIGBDZWxsQ29udGVudFdyYXBgIHRoYXQgaW5kaWNhdGVzIGhvdyB0byB3cmFwIHRoZSBjb250ZW50IG9mIHRoZSBjb2x1bW5zLiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYFtdYC4gXG4gICAgICovXG4gICAgY29sdW1uQ29udGVudFdyYXA/OiBDZWxsQ29udGVudFdyYXBbXTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgdGhlIGxpc3Qgb2YgQ1NTIGNsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIHRhYmxlIHJvd3MuIFxuICAgICAqIEluIG9yZGVyIHRvIHRha2UgZWZmZWN0IHRoZXNlIGNsYXNzZXMsIHRoZSB0YWJsZSBDU1MgZmlsZSBtdXN0IGhhdmUgZGVmaW5lZCB0aGVzZSBjbGFzc2VzLiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuIFxuICAgICAqIEBwYXJhbSByb3dEYXRhIFRoZSBkYXRhIHRoYXQgaXMgY29udGFpbmVkIGluIHRoZSByb3cuIFxuICAgICAqL1xuICAgIGNyZWF0ZUNzc0NsYXNzZXNGb3JSb3c/OiAocm93RGF0YTogYW55KSA9PiB7IFtjbGFzc05hbWU6IHN0cmluZ106IGJvb2xlYW47IH07XG5cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvcGVydHkgbmFtZSBvZiB0aGUgZGF0YSBjb250YWluZWQgaW4gYHBhZ2VgIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSB0aGF0IGRhdGEuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgJydgLiBcbiAgICAgKi9cbiAgICBwcm9wZXJ0eU5hbWVUb0lkZW50aWZ5Pzogc3RyaW5nO1xuXG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50IGZpbHRlciBzdGF0ZS4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGB7fWAuIFxuICAgICAqL1xuICAgIGZpbHRlcj86IEZpbHRlckNvbnRyb2xzO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgc29ydCBzdGF0ZS4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGB7ICdhY3RpdmUnOiBwcm9wZXJ0eU5hbWVUb0lkZW50aWZ5LCAnZGlyZWN0aW9uJzogU29ydERpcmVjdGlvbi5hc2MgfWAuIFxuICAgICAqL1xuICAgIHNvcnQ/OiBTb3J0O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSB0b3RhbCBudW1iZXIgb2YgaXRlbXMgdGhhdCBhcmUgYmVpbmcgcGFnaW5hdGVkLiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYDBgLiBcbiAgICAgKi9cbiAgICBsZW5ndGg/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB6ZXJvLWJhc2VkIHBhZ2UgaW5kZXggb2YgdGhlIGRpc3BsYXllZCBsaXN0IG9mIGl0ZW1zLiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYDBgLiBcbiAgICAgKi9cbiAgICBwYWdlSW5kZXg/OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgaXRlbXMgdG8gZGlzcGxheSBvbiBhIHBhZ2UuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgNTBgLiBcbiAgICAgKi9cbiAgICBwYWdlU2l6ZT86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNldCBvZiBwcm92aWRlZCBwYWdlIHNpemUgb3B0aW9ucyB0byBkaXNwbGF5IHRvIHRoZSB1c2VyLiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYFsxMCwgMjAsIDUwXWAuIFxuICAgICAqL1xuICAgIHBhZ2VTaXplT3B0aW9ucz86IG51bWJlcltdO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGl0IGhpZGVzIHRoZSBwYWdlIHNpemUgc2VsZWN0aW9uIFVJIGZyb20gdGhlIHVzZXI7IG90aGVyd2lzZSwgZmFsc2UuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgZmFsc2VgLiBcbiAgICAgKi9cbiAgICBoaWRlUGFnZVNpemU/OiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGl0IHNob3dzIHRoZSBmaXJzdC9sYXN0IGJ1dHRvbnMgVUkgdG8gdGhlIHVzZXI7IG90aGVyd2lzZSwgZmFsc2UuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgZmFsc2VgLiBcbiAgICAgKi9cbiAgICBzaG93Rmlyc3RMYXN0QnV0dG9ucz86IGJvb2xlYW47XG5cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZnVuY3Rpb24gdGhhdCBpcyB1c2VkIHRvIGdldCB0aGUgZGF0YSBzb3VyY2UgZnJvbSBiYWNrZW5kLiBcbiAgICAgKiBUaGUgZ2VuZXJpYyBwYXJhbWV0ZXIgVCBhbHdheXMgcmVmZXJzIHRvIHRoZSB0eXBlIG9mIGRhdGEgdGhhdCBpdCBpcyBkZWFsaW5nIHdpdGguIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4gXG4gICAgICovXG4gICAgZW5kcG9pbnQ/OiBCYWNrZW5kRGF0YVNvdXJjZUZ1bmN0aW9uPFQ+O1xuXG4gICAgYWN0aW9ucz86IFRhYmxlQWN0aW9uW107XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBkZWZhdWx0IGBUYWJsZUNvbnRlbnRgLiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRUYWJsZUNvbnRlbnQoKTogVGFibGVDb250ZW50PGFueT5cbntcbiAgICByZXR1cm4ge1xuICAgICAgICAnY29sdW1uc09iamVjdFByb3BlcnR5JzogW10sXG4gICAgICAgICdjb2x1bW5zSGVhZGVyVGV4dCc6IFtdLFxuICAgICAgICAnY29sdW1uc1dpZHRoJzogW10sXG4gICAgICAgICdjb2x1bW5Db250ZW50V3JhcCc6IFtdLFxuICAgICAgICAnY3JlYXRlQ3NzQ2xhc3Nlc0ZvclJvdyc6IHVuZGVmaW5lZCxcblxuICAgICAgICAncHJvcGVydHlOYW1lVG9JZGVudGlmeSc6ICcnLFxuXG4gICAgICAgICdmaWx0ZXInOiB7fSxcbiAgICAgICAgJ3NvcnQnOiB7XG4gICAgICAgICAgICAnYWN0aXZlJzogdGhpcy5fY29udGVudC5wcm9wZXJ0eU5hbWVUb0lkZW50aWZ5LFxuICAgICAgICAgICAgJ2RpcmVjdGlvbic6IFNvcnREaXJlY3Rpb24uYXNjXG4gICAgICAgIH0sXG4gICAgICAgICdsZW5ndGgnOiAwLFxuICAgICAgICAncGFnZUluZGV4JzogMCxcbiAgICAgICAgJ3BhZ2VTaXplJzogNTAsXG4gICAgICAgICdwYWdlU2l6ZU9wdGlvbnMnOiBbMTAsIDIwLCA1MF0sXG4gICAgICAgICdoaWRlUGFnZVNpemUnOiBmYWxzZSxcbiAgICAgICAgJ3Nob3dGaXJzdExhc3RCdXR0b25zJzogZmFsc2UsXG5cbiAgICAgICAgJ2VuZHBvaW50JzogdW5kZWZpbmVkXG4gICAgfTtcbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJlcHJlc2VudHMgYSB0YWJsZSBjb250cm9sLiBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICd0b2NvLXRhYmxlJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdGFibGUuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3RhYmxlLmNvbXBvbmVudC5zY3NzJ11cbn0pXG5leHBvcnQgY2xhc3MgVGFibGVDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveVxue1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBiYWNrZW5kIHN1YnNjcmlwdGlvbnMuIFxuICAgICAqIFdoZW4gaXRzIHZhbHVlIGlzIGRpZmZlcmVudCBvZiAwLCBtZWFucyB0aGUgY29tcG9uZW50IGlzIGxvYWRpbmcgdGhlIGRhdGEgc291cmNlLiBcbiAgICAgKiBJbiB0aGlzIHdheSwgaXQgc2hvd3MvaGlkZXMgdGhlIGxvYWRpbmcgcHJvZ3Jlc3MgY29udHJvbC4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGAwYC4gXG4gICAgICovXG4gICAgcHJpdmF0ZSBfY291bnRCYWNrZW5kU3Vic2NyaXB0aW9uczogbnVtYmVyO1xuXG4gICAgcHJpdmF0ZSBfY29udGVudDogVGFibGVDb250ZW50PGFueT47XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdHJlYW0gdGhhdCBlbWl0cyB0aGUgcGFnZSB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCBieSB0aGUgdGFibGUsIFxuICAgICAqIHdoZW4gdGhlcmUgaXMgYSBjaGFuZ2UgaW4gdGhlIGZpbHRlcmluZywgc29ydGluZywgb3IgcGFnaW5hdGlvbiBvZiB0aGUgZGF0YS4gRWFjaCBvYmplY3QgXG4gICAgICogaW4gdGhlIGBkYXRhYCBmaWVsZCByZXByZXNlbnRzIG9uZSByb3cuIFRoaXMgaXMgbWFkZSBmb3Igc29tZW9uZSB0aGF0IHdhbnRzIHRvIGtub3cgaXQuIFxuICAgICAqL1xuICAgIHByaXZhdGUgcmVhZG9ubHkgX3BhZ2U6IFN1YmplY3Q8UGFnZTxhbnk+PjsgIFxuICAgIHByaXZhdGUgX3BhZ2VBc09ic2VydmFibGU6IE9ic2VydmFibGU8UGFnZTxhbnk+PjtcbiAgICBwcml2YXRlIF9kYXRhU291cmNlOiBNYXRUYWJsZURhdGFTb3VyY2U8YW55PjtcbiAgICAvKiBSZXR1cm5zIGEgZGF0YSBzb3VyY2Ugd2l0aCBvbmx5IG9uZSBlbXB0eSBlbGVtZW50LiAqL1xuICAgIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IF9kZWZhdWx0RGF0YVNvdXJjZTogTWF0VGFibGVEYXRhU291cmNlPGFueT4gPSBuZXcgTWF0VGFibGVEYXRhU291cmNlKFsgeyB9IF0pO1xuICAgIHByaXZhdGUgX3NlbGVjdGVkUm93OiBudW1iZXI7ICAvKiBSZXByZXNlbnRzIHRoZSBzZWxlY3RlZCByb3cuICovXG5cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gdGhhdCBlbWl0cyB3aGVuIGEgbmV3IGZpbHRlciBpcyBzZXQgb24gdGhlIGRhdGEgc291cmNlLiBcbiAgICAgKiBCZWNhdXNlIG9mIHRoZSBiZWhhdmlvciBhbmQgYXBwZWFyYW5jZSBvZiB0aGUgY29tcG9uZW50LCBpdCBpcyBuZWNlc3NhcnkgdG8gdXNlIFxuICAgICAqIGBTdWJqZWN0YCBpbnN0ZWFkIG9mIGBCZWhhdmlvclN1YmplY3RgIHRvIHJlcHJlc2VudCB0aGUgYF9maWx0ZXJWYWx1ZXNDaGFuZ2VgLiBcbiAgICAgKi9cbiAgICBwcml2YXRlIHJlYWRvbmx5IF9maWx0ZXJWYWx1ZXNDaGFuZ2U6IFN1YmplY3Q8RmlsdGVyVmFsdWVzPjtcbiAgICAvKiBUaGUgY3VycmVudCBmaWx0ZXIgdmFsdWVzLiAqL1xuICAgIHByaXZhdGUgX2ZpbHRlclZhbHVlczogRmlsdGVyVmFsdWVzO1xuICAgIC8qIFRoZSBjdXJyZW50IHN1YnNjcmlwdGlvbnMgZm9yIG9ic2VydmluZyB0aGUgY2hhbmdlcyBpbiB0aGUgZmlsdGVyIGNvbnRyb2xzIHZhbHVlLiBJdCBoYXMgdGhlIHNhbWUgcHJvcGVydGllcyB0aGFuIGBfZmlsdGVyVmFsdWVzYCAqL1xuICAgIHByaXZhdGUgX2ZpbHRlclZhbHVlc1N1YnNjcmlwdGlvbjogUGFyYW1zPFN1YnNjcmlwdGlvbj47XG5cbiAgICBAVmlld0NoaWxkKE1hdFNvcnQsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJpdmF0ZSBfc29ydDogTWF0U29ydDtcblxuICAgIEBWaWV3Q2hpbGQoTWF0UGFnaW5hdG9yLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByaXZhdGUgX3BhZ2luYXRvcjogTWF0UGFnaW5hdG9yO1xuXG4gICAgLyoqXG4gICAgICogU3Vic2NyaXB0aW9uIHRvIHRoZSBjaGFuZ2VzIHRoYXQgc2hvdWxkIHRyaWdnZXIgYW4gdXBkYXRlIHRvIHRoZSB0YWJsZSdzIHJlbmRlcmVkIHJvd3MsIHN1Y2ggXG4gICAgICogYXMgZmlsdGVyaW5nLCBzb3J0aW5nLCBvciBwYWdpbmF0aW9uLiBcbiAgICAgKi9cbiAgICBwcml2YXRlIF9yZW5kZXJDaGFuZ2VzU3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBfcm91dGVyOiBSb3V0ZXIsIHByaXZhdGUgX2FjdGl2YXRlZFJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSlcbiAgICB7XG4gICAgICAgIC8qIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgMGAsIG1lYW5zIHRoZSBjb21wb25lbnQgaXMgTk9UIGxvYWRpbmcgdGhlIGRhdGEgc291cmNlLiAqL1xuICAgICAgICB0aGlzLl9jb3VudEJhY2tlbmRTdWJzY3JpcHRpb25zID0gMDtcblxuICAgICAgICB0aGlzLl9wYWdlID0gbmV3IFN1YmplY3Q8UGFnZTxhbnk+PigpO1xuICAgICAgICB0aGlzLl9wYWdlQXNPYnNlcnZhYmxlID0gdGhpcy5fcGFnZS5hc09ic2VydmFibGUoKTtcblxuICAgICAgICB0aGlzLl9kYXRhU291cmNlID0gbmV3IE1hdFRhYmxlRGF0YVNvdXJjZSgpO1xuXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkUm93ID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIHRoaXMuX2ZpbHRlclZhbHVlc0NoYW5nZSA9IG5ldyBTdWJqZWN0PEZpbHRlclZhbHVlcz4oKTtcbiAgICAgICAgdGhpcy5fZmlsdGVyVmFsdWVzID0ge307XG4gICAgICAgIHRoaXMuX2ZpbHRlclZhbHVlc1N1YnNjcmlwdGlvbiA9IHt9O1xuXG4gICAgICAgIHRoaXMuX3JlbmRlckNoYW5nZXNTdWJzY3JpcHRpb24gPSBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8qIFNldHMgdGhlIGRlZmF1bHQgdmFsdWVzIG9ubHkgaWYgdGhlIGBfY29udGVudGAgaGFzIG5vdCBiZWVuIHNldCB5ZXQuICovXG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50ID09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogRGlzcG9zZXMgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uICovXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2ZpbHRlclZhbHVlc1N1YnNjcmlwdGlvbikuZm9yRWFjaCgobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJWYWx1ZXNTdWJzY3JpcHRpb25bbmFtZV0udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLyogRGlzcG9zZXMgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uICovXG4gICAgICAgIHRoaXMuX3JlbmRlckNoYW5nZXNTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRhdGEgc291cmNlIGlzIGVtcHR5OyBvdGhlcndpc2UsIGZhbHNlLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGlzRW1wdHkoKTogYm9vbGVhblxuICAgIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9kYXRhU291cmNlLmRhdGEubGVuZ3RoID09IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQuIFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIHRoaXMuX2luaXRDb250ZW50KCk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQ2hhbmdlU3Vic2NyaXB0aW9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGBjb250ZW50YCBpbnB1dCBwcm9wZXJ0eS4gXG4gICAgICovXG4gICAgcHJpdmF0ZSBfaW5pdENvbnRlbnQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZXMuICovXG5cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQgPT0gdW5kZWZpbmVkKSB0aGlzLl9jb250ZW50ID0geyB9OyAgLyogVGhpcyBjb2RlIGxpbmUgbXVzdCBiZSBoZXJlLiAqL1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqIGBtYXQtY2VsbGAgcHJvcGVydGllcy4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBpZiAodGhpcy5fY29udGVudC5jb2x1bW5zT2JqZWN0UHJvcGVydHkgPT0gdW5kZWZpbmVkKSB0aGlzLl9jb250ZW50LmNvbHVtbnNPYmplY3RQcm9wZXJ0eSA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fY29udGVudC5jb2x1bW5zSGVhZGVyVGV4dCA9PSB1bmRlZmluZWQpIHRoaXMuX2NvbnRlbnQuY29sdW1uc0hlYWRlclRleHQgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQuY29sdW1uc1dpZHRoID09IHVuZGVmaW5lZCkgdGhpcy5fY29udGVudC5jb2x1bW5zV2lkdGggPSBbXTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQuY29sdW1uQ29udGVudFdyYXAgPT0gdW5kZWZpbmVkKSB0aGlzLl9jb250ZW50LmNvbHVtbkNvbnRlbnRXcmFwID0gW107XG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50LmNyZWF0ZUNzc0NsYXNzZXNGb3JSb3cgPT0gdW5kZWZpbmVkKSB0aGlzLl9jb250ZW50LmNyZWF0ZUNzc0NsYXNzZXNGb3JSb3cgPSB0aGlzLmRlZmF1bHRDcmVhdGVDc3NDbGFzc2VzRm9yUm93LmJpbmQodGhpcyk7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKiogYG1hdC1yb3dgIHByb3BlcnRpZXMuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50LnByb3BlcnR5TmFtZVRvSWRlbnRpZnkgPT0gdW5kZWZpbmVkKSB0aGlzLl9jb250ZW50LnByb3BlcnR5TmFtZVRvSWRlbnRpZnkgPSAnJztcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBgZmlsdGVyYCBwcm9wZXJ0aWVzLiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQuZmlsdGVyID09IHVuZGVmaW5lZCkgdGhpcy5fY29udGVudC5maWx0ZXIgPSB7fTtcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogYHNvcnRgIHByb3BlcnRpZXMuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQuc29ydCA9PSB1bmRlZmluZWQpIHRoaXMuX2NvbnRlbnQuc29ydCA9IHtcbiAgICAgICAgICAgICdhY3RpdmUnOiB0aGlzLl9jb250ZW50LnByb3BlcnR5TmFtZVRvSWRlbnRpZnksXG4gICAgICAgICAgICAnZGlyZWN0aW9uJzogU29ydERpcmVjdGlvbi5hc2NcbiAgICAgICAgfTtcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKiBgbWF0LXBhZ2luYXRvcmAgcHJvcGVydGllcy4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQubGVuZ3RoID09IHVuZGVmaW5lZCkgdGhpcy5fY29udGVudC5sZW5ndGggPSAwO1xuICAgICAgICBpZiAodGhpcy5fY29udGVudC5wYWdlSW5kZXggPT0gdW5kZWZpbmVkKSB0aGlzLl9jb250ZW50LnBhZ2VJbmRleCA9IDA7XG4gICAgICAgIGlmICh0aGlzLl9jb250ZW50LnBhZ2VTaXplID09IHVuZGVmaW5lZCkgdGhpcy5fY29udGVudC5wYWdlU2l6ZSA9IDUwO1xuICAgICAgICBpZiAodGhpcy5fY29udGVudC5wYWdlU2l6ZU9wdGlvbnMgPT0gdW5kZWZpbmVkKSB0aGlzLl9jb250ZW50LnBhZ2VTaXplT3B0aW9ucyA9IFsxMCwgMjAsIDUwXTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQuaGlkZVBhZ2VTaXplID09IHVuZGVmaW5lZCkgdGhpcy5fY29udGVudC5oaWRlUGFnZVNpemUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnQuc2hvd0ZpcnN0TGFzdEJ1dHRvbnMgPT0gdW5kZWZpbmVkKSB0aGlzLl9jb250ZW50LnNob3dGaXJzdExhc3RCdXR0b25zID0gZmFsc2U7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqIEludGVybmFsIGNvbnRyb2wgcHJvcGVydGllcy4gKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogT3RoZXIgcHJvcGVydGllcy4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIC8qIFRoZSBgX2NvbnRlbnQuZW5kcG9pbnRgIGZpZWxkIGlzIGB1bmRlZmluZWRgIGJ5IGRlZmF1bHQuICovXG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKiBNdXN0IGJlIHRoZSBsYXN0IGluaXRpYWxpemF0aW9uLiAqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIHRoaXMuY2hlY2tDb2x1bW4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBmaWVsZHMgcmVsYXRlZCB0byB0aGUgZmlsdGVyIGNvbXBvbmVudC4gXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdXBkYXRlRmlsdGVyKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8qIEZvciBlYWNoIGZpbHRlciBwcm9wZXJ0eS4gKi9cbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fY29udGVudC5maWx0ZXIpLmZvckVhY2goKGZpbHRlck5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgLyogU2F2ZXMgdGhlIGluaXRpYWwgdmFsdWVzLiAqL1xuICAgICAgICAgICAgdGhpcy5fZmlsdGVyVmFsdWVzW2ZpbHRlck5hbWVdID0gdGhpcy5fY29udGVudC5maWx0ZXJbZmlsdGVyTmFtZV0uY29udGVudC5mb3JtQ29udHJvbC52YWx1ZTtcblxuICAgICAgICAgICAgLyogRGlzcG9zZXMgdGhlIHJlc291cmNlcyBoZWxkIGJ5IHRoZSBzdWJzY3JpcHRpb24uICovXG4gICAgICAgICAgICBpZiAodGhpcy5fZmlsdGVyVmFsdWVzU3Vic2NyaXB0aW9uW2ZpbHRlck5hbWVdICE9IHVuZGVmaW5lZCkgdGhpcy5fZmlsdGVyVmFsdWVzU3Vic2NyaXB0aW9uW2ZpbHRlck5hbWVdLnVuc3Vic2NyaWJlKCk7XG5cbiAgICAgICAgICAgIC8qIFN1YnNjcmliZXMgdG8gb2JzZXJ2ZSB0aGUgY2hhbmdlcyBpbiB0aGUgY29udHJvbCB2YWx1ZSB3aGVuIHRoZXJlIGlzIGFuIGV4dGVybmFsIGNoYW5nZS4gKi9cbiAgICAgICAgICAgIHRoaXMuX2ZpbHRlclZhbHVlc1N1YnNjcmlwdGlvbltmaWx0ZXJOYW1lXSA9IHRoaXMuX2NvbnRlbnQuZmlsdGVyW2ZpbHRlck5hbWVdLmNvbnRlbnQuZm9ybUNvbnRyb2wudmFsdWVDaGFuZ2VzLnBpcGUoXG4gICAgICAgICAgICAgICAgLyogV2FpdHMgNTAwbXMgYWZ0ZXIgZWFjaCBrZXlzdHJva2UgYmVmb3JlIGNvbnNpZGVyaW5nIHRoZSB0ZXJtLiAqL1xuICAgICAgICAgICAgICAgIGRlYm91bmNlVGltZSg1MDApLFxuICAgICAgICAgICAgICAgIC8qIElnbm9yZXMgbmV3IHRlcm0gaWYgc2FtZSBhcyBwcmV2aW91cyB0ZXJtLiAqL1xuICAgICAgICAgICAgICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHZhbHVlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5RmlsdGVyKGZpbHRlck5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBmaWVsZHMgcmVsYXRlZCB0byBzb3J0aW5nLiBcbiAgICAgKiBAcGFyYW0gc29ydEV2ZW50IFRoZSBuZXcgc29ydGluZyB0byBzZXQuIFxuICAgICAqL1xuICAgIHByaXZhdGUgX3VwZGF0ZVNvcnQoc29ydEV2ZW50OiBTb3J0KTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogSW4gdGhpcyBjYXNlLCBgX2NvbnRlbnRgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgbmV3IHZhbHVlczsgdGhlIGBNYXRTb3J0YCBhbHJlYWR5IGhhcyB0aGVtLiAqL1xuICAgICAgICB0aGlzLl9jb250ZW50LnNvcnQuYWN0aXZlID0gc29ydEV2ZW50LmFjdGl2ZTtcbiAgICAgICAgdGhpcy5fY29udGVudC5zb3J0LmRpcmVjdGlvbiA9IHNvcnRFdmVudC5kaXJlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYE1hdFNvcnRgIGluaXRpYWwgdmFsdWVzLiBcbiAgICAgKiBUaGUgZmlsdGVyIGNvbXBvbmVudCBhbmQgYE1hdFBhZ2luYXRvcmAgYXJlIGluaXRpYWxpemVkIGluIGEgZGlmZmVyZW50IHdheS4gXG4gICAgICovXG4gICAgcHJpdmF0ZSBfc2V0TWF0U29ydEluaXRpYWxWYWx1ZSgpOiB2b2lkXG4gICAge1xuICAgICAgICAvKiBTYXZlcyB0aGUgaW5pdGlhbCB2YWx1ZXMuICovXG4gICAgICAgIHRoaXMuX3NvcnQuYWN0aXZlID0gdGhpcy5fY29udGVudC5zb3J0LmFjdGl2ZTtcbiAgICAgICAgdGhpcy5fc29ydC5kaXJlY3Rpb24gPSB0aGlzLl9jb250ZW50LnNvcnQuZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGZpZWxkcyByZWxhdGVkIHRvIHBhZ2luYXRpb24uIFxuICAgICAqIEBwYXJhbSBuZXdQYWdlIFRoZSBuZXcgcGFnZSB0byBzZXQuIEl0cyB0eXBlIGlzIGBQYWdlPGFueT5gIG9yIGBQYWdlRXZlbnRgLiBcbiAgICAgKi9cbiAgICBwcml2YXRlIF91cGRhdGVQYWdpbmF0b3IobmV3UGFnZTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogSW4gdGhpcyBjYXNlLCBgX2NvbnRlbnRgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgbmV3IHZhbHVlcywgdGhlbiB0aGUgYE1hdFBhZ2luYXRvcmAgXG4gICAgICAgICAqIHRha2VzIHRoZSB2YWx1ZXMgdmlhIHByb3BlcnR5IGJpbmRpbmcgZnJvbSBgX2NvbnRlbnRgICh0aHJvdWdoIHRoZSB0ZW1wbGF0ZSkuICovXG4gICAgICAgIHRoaXMuX2NvbnRlbnQubGVuZ3RoID0gKG5ld1BhZ2UudG90YWxEYXRhIHx8IG5ld1BhZ2UubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fY29udGVudC5wYWdlSW5kZXggPSBuZXdQYWdlLnBhZ2VJbmRleDtcbiAgICAgICAgdGhpcy5fY29udGVudC5wYWdlU2l6ZSA9IG5ld1BhZ2UucGFnZVNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYE1hdFNvcnRgIGFuZCBgTWF0UGFnaW5hdG9yYCBkaXNhYmxlZCBvciBub3QuIFxuICAgICAqIEBwYXJhbSBkaXNhYmxlZCBXaGV0aGVyIHRoZSBgTWF0U29ydGAgYW5kIGBNYXRQYWdpbmF0b3JgIGFyZSBkaXNhYmxlZC4gXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZGlzYWJsZWRTb3J0UGFnaW5hdG9yKGRpc2FibGVkOiBib29sZWFuKTogdm9pZFxuICAgIHtcbiAgICAgICAgdGhpcy5fc29ydC5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgICAgICB0aGlzLl9wYWdpbmF0b3IuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmVzIHRvIGNoYW5nZXMgdGhhdCBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgdG8gdGhlIHRhYmxlJ3MgcmVuZGVyZWQgcm93cy4gV2hlbiB0aGUgXG4gICAgICogY2hhbmdlcyBvY2N1ciwgcHJvY2VzcyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZmlsdGVyLCBzb3J0LCBhbmQgcGFnaW5hdGlvbiBhbG9uZyB3aXRoIFxuICAgICAqIHRoZSBwcm92aWRlZCBiYXNlIGRhdGEgYW5kIHNlbmQgaXQgdG8gdGhlIHRhYmxlIGZvciByZW5kZXJpbmcuIFxuICAgICAqL1xuICAgIHByaXZhdGUgX3VwZGF0ZUNoYW5nZVN1YnNjcmlwdGlvbigpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5fY29udGVudC5lbmRwb2ludCA9PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgICAgICAvKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gKi9cbiAgICAgICAgdGhpcy5fcmVuZGVyQ2hhbmdlc1N1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuXG4gICAgICAgIC8qIFVwZGF0ZXMgdGhlIGZpZWxkcyByZWxhdGVkIHRvIHRoZSBmaWx0ZXIgY29tcG9uZW50OyB0aGUgYE1hdFNvcnRgIGFuZCBgTWF0UGFnaW5hdG9yYCBhcmUgdXBkYXRlZCBsYXRlci4gKi9cbiAgICAgICAgdGhpcy5fdXBkYXRlRmlsdGVyKCk7XG4gICAgICAgIC8qIFNldHMgdGhlIGBNYXRTb3J0YCBpbml0aWFsIHZhbHVlczsgdGhlIGZpbHRlciBjb21wb25lbnQgYW5kIGBNYXRQYWdpbmF0b3JgIGFyZSBpbml0aWFsaXplZCBpbiBhIGRpZmZlcmVudCB3YXkuICovXG4gICAgICAgIHRoaXMuX3NldE1hdFNvcnRJbml0aWFsVmFsdWUoKTtcblxuICAgICAgICAvKiBUaGUgYF9maWx0ZXJWYWx1ZXNDaGFuZ2VgIGlzIGFsd2F5cyBwcmVzZW50OyBhbHRob3VnaCB0aGUgdXNlciBkZWNpZGVzIGlmIGl0IGlzIHVzZWQgb3Igbm90LiBcbiAgICAgICAgICogQWxzbywgYE1hdFNvcnRgIGFuZCBgTWF0UGFnaW5hdG9yYCBhcmUgYWx3YXlzIHByZXNlbnQgYmVjYXVzZSB0aGV5IGFyZSBtYW5hZ2VkIGJ5IHRoZSBjb21wb25lbnQgY29tcGxldGVseS4gXG4gICAgICAgICAqIFN1YnNjcmliZXMgdG8gZ2V0IHRoZSB2YWx1ZXMgd2hlbiB0aGVyZSBpcyBhIGNoYW5nZSBpbiB0aGUgZmlsdGVyaW5nLCBzb3J0aW5nLCBvciBwYWdpbmF0aW9uIG9mIHRoZSBkYXRhLiAqL1xuICAgICAgICB0aGlzLl9yZW5kZXJDaGFuZ2VzU3Vic2NyaXB0aW9uID0gY29tYmluZUxhdGVzdChbXG4gICAgICAgICAgICB0aGlzLl9maWx0ZXJWYWx1ZXNDaGFuZ2UucGlwZShcbiAgICAgICAgICAgICAgICAvKiBFbWl0cyB0aGUgZmlyc3QgdmFsdWUuIEZpbHRlcnMgdXNpbmcgdGhlIGluaXRpYWwgdmFsdWVzLiBUaGUgb3BlcmF0b3JzIG11c3QgYmUgY2FsbGVkIGluIHRoaXMgb3JkZXIuICovXG4gICAgICAgICAgICAgICAgc3RhcnRXaXRoKHRoaXMuX2ZpbHRlclZhbHVlcylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICB0aGlzLl9zb3J0LnNvcnRDaGFuZ2UucGlwZShcbiAgICAgICAgICAgICAgICAvKiBFbWl0cyB0aGUgZmlyc3QgdmFsdWUuIFNvcnRzIHVzaW5nIHRoZSBpbml0aWFsIHZhbHVlcy4gVGhlIG9wZXJhdG9ycyBtdXN0IGJlIGNhbGxlZCBpbiB0aGlzIG9yZGVyLiAqL1xuICAgICAgICAgICAgICAgIHN0YXJ0V2l0aCh0aGlzLl9jb250ZW50LnNvcnQpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgdGhpcy5fcGFnaW5hdG9yLnBhZ2UucGlwZShcbiAgICAgICAgICAgICAgICAvKiBFbWl0cyB0aGUgZmlyc3QgdmFsdWUuIFBhZ2luYXRlcyB1c2luZyB0aGUgaW5pdGlhbCB2YWx1ZXMuICovXG4gICAgICAgICAgICAgICAgc3RhcnRXaXRoKHtcbiAgICAgICAgICAgICAgICAgICAgJ3BhZ2VJbmRleCc6IHRoaXMuX2NvbnRlbnQucGFnZUluZGV4LFxuICAgICAgICAgICAgICAgICAgICAncGFnZVNpemUnOiB0aGlzLl9jb250ZW50LnBhZ2VTaXplLFxuICAgICAgICAgICAgICAgICAgICAnbGVuZ3RoJzogMCAgLyogSW4gdGhlIGZpcnN0IHZhbHVlLCBpdCBpcyBub3QgaW1wb3J0YW50LiAqL1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgIF0pLnBpcGUoXG4gICAgICAgICAgICAvKiBTd2l0Y2hlcyB0byBuZXcgc2VhcmNoIG9ic2VydmFibGUgZWFjaCB0aW1lIHRoZSB0ZXJtIGNoYW5nZXMuICovXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKFtmaWx0ZXJFdmVudCwgc29ydEV2ZW50LCBwYWdlRXZlbnRdKTogT2JzZXJ2YWJsZTxQYWdlPGFueT4+ID0+IHtcblxuICAgICAgICAgICAgICAgIC8qIEFkZHMgdGhlIG5ldyBiYWNrZW5kIHN1YnNjcmlwdGlvbi4gSXQgYmVnaW5zL2NvbnRpbnVlcyB0aGUgbG9hZGluZyBvZiB0aGUgZGF0YS4gXG4gICAgICAgICAgICAgICAgICogSW4gdGhpcyB3YXksIGl0IHNob3dzIHRoZSBsb2FkaW5nIHByb2dyZXNzIGNvbnRyb2wuICovXG4gICAgICAgICAgICAgICAgdGhpcy5fY291bnRCYWNrZW5kU3Vic2NyaXB0aW9ucysrO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDYWxsIF9jb3VudEJhY2tlbmRTdWJzY3JpcHRpb25zOiAnLCB0aGlzLl9jb3VudEJhY2tlbmRTdWJzY3JpcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIC8qIEVyYXNlcyB0aGUgZGF0YSBmcm9tIHRoZSB0YWJsZS4gKi9cbiAgICAgICAgICAgICAgICB0aGlzLl9zZXREYXRhQmVmb3JlQ2FsbEVuZHBvaW50KHNvcnRFdmVudCwgcGFnZUV2ZW50KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LmVuZHBvaW50KHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbHRlcic6IGZpbHRlckV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAnc29ydCc6IHNvcnRFdmVudCxcbiAgICAgICAgICAgICAgICAgICAgJ3BhZ2luYXRvcic6IHBhZ2VFdmVudFxuICAgICAgICAgICAgICAgIH0pLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIGZpbmFsaXplKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlbW92ZXMgdGhlIGxhc3QgYmFja2VuZCBzdWJzY3JpcHRpb24uIEluIHRoaXMgd2F5LCB3aGVuIGl0cyB2YWx1ZSBpcyBgMGAsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICogbWVhbnMgdGhlIGNvbXBvbmVudCBpcyBOT1QgbG9hZGluZyB0aGUgZGF0YSBzb3VyY2U7IGl0IHRoZW4gaGlkZXMgdGhlIGxvYWRpbmcgcHJvZ3Jlc3MgY29udHJvbC4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50QmFja2VuZFN1YnNjcmlwdGlvbnMtLTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKS5zdWJzY3JpYmUoKHJlc3BvbnNlOiBQYWdlPGFueT4pOiB2b2lkID0+IHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coJ0VuZHBvaW50IFJlc3BvbnNlOiAnLCByZXNwb25zZSk7XG5cbiAgICAgICAgICAgIC8qIFNldHMgdGhlIG5ldyBkYXRhIG9uIHRoZSB0YWJsZS4gKi9cbiAgICAgICAgICAgIHRoaXMuX3NldERhdGFBZnRlckNhbGxFbmRwb2ludChyZXNwb25zZSk7XG5cbiAgICAgICAgICAgIC8qIEVtaXRzIHRoZSBuZXcgcGFnZSBmb3Igc29tZW9uZSB0aGF0IHdhbnRzIHRvIGtub3cgaXQuICovXG4gICAgICAgICAgICB0aGlzLl9wYWdlLm5leHQocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIENTUyBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSB0YWJsZSByb3dzLiBUaGlzIG1ldGhvZCBtdXN0IGJlIG9ubHkgb3ZlcndyaXRlLCBcbiAgICAgKiBidXQgbXVzdCBuZXZlciBiZSBjYWxsZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbjsgaXQgaXMgY2FsbGVkIGluIHRoZSBjb3JyZWN0IHBsYWNlcyBpbnRlcm5hbGx5LiBcbiAgICAgKiBJbiBvcmRlciB0byB0YWtlIGVmZmVjdCB0aGVzZSBjbGFzc2VzLCB0aGUgdGFibGUgQ1NTIGZpbGUgbXVzdCBoYXZlIGRlZmluZWQgdGhlc2UgY2xhc3Nlcy4gXG4gICAgICogQHBhcmFtIHJvd0RhdGEgVGhlIGRhdGEgdGhhdCBpcyBjb250YWluZWQgaW4gdGhlIHJvdy4gXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRlZmF1bHRDcmVhdGVDc3NDbGFzc2VzRm9yUm93KHJvd0RhdGE6IGFueSk6IHsgW2NsYXNzTmFtZTogc3RyaW5nXTogYm9vbGVhbjsgfVxuICAgIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdzZWxlY3RlZC1yb3cnOiAocm93RGF0YVt0aGlzLl9jb250ZW50LnByb3BlcnR5TmFtZVRvSWRlbnRpZnldKSA9PSB0aGlzLl9zZWxlY3RlZFJvd1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgQ1NTIHN0eWxlcyB0byBhcHBseSB0byB0aGUgdGFibGUgaGVhZGVycy4gVGhpcyBtZXRob2QgbXVzdCBuZXZlciBiZSBjYWxsZWQgXG4gICAgICogYmVjYXVzZSBpdCBpcyBmb3IgaW50ZXJuYWwgdXNlIG9ubHk7IGl0IGlzIGNhbGxlZCBpbiB0aGUgY29ycmVjdCBwbGFjZXMgaW50ZXJuYWxseS4gXG4gICAgICogQHBhcmFtIHBvcyBUaGUgY29sdW1uIHBvc2l0aW9uLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgX2NyZWF0ZUNzc1N0eWxlc0ZvckhlYWRlcihwb3M6IG51bWJlcik6IENzc1N0eWxlc1xuICAgIHtcbiAgICAgICAgbGV0IHJlc3VsdDogQ3NzU3R5bGVzID0ge307XG5cbiAgICAgICAgdGhpcy5fYWRkQ3NzU3R5bGVzX0NlbGxXaWR0aChyZXN1bHQsIHBvcyk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIENTUyBzdHlsZXMgdG8gYXBwbHkgdG8gdGhlIHRhYmxlIGNlbGxzLiBUaGlzIG1ldGhvZCBtdXN0IG5ldmVyIGJlIGNhbGxlZCBcbiAgICAgKiBiZWNhdXNlIGl0IGlzIGZvciBpbnRlcm5hbCB1c2Ugb25seTsgaXQgaXMgY2FsbGVkIGluIHRoZSBjb3JyZWN0IHBsYWNlcyBpbnRlcm5hbGx5LiBcbiAgICAgKiBAcGFyYW0gcG9zIFRoZSBjb2x1bW4gcG9zaXRpb24uIFxuICAgICAqL1xuICAgIHB1YmxpYyBfY3JlYXRlQ3NzU3R5bGVzRm9yQ2VsbChwb3M6IG51bWJlcik6IENzc1N0eWxlc1xuICAgIHtcbiAgICAgICAgbGV0IHJlc3VsdDogQ3NzU3R5bGVzID0ge307XG5cbiAgICAgICAgdGhpcy5fYWRkQ3NzU3R5bGVzX0NlbGxXaWR0aChyZXN1bHQsIHBvcyk7XG4gICAgICAgIHRoaXMuX2FkZENzc1N0eWxlc19DZWxsQ29udGVudFdyYXAocmVzdWx0LCBwb3MpO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfYWRkQ3NzU3R5bGVzX0NlbGxXaWR0aChjc3NTdHlsZXM6IENzc1N0eWxlcywgcG9zOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBjc3NTdHlsZXNbJ2ZsZXgnXSA9ICcwIDAgJyArIHRoaXMuX2NvbnRlbnQuY29sdW1uc1dpZHRoW3Bvc107XG4gICAgICAgIGNzc1N0eWxlc1snd2lkdGgnXSA9IHRoaXMuX2NvbnRlbnQuY29sdW1uc1dpZHRoW3Bvc107XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfYWRkQ3NzU3R5bGVzX0NlbGxDb250ZW50V3JhcChjc3NTdHlsZXM6IENzc1N0eWxlcywgcG9zOiBudW1iZXIpOiB2b2lkXG4gICAge1xuICAgICAgICBzd2l0Y2godGhpcy5fY29udGVudC5jb2x1bW5Db250ZW50V3JhcFtwb3NdKVxuICAgICAgICB7XG4gICAgICAgICAgICBjYXNlIENlbGxDb250ZW50V3JhcC5icmVhazpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjc3NTdHlsZXNbJ3dvcmQtd3JhcCddID0gJ2JyZWFrLXdvcmQnIC8qIWltcG9ydGFudCovO1xuICAgICAgICAgICAgICAgIGNzc1N0eWxlc1snd2hpdGUtc3BhY2UnXSA9ICd1bnNldCcgLyohaW1wb3J0YW50Ki87XG4gICAgICAgICAgICAgICAgY3NzU3R5bGVzWydvdmVyZmxvdy13cmFwJ10gPSAnYnJlYWstd29yZCc7XG4gICAgICAgICAgICAgICAgY3NzU3R5bGVzWyd3b3JkLWJyZWFrJ10gPSAnYnJlYWstd29yZCc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3NzU3R5bGVzWyctbXMtaHlwaGVucyddID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIGNzc1N0eWxlc1snLW1vei1oeXBoZW5zJ10gPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgY3NzU3R5bGVzWyctd2Via2l0LWh5cGhlbnMnXSA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICBjc3NTdHlsZXNbJ2h5cGhlbnMnXSA9ICdhdXRvJztcblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDZWxsQ29udGVudFdyYXAuZWxsaXBzaXM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY3NzU3R5bGVzWydvdmVyZmxvdyddID0gJ2hpZGRlbic7XG4gICAgICAgICAgICAgICAgY3NzU3R5bGVzWyd0ZXh0LW92ZXJmbG93J10gPSAnZWxsaXBzaXMnO1xuICAgICAgICAgICAgICAgIGNzc1N0eWxlc1snd2hpdGUtc3BhY2UnXSA9ICdub3dyYXAnO1xuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiAvKiBDZWxsQ29udGVudFdyYXAucmVzcG9uc2libGUgKi9cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvKiBUaGUgYHJlc3BvbnNpYmxlYCB3cmFwIGlzIHRoZSBkZWZhdWx0IHN0eWxlLiBJdCBvbmx5IGFwcGxpZXMgdGhlIHJlc3BvbnNpYmxlIHN0eWxlcyBcbiAgICAgICAgICAgICAgICAgKiB0aGF0IGFyZSBkZWZpbmVkIGluIHRoZSB0YWJsZS4gKi9cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIGl0IGlzIGxvYWRpbmcgdGhlIGRhdGEgc291cmNlOyBvdGhlcndpc2UsIGZhbHNlLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGlzTG9hZGluZygpOiBib29sZWFuXG4gICAge1xuICAgICAgICAvKiBXaGVuIHRoZSBgX2NvdW50QmFja2VuZFN1YnNjcmlwdGlvbnNgIHZhbHVlIGlzIGRpZmZlcmVudCBvZiAwLCBcbiAgICAgICAgICogbWVhbnMgdGhlIGNvbXBvbmVudCBpcyBsb2FkaW5nIHRoZSBkYXRhIHNvdXJjZS4gKi9cbiAgICAgICAgcmV0dXJuICh0aGlzLl9jb3VudEJhY2tlbmRTdWJzY3JpcHRpb25zICE9IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNlbGVjdGVkIHJvdy4gXG4gICAgICovXG4gICAgcHVibGljIGdldCBzZWxlY3RlZFJvdygpOiBudW1iZXJcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZFJvdztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbnB1dCBmaWVsZCB0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoaXMgY2xhc3MgKHRoZSB0YWJsZSBjb250cm9sIGNvbnRlbnQgdG8gc2hvdykuIFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBjb250ZW50KCk6IFRhYmxlQ29udGVudDxhbnk+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGlucHV0IGZpZWxkIHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnQgb2YgdGhpcyBjbGFzcyAodGhlIHRhYmxlIGNvbnRyb2wgY29udGVudCB0byBzaG93KS4gXG4gICAgICogSW4gdGhpcyB3YXksIHRoZSBjb21wb25lbnQgaXMgdXBkYXRlZCBjb3JyZWN0bHkuIFxuICAgICAqIEBwYXJhbSBuZXdDb250ZW50IFRoZSBuZXcgY29udGVudCB0byBzZXQuIFxuICAgICAqIElmIHRoZSB2YWx1ZSBpcyBudWxsLCBzZXRzIHRvIGBkZWZhdWx0VGFibGVDb250ZW50YC4gXG5cdCAqL1xuICAgIHB1YmxpYyBzZXQgY29udGVudChuZXdDb250ZW50OiBUYWJsZUNvbnRlbnQ8YW55PiB8IG51bGwpXG4gICAge1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gbmV3Q29udGVudDtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc3RyZWFtIHRoYXQgZW1pdHMgdGhlIHBhZ2UgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYnkgdGhlIHRhYmxlLCBcbiAgICAgKiB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlIGluIHRoZSBmaWx0ZXJpbmcsIHNvcnRpbmcsIG9yIHBhZ2luYXRpb24gb2YgdGhlIGRhdGEuIEVhY2ggb2JqZWN0IFxuICAgICAqIGluIHRoZSBgZGF0YWAgZmllbGQgcmVwcmVzZW50cyBvbmUgcm93LiBUaGlzIGlzIG1hZGUgZm9yIHNvbWVvbmUgdGhhdCB3YW50cyB0byBrbm93IGl0LiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBhZ2UoKTogT2JzZXJ2YWJsZTxQYWdlPGFueT4+XG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFnZUFzT2JzZXJ2YWJsZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBhZ2UgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYnkgdGhlIHRhYmxlLCBpdCBlcmFzZXMgdGhlIGRhdGEuIEZvciBpbnRlcm5hbCB1c2Ugb25seS4gXG4gICAgICogQHBhcmFtIHNvcnRFdmVudCBUaGUgY3VycmVudCBzb3J0IHN0YXRlLiBcbiAgICAgKiBAcGFyYW0gcGFnZUV2ZW50IFRoZSBjdXJyZW50IHBhZ2luYXRvciBzdGF0ZS4gXG5cdCAqL1xuICAgIHByaXZhdGUgX3NldERhdGFCZWZvcmVDYWxsRW5kcG9pbnQoc29ydEV2ZW50OiBTb3J0LCBwYWdlRXZlbnQ6IFBhZ2VFdmVudCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8qIEVyYXNlcyB0aGUgZGF0YSBmcm9tIHRoZSB0YWJsZS4gKi9cbiAgICAgICAgdGhpcy5fZGF0YVNvdXJjZS5kYXRhID0gW107XG5cbiAgICAgICAgLyogVXBkYXRlcyB0aGUgZmllbGRzIHJlbGF0ZWQgdG8gc29ydGluZyBhbmQgcGFnaW5hdGlvbjsgdGhlIGZpbHRlciBjb21wb25lbnQgaXMgdXBkYXRlZCBpbiBhIGRpZmZlcmVudCB3YXkuICovXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNvcnQoc29ydEV2ZW50KTtcbiAgICAgICAgdGhpcy5fdXBkYXRlUGFnaW5hdG9yKHBhZ2VFdmVudCk7XG5cbiAgICAgICAgLyogVGhlIGBNYXRTb3J0YCBhbmQgYE1hdFBhZ2luYXRvcmAgYXJlIGFsd2F5cyBlbmFibGVkLiAqL1xuICAgICAgICB0aGlzLl9kaXNhYmxlZFNvcnRQYWdpbmF0b3IoZmFsc2UpO1xuICAgIH1cblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGFnZSB0aGF0IHNob3VsZCBiZSByZW5kZXJlZCBieSB0aGUgdGFibGUsIHdoZXJlIGVhY2ggb2JqZWN0IGluIHRoZSBgbmV3UGFnZS5kYXRhYCBcbiAgICAgKiByZXByZXNlbnRzIG9uZSByb3cuIEZvciBpbnRlcm5hbCB1c2Ugb25seS4gXG4gICAgICogQHBhcmFtIG5ld1BhZ2UgVGhlIG5ldyBwYWdlIHRvIHNldC4gXG5cdCAqL1xuICAgIHByaXZhdGUgX3NldERhdGFBZnRlckNhbGxFbmRwb2ludChuZXdQYWdlOiBQYWdlPGFueT4pOiB2b2lkXG4gICAge1xuICAgICAgICAvKiBJbiBgX2RhdGFTb3VyY2VgLCBuZWVkcyB0byB1cGRhdGUgdGhlIGRhdGEgb25seS4gKi9cbiAgICAgICAgdGhpcy5fZGF0YVNvdXJjZS5kYXRhID0gbmV3UGFnZS5kYXRhO1xuXG4gICAgICAgIC8qIFVwZGF0ZXMgdGhlIGZpZWxkcyByZWxhdGVkIHRvIHBhZ2luYXRpb247IHRoZSBmaWx0ZXIgY29tcG9uZW50IGFuZCBzb3J0aW5nIGRvIG5vdCBuZWVkIHRvIHVwZGF0ZS4gKi9cbiAgICAgICAgdGhpcy5fdXBkYXRlUGFnaW5hdG9yKG5ld1BhZ2UpO1xuXG4gICAgICAgIC8qIFRoZSBgTWF0U29ydGAgYW5kIGBNYXRQYWdpbmF0b3JgIGFyZSBkaXNhYmxlZCBpZiB0aGUgdGFibGUgaXMgZW1wdHkuICovXG4gICAgICAgIHRoaXMuX2Rpc2FibGVkU29ydFBhZ2luYXRvcih0aGlzLmlzRW1wdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgc291cmNlIHRvIHJlbmRlci4gSWYgdGhlIGRhdGEgc291cmNlIGlzIGVtcHR5LCB0aGVuIHJldHVybnMgdGhlIGRlZmF1bHQgZGF0YSBzb3VyY2UgXG4gICAgICogdGhhdCBjb250YWlucyBvbmx5IG9uZSBlbXB0eSBlbGVtZW50IChpdCBpcyB1c2VkIHRvIHNob3cgb25lIHJvdyB0aGF0IGNvbnRhaW5zIHRoZSBlbXB0eSBcbiAgICAgKiB0YWJsZSBpbmZvcm1hdGlvbikuIEZvciBpbnRlcm5hbCB1c2Ugb25seS4gXG4gICAgICovXG4gICAgcHVibGljIGdldCBfZ2V0RGF0YVNvdXJjZSgpOiBNYXRUYWJsZURhdGFTb3VyY2U8YW55PlxuICAgIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkgcmV0dXJuIFRhYmxlQ29tcG9uZW50Ll9kZWZhdWx0RGF0YVNvdXJjZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVNvdXJjZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgY29sdW1uLiBMb2dzIGEgd2FybiB0byB0aGUgY29uc29sZSBpcyB0aGUgYXJyYXkgb2YgY29sdW1ucyBpcyBlbXB0eS4gXG4gICAgICovXG4gICAgcHVibGljIGNoZWNrQ29sdW1uKCk6IHZvaWRcbiAgICB7XG4gICAgICAgIGNvbnN0IGxlbjogbnVtYmVyID0gdGhpcy5fY29udGVudC5jb2x1bW5zT2JqZWN0UHJvcGVydHkubGVuZ3RoO1xuXG4gICAgICAgIGlmICgobGVuID09IDApXG4gICAgICAgICAgICB8fCAobGVuICE9IHRoaXMuX2NvbnRlbnQuY29sdW1uc0hlYWRlclRleHQubGVuZ3RoKVxuICAgICAgICAgICAgfHwgKGxlbiAhPSB0aGlzLl9jb250ZW50LmNvbHVtbnNXaWR0aC5sZW5ndGgpXG4gICAgICAgICAgICB8fCAobGVuICE9IHRoaXMuX2NvbnRlbnQuY29sdW1uQ29udGVudFdyYXAubGVuZ3RoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVGhlICdjb2x1bW5zT2JqZWN0UHJvcGVydHknLCAnY29sdW1uc0hlYWRlclRleHQnLCAnY29sdW1uc1dpZHRoJyBhbmQgJ2NvbHVtbkNvbnRlbnRXcmFwJyBhcnJheXMgbXVzdCBiZSBkaWZmZXJlbnQgb2YgZW1wdHksIGFuZCBtdXN0IGhhdmUgdGhlIHNhbWUgYW1vdW50IG9mIGVsZW1lbnRzLlwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5hdmlnYXRlcyB0byB0aGUgdmlldyB0aGF0IHNob3dzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzcGVjaWZpZWQgYHJvd0RhdGFgLiBcbiAgICAgKiBAcGFyYW0gcmVsYXRpdmVVcmwgVGhlIHJlbGF0aXZlIFVSTCB0byBuYXZpZ2F0ZS4gXG4gICAgICogQHBhcmFtIHJvd0RhdGEgVGhlIGRhdGEgdGhhdCBpcyBjb250YWluZWQgaW4gdGhlIHJvdy4gXG4gICAgICovXG4gICAgcHVibGljIG5hdmlnYXRlVG8ocmVsYXRpdmVVcmw6IHN0cmluZywgcm93RGF0YTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogU2VsZWN0cyB0aGUgc3BlY2lmaWVkIHJvdy4gKi9cbiAgICAgICAgdGhpcy5zZWxlY3RSb3cocm93RGF0YSk7XG5cbiAgICAgICAgLyogTmF2aWdhdGVzIHRvIHRoZSBzcGVjaWZpZWQgdmlldy4gKi9cbiAgICAgICAgdGhpcy5fcm91dGVyLm5hdmlnYXRlKFsgcm93RGF0YVt0aGlzLl9jb250ZW50LnByb3BlcnR5TmFtZVRvSWRlbnRpZnldLCByZWxhdGl2ZVVybCBdLCB7IHJlbGF0aXZlVG86IHRoaXMuX2FjdGl2YXRlZFJvdXRlIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIHNwZWNpZmllZCByb3cuIFxuICAgICAqIEBwYXJhbSByb3dEYXRhIFRoZSBkYXRhIHRoYXQgaXMgY29udGFpbmVkIGluIHRoZSByb3cuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzZWxlY3RSb3cocm93RGF0YTogYW55KTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogU2F2ZXMgdGhlIHNlbGVjdGVkIHJvdy4gKi9cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRSb3cgPSByb3dEYXRhW3RoaXMuX2NvbnRlbnQucHJvcGVydHlOYW1lVG9JZGVudGlmeV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmlsdGVyIG1vZGVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZmlsdGVyIG91dCBvYmplY3RzIGZyb20gdGhlIGRhdGEgc291cmNlLiBcbiAgICAgKiBBc3N1bWVzIHRoYXQgdGhlIGJhY2tlbmQgd2lsbCBjYWxsIHRoZSBgdHJpbSgpYCBtZXRob2Qgb3ZlciBpdHMgcHJvcGVydGllcy4gXG4gICAgICogVGhpcyBtZXRob2QgaXMgYWNjZXB0aW5nIGEgcGFydGlhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZmlsdGVyIG1vZGVsLiBcbiAgICAgKiBJdCBjb21iaW5lcyB0aGUgc3BlY2lmaWVkIGZpbHRlciB3aXRoIHRoZSBsYXN0IG9uZS4gVGhpcyB3YXkgb2xkIGZpbHRlciBwcm9wZXJ0aWVzIFxuICAgICAqIHdvbid0IGJlIG92ZXJyaWRkZW4gd2hlbiBvbmx5IG9uZSBwcm9wZXJ0eSBpcyB1cGRhdGVkLiBcbiAgICAgKiBAcGFyYW0gZmlsdGVyIFRoZSBwYXJ0aWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmaWx0ZXIgbW9kZWwgdG8gY29tYmluZS4gXG4gICAgICovXG4gICAgcHVibGljIGFwcGx5RmlsdGVycyhmaWx0ZXI6IFBhcnRpYWw8RmlsdGVyVmFsdWVzPik6IHZvaWRcbiAgICB7XG4gICAgICAgIC8qIFRoaXMgbWV0aG9kIGlzIGFjY2VwdGluZyBhIHBhcnRpYWwgcmVwcmVzZW50YXRpb24gb2YgdGhlIGZpbHRlciBtb2RlbC4gXG4gICAgICAgICAqIEl0IGNvbWJpbmVzIHRoZSBzcGVjaWZpZWQgZmlsdGVyIHdpdGggdGhlIGxhc3Qgb25lIGJ5IG1lcmdpbmcgYm90aCBmaWx0ZXJzIFxuICAgICAgICAgKiB2aWEgdGhlIHNwcmVhZCBvcGVyYXRvci4gVGhpcyB3YXkgb2xkIGZpbHRlciBwcm9wZXJ0aWVzIHdvbid0IGJlIG92ZXJyaWRkZW4gXG4gICAgICAgICAqIHdoZW4gb25seSBvbmUgcHJvcGVydHkgaXMgdXBkYXRlZC4gXG4gICAgICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY2FsbCB0aGUgYHRyaW0oKWAgbWV0aG9kIG92ZXIgaXRzIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBpcyBjYWxsZWQgXG4gICAgICAgICAqIGluIHRoZSBiYWNrZW5kIGludGVybmFsbHkuICovXG5cbiAgICAgICAgdGhpcy5fZmlsdGVyVmFsdWVzID0geyAuLi50aGlzLl9maWx0ZXJWYWx1ZXMsIC4uLmZpbHRlciB9O1xuXG4gICAgICAgIHRoaXMuX2ZpbHRlclZhbHVlc0NoYW5nZS5uZXh0KHRoaXMuX2ZpbHRlclZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgZmlsdGVyIG1vZGVsIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZmlsdGVyIG91dCBvYmplY3RzIGZyb20gdGhlIGRhdGEgc291cmNlLiBcbiAgICAgKiBBc3N1bWVzIHRoYXQgdGhlIGJhY2tlbmQgd2lsbCBjYWxsIHRoZSBgdHJpbSgpYCBtZXRob2Qgb3ZlciBpdHMgcHJvcGVydGllcy4gXG4gICAgICogSXQgY29tYmluZXMgdGhlIHNwZWNpZmllZCBmaWx0ZXIgcHJvcGVydHkgd2l0aCB0aGUgbGFzdCBvbmUuIFRoaXMgd2F5IG9sZCBmaWx0ZXIgcHJvcGVydGllcyBcbiAgICAgKiB3b24ndCBiZSBvdmVycmlkZGVuIHdoZW4gb25seSBvbmUgcHJvcGVydHkgaXMgdXBkYXRlZC4gXG4gICAgICogQHBhcmFtIG5hbWUgVGhlIGZpbHRlciBuYW1lLiBcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGZpbHRlciB2YWx1ZS4gXG4gICAgICovXG4gICAgcHVibGljIGFwcGx5RmlsdGVyKG5hbWU6IHN0cmluZywgdmFsdWU6IGFueSk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8qIEl0IGNvbWJpbmVzIHRoZSBzcGVjaWZpZWQgZmlsdGVyIHByb3BlcnR5IHdpdGggdGhlIGxhc3Qgb25lIGJ5IG1lcmdpbmcgYm90aCBmaWx0ZXJzIFxuICAgICAgICAgKiB2aWEgdGhlIHNwcmVhZCBvcGVyYXRvci4gVGhpcyB3YXkgb2xkIGZpbHRlciBwcm9wZXJ0aWVzIHdvbid0IGJlIG92ZXJyaWRkZW4gXG4gICAgICAgICAqIHdoZW4gb25seSBvbmUgcHJvcGVydHkgaXMgdXBkYXRlZC4gXG4gICAgICAgICAqIEl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY2FsbCB0aGUgYHRyaW0oKWAgbWV0aG9kIG92ZXIgaXRzIHByb3BlcnRpZXMgYmVjYXVzZSBpdCBpcyBjYWxsZWQgXG4gICAgICAgICAqIGluIHRoZSBiYWNrZW5kIGludGVybmFsbHkuICovXG5cbiAgICAgICAgdGhpcy5fZmlsdGVyVmFsdWVzID0geyAuLi50aGlzLl9maWx0ZXJWYWx1ZXMgfTtcbiAgICAgICAgdGhpcy5fZmlsdGVyVmFsdWVzW25hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgdGhpcy5fZmlsdGVyVmFsdWVzQ2hhbmdlLm5leHQodGhpcy5fZmlsdGVyVmFsdWVzKTtcbiAgICB9XG59XG4iXX0=