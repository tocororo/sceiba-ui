/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/input/rnps/rnps-input.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component } from '@angular/core';
import { FormControl, Validators } from '@angular/forms';
import { ExtraValidators } from '../../../core/utils/validator';
import { RnpsValue } from './rnps-value';
import { InputControl } from '../input.control';
/**
 * Represents a control that allows the writing of an RNPS.
 * An RNPS (Registro Nacional de Publicaciones Seriadas) is an 4-digit code used to control
 * the serial publications authorized to be edited, printed and circulated in Cuba.
 * For more information follow the link: http://www.seriadas.cult.cu/.
 * It uses the `RnpsValue.rnps_Abbreviation` as a label if the `content.label` is not specified.
 * It uses the `RnpsValue.rnps_Placeholder` as a placeholder if the `content.placeholder` is not specified.
 */
export class InputRnpsComponent extends InputControl {
    constructor() {
        super();
        this._codeOldValue = undefined;
    }
    /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputRnpsComponent`'s `content.formControl` value by default.
     * In this case, the `validatorArguments` argument is always `undefined`.
     * @param {?=} validatorArguments
     * @return {?}
     */
    static getFormControlByDefault(validatorArguments = undefined) {
        return new FormControl('', [
            ExtraValidators.equalLength(RnpsValue.codeLength),
            Validators.pattern('^[0-9]*$')
        ]);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /* Sets the default values. */
        this.init(RnpsValue.rnps_Abbreviation, RnpsValue.rnps_Placeholder, true, true);
        /* The '_codeOldValue' must be set after the 'content.formControl.value' is set. */
        this.handleSpecificInput();
    }
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * @return {?}
     */
    getErrorMessage() {
        /** @type {?} */
        let result = '';
        /** @type {?} */
        let result_alreadyHaveErrorInfo = false;
        /** @type {?} */
        let validationErrors = this.content.formControl.errors;
        /* Shows the code errors. */
        if (validationErrors) {
            if ((validationErrors[ExtraValidators.equalLength.name]) || (validationErrors[Validators.required.name])) {
                result = 'TOCO_NG_ERROR_MSG_RNPS_LONG_INVAL';
                result_alreadyHaveErrorInfo = true;
            }
            if (validationErrors[Validators.pattern.name]) {
                if (result_alreadyHaveErrorInfo) {
                    result = 'TOCO_NG_ERROR_MSG_RNPS_LONG_Y_DIG_INVAL';
                }
                else {
                    result = 'TOCO_NG_ERROR_MSG_RNPS_DIG_INVAL';
                }
                result_alreadyHaveErrorInfo = true;
            }
        }
        return result;
    }
    /**
     * Handler method that is called by the internal logic when the control's value changes in the UI.
     * This method contains the specific handling of the input that the derived class wants to do.
     * @return {?}
     */
    handleSpecificInput() {
        if (this.content.formControl.value.length > RnpsValue.codeLength) {
            /* Sets the old value. */
            this.content.formControl.setValue(this._codeOldValue);
        }
        else {
            /* Updates the old values. */
            this._codeOldValue = this.content.formControl.value;
        }
    }
}
InputRnpsComponent.decorators = [
    { type: Component, args: [{
                selector: 'input-rnps',
                template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                host: {
                    '[style.minWidth]': 'content.minWidth',
                    '[style.width]': 'content.width'
                },
                styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
            }] }
];
/** @nocollapse */
InputRnpsComponent.ctorParameters = () => [];
if (false) {
    /**
     * It is used by `handleSpecificInput` method.
     * @type {?}
     * @private
     */
    InputRnpsComponent.prototype._codeOldValue;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicm5wcy1pbnB1dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly90b2NvLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9mb3Jtcy9pbnB1dC9ybnBzL3JucHMtaW5wdXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUNsRCxPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBb0IsTUFBTSxnQkFBZ0IsQ0FBQztBQUUzRSxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFaEUsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUN6QyxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7Ozs7Ozs7OztBQW9CaEQsTUFBTSxPQUFPLGtCQUFtQixTQUFRLFlBQVk7SUFvQmhEO1FBRUksS0FBSyxFQUFFLENBQUM7UUFFUixJQUFJLENBQUMsYUFBYSxHQUFHLFNBQVMsQ0FBQztJQUNuQyxDQUFDOzs7Ozs7OztJQWxCTSxNQUFNLENBQUMsdUJBQXVCLENBQUMscUJBQXlDLFNBQVM7UUFFcEYsT0FBTyxJQUFJLFdBQVcsQ0FBQyxFQUFFLEVBQUU7WUFDdkIsZUFBZSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDO1lBQ2pELFVBQVUsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDO1NBQ2pDLENBQUMsQ0FBQztJQUNQLENBQUM7Ozs7SUFjTSxRQUFRO1FBRVgsOEJBQThCO1FBRTlCLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGlCQUFpQixFQUFFLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFL0UsbUZBQW1GO1FBQ25GLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDO0lBQy9CLENBQUM7Ozs7O0lBS00sZUFBZTs7WUFFZCxNQUFNLEdBQVcsRUFBRTs7WUFDbkIsMkJBQTJCLEdBQVksS0FBSzs7WUFDNUMsZ0JBQWdCLEdBQXFCLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLE1BQU07UUFFeEUsNEJBQTRCO1FBQzVCLElBQUksZ0JBQWdCLEVBQ3BCO1lBQ0ksSUFBSSxDQUFDLGdCQUFnQixDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsRUFDeEc7Z0JBQ0ksTUFBTSxHQUFHLG1DQUFtQyxDQUFDO2dCQUM3QywyQkFBMkIsR0FBRyxJQUFJLENBQUM7YUFDdEM7WUFFRCxJQUFJLGdCQUFnQixDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEVBQzdDO2dCQUNJLElBQUksMkJBQTJCLEVBQy9CO29CQUNJLE1BQU0sR0FBRyx5Q0FBeUMsQ0FBQztpQkFDdEQ7cUJBRUQ7b0JBQ0ksTUFBTSxHQUFHLGtDQUFrQyxDQUFDO2lCQUMvQztnQkFFRCwyQkFBMkIsR0FBRyxJQUFJLENBQUM7YUFDdEM7U0FDSjtRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7Ozs7OztJQU1HLG1CQUFtQjtRQUV6QixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxNQUFNLEdBQUcsU0FBUyxDQUFDLFVBQVUsRUFDaEU7WUFDQyx5QkFBeUI7WUFDekIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNoRDthQUVEO1lBQ0ksNkJBQTZCO1lBQzdCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDO1NBQ3ZEO0lBQ0wsQ0FBQzs7O1lBbEdKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsWUFBWTtnQkFDdEIseXdHQUFnRDtnQkFFaEQsSUFBSSxFQUFFO29CQUNGLGtCQUFrQixFQUFFLGtCQUFrQjtvQkFDdEMsZUFBZSxFQUFFLGVBQWU7aUJBQ25DOzthQUNKOzs7Ozs7Ozs7O0lBbUJHLDJDQUE4QiIsInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgQ29tcG9uZW50LCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Db250cm9sLCBWYWxpZGF0b3JzLCBWYWxpZGF0aW9uRXJyb3JzIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBFeHRyYVZhbGlkYXRvcnMgfSBmcm9tICcuLi8uLi8uLi9jb3JlL3V0aWxzL3ZhbGlkYXRvcic7XG5cbmltcG9ydCB7IFJucHNWYWx1ZSB9IGZyb20gJy4vcm5wcy12YWx1ZSc7XG5pbXBvcnQgeyBJbnB1dENvbnRyb2wgfSBmcm9tICcuLi9pbnB1dC5jb250cm9sJztcbmltcG9ydCB7IFZhbGlkYXRvckFyZ3VtZW50cyB9IGZyb20gJy4uLy4uL2Zvcm0tZmllbGQuY29udHJvbCc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIGNvbnRyb2wgdGhhdCBhbGxvd3MgdGhlIHdyaXRpbmcgb2YgYW4gUk5QUy4gXG4gKiBBbiBSTlBTIChSZWdpc3RybyBOYWNpb25hbCBkZSBQdWJsaWNhY2lvbmVzIFNlcmlhZGFzKSBpcyBhbiA0LWRpZ2l0IGNvZGUgdXNlZCB0byBjb250cm9sIFxuICogdGhlIHNlcmlhbCBwdWJsaWNhdGlvbnMgYXV0aG9yaXplZCB0byBiZSBlZGl0ZWQsIHByaW50ZWQgYW5kIGNpcmN1bGF0ZWQgaW4gQ3ViYS4gXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBmb2xsb3cgdGhlIGxpbms6IGh0dHA6Ly93d3cuc2VyaWFkYXMuY3VsdC5jdS8uIFxuICogSXQgdXNlcyB0aGUgYFJucHNWYWx1ZS5ybnBzX0FiYnJldmlhdGlvbmAgYXMgYSBsYWJlbCBpZiB0aGUgYGNvbnRlbnQubGFiZWxgIGlzIG5vdCBzcGVjaWZpZWQuIFxuICogSXQgdXNlcyB0aGUgYFJucHNWYWx1ZS5ybnBzX1BsYWNlaG9sZGVyYCBhcyBhIHBsYWNlaG9sZGVyIGlmIHRoZSBgY29udGVudC5wbGFjZWhvbGRlcmAgaXMgbm90IHNwZWNpZmllZC4gXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaW5wdXQtcm5wcycsXG4gICAgdGVtcGxhdGVVcmw6ICcuLi90ZXh0L3RleHQtaW5wdXQuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuLi90ZXh0L3RleHQtaW5wdXQuY29tcG9uZW50LnNjc3MnXSxcbiAgICBob3N0OiB7XG4gICAgICAgICdbc3R5bGUubWluV2lkdGhdJzogJ2NvbnRlbnQubWluV2lkdGgnLFxuICAgICAgICAnW3N0eWxlLndpZHRoXSc6ICdjb250ZW50LndpZHRoJ1xuICAgIH1cbn0pXG5leHBvcnQgY2xhc3MgSW5wdXRSbnBzQ29tcG9uZW50IGV4dGVuZHMgSW5wdXRDb250cm9sIGltcGxlbWVudHMgT25Jbml0XG57XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGBGb3JtQ29udHJvbGAgYnkgZGVmYXVsdC4gXG4gICAgICogSXQgaXMgdXNlZCB0byBpbml0aWFsaXplZCB0aGUgYElucHV0Um5wc0NvbXBvbmVudGAncyBgY29udGVudC5mb3JtQ29udHJvbGAgdmFsdWUgYnkgZGVmYXVsdC4gXG4gICAgICogSW4gdGhpcyBjYXNlLCB0aGUgYHZhbGlkYXRvckFyZ3VtZW50c2AgYXJndW1lbnQgaXMgYWx3YXlzIGB1bmRlZmluZWRgLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIGdldEZvcm1Db250cm9sQnlEZWZhdWx0KHZhbGlkYXRvckFyZ3VtZW50czogVmFsaWRhdG9yQXJndW1lbnRzID0gdW5kZWZpbmVkKTogRm9ybUNvbnRyb2xcbiAgICB7XG4gICAgICAgIHJldHVybiBuZXcgRm9ybUNvbnRyb2woJycsIFtcbiAgICAgICAgICAgIEV4dHJhVmFsaWRhdG9ycy5lcXVhbExlbmd0aChSbnBzVmFsdWUuY29kZUxlbmd0aCksXG4gICAgICAgICAgICBWYWxpZGF0b3JzLnBhdHRlcm4oJ15bMC05XSokJylcbiAgICAgICAgXSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBJdCBpcyB1c2VkIGJ5IGBoYW5kbGVTcGVjaWZpY0lucHV0YCBtZXRob2QuIFxuXHQgKi9cbiAgICBwcml2YXRlIF9jb2RlT2xkVmFsdWU6IHN0cmluZztcblxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuX2NvZGVPbGRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgbmdPbkluaXQoKTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZXMuICovXG5cbiAgICAgICAgdGhpcy5pbml0KFJucHNWYWx1ZS5ybnBzX0FiYnJldmlhdGlvbiwgUm5wc1ZhbHVlLnJucHNfUGxhY2Vob2xkZXIsIHRydWUsIHRydWUpO1xuXG4gICAgICAgIC8qIFRoZSAnX2NvZGVPbGRWYWx1ZScgbXVzdCBiZSBzZXQgYWZ0ZXIgdGhlICdjb250ZW50LmZvcm1Db250cm9sLnZhbHVlJyBpcyBzZXQuICovXG4gICAgICAgIHRoaXMuaGFuZGxlU3BlY2lmaWNJbnB1dCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZXJyb3Igc3RyaW5nIGlmIHRoZSBjb250cm9sIGlzIGluIGFuIGVycm9yIHN0YXRlOyBvdGhlcndpc2UsIGVtcHR5IHN0cmluZy4gXG4gICAgICovXG4gICAgcHVibGljIGdldEVycm9yTWVzc2FnZSgpOiBzdHJpbmdcbiAgICB7XG4gICAgICAgIGxldCByZXN1bHQ6IHN0cmluZyA9ICcnO1xuICAgICAgICBsZXQgcmVzdWx0X2FscmVhZHlIYXZlRXJyb3JJbmZvOiBib29sZWFuID0gZmFsc2U7XG4gICAgICAgIGxldCB2YWxpZGF0aW9uRXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JzID0gdGhpcy5jb250ZW50LmZvcm1Db250cm9sLmVycm9ycztcblxuICAgICAgICAvKiBTaG93cyB0aGUgY29kZSBlcnJvcnMuICovXG4gICAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3JzKVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKHZhbGlkYXRpb25FcnJvcnNbRXh0cmFWYWxpZGF0b3JzLmVxdWFsTGVuZ3RoLm5hbWVdKSB8fCAodmFsaWRhdGlvbkVycm9yc1tWYWxpZGF0b3JzLnJlcXVpcmVkLm5hbWVdKSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAnVE9DT19OR19FUlJPUl9NU0dfUk5QU19MT05HX0lOVkFMJztcbiAgICAgICAgICAgICAgICByZXN1bHRfYWxyZWFkeUhhdmVFcnJvckluZm8gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9yc1tWYWxpZGF0b3JzLnBhdHRlcm4ubmFtZV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdF9hbHJlYWR5SGF2ZUVycm9ySW5mbylcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICdUT0NPX05HX0VSUk9SX01TR19STlBTX0xPTkdfWV9ESUdfSU5WQUwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSAnVE9DT19OR19FUlJPUl9NU0dfUk5QU19ESUdfSU5WQUwnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdF9hbHJlYWR5SGF2ZUVycm9ySW5mbyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuXHQvKipcblx0ICogSGFuZGxlciBtZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGludGVybmFsIGxvZ2ljIHdoZW4gdGhlIGNvbnRyb2wncyB2YWx1ZSBjaGFuZ2VzIGluIHRoZSBVSS4gXG4gICAgICogVGhpcyBtZXRob2QgY29udGFpbnMgdGhlIHNwZWNpZmljIGhhbmRsaW5nIG9mIHRoZSBpbnB1dCB0aGF0IHRoZSBkZXJpdmVkIGNsYXNzIHdhbnRzIHRvIGRvLiBcblx0ICovXG5cdHB1YmxpYyBoYW5kbGVTcGVjaWZpY0lucHV0KCk6IHZvaWRcblx0e1xuXHRcdGlmICh0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wudmFsdWUubGVuZ3RoID4gUm5wc1ZhbHVlLmNvZGVMZW5ndGgpXG5cdFx0e1xuXHRcdFx0LyogU2V0cyB0aGUgb2xkIHZhbHVlLiAqL1xuXHRcdFx0dGhpcy5jb250ZW50LmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuX2NvZGVPbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICAvKiBVcGRhdGVzIHRoZSBvbGQgdmFsdWVzLiAqL1xuICAgICAgICAgICAgdGhpcy5fY29kZU9sZFZhbHVlID0gdGhpcy5jb250ZW50LmZvcm1Db250cm9sLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19