/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/input/text/text-input.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component } from '@angular/core';
import { FormControl, Validators } from '@angular/forms';
import { InputControl } from '../input.control';
/**
 * Represents a control that allows the writing of a text.
 */
export class InputTextComponent extends InputControl {
    constructor() {
        super();
    }
    /**
     * Returns a `FormControl` by default.
     * It is used to initialized the `InputTextComponent`'s `content.formControl` value by default.
     * @param {?=} validatorArguments An object that has only one field of `pattern` name and its value is a string.
     * The `pattern` name is the validator name and the value is the value that the validator needs to check.
     * For example, you can call the `getFormControlByDefault` method in this way:
     * InputTextComponent.getFormControlByDefault({ 'pattern': '^[a-zA-Z][a-zA-Z\-\_\ 0-9]*$' });
     * If this argument is not specified, by default its value is `undefined`.
     * @return {?}
     */
    static getFormControlByDefault(validatorArguments = undefined) {
        return new FormControl('', (((validatorArguments) && (validatorArguments.pattern)) ? [Validators.pattern(validatorArguments.pattern)] : []));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /* Sets the default values. */
        this.init('', '', false, true);
    }
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * @return {?}
     */
    getErrorMessage() {
        /** @type {?} */
        let validationErrors = this.content.formControl.errors;
        /* Shows the identifier errors. */
        if (validationErrors) {
            if (validationErrors[Validators.required.name]) {
                return this.validationError_required;
            }
            else {
                /* It is `validationErrors[Validators.pattern.name]`. */
                return 'TOCO_NG_ERROR_MSG_TEXTO_INVAL';
            }
        }
        return '';
    }
}
InputTextComponent.decorators = [
    { type: Component, args: [{
                selector: 'input-text',
                template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                host: {
                    '[style.minWidth]': 'content.minWidth',
                    '[style.width]': 'content.width'
                },
                styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
            }] }
];
/** @nocollapse */
InputTextComponent.ctorParameters = () => [];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGV4dC1pbnB1dC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly90b2NvLWxpYi8iLCJzb3VyY2VzIjpbImxpYi9mb3Jtcy9pbnB1dC90ZXh0L3RleHQtaW5wdXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUNsRCxPQUFPLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBb0IsTUFBTSxnQkFBZ0IsQ0FBQztBQUUzRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7Ozs7QUFlaEQsTUFBTSxPQUFPLGtCQUFtQixTQUFRLFlBQVk7SUFnQmhEO1FBRUksS0FBSyxFQUFFLENBQUM7SUFDWixDQUFDOzs7Ozs7Ozs7OztJQVJNLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxxQkFBeUMsU0FBUztRQUVwRixPQUFPLElBQUksV0FBVyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUcsQ0FBQyxDQUFDLENBQUM7SUFDbEosQ0FBQzs7OztJQU9NLFFBQVE7UUFFWCw4QkFBOEI7UUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNuQyxDQUFDOzs7OztJQUtNLGVBQWU7O1lBRWQsZ0JBQWdCLEdBQXFCLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLE1BQU07UUFFeEUsa0NBQWtDO1FBQ2xDLElBQUksZ0JBQWdCLEVBQ3BCO1lBQ0ksSUFBSSxnQkFBZ0IsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUM5QztnQkFDSSxPQUFPLElBQUksQ0FBQyx3QkFBd0IsQ0FBQzthQUN4QztpQkFFRDtnQkFDSSx3REFBd0Q7Z0JBQ3hELE9BQU8sK0JBQStCLENBQUM7YUFDMUM7U0FDSjtRQUVELE9BQU8sRUFBRSxDQUFDO0lBQ2QsQ0FBQzs7O1lBMURKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsWUFBWTtnQkFDdEIseXdHQUEwQztnQkFFMUMsSUFBSSxFQUFFO29CQUNGLGtCQUFrQixFQUFFLGtCQUFrQjtvQkFDdEMsZUFBZSxFQUFFLGVBQWU7aUJBQ25DOzthQUNKIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgeyBDb21wb25lbnQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIFZhbGlkYXRvcnMsIFZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbmltcG9ydCB7IElucHV0Q29udHJvbCB9IGZyb20gJy4uL2lucHV0LmNvbnRyb2wnO1xuaW1wb3J0IHsgVmFsaWRhdG9yQXJndW1lbnRzIH0gZnJvbSAnLi4vLi4vZm9ybS1maWVsZC5jb250cm9sJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29udHJvbCB0aGF0IGFsbG93cyB0aGUgd3JpdGluZyBvZiBhIHRleHQuIFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lucHV0LXRleHQnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi90ZXh0LWlucHV0LmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi90ZXh0LWlucHV0LmNvbXBvbmVudC5zY3NzJ10sXG4gICAgaG9zdDoge1xuICAgICAgICAnW3N0eWxlLm1pbldpZHRoXSc6ICdjb250ZW50Lm1pbldpZHRoJyxcbiAgICAgICAgJ1tzdHlsZS53aWR0aF0nOiAnY29udGVudC53aWR0aCdcbiAgICB9XG59KVxuZXhwb3J0IGNsYXNzIElucHV0VGV4dENvbXBvbmVudCBleHRlbmRzIElucHV0Q29udHJvbCBpbXBsZW1lbnRzIE9uSW5pdFxue1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgRm9ybUNvbnRyb2xgIGJ5IGRlZmF1bHQuIFxuICAgICAqIEl0IGlzIHVzZWQgdG8gaW5pdGlhbGl6ZWQgdGhlIGBJbnB1dFRleHRDb21wb25lbnRgJ3MgYGNvbnRlbnQuZm9ybUNvbnRyb2xgIHZhbHVlIGJ5IGRlZmF1bHQuIFxuICAgICAqIEBwYXJhbSB2YWxpZGF0b3JBcmd1bWVudHMgQW4gb2JqZWN0IHRoYXQgaGFzIG9ubHkgb25lIGZpZWxkIG9mIGBwYXR0ZXJuYCBuYW1lIGFuZCBpdHMgdmFsdWUgaXMgYSBzdHJpbmcuIFxuICAgICAqIFRoZSBgcGF0dGVybmAgbmFtZSBpcyB0aGUgdmFsaWRhdG9yIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgdmFsdWUgdGhhdCB0aGUgdmFsaWRhdG9yIG5lZWRzIHRvIGNoZWNrLiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgeW91IGNhbiBjYWxsIHRoZSBgZ2V0Rm9ybUNvbnRyb2xCeURlZmF1bHRgIG1ldGhvZCBpbiB0aGlzIHdheTogXG4gICAgICogSW5wdXRUZXh0Q29tcG9uZW50LmdldEZvcm1Db250cm9sQnlEZWZhdWx0KHsgJ3BhdHRlcm4nOiAnXlthLXpBLVpdW2EtekEtWlxcLVxcX1xcIDAtOV0qJCcgfSk7XG4gICAgICogSWYgdGhpcyBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkLCBieSBkZWZhdWx0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4gXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBnZXRGb3JtQ29udHJvbEJ5RGVmYXVsdCh2YWxpZGF0b3JBcmd1bWVudHM6IFZhbGlkYXRvckFyZ3VtZW50cyA9IHVuZGVmaW5lZCk6IEZvcm1Db250cm9sXG4gICAge1xuICAgICAgICByZXR1cm4gbmV3IEZvcm1Db250cm9sKCcnLCAoKCh2YWxpZGF0b3JBcmd1bWVudHMpICYmICh2YWxpZGF0b3JBcmd1bWVudHMucGF0dGVybikpID8gW1ZhbGlkYXRvcnMucGF0dGVybih2YWxpZGF0b3JBcmd1bWVudHMucGF0dGVybildIDogWyBdKSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKClcbiAgICB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8qIFNldHMgdGhlIGRlZmF1bHQgdmFsdWVzLiAqL1xuICAgICAgICB0aGlzLmluaXQoJycsICcnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBlcnJvciBzdHJpbmcgaWYgdGhlIGNvbnRyb2wgaXMgaW4gYW4gZXJyb3Igc3RhdGU7IG90aGVyd2lzZSwgZW1wdHkgc3RyaW5nLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0RXJyb3JNZXNzYWdlKCk6IHN0cmluZ1xuICAgIHtcbiAgICAgICAgbGV0IHZhbGlkYXRpb25FcnJvcnM6IFZhbGlkYXRpb25FcnJvcnMgPSB0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wuZXJyb3JzO1xuXG4gICAgICAgIC8qIFNob3dzIHRoZSBpZGVudGlmaWVyIGVycm9ycy4gKi9cbiAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uRXJyb3JzW1ZhbGlkYXRvcnMucmVxdWlyZWQubmFtZV0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGlvbkVycm9yX3JlcXVpcmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8qIEl0IGlzIGB2YWxpZGF0aW9uRXJyb3JzW1ZhbGlkYXRvcnMucGF0dGVybi5uYW1lXWAuICovXG4gICAgICAgICAgICAgICAgcmV0dXJuICdUT0NPX05HX0VSUk9SX01TR19URVhUT19JTlZBTCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuIl19