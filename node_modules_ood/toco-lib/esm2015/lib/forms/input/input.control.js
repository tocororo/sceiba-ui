/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/input/input.control.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *   Copyright (c) 2020 Universidad de Pinar del Río "Hermanos Saíz Montes de Oca"
 *   All rights reserved.
 */
import { Input, ViewChild } from '@angular/core';
import { Validators, FormControl } from '@angular/forms';
import { isNullOrUndefined } from 'util';
import { ContentPosition, HintPosition, HintValue, FormFieldControl } from '../form-field.control';
/** @enum {string} */
const TextInputAppearance = {
    /**
     * The `standard` appearance is the default style. It shows the input box with an underline underneath it.
     */
    standard: "standard",
    /**
     * The `fill` appearance displays the form field with a filled background box in addition to the underline.
     */
    fill: "fill",
    /**
     * The `outline` appearance shows the form field with a border all the way around, not just an underline.
     */
    outline: "outline",
};
export { TextInputAppearance };
/**
 * A base interface that represents the content of an `InputControl`.
 * @record
 */
export function InputContent() { }
if (false) {
    /**
     * Returns the `FormControl` that tracks the value and validity state of the internal control that contains the text input.
     * Implementation notes: There are two cases:
     *  - You only have the `content.formControl` field as the `InputEmailComponent` class.
     *  - You have the `content.formControl` and `InputControl.internalComponent` fields as the `InputIssnComponent` class.
     *  - It must be specified; otherwise, an exception is thrown.
     * @type {?|undefined}
     */
    InputContent.prototype.formControl;
    /**
     * Returns the control's appearance.
     * By default, its value is `TextInputAppearance.standard`.
     * @type {?|undefined}
     */
    InputContent.prototype.appearance;
    /**
     * Returns the control's prefix icon.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.prefixIcon;
    /**
     * Returns the control's suffix icon.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.suffixIcon;
    /**
     * Returns the control's prefix text.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.prefixText;
    /**
     * Returns the control's suffix text.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.suffixText;
    /**
     * Returns the control's start hint.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.startHint;
    /**
     * Returns the control's end hint.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    InputContent.prototype.endHint;
}
/**
 * An interface which allows to manipulate the internal component that contains the text input.
 * This interface is implemented when it is created a custom `MatFormFieldControl`.
 * @record
 */
export function IInternalComponent() { }
if (false) {
    /**
     * Tracks the value and validity state of the internal control that contains the text input.
     * @type {?}
     */
    IInternalComponent.prototype.formControl;
    /**
     * Returns or sets the value of the control.
     * @type {?}
     */
    IInternalComponent.prototype.value;
    /**
     * Returns true if the control is empty; otherwise, false.
     * A control is empty if its value is `undefined` or empty string.
     * @type {?}
     */
    IInternalComponent.prototype.empty;
    /**
     * Returns true if the control is in an error state; otherwise, false.
     * @type {?}
     */
    IInternalComponent.prototype.errorState;
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * @return {?}
     */
    IInternalComponent.prototype.getErrorMessage = function () { };
}
/**
 * Represents the base abstract class for a control that allows the writing/selection of a text.
 * @abstract
 */
export class InputControl extends FormFieldControl {
    /**
     * Constructs a new instance of this class.
     */
    constructor() {
        super();
        this.validationError_required = '';
    }
    /**
     * Returns a `FormControl` by default.
     * Its value is empty, and does not have validators.
     * @param {?=} validatorArguments A collection of key/value elements, where the key is the validator name
     * and the value is the value that the validator needs to check.
     * @return {?}
     */
    static getFormControlByDefault(validatorArguments = undefined) {
        return new FormControl('', []);
    }
    /**
     * Sets the new language.
     * @protected
     * @param {?} transServ The `TranslateService` instance injected.
     * @return {?}
     */
    setNewLanguage(transServ) {
        /* The `InputControl.currentLang != transServ.currentLang` test is NOT necessary here because it is done in the non-abstract child classes. */
        super.setNewLanguage(transServ);
        /* The `InputControl.currentLang` value is updated correctly in the parent class. */
        transServ.get('TOCO_NG_ERROR_MSG_REQUERIDO').subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            InputControl.toco_ng_Error_Msg_Requerido = res;
        }));
    }
    /**
     * Initializes the `content` input property.
     * @protected
     * @param {?} label The default label to use. It is used if the `content.label` is not specified.
     * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
     * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
     * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
     * @return {?}
     */
    init(label, placeholder = '', isAbbreviation = false, alwaysHint = true) {
        /* Sets the default values. */
        super.init(label, placeholder);
        if (this.content.formControl == undefined) {
            if (this.internalComponent == undefined)
                throw new Error(`For the '${this.content.name}' control, the 'content.formControl' value can not be undefined; it must be a 'FormControl' value.`);
            this.content.formControl = this.internalComponent.formControl;
        }
        // let temp: string = (isAbbreviation) ? this.content.label : this.content.label.toLowerCase();
        this.validationError_required = 'TOCO_NG_ERROR_MSG_REQUERIDO';
        /************************** Internal control properties. **************************/
        if (this.content.required == undefined)
            this.content.required = false;
        /************************** `mat-form-field` properties. **************************/
        if (this.content.appearance == undefined)
            this.content.appearance = TextInputAppearance.standard;
        /***************************** `mat-icon` properties. *****************************/
        if (this.content.prefixIcon != undefined)
            this.content.prefixIcon.setDefaultValueIfUndefined_setPosition(ContentPosition.prefix);
        if (this.content.suffixIcon != undefined)
            this.content.suffixIcon.setDefaultValueIfUndefined_setPosition(ContentPosition.suffix);
        /***************************** `mat-hint` properties. *****************************/
        if (alwaysHint && (this.content.startHint == undefined) && (this.content.endHint == undefined)) {
            this.content.startHint = new HintValue(HintPosition.start, 'TOCO_NG_HINT_TEXTO_POR_DEFECTO');
        }
        else {
            if (this.content.startHint != undefined)
                this.content.startHint.setDefaultValueIfUndefined_setPosition(HintPosition.start);
            if (this.content.endHint != undefined)
                this.content.endHint.setDefaultValueIfUndefined_setPosition(HintPosition.end);
        }
        /* Adds this control as a child to the `content.parentFormSection`.
        It must be called at the end. */
        if (this.content.parentFormSection != undefined) {
            console.log('addAsChildControl(this.content.formControl)');
            this.addAsChildControl(this, this.content.formControl);
        }
    }
    /**
     * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
     * It also checks if the specified `content.value` is correct. For internal use only.
     * @protected
     * @return {?}
     */
    initValue() {
        /* In this way, checks if the specified `content.value` is correct. */
        this.content.formControl.setValue(this.content.value);
        /* Marks the control as `touched`. */
        this.content.formControl.markAsTouched({
            onlySelf: true
        });
    }
    /**
     * Returns this instance.
     * @return {?}
     */
    get getInstance() {
        return this;
    }
    /**
     * Returns true if the control is empty; otherwise, false.
     * A control is empty if its value is `undefined` or empty string.
     * @return {?}
     */
    get empty() {
        if (this.internalComponent == undefined)
            return ((isNullOrUndefined(this.content.formControl.value)) || (this.content.formControl.value === ''));
        return this.internalComponent.empty;
    }
    /**
     * Returns true if the control is in a hint state; otherwise, false.
     * @return {?}
     */
    get hintState() {
        return this.empty;
    }
    /**
     * Returns true if the control is in an error state; otherwise, false.
     * @return {?}
     */
    get errorState() {
        /* The control does not display errors before the user has a
         * chance to edit the form. The checks for dirty and touched prevent errors
         * from showing until the user does one of two things: changes the value,
         * turning the control dirty; or blurs the form control element, setting the
         * control to touched.
         * Thus, it reveals an error message only if the control is invalid and
         * the control is either dirty or touched. */
        if (this.internalComponent == undefined)
            return ((this.content.formControl.invalid) && (this.content.formControl.dirty || this.content.formControl.touched));
        return this.internalComponent.errorState;
    }
    /**
     * Handler method that is called when the control's value changes in the UI. For internal use only.
     * If a derived class wants to do some specific handling then it must overwrite
     * the `handleSpecificInput` method.
     * @return {?}
     */
    handleInput() {
        /* Calls the specific handling of the input that the derived class wants to do. */
        this.handleSpecificInput();
        // TODO: hacer la salva del valor del control para `this.content.value` de una mejor forma 
        // porque hacerlo aquí genera inconsistencias. Una mejor forma sería proporcionar un method que 
        // haga la función de salvar el valor y entonces es llamado cuando haga falta. 
        /* If the control does not have error ... */
        if (!this.errorState) {
            /* ... sets the new value of the control in the `content`. */
            this.content.value = this.content.formControl.value;
        }
        /* If the control is not marked as `touched` ... */
        if (this.content.formControl.untouched) {
            /* ... marks the control as `touched`. */
            this.content.formControl.markAsTouched({
                onlySelf: true
            });
        }
    }
    /**
     * Returns the control's default value.
     * This function can be overwrite in the derived class.
     * @return {?}
     */
    get getDefaultValue() {
        /* By default, its implementation is returning the empty string. */
        return '';
    }
    /**
     * Returns an error string if the control is in an error state; otherwise, empty string.
     * This function can be overwrite in the derived class.
     * @return {?}
     */
    getErrorMessage() {
        /* By default, its implementation is returning the error of the `internalComponent.getErrorMessage`
         * method or returning the text errors. */
        if (this.internalComponent != undefined)
            return this.internalComponent.getErrorMessage();
        /** @type {?} */
        let validationErrors = this.content.formControl.errors;
        /* Shows the text errors. */
        if (validationErrors) {
            if (validationErrors[Validators.required.name]) {
                return ((this.isTranslationBuiltByControl) ? InputControl.toco_ng_Error_Msg_Requerido : this.validationError_required);
            }
        }
        return '';
    }
    /**
     * Handler method that is called by the internal logic when the control's value changes in the UI.
     * This method contains the specific handling of the input that the derived class wants to do.
     * This function can be overwrite in the derived class.
     * @return {?}
     */
    handleSpecificInput() {
        /* By default, its implementation has nothing to do. */
    }
}
InputControl.toco_ng_Error_Msg_Requerido = '';
InputControl.propDecorators = {
    content: [{ type: Input }],
    internalComponent: [{ type: ViewChild, args: ['internalComponent', { static: true },] }]
};
if (false) {
    /**
     * @type {?}
     * @protected
     */
    InputControl.toco_ng_Error_Msg_Requerido;
    /**
     * Input field that contains the content of this class.
     * @type {?}
     */
    InputControl.prototype.content;
    /**
     * Tracks the value and validity state of the internal component that contains the text input.
     * Implementation notes: There are two cases:
     *  - You only have the `content.formControl` field as the `InputEmailComponent` class.
     *  - You have the `content.formControl` and `internalComponent` fields as the `InputIssnComponent` class.
     * @type {?}
     * @protected
     */
    InputControl.prototype.internalComponent;
    /**
     * Represents the validation error of required. Its default value can be overwritten.
     * @type {?}
     * @protected
     */
    InputControl.prototype.validationError_required;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXQuY29udHJvbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3RvY28tbGliLyIsInNvdXJjZXMiOlsibGliL2Zvcm1zL2lucHV0L2lucHV0LmNvbnRyb2wudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBTUEsT0FBTyxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDakQsT0FBTyxFQUFFLFVBQVUsRUFBb0IsV0FBVyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0UsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRXpDLE9BQU8sRUFBRSxlQUFlLEVBQWEsWUFBWSxFQUFFLFNBQVMsRUFDdEMsZ0JBQWdCLEVBQXNCLE1BQU0sdUJBQXVCLENBQUM7O0FBSzFGLE1BQVksbUJBQW1CO0lBRTNCOztPQUVHO0lBQ0gsUUFBUSxZQUFhO0lBRXJCOztPQUVHO0lBQ0gsSUFBSSxRQUFTO0lBRWI7O09BRUc7SUFDSCxPQUFPLFdBQVk7RUFDdEI7Ozs7OztBQUtELGtDQTREQzs7Ozs7Ozs7OztJQW5ERyxtQ0FBMEI7Ozs7OztJQVExQixrQ0FBaUM7Ozs7OztJQVFqQyxrQ0FBdUI7Ozs7OztJQU12QixrQ0FBdUI7Ozs7OztJQVF2QixrQ0FBb0I7Ozs7OztJQU1wQixrQ0FBb0I7Ozs7OztJQVFwQixpQ0FBc0I7Ozs7OztJQU10QiwrQkFBb0I7Ozs7Ozs7QUFPeEIsd0NBMkJDOzs7Ozs7SUF0QkcseUNBQWtDOzs7OztJQUtsQyxtQ0FBdUI7Ozs7OztJQU0xQixtQ0FBd0I7Ozs7O0lBS3JCLHdDQUE2Qjs7Ozs7SUFLN0IsK0RBQTBCOzs7Ozs7QUFNOUIsTUFBTSxPQUFnQixZQUFhLFNBQVEsZ0JBQWdCOzs7O0lBc0N2RDtRQUVJLEtBQUssRUFBRSxDQUFDO1FBRVIsSUFBSSxDQUFDLHdCQUF3QixHQUFHLEVBQUUsQ0FBQztJQUN2QyxDQUFDOzs7Ozs7OztJQW5DTSxNQUFNLENBQUMsdUJBQXVCLENBQUMs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LENBQUMsd0JBQXdCLENBQUMsQ0FBQzthQUMxSDtTQUNKO1FBRUQsT0FBTyxFQUFFLENBQUM7SUFDakIsQ0FBQzs7Ozs7OztJQU9TLG1CQUFtQjtRQUV0Qix1REFBdUQ7SUFDM0QsQ0FBQzs7QUEzTmdCLHdDQUEyQixHQUFXLEVBQUUsQ0FBQzs7c0JBWnpELEtBQUs7Z0NBU1IsU0FBUyxTQUFDLG1CQUFtQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTs7Ozs7OztJQUc3Qyx5Q0FBMEQ7Ozs7O0lBWjFELCtCQUM2Qjs7Ozs7Ozs7O0lBUWhDLHlDQUM0RDs7Ozs7O0lBT3pELGdEQUEyQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgIENvcHlyaWdodCAoYykgMjAyMCBVbml2ZXJzaWRhZCBkZSBQaW5hciBkZWwgUsOtbyBcIkhlcm1hbm9zIFNhw616IE1vbnRlcyBkZSBPY2FcIlxuICogICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cblxuaW1wb3J0IHsgSW5wdXQsIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVmFsaWRhdG9ycywgVmFsaWRhdGlvbkVycm9ycywgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XG5pbXBvcnQgeyBpc051bGxPclVuZGVmaW5lZCB9IGZyb20gJ3V0aWwnO1xuXG5pbXBvcnQgeyBDb250ZW50UG9zaXRpb24sIEljb25WYWx1ZSwgSGludFBvc2l0aW9uLCBIaW50VmFsdWUsXG4gICAgRm9ybUZpZWxkQ29udGVudCwgRm9ybUZpZWxkQ29udHJvbCwgVmFsaWRhdG9yQXJndW1lbnRzIH0gZnJvbSAnLi4vZm9ybS1maWVsZC5jb250cm9sJztcblxuLyoqXG4gKiBBbiBlbnVtIHRoYXQgcmVwcmVzZW50cyB0aGUgYXBwZWFyYW5jZSBzdHlsZSBvZiBhbiBgSW5wdXRDb250cm9sYC4gXG4gKi9cbmV4cG9ydCBlbnVtIFRleHRJbnB1dEFwcGVhcmFuY2VcbntcbiAgICAvKipcbiAgICAgKiBUaGUgYHN0YW5kYXJkYCBhcHBlYXJhbmNlIGlzIHRoZSBkZWZhdWx0IHN0eWxlLiBJdCBzaG93cyB0aGUgaW5wdXQgYm94IHdpdGggYW4gdW5kZXJsaW5lIHVuZGVybmVhdGggaXQuIFxuICAgICAqL1xuICAgIHN0YW5kYXJkID0gJ3N0YW5kYXJkJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBgZmlsbGAgYXBwZWFyYW5jZSBkaXNwbGF5cyB0aGUgZm9ybSBmaWVsZCB3aXRoIGEgZmlsbGVkIGJhY2tncm91bmQgYm94IGluIGFkZGl0aW9uIHRvIHRoZSB1bmRlcmxpbmUuIFxuICAgICAqL1xuICAgIGZpbGwgPSAnZmlsbCcsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYG91dGxpbmVgIGFwcGVhcmFuY2Ugc2hvd3MgdGhlIGZvcm0gZmllbGQgd2l0aCBhIGJvcmRlciBhbGwgdGhlIHdheSBhcm91bmQsIG5vdCBqdXN0IGFuIHVuZGVybGluZS4gXG4gICAgICovXG4gICAgb3V0bGluZSA9ICdvdXRsaW5lJ1xufVxuXG4vKipcbiAqIEEgYmFzZSBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IG9mIGFuIGBJbnB1dENvbnRyb2xgLiBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dENvbnRlbnQgZXh0ZW5kcyBGb3JtRmllbGRDb250ZW50XG57XG4gICAgLyoqXG5cdCAqIFJldHVybnMgdGhlIGBGb3JtQ29udHJvbGAgdGhhdCB0cmFja3MgdGhlIHZhbHVlIGFuZCB2YWxpZGl0eSBzdGF0ZSBvZiB0aGUgaW50ZXJuYWwgY29udHJvbCB0aGF0IGNvbnRhaW5zIHRoZSB0ZXh0IGlucHV0LiBcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBub3RlczogVGhlcmUgYXJlIHR3byBjYXNlczogXG4gICAgICogIC0gWW91IG9ubHkgaGF2ZSB0aGUgYGNvbnRlbnQuZm9ybUNvbnRyb2xgIGZpZWxkIGFzIHRoZSBgSW5wdXRFbWFpbENvbXBvbmVudGAgY2xhc3MuIFxuICAgICAqICAtIFlvdSBoYXZlIHRoZSBgY29udGVudC5mb3JtQ29udHJvbGAgYW5kIGBJbnB1dENvbnRyb2wuaW50ZXJuYWxDb21wb25lbnRgIGZpZWxkcyBhcyB0aGUgYElucHV0SXNzbkNvbXBvbmVudGAgY2xhc3MuIFxuICAgICAqICAtIEl0IG11c3QgYmUgc3BlY2lmaWVkOyBvdGhlcndpc2UsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uIFxuXHQgKi9cbiAgICBmb3JtQ29udHJvbD86IEZvcm1Db250cm9sO1xuXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyb2wncyBhcHBlYXJhbmNlLiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYFRleHRJbnB1dEFwcGVhcmFuY2Uuc3RhbmRhcmRgLiBcbiAgICAgKi9cbiAgICBhcHBlYXJhbmNlPzogVGV4dElucHV0QXBwZWFyYW5jZTtcblxuXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cm9sJ3MgcHJlZml4IGljb24uIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4gXG4gICAgICovXG4gICAgcHJlZml4SWNvbj86IEljb25WYWx1ZTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyb2wncyBzdWZmaXggaWNvbi4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLiBcbiAgICAgKi9cbiAgICBzdWZmaXhJY29uPzogSWNvblZhbHVlO1xuXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyb2wncyBwcmVmaXggdGV4dC4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLiBcbiAgICAgKi9cbiAgICBwcmVmaXhUZXh0Pzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udHJvbCdzIHN1ZmZpeCB0ZXh0LiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuIFxuICAgICAqL1xuICAgIHN1ZmZpeFRleHQ/OiBzdHJpbmc7XG5cblxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb250cm9sJ3Mgc3RhcnQgaGludC4gXG5cdCAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4gXG5cdCAqL1xuICAgIHN0YXJ0SGludD86IEhpbnRWYWx1ZTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgY29udHJvbCdzIGVuZCBoaW50LiBcblx0ICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLiBcblx0ICovXG4gICAgZW5kSGludD86IEhpbnRWYWx1ZTtcbn1cblxuLyoqXG4gKiBBbiBpbnRlcmZhY2Ugd2hpY2ggYWxsb3dzIHRvIG1hbmlwdWxhdGUgdGhlIGludGVybmFsIGNvbXBvbmVudCB0aGF0IGNvbnRhaW5zIHRoZSB0ZXh0IGlucHV0LiBcbiAqIFRoaXMgaW50ZXJmYWNlIGlzIGltcGxlbWVudGVkIHdoZW4gaXQgaXMgY3JlYXRlZCBhIGN1c3RvbSBgTWF0Rm9ybUZpZWxkQ29udHJvbGAuIFxuICovXG5leHBvcnQgaW50ZXJmYWNlIElJbnRlcm5hbENvbXBvbmVudFxue1xuXHQvKipcblx0ICogVHJhY2tzIHRoZSB2YWx1ZSBhbmQgdmFsaWRpdHkgc3RhdGUgb2YgdGhlIGludGVybmFsIGNvbnRyb2wgdGhhdCBjb250YWlucyB0aGUgdGV4dCBpbnB1dC4gXG5cdCAqL1xuICAgIHJlYWRvbmx5IGZvcm1Db250cm9sOiBGb3JtQ29udHJvbDtcblxuXHQvKipcblx0ICogUmV0dXJucyBvciBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgY29udHJvbC4gXG5cdCAqL1xuICAgIHZhbHVlOiBhbnkgfCB1bmRlZmluZWQ7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJvbCBpcyBlbXB0eTsgb3RoZXJ3aXNlLCBmYWxzZS4gXG4gICAgICogQSBjb250cm9sIGlzIGVtcHR5IGlmIGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYCBvciBlbXB0eSBzdHJpbmcuIFxuXHQgKi9cblx0cmVhZG9ubHkgZW1wdHk6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyb2wgaXMgaW4gYW4gZXJyb3Igc3RhdGU7IG90aGVyd2lzZSwgZmFsc2UuIFxuICAgICAqL1xuICAgIHJlYWRvbmx5IGVycm9yU3RhdGU6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGVycm9yIHN0cmluZyBpZiB0aGUgY29udHJvbCBpcyBpbiBhbiBlcnJvciBzdGF0ZTsgb3RoZXJ3aXNlLCBlbXB0eSBzdHJpbmcuIFxuICAgICAqL1xuICAgIGdldEVycm9yTWVzc2FnZSgpOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYmFzZSBhYnN0cmFjdCBjbGFzcyBmb3IgYSBjb250cm9sIHRoYXQgYWxsb3dzIHRoZSB3cml0aW5nL3NlbGVjdGlvbiBvZiBhIHRleHQuIFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSW5wdXRDb250cm9sIGV4dGVuZHMgRm9ybUZpZWxkQ29udHJvbFxue1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgRm9ybUNvbnRyb2xgIGJ5IGRlZmF1bHQuIFxuICAgICAqIEl0cyB2YWx1ZSBpcyBlbXB0eSwgYW5kIGRvZXMgbm90IGhhdmUgdmFsaWRhdG9ycy4gXG4gICAgICogQHBhcmFtIHZhbGlkYXRvckFyZ3VtZW50cyBBIGNvbGxlY3Rpb24gb2Yga2V5L3ZhbHVlIGVsZW1lbnRzLCB3aGVyZSB0aGUga2V5IGlzIHRoZSB2YWxpZGF0b3IgbmFtZSBcbiAgICAgKiBhbmQgdGhlIHZhbHVlIGlzIHRoZSB2YWx1ZSB0aGF0IHRoZSB2YWxpZGF0b3IgbmVlZHMgdG8gY2hlY2suIFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZ2V0Rm9ybUNvbnRyb2xCeURlZmF1bHQodmFsaWRhdG9yQXJndW1lbnRzOiBWYWxpZGF0b3JBcmd1bWVudHMgPSB1bmRlZmluZWQpOiBGb3JtQ29udHJvbFxuICAgIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGb3JtQ29udHJvbCgnJywgWyBdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBmaWVsZCB0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoaXMgY2xhc3MuIFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNvbnRlbnQ6IElucHV0Q29udGVudDtcblxuICAgIC8qKlxuXHQgKiBUcmFja3MgdGhlIHZhbHVlIGFuZCB2YWxpZGl0eSBzdGF0ZSBvZiB0aGUgaW50ZXJuYWwgY29tcG9uZW50IHRoYXQgY29udGFpbnMgdGhlIHRleHQgaW5wdXQuIFxuICAgICAqIEltcGxlbWVudGF0aW9uIG5vdGVzOiBUaGVyZSBhcmUgdHdvIGNhc2VzOiBcbiAgICAgKiAgLSBZb3Ugb25seSBoYXZlIHRoZSBgY29udGVudC5mb3JtQ29udHJvbGAgZmllbGQgYXMgdGhlIGBJbnB1dEVtYWlsQ29tcG9uZW50YCBjbGFzcy4gXG4gICAgICogIC0gWW91IGhhdmUgdGhlIGBjb250ZW50LmZvcm1Db250cm9sYCBhbmQgYGludGVybmFsQ29tcG9uZW50YCBmaWVsZHMgYXMgdGhlIGBJbnB1dElzc25Db21wb25lbnRgIGNsYXNzLiBcblx0ICovXG5cdEBWaWV3Q2hpbGQoJ2ludGVybmFsQ29tcG9uZW50JywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgaW50ZXJuYWxDb21wb25lbnQ6IElJbnRlcm5hbENvbXBvbmVudDtcblxuICAgIHByb3RlY3RlZCBzdGF0aWMgdG9jb19uZ19FcnJvcl9Nc2dfUmVxdWVyaWRvOiBzdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIHZhbGlkYXRpb24gZXJyb3Igb2YgcmVxdWlyZWQuIEl0cyBkZWZhdWx0IHZhbHVlIGNhbiBiZSBvdmVyd3JpdHRlbi4gXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHZhbGlkYXRpb25FcnJvcl9yZXF1aXJlZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLnZhbGlkYXRpb25FcnJvcl9yZXF1aXJlZCA9ICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG5ldyBsYW5ndWFnZS4gXG4gICAgICogQHBhcmFtIHRyYW5zU2VydiBUaGUgYFRyYW5zbGF0ZVNlcnZpY2VgIGluc3RhbmNlIGluamVjdGVkLiBcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2V0TmV3TGFuZ3VhZ2UodHJhbnNTZXJ2OiBUcmFuc2xhdGVTZXJ2aWNlKTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogVGhlIGBJbnB1dENvbnRyb2wuY3VycmVudExhbmcgIT0gdHJhbnNTZXJ2LmN1cnJlbnRMYW5nYCB0ZXN0IGlzIE5PVCBuZWNlc3NhcnkgaGVyZSBiZWNhdXNlIGl0IGlzIGRvbmUgaW4gdGhlIG5vbi1hYnN0cmFjdCBjaGlsZCBjbGFzc2VzLiAqL1xuXG4gICAgICAgIHN1cGVyLnNldE5ld0xhbmd1YWdlKHRyYW5zU2Vydik7XG5cbiAgICAgICAgLyogVGhlIGBJbnB1dENvbnRyb2wuY3VycmVudExhbmdgIHZhbHVlIGlzIHVwZGF0ZWQgY29ycmVjdGx5IGluIHRoZSBwYXJlbnQgY2xhc3MuICovXG5cbiAgICAgICAgdHJhbnNTZXJ2LmdldCgnVE9DT19OR19FUlJPUl9NU0dfUkVRVUVSSURPJykuc3Vic2NyaWJlKChyZXM6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgSW5wdXRDb250cm9sLnRvY29fbmdfRXJyb3JfTXNnX1JlcXVlcmlkbyA9IHJlcztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGBjb250ZW50YCBpbnB1dCBwcm9wZXJ0eS4gXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBkZWZhdWx0IGxhYmVsIHRvIHVzZS4gSXQgaXMgdXNlZCBpZiB0aGUgYGNvbnRlbnQubGFiZWxgIGlzIG5vdCBzcGVjaWZpZWQuIFxuICAgICAqIEBwYXJhbSBwbGFjZWhvbGRlciBUaGUgZGVmYXVsdCBwbGFjZWhvbGRlciB0byB1c2UuIEl0IGlzIHVzZWQgaWYgdGhlIGBjb250ZW50LnBsYWNlaG9sZGVyYCBpcyBub3Qgc3BlY2lmaWVkLiBcbiAgICAgKiBAcGFyYW0gaXNBYmJyZXZpYXRpb24gSWYgaXQgaXMgdHJ1ZSB0aGVuIHRoZSBgbGFiZWxgIGFyZ3VtZW50IHJlcHJlc2VudHMgYW4gYWJicmV2aWF0aW9uOyBvdGhlcndpc2UsIGZhbHNlLiBcbiAgICAgKiBAcGFyYW0gYWx3YXlzSGludCBJZiBpdCBpcyB0cnVlIHRoZW4gdGhlcmUgaXMgYWx3YXlzIGF0IGxlYXQgb25lIGhpbnQgc3RhcnQtYWxpZ25lZC4gXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluaXQobGFiZWw6IHN0cmluZywgcGxhY2Vob2xkZXI6IHN0cmluZyA9ICcnLCBpc0FiYnJldmlhdGlvbjogYm9vbGVhbiA9IGZhbHNlLCBhbHdheXNIaW50OiBib29sZWFuID0gdHJ1ZSk6IHZvaWRcbiAgICB7XG4gICAgICAgIC8qIFNldHMgdGhlIGRlZmF1bHQgdmFsdWVzLiAqL1xuXG4gICAgICAgIHN1cGVyLmluaXQobGFiZWwsIHBsYWNlaG9sZGVyKTtcblxuICAgICAgICBpZiAodGhpcy5jb250ZW50LmZvcm1Db250cm9sID09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxDb21wb25lbnQgPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoYEZvciB0aGUgJyR7IHRoaXMuY29udGVudC5uYW1lIH0nIGNvbnRyb2wsIHRoZSAnY29udGVudC5mb3JtQ29udHJvbCcgdmFsdWUgY2FuIG5vdCBiZSB1bmRlZmluZWQ7IGl0IG11c3QgYmUgYSAnRm9ybUNvbnRyb2wnIHZhbHVlLmApO1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wgPSB0aGlzLmludGVybmFsQ29tcG9uZW50LmZvcm1Db250cm9sO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGV0IHRlbXA6IHN0cmluZyA9IChpc0FiYnJldmlhdGlvbikgPyB0aGlzLmNvbnRlbnQubGFiZWwgOiB0aGlzLmNvbnRlbnQubGFiZWwudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0aW9uRXJyb3JfcmVxdWlyZWQgPSAnVE9DT19OR19FUlJPUl9NU0dfUkVRVUVSSURPJztcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKiogSW50ZXJuYWwgY29udHJvbCBwcm9wZXJ0aWVzLiAqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5yZXF1aXJlZCA9PSB1bmRlZmluZWQpIHRoaXMuY29udGVudC5yZXF1aXJlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKiBgbWF0LWZvcm0tZmllbGRgIHByb3BlcnRpZXMuICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LmFwcGVhcmFuY2UgPT0gdW5kZWZpbmVkKSB0aGlzLmNvbnRlbnQuYXBwZWFyYW5jZSA9IFRleHRJbnB1dEFwcGVhcmFuY2Uuc3RhbmRhcmQ7XG5cbiAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqIGBtYXQtaWNvbmAgcHJvcGVydGllcy4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQucHJlZml4SWNvbiAhPSB1bmRlZmluZWQpIHRoaXMuY29udGVudC5wcmVmaXhJY29uLnNldERlZmF1bHRWYWx1ZUlmVW5kZWZpbmVkX3NldFBvc2l0aW9uKENvbnRlbnRQb3NpdGlvbi5wcmVmaXgpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LnN1ZmZpeEljb24gIT0gdW5kZWZpbmVkKSB0aGlzLmNvbnRlbnQuc3VmZml4SWNvbi5zZXREZWZhdWx0VmFsdWVJZlVuZGVmaW5lZF9zZXRQb3NpdGlvbihDb250ZW50UG9zaXRpb24uc3VmZml4KTtcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogYG1hdC1oaW50YCBwcm9wZXJ0aWVzLiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKGFsd2F5c0hpbnQgJiYgKHRoaXMuY29udGVudC5zdGFydEhpbnQgPT0gdW5kZWZpbmVkKSAmJiAodGhpcy5jb250ZW50LmVuZEhpbnQgPT0gdW5kZWZpbmVkKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnN0YXJ0SGludCA9IG5ldyBIaW50VmFsdWUoSGludFBvc2l0aW9uLnN0YXJ0LCAnVE9DT19OR19ISU5UX1RFWFRPX1BPUl9ERUZFQ1RPJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50LnN0YXJ0SGludCAhPSB1bmRlZmluZWQpIHRoaXMuY29udGVudC5zdGFydEhpbnQuc2V0RGVmYXVsdFZhbHVlSWZVbmRlZmluZWRfc2V0UG9zaXRpb24oSGludFBvc2l0aW9uLnN0YXJ0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnQuZW5kSGludCAhPSB1bmRlZmluZWQpIHRoaXMuY29udGVudC5lbmRIaW50LnNldERlZmF1bHRWYWx1ZUlmVW5kZWZpbmVkX3NldFBvc2l0aW9uKEhpbnRQb3NpdGlvbi5lbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogQWRkcyB0aGlzIGNvbnRyb2wgYXMgYSBjaGlsZCB0byB0aGUgYGNvbnRlbnQucGFyZW50Rm9ybVNlY3Rpb25gLiBcbiAgICAgICAgSXQgbXVzdCBiZSBjYWxsZWQgYXQgdGhlIGVuZC4gKi9cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5wYXJlbnRGb3JtU2VjdGlvbiAhPSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhZGRBc0NoaWxkQ29udHJvbCh0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wpJyk7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkQXNDaGlsZENvbnRyb2wodGhpcywgdGhpcy5jb250ZW50LmZvcm1Db250cm9sKTtcbiAgICAgICAgfVxuICAgIH1cblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZXMgdGhlIGNvbnRyb2wncyB2YWx1ZS4gSXQgdXNlcyB0aGUgYGNvbnRlbnQudmFsdWVgIGFuZCBpdCBpcyBhbHJlYWR5IGRpZmZlcmVudCBvZiBgdW5kZWZpbmVkYC4gXG4gICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIHNwZWNpZmllZCBgY29udGVudC52YWx1ZWAgaXMgY29ycmVjdC4gRm9yIGludGVybmFsIHVzZSBvbmx5LiBcblx0ICovXG5cdHByb3RlY3RlZCBpbml0VmFsdWUoKTogdm9pZFxuXHR7XG4gICAgICAgIC8qIEluIHRoaXMgd2F5LCBjaGVja3MgaWYgdGhlIHNwZWNpZmllZCBgY29udGVudC52YWx1ZWAgaXMgY29ycmVjdC4gKi9cbiAgICAgICAgdGhpcy5jb250ZW50LmZvcm1Db250cm9sLnNldFZhbHVlKHRoaXMuY29udGVudC52YWx1ZSk7XG5cbiAgICAgICAgLyogTWFya3MgdGhlIGNvbnRyb2wgYXMgYHRvdWNoZWRgLiAqL1xuICAgICAgICB0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wubWFya0FzVG91Y2hlZCh7XG4gICAgICAgICAgICBvbmx5U2VsZjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgaW5zdGFuY2UuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZ2V0SW5zdGFuY2UoKTogSW5wdXRDb250cm9sXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJvbCBpcyBlbXB0eTsgb3RoZXJ3aXNlLCBmYWxzZS4gXG4gICAgICogQSBjb250cm9sIGlzIGVtcHR5IGlmIGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYCBvciBlbXB0eSBzdHJpbmcuIFxuXHQgKi9cblx0cHVibGljIGdldCBlbXB0eSgpOiBib29sZWFuXG5cdHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxDb21wb25lbnQgPT0gdW5kZWZpbmVkKSByZXR1cm4gKChpc051bGxPclVuZGVmaW5lZCh0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wudmFsdWUpKSB8fCAodGhpcy5jb250ZW50LmZvcm1Db250cm9sLnZhbHVlID09PSAnJykpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENvbXBvbmVudC5lbXB0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyb2wgaXMgaW4gYSBoaW50IHN0YXRlOyBvdGhlcndpc2UsIGZhbHNlLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGhpbnRTdGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gdGhpcy5lbXB0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbnRyb2wgaXMgaW4gYW4gZXJyb3Igc3RhdGU7IG90aGVyd2lzZSwgZmFsc2UuIFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZXJyb3JTdGF0ZSgpOiBib29sZWFuXG4gICAge1xuICAgICAgICAvKiBUaGUgY29udHJvbCBkb2VzIG5vdCBkaXNwbGF5IGVycm9ycyBiZWZvcmUgdGhlIHVzZXIgaGFzIGEgXG4gICAgICAgICAqIGNoYW5jZSB0byBlZGl0IHRoZSBmb3JtLiBUaGUgY2hlY2tzIGZvciBkaXJ0eSBhbmQgdG91Y2hlZCBwcmV2ZW50IGVycm9ycyBcbiAgICAgICAgICogZnJvbSBzaG93aW5nIHVudGlsIHRoZSB1c2VyIGRvZXMgb25lIG9mIHR3byB0aGluZ3M6IGNoYW5nZXMgdGhlIHZhbHVlLCBcbiAgICAgICAgICogdHVybmluZyB0aGUgY29udHJvbCBkaXJ0eTsgb3IgYmx1cnMgdGhlIGZvcm0gY29udHJvbCBlbGVtZW50LCBzZXR0aW5nIHRoZSBcbiAgICAgICAgICogY29udHJvbCB0byB0b3VjaGVkLiBcbiAgICAgICAgICogVGh1cywgaXQgcmV2ZWFscyBhbiBlcnJvciBtZXNzYWdlIG9ubHkgaWYgdGhlIGNvbnRyb2wgaXMgaW52YWxpZCBhbmQgXG4gICAgICAgICAqIHRoZSBjb250cm9sIGlzIGVpdGhlciBkaXJ0eSBvciB0b3VjaGVkLiAqL1xuICAgICAgICBpZiAodGhpcy5pbnRlcm5hbENvbXBvbmVudCA9PSB1bmRlZmluZWQpIHJldHVybiAoKHRoaXMuY29udGVudC5mb3JtQ29udHJvbC5pbnZhbGlkKSAmJiAodGhpcy5jb250ZW50LmZvcm1Db250cm9sLmRpcnR5IHx8IHRoaXMuY29udGVudC5mb3JtQ29udHJvbC50b3VjaGVkKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsQ29tcG9uZW50LmVycm9yU3RhdGU7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBIYW5kbGVyIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjb250cm9sJ3MgdmFsdWUgY2hhbmdlcyBpbiB0aGUgVUkuIEZvciBpbnRlcm5hbCB1c2Ugb25seS4gXG4gICAgICogSWYgYSBkZXJpdmVkIGNsYXNzIHdhbnRzIHRvIGRvIHNvbWUgc3BlY2lmaWMgaGFuZGxpbmcgdGhlbiBpdCBtdXN0IG92ZXJ3cml0ZSBcbiAgICAgKiB0aGUgYGhhbmRsZVNwZWNpZmljSW5wdXRgIG1ldGhvZC4gXG5cdCAqL1xuXHRwdWJsaWMgaGFuZGxlSW5wdXQoKTogdm9pZFxuXHR7XG4gICAgICAgIC8qIENhbGxzIHRoZSBzcGVjaWZpYyBoYW5kbGluZyBvZiB0aGUgaW5wdXQgdGhhdCB0aGUgZGVyaXZlZCBjbGFzcyB3YW50cyB0byBkby4gKi9cbiAgICAgICAgdGhpcy5oYW5kbGVTcGVjaWZpY0lucHV0KCk7XG5cbiAgICAgICAgLy8gVE9ETzogaGFjZXIgbGEgc2FsdmEgZGVsIHZhbG9yIGRlbCBjb250cm9sIHBhcmEgYHRoaXMuY29udGVudC52YWx1ZWAgZGUgdW5hIG1lam9yIGZvcm1hIFxuICAgICAgICAvLyBwb3JxdWUgaGFjZXJsbyBhcXXDrSBnZW5lcmEgaW5jb25zaXN0ZW5jaWFzLiBVbmEgbWVqb3IgZm9ybWEgc2Vyw61hIHByb3BvcmNpb25hciB1biBtZXRob2QgcXVlIFxuICAgICAgICAvLyBoYWdhIGxhIGZ1bmNpw7NuIGRlIHNhbHZhciBlbCB2YWxvciB5IGVudG9uY2VzIGVzIGxsYW1hZG8gY3VhbmRvIGhhZ2EgZmFsdGEuIFxuICAgICAgICAvKiBJZiB0aGUgY29udHJvbCBkb2VzIG5vdCBoYXZlIGVycm9yIC4uLiAqL1xuICAgICAgICBpZiAoIXRoaXMuZXJyb3JTdGF0ZSlcbiAgICAgICAge1xuICAgICAgICAgICAgLyogLi4uIHNldHMgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgY29udHJvbCBpbiB0aGUgYGNvbnRlbnRgLiAqL1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnZhbHVlID0gdGhpcy5jb250ZW50LmZvcm1Db250cm9sLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogSWYgdGhlIGNvbnRyb2wgaXMgbm90IG1hcmtlZCBhcyBgdG91Y2hlZGAgLi4uICovXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wudW50b3VjaGVkKVxuICAgICAgICB7XG4gICAgICAgICAgICAvKiAuLi4gbWFya3MgdGhlIGNvbnRyb2wgYXMgYHRvdWNoZWRgLiAqL1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LmZvcm1Db250cm9sLm1hcmtBc1RvdWNoZWQoe1xuICAgICAgICAgICAgICAgIG9ubHlTZWxmOiB0cnVlXG4gICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb250cm9sJ3MgZGVmYXVsdCB2YWx1ZS4gXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgb3ZlcndyaXRlIGluIHRoZSBkZXJpdmVkIGNsYXNzLiBcblx0ICovXG4gICAgcHVibGljIGdldCBnZXREZWZhdWx0VmFsdWUoKTogYW55XG4gICAge1xuICAgICAgICAvKiBCeSBkZWZhdWx0LCBpdHMgaW1wbGVtZW50YXRpb24gaXMgcmV0dXJuaW5nIHRoZSBlbXB0eSBzdHJpbmcuICovXG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gZXJyb3Igc3RyaW5nIGlmIHRoZSBjb250cm9sIGlzIGluIGFuIGVycm9yIHN0YXRlOyBvdGhlcndpc2UsIGVtcHR5IHN0cmluZy4gXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgb3ZlcndyaXRlIGluIHRoZSBkZXJpdmVkIGNsYXNzLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0RXJyb3JNZXNzYWdlKCk6IHN0cmluZ1xuXHR7XG4gICAgICAgIC8qIEJ5IGRlZmF1bHQsIGl0cyBpbXBsZW1lbnRhdGlvbiBpcyByZXR1cm5pbmcgdGhlIGVycm9yIG9mIHRoZSBgaW50ZXJuYWxDb21wb25lbnQuZ2V0RXJyb3JNZXNzYWdlYCBcbiAgICAgICAgICogbWV0aG9kIG9yIHJldHVybmluZyB0aGUgdGV4dCBlcnJvcnMuICovXG5cbiAgICAgICAgaWYgKHRoaXMuaW50ZXJuYWxDb21wb25lbnQgIT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5pbnRlcm5hbENvbXBvbmVudC5nZXRFcnJvck1lc3NhZ2UoKTtcblxuICAgICAgICBsZXQgdmFsaWRhdGlvbkVycm9yczogVmFsaWRhdGlvbkVycm9ycyA9IHRoaXMuY29udGVudC5mb3JtQ29udHJvbC5lcnJvcnM7XG5cbiAgICAgICAgLyogU2hvd3MgdGhlIHRleHQgZXJyb3JzLiAqL1xuICAgICAgICBpZiAodmFsaWRhdGlvbkVycm9ycylcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRpb25FcnJvcnNbVmFsaWRhdG9ycy5yZXF1aXJlZC5uYW1lXSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh0aGlzLmlzVHJhbnNsYXRpb25CdWlsdEJ5Q29udHJvbCkgPyBJbnB1dENvbnRyb2wudG9jb19uZ19FcnJvcl9Nc2dfUmVxdWVyaWRvIDogdGhpcy52YWxpZGF0aW9uRXJyb3JfcmVxdWlyZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuXHR9XG4gICAgXG5cdC8qKlxuXHQgKiBIYW5kbGVyIG1ldGhvZCB0aGF0IGlzIGNhbGxlZCBieSB0aGUgaW50ZXJuYWwgbG9naWMgd2hlbiB0aGUgY29udHJvbCdzIHZhbHVlIGNoYW5nZXMgaW4gdGhlIFVJLiBcbiAgICAgKiBUaGlzIG1ldGhvZCBjb250YWlucyB0aGUgc3BlY2lmaWMgaGFuZGxpbmcgb2YgdGhlIGlucHV0IHRoYXQgdGhlIGRlcml2ZWQgY2xhc3Mgd2FudHMgdG8gZG8uIFxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIG92ZXJ3cml0ZSBpbiB0aGUgZGVyaXZlZCBjbGFzcy4gXG5cdCAqL1xuICAgIHB1YmxpYyBoYW5kbGVTcGVjaWZpY0lucHV0KCk6IHZvaWRcblx0e1xuICAgICAgICAvKiBCeSBkZWZhdWx0LCBpdHMgaW1wbGVtZW50YXRpb24gaGFzIG5vdGhpbmcgdG8gZG8uICovXG4gICAgfVxufVxuIl19