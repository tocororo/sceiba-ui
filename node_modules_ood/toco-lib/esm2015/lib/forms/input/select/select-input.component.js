/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/input/select/select-input.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, Input } from '@angular/core';
import { Observable } from 'rxjs';
import { TranslateService } from '@ngx-translate/core';
import { isArray } from 'util';
import { InputControl } from '../input.control';
import { HintPosition, HintValue } from '../../form-field.control';
/**
 * An interface that represents a selectable option.
 * @record
 */
export function SelectOption() { }
if (false) {
    /**
     * Returns the label that is showed.
     * @type {?}
     */
    SelectOption.prototype.label;
    /**
     * Returns the value that is stored internally.
     * @type {?}
     */
    SelectOption.prototype.value;
}
/**
 * An interface that represents the content of a select control.
 * @record
 */
export function SelectContent() { }
if (false) {
    /**
     * Returns the options list that can be selected.
     * This field can be set using three ways:
     *  - Its value is `undefined`, then it takes the options from the `content.value` field.
     *  - Its value is a `SelectOption[]`, then it already contains the options.
     *  - Its value is an `Observable<SelectOption[]>`, then it takes the options when the observable emits values.
     * By default, its value is `[]`.
     * @type {?|undefined}
     */
    SelectContent.prototype.selectOptions;
    /**
     * Returns true if the selection can be multiple; otherwise, false.
     * By default, its value is `false`.
     * @type {?|undefined}
     */
    SelectContent.prototype.multiple;
    /**
     * Returns true if the tooltip is showed; otherwise, false.
     * By default, its value is `false`.
     * @type {?|undefined}
     */
    SelectContent.prototype.showTooltip;
    /**
     * Returns a value that allows the user to define the position of the tooltip for the select control.
     * It is used if the `showTooltip` field value is `true`.
     * By default, its value is `'below'`.
     * Its value can be one of these values: 'left', 'right', 'above', 'below', 'after', 'before'
     * @type {?|undefined}
     */
    SelectContent.prototype.selectTooltipPosition;
    /**
     * Returns a value that allows the user to define the position of the tooltip for the select control's options.
     * It is used if the `showTooltip` field value is `true`.
     * By default, its value is `'right'`.
     * Its value can be one of these values: 'left', 'right', 'above', 'below', 'after', 'before'
     * @type {?|undefined}
     */
    SelectContent.prototype.optionsTooltipPosition;
}
/**
 * Represents a control that allows to select one value or multiple values.
 * Implementation notes:
 * The `extraContent` recibe una funcion llamada getOptions() que se encarga de contruir un SelectOption[].
 * Si es multiple, entonces el `value` es un array de valores.
 */
export class InputSelectComponent extends InputControl {
    /**
     * @param {?} _transServ
     */
    constructor(_transServ) {
        super();
        this._transServ = _transServ;
        this._selectOptionsSubscription = null;
        this.selectTooltip = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        /* Sets the default values. */
        this.init('', '', false, true);
        /* The `selectTooltip` value is set in `onSelectionChange` method when happening initialization or selection change. */
        this.onSelectionChange();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        /* Disposes the resources held by the subscription. */
        this._selectOptions_Unsubscription();
    }
    /**
     * Initializes the `content` input property.
     * @protected
     * @param {?} label The default label to use. It is used if the `content.label` is not specified.
     * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
     * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
     * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
     * @return {?}
     */
    init(label, placeholder = '', isAbbreviation, alwaysHint) {
        /* Changes the translation when the language changes. */
        this._transServ.onLangChange.subscribe((/**
         * @param {?} params
         * @return {?}
         */
        (params) => {
            this._setSelectTooltip();
        }));
        /* Sets the default values. */
        super.init(label, placeholder, isAbbreviation, alwaysHint);
        if (this.content.startHint != undefined) {
            if (this.content.startHint.label == 'TOCO_NG_HINT_TEXTO_POR_DEFECTO')
                this.content.startHint.label = 'TOCO_NG_HINT_TEXTO_SELECC_POR_DEFECTO';
        }
        else
            this.content.startHint = new HintValue(HintPosition.start, 'TOCO_NG_HINT_TEXTO_SELECC_POR_DEFECTO');
        if (this.content.multiple == undefined)
            this.content.multiple = false;
        if (this.content.showTooltip == undefined)
            this.content.showTooltip = false;
        if (this.content.selectTooltipPosition == undefined)
            this.content.selectTooltipPosition = 'below';
        if (this.content.optionsTooltipPosition == undefined)
            this.content.optionsTooltipPosition = 'right';
        if (this.content.selectOptions == undefined) {
            if (this.content.value == undefined) {
                this.content.selectOptions = [];
            }
            else {
                /* Gets the `content.selectOptions` from the `content.value` field. */
                if (isArray(this.content.value)) {
                    this.content.multiple = true; /* The control must be multiple. */
                    this.content.selectOptions = [];
                    this.content.value.forEach((/**
                     * @param {?} option
                     * @return {?}
                     */
                    (option) => {
                        ((/** @type {?} */ (this.content.selectOptions))).push({
                            'label': option,
                            'value': option.toUpperCase()
                        });
                    }));
                }
                else {
                    this.content.selectOptions = [
                        {
                            'label': this.content.value,
                            'value': this.content.value.toUpperCase()
                        }
                    ];
                }
            }
        }
        else if (isArray(this.content.selectOptions)) {
            /* Nothing to do here, but this case must be here. */
        }
        else if (this.content.selectOptions instanceof Observable) {
            /* Gets the `content.selectOptions` from an `Observable` when it emits values. */
            this._selectOptions_Unsubscription();
            this._selectOptionsSubscription = this.content.selectOptions.subscribe((/**
             * @param {?} selectOptions
             * @return {?}
             */
            (selectOptions) => {
                this.content.selectOptions = selectOptions;
            }));
        }
        else {
            throw new Error(`For the '${InputSelectComponent.name}' control, the 'content.selectOptions' type value has a configuration error because the programme does not know what to do with it!`);
        }
        /* The `selectTooltip` value is set in `onSelectionChange` method when happening initialization or selection change. */
    }
    /**
     * @private
     * @return {?}
     */
    _selectOptions_Unsubscription() {
        /* Disposes the resources held by the subscription. */
        if (this._selectOptionsSubscription) {
            this._selectOptionsSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    onSelectionChange() {
        // console.log('Call `onSelectionChange` - ', 'Select value: ', this.content.formControl.value);
        this._setSelectTooltip();
        if ((this.content.extraContent) && (this.content.extraContent.selectionChange)) {
            this.content.extraContent.selectionChange(this.content.formControl.value);
        }
    }
    /**
     * Does the translation for a key (or an array of keys).
     * @private
     * @param {?} key The key (or an array of keys) to translate.
     * @return {?}
     */
    _doTranslation(key) {
        if (key.length == 0) {
            this.selectTooltip = '';
            return;
        }
        this._transServ.get(key).subscribe((/**
         * @param {?} res
         * @return {?}
         */
        (res) => {
            // console.log(key, ' --> ', res);
            if (this.content.multiple) {
                /* `res` is an object of translated keys. */
                /** @type {?} */
                let translationKeys = Object.keys(res);
                /** @type {?} */
                let len = translationKeys.length;
                /** @type {?} */
                let translationRes = res[translationKeys[0]];
                for (let i = 1; i < len; ++i) {
                    translationRes += '\n' + res[translationKeys[i]];
                }
                this.selectTooltip = translationRes;
            }
            else {
                /* `res` is a translated key. */
                this.selectTooltip = res;
            }
        }));
    }
    /**
     * Finds the label for a value (or an array of values).
     * @private
     * @param {?} value The value (or an array of values) to find the label.
     * @return {?} Returns a label (or an array of labels).
     */
    _findLabel(value) {
        if (this.content.multiple) {
            /** @type {?} */
            let label = [];
            for (let val of value) {
                for (let opt of ((/** @type {?} */ (this.content.selectOptions)))) {
                    if (opt.value == val) {
                        label.push(opt.label);
                        break;
                    }
                }
            }
            return label;
        }
        else {
            /** @type {?} */
            let label = '';
            for (let opt of ((/** @type {?} */ (this.content.selectOptions)))) {
                if (opt.value == value) {
                    label = opt.label;
                    break;
                }
            }
            return label;
        }
    }
    /**
     * Sets the `selectTooltip` field value.
     * @private
     * @return {?}
     */
    _setSelectTooltip() {
        if (this.content.formControl.value != undefined) {
            this._doTranslation(this._findLabel(this.content.formControl.value));
        }
        else {
            this.selectTooltip = '';
        }
    }
}
InputSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'input-select',
                template: "\n<mat-form-field\n\tclass=\"select-mat-form-field\"\n\t[appearance]=\"content.appearance\"\n>\n\n\t<mat-label>\n\t\t{{ content.label | translate }}\n\t</mat-label>\n\n\t<ng-container *ngIf=\"content.showTooltip; then thenTemplate_Tooltip; else elseTemplate_WithoutTooltip\"></ng-container>\n\n\t<ng-template #thenTemplate_Tooltip>\n\t\t<mat-select \n\t\t\t[formControl]=\"content.formControl\"\n\t\t\t[required]=\"content.required\"\n\t\t\t[style.textAlign]=\"content.textAlign\"\n\t\t\t[attr.aria-label]=\"content.ariaLabel | translate\"\n\t\t\t[(value)]=\"content.value\"\n\t\t\t[multiple]=\"content.multiple\"\n\t\t\t(selectionChange)=\"onSelectionChange()\"\n\t\t\t[matTooltip]=\"selectTooltip\" [matTooltipPosition]=\"content.selectTooltipPosition\" [matTooltipClass]=\"'tooltip-multiple-lines'\"\n\t\t>\n\t\t\t<mat-option \n\t\t\t\t*ngFor=\"let option of content.selectOptions\" \n\t\t\t\t[value]=\"option.value\"\n\t\t\t\t[matTooltip]=\"option.label | translate\" [matTooltipPosition]=\"content.optionsTooltipPosition\"\n\t\t\t>\n\t\t\t\t{{ option.label | translate }}\n\t\t\t</mat-option>\n\t\t</mat-select>\n\t</ng-template>\n\n\t<ng-template #elseTemplate_WithoutTooltip>\n\t\t<mat-select \n\t\t\t[formControl]=\"content.formControl\"\n\t\t\t[required]=\"content.required\"\n\t\t\t[style.textAlign]=\"content.textAlign\"\n\t\t\t[attr.aria-label]=\"content.ariaLabel | translate\"\n\t\t\t[(value)]=\"content.value\"\n\t\t\t[multiple]=\"content.multiple\"\n\t\t\t(selectionChange)=\"onSelectionChange()\"\n\t\t>\n\t\t\t<mat-option \n\t\t\t\t*ngFor=\"let option of content.selectOptions\" \n\t\t\t\t[value]=\"option.value\"\n\t\t\t>\n\t\t\t\t{{ option.label | translate }}\n\t\t\t</mat-option>\n\t\t</mat-select>\n\t</ng-template>\n\n\t<mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                host: {
                    '[style.minWidth]': 'content.minWidth',
                    '[style.width]': 'content.width'
                },
                styles: [".select-mat-form-field{width:100%}::ng-deep .tooltip-multiple-lines{white-space:pre-line!important}"]
            }] }
];
/** @nocollapse */
InputSelectComponent.ctorParameters = () => [
    { type: TranslateService }
];
InputSelectComponent.propDecorators = {
    content: [{ type: Input }]
};
if (false) {
    /**
     * Input field that contains the content of this class.
     * @type {?}
     */
    InputSelectComponent.prototype.content;
    /**
     * Returns the current selected option tooltip.
     * If nothing is selected, then its value is `''`.
     * @type {?}
     */
    InputSelectComponent.prototype.selectTooltip;
    /**
     * @type {?}
     * @private
     */
    InputSelectComponent.prototype._selectOptionsSubscription;
    /**
     * @type {?}
     * @private
     */
    InputSelectComponent.prototype._transServ;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LWlucHV0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3RvY28tbGliLyIsInNvdXJjZXMiOlsibGliL2Zvcm1zL2lucHV0L3NlbGVjdC9zZWxlY3QtaW5wdXQuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0EsT0FBTyxFQUFFLFNBQVMsRUFBcUIsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxVQUFVLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBRWhELE9BQU8sRUFBbUIsZ0JBQWdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN4RSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRS9CLE9BQU8sRUFBRSxZQUFZLEVBQWdCLE1BQU0sa0JBQWtCLENBQUM7QUFDOUQsT0FBTyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7Ozs7QUFLbkUsa0NBZ0JDOzs7Ozs7SUFYQSw2QkFBYzs7Ozs7SUFLZCw2QkFBVzs7Ozs7O0FBV1osbUNBdUNDOzs7Ozs7Ozs7OztJQTdCQSxzQ0FBNEQ7Ozs7OztJQU01RCxpQ0FBbUI7Ozs7OztJQU1uQixvQ0FBc0I7Ozs7Ozs7O0lBUXRCLDhDQUF3Qzs7Ozs7Ozs7SUFReEMsK0NBQXlDOzs7Ozs7OztBQWtCMUMsTUFBTSxPQUFPLG9CQUFxQixTQUFRLFlBQVk7Ozs7SUFnQnJELFlBQTJCLFVBQTRCO1FBRWhELEtBQUssRUFBRSxDQUFDO1FBRlksZUFBVSxHQUFWLFVBQVUsQ0FBa0I7UUFGL0MsK0JBQTBCLEdBQWlCLElBQUksQ0FBQztRQU12RCxJQUFJLENBQUMsYUFBYSxHQUFHLEVBQUUsQ0FBQztJQUN6QixDQUFDOzs7O0lBRU0sUUFBUTtRQUVSLDhCQUE4QjtRQUNwQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRS9CLHVI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Q3RCLE1BQU07cUJBQ047aUJBQ0Q7YUFDRDtZQUVELE9BQU8sS0FBSyxDQUFDO1NBQ2I7YUFFRDs7Z0JBQ0ssS0FBSyxHQUFXLEVBQUU7WUFFdEIsS0FBSyxJQUFJLEdBQUcsSUFBSSxDQUFDLG1CQUFBLElBQUksQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFrQixDQUFDLEVBQzlEO2dCQUNDLElBQUksR0FBRyxDQUFDLEtBQUssSUFBSSxLQUFLLEVBQ3RCO29CQUNDLEtBQUssR0FBRyxHQUFHLENBQUMsS0FBSyxDQUFDO29CQUNsQixNQUFNO2lCQUNOO2FBQ0Q7WUFFRCxPQUFPLEtBQUssQ0FBQztTQUNiO0lBQ0YsQ0FBQzs7Ozs7O0lBS08saUJBQWlCO1FBRXhCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsS0FBSyxJQUFJLFNBQVMsRUFDL0M7WUFDQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztTQUNyRTthQUVEO1lBQ0MsSUFBSSxDQUFDLGFBQWEsR0FBRyxFQUFFLENBQUM7U0FDeEI7SUFDRixDQUFDOzs7WUEzUEQsU0FBUyxTQUFDO2dCQUNWLFFBQVEsRUFBRSxjQUFjO2dCQUN4QixrNEVBQTRDO2dCQUU1QyxJQUFJLEVBQUU7b0JBQ0wsa0JBQWtCLEVBQUUsa0JBQWtCO29CQUN0QyxlQUFlLEVBQUUsZUFBZTtpQkFDaEM7O2FBQ0Q7Ozs7WUFyRnlCLGdCQUFnQjs7O3NCQTJGckMsS0FBSzs7Ozs7OztJQUFOLHVDQUMyQjs7Ozs7O0lBTTlCLDZDQUE2Qjs7Ozs7SUFFN0IsMERBQXdEOzs7OztJQUVyQywwQ0FBb0MiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IENvbXBvbmVudCwgT25Jbml0LCBPbkRlc3Ryb3ksIElucHV0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFRvb2x0aXBQb3NpdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3Rvb2x0aXAnO1xuaW1wb3J0IHsgTGFuZ0NoYW5nZUV2ZW50LCBUcmFuc2xhdGVTZXJ2aWNlIH0gZnJvbSAnQG5neC10cmFuc2xhdGUvY29yZSc7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAndXRpbCc7XG5cbmltcG9ydCB7IElucHV0Q29udHJvbCwgSW5wdXRDb250ZW50IH0gZnJvbSAnLi4vaW5wdXQuY29udHJvbCc7XG5pbXBvcnQgeyBIaW50UG9zaXRpb24sIEhpbnRWYWx1ZSB9IGZyb20gJy4uLy4uL2Zvcm0tZmllbGQuY29udHJvbCc7XG5cbi8qKlxuICogQW4gaW50ZXJmYWNlIHRoYXQgcmVwcmVzZW50cyBhIHNlbGVjdGFibGUgb3B0aW9uLiBcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZWxlY3RPcHRpb25cbntcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxhYmVsIHRoYXQgaXMgc2hvd2VkLiBcblx0ICovXG5cdGxhYmVsOiBzdHJpbmc7XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHZhbHVlIHRoYXQgaXMgc3RvcmVkIGludGVybmFsbHkuIFxuXHQgKi9cblx0dmFsdWU6IGFueTtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoaXMgb3B0aW9uIGlzIHNlbGVjdGVkOyBvdGhlcndpc2UsIGZhbHNlLiBcblx0ICovXG5cdC8vIHNlbGVjdGVkPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IG9mIGEgc2VsZWN0IGNvbnRyb2wuIFxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdENvbnRlbnQgZXh0ZW5kcyBJbnB1dENvbnRlbnRcbntcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG9wdGlvbnMgbGlzdCB0aGF0IGNhbiBiZSBzZWxlY3RlZC4gXG5cdCAqIFRoaXMgZmllbGQgY2FuIGJlIHNldCB1c2luZyB0aHJlZSB3YXlzOiBcblx0ICogIC0gSXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLCB0aGVuIGl0IHRha2VzIHRoZSBvcHRpb25zIGZyb20gdGhlIGBjb250ZW50LnZhbHVlYCBmaWVsZC4gXG5cdCAqICAtIEl0cyB2YWx1ZSBpcyBhIGBTZWxlY3RPcHRpb25bXWAsIHRoZW4gaXQgYWxyZWFkeSBjb250YWlucyB0aGUgb3B0aW9ucy4gXG5cdCAqICAtIEl0cyB2YWx1ZSBpcyBhbiBgT2JzZXJ2YWJsZTxTZWxlY3RPcHRpb25bXT5gLCB0aGVuIGl0IHRha2VzIHRoZSBvcHRpb25zIHdoZW4gdGhlIG9ic2VydmFibGUgZW1pdHMgdmFsdWVzLiBcblx0ICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBbXWAuIFxuXHQgKi9cblx0c2VsZWN0T3B0aW9ucz86IFNlbGVjdE9wdGlvbltdIHwgT2JzZXJ2YWJsZTxTZWxlY3RPcHRpb25bXT47XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9uIGNhbiBiZSBtdWx0aXBsZTsgb3RoZXJ3aXNlLCBmYWxzZS4gXG5cdCAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgZmFsc2VgLiBcblx0ICovXG5cdG11bHRpcGxlPzogYm9vbGVhbjtcblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSB0b29sdGlwIGlzIHNob3dlZDsgb3RoZXJ3aXNlLCBmYWxzZS4gXG5cdCAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgZmFsc2VgLiBcblx0ICovXG5cdHNob3dUb29sdGlwPzogYm9vbGVhbjtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZhbHVlIHRoYXQgYWxsb3dzIHRoZSB1c2VyIHRvIGRlZmluZSB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAgZm9yIHRoZSBzZWxlY3QgY29udHJvbC4gXG5cdCAqIEl0IGlzIHVzZWQgaWYgdGhlIGBzaG93VG9vbHRpcGAgZmllbGQgdmFsdWUgaXMgYHRydWVgLiBcblx0ICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGAnYmVsb3cnYC4gXG5cdCAqIEl0cyB2YWx1ZSBjYW4gYmUgb25lIG9mIHRoZXNlIHZhbHVlczogJ2xlZnQnLCAncmlnaHQnLCAnYWJvdmUnLCAnYmVsb3cnLCAnYWZ0ZXInLCAnYmVmb3JlJyBcblx0ICovXG5cdHNlbGVjdFRvb2x0aXBQb3NpdGlvbj86IFRvb2x0aXBQb3NpdGlvbjtcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZhbHVlIHRoYXQgYWxsb3dzIHRoZSB1c2VyIHRvIGRlZmluZSB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAgZm9yIHRoZSBzZWxlY3QgY29udHJvbCdzIG9wdGlvbnMuIFxuXHQgKiBJdCBpcyB1c2VkIGlmIHRoZSBgc2hvd1Rvb2x0aXBgIGZpZWxkIHZhbHVlIGlzIGB0cnVlYC4gXG5cdCAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgJ3JpZ2h0J2AuIFxuXHQgKiBJdHMgdmFsdWUgY2FuIGJlIG9uZSBvZiB0aGVzZSB2YWx1ZXM6ICdsZWZ0JywgJ3JpZ2h0JywgJ2Fib3ZlJywgJ2JlbG93JywgJ2FmdGVyJywgJ2JlZm9yZScgXG5cdCAqL1xuXHRvcHRpb25zVG9vbHRpcFBvc2l0aW9uPzogVG9vbHRpcFBvc2l0aW9uO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb250cm9sIHRoYXQgYWxsb3dzIHRvIHNlbGVjdCBvbmUgdmFsdWUgb3IgbXVsdGlwbGUgdmFsdWVzLiBcbiAqIEltcGxlbWVudGF0aW9uIG5vdGVzOiBcbiAqIFRoZSBgZXh0cmFDb250ZW50YCByZWNpYmUgdW5hIGZ1bmNpb24gbGxhbWFkYSBnZXRPcHRpb25zKCkgcXVlIHNlIGVuY2FyZ2EgZGUgY29udHJ1aXIgdW4gU2VsZWN0T3B0aW9uW10uIFxuICogU2kgZXMgbXVsdGlwbGUsIGVudG9uY2VzIGVsIGB2YWx1ZWAgZXMgdW4gYXJyYXkgZGUgdmFsb3Jlcy4gXG4gKi9cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogJ2lucHV0LXNlbGVjdCcsXG5cdHRlbXBsYXRlVXJsOiAnLi9zZWxlY3QtaW5wdXQuY29tcG9uZW50Lmh0bWwnLFxuXHRzdHlsZVVybHM6IFsnLi9zZWxlY3QtaW5wdXQuY29tcG9uZW50LnNjc3MnXSxcblx0aG9zdDoge1xuXHRcdCdbc3R5bGUubWluV2lkdGhdJzogJ2NvbnRlbnQubWluV2lkdGgnLFxuXHRcdCdbc3R5bGUud2lkdGhdJzogJ2NvbnRlbnQud2lkdGgnXG5cdH1cbn0pXG5leHBvcnQgY2xhc3MgSW5wdXRTZWxlY3RDb21wb25lbnQgZXh0ZW5kcyBJbnB1dENvbnRyb2wgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveVxue1xuXHQvKipcbiAgICAgKiBJbnB1dCBmaWVsZCB0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoaXMgY2xhc3MuIFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG5cdHB1YmxpYyBjb250ZW50OiBTZWxlY3RDb250ZW50O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHNlbGVjdGVkIG9wdGlvbiB0b29sdGlwLiBcblx0ICogSWYgbm90aGluZyBpcyBzZWxlY3RlZCwgdGhlbiBpdHMgdmFsdWUgaXMgYCcnYC4gXG5cdCAqL1xuXHRwdWJsaWMgc2VsZWN0VG9vbHRpcDogc3RyaW5nO1xuXG5cdHByaXZhdGUgX3NlbGVjdE9wdGlvbnNTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IG51bGw7XG5cblx0cHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgX3RyYW5zU2VydjogVHJhbnNsYXRlU2VydmljZSlcblx0e1xuICAgICAgICBzdXBlcigpO1xuXG5cdFx0dGhpcy5zZWxlY3RUb29sdGlwID0gJyc7XG5cdH1cblxuXHRwdWJsaWMgbmdPbkluaXQoKTogdm9pZFxuXHR7XG4gICAgICAgIC8qIFNldHMgdGhlIGRlZmF1bHQgdmFsdWVzLiAqL1xuXHRcdHRoaXMuaW5pdCgnJywgJycsIGZhbHNlLCB0cnVlKTtcblxuXHRcdC8qIFRoZSBgc2VsZWN0VG9vbHRpcGAgdmFsdWUgaXMgc2V0IGluIGBvblNlbGVjdGlvbkNoYW5nZWAgbWV0aG9kIHdoZW4gaGFwcGVuaW5nIGluaXRpYWxpemF0aW9uIG9yIHNlbGVjdGlvbiBjaGFuZ2UuICovXG5cdFx0dGhpcy5vblNlbGVjdGlvbkNoYW5nZSgpO1xuXHR9XG5cblx0cHVibGljIG5nT25EZXN0cm95KCk6IHZvaWRcblx0e1xuXHRcdC8qIERpc3Bvc2VzIHRoZSByZXNvdXJjZXMgaGVsZCBieSB0aGUgc3Vic2NyaXB0aW9uLiAqL1xuXHRcdHRoaXMuX3NlbGVjdE9wdGlvbnNfVW5zdWJzY3JpcHRpb24oKTtcblx0fVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGBjb250ZW50YCBpbnB1dCBwcm9wZXJ0eS4gXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBkZWZhdWx0IGxhYmVsIHRvIHVzZS4gSXQgaXMgdXNlZCBpZiB0aGUgYGNvbnRlbnQubGFiZWxgIGlzIG5vdCBzcGVjaWZpZWQuIFxuXHQgKiBAcGFyYW0gcGxhY2Vob2xkZXIgVGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgdG8gdXNlLiBJdCBpcyB1c2VkIGlmIHRoZSBgY29udGVudC5wbGFjZWhvbGRlcmAgaXMgbm90IHNwZWNpZmllZC4gXG4gICAgICogQHBhcmFtIGlzQWJicmV2aWF0aW9uIElmIGl0IGlzIHRydWUgdGhlbiB0aGUgYGxhYmVsYCBhcmd1bWVudCByZXByZXNlbnRzIGFuIGFiYnJldmlhdGlvbjsgb3RoZXJ3aXNlLCBmYWxzZS4gXG4gICAgICogQHBhcmFtIGFsd2F5c0hpbnQgSWYgaXQgaXMgdHJ1ZSB0aGVuIHRoZXJlIGlzIGFsd2F5cyBhdCBsZWF0IG9uZSBoaW50IHN0YXJ0LWFsaWduZWQuIFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0KGxhYmVsOiBzdHJpbmcsIHBsYWNlaG9sZGVyOiBzdHJpbmcgPSAnJywgaXNBYmJyZXZpYXRpb246IGJvb2xlYW4sIGFsd2F5c0hpbnQ6IGJvb2xlYW4pOiB2b2lkXG4gICAge1xuXHRcdC8qIENoYW5nZXMgdGhlIHRyYW5zbGF0aW9uIHdoZW4gdGhlIGxhbmd1YWdlIGNoYW5nZXMuICovXG5cdFx0dGhpcy5fdHJhbnNTZXJ2Lm9uTGFuZ0NoYW5nZS5zdWJzY3JpYmUoKHBhcmFtczogTGFuZ0NoYW5nZUV2ZW50KSA9PiB7XG5cdFx0XHR0aGlzLl9zZXRTZWxlY3RUb29sdGlwKCk7XG5cdFx0fSk7XG5cbiAgICAgICAgLyogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZXMuICovXG5cblx0XHRzdXBlci5pbml0KGxhYmVsLCBwbGFjZWhvbGRlciwgaXNBYmJyZXZpYXRpb24sIGFsd2F5c0hpbnQpO1xuXG5cdFx0aWYgKHRoaXMuY29udGVudC5zdGFydEhpbnQgIT0gdW5kZWZpbmVkKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNvbnRlbnQuc3RhcnRIaW50LmxhYmVsID09ICdUT0NPX05HX0hJTlRfVEVYVE9fUE9SX0RFRkVDVE8nKSB0aGlzLmNvbnRlbnQuc3RhcnRIaW50LmxhYmVsID0gJ1RPQ09fTkdfSElOVF9URVhUT19TRUxFQ0NfUE9SX0RFRkVDVE8nO1xuXHRcdH1cblx0XHRlbHNlIHRoaXMuY29udGVudC5zdGFydEhpbnQgPSBuZXcgSGludFZhbHVlKEhpbnRQb3NpdGlvbi5zdGFydCwgJ1RPQ09fTkdfSElOVF9URVhUT19TRUxFQ0NfUE9SX0RFRkVDVE8nKTtcblxuXHRcdGlmICh0aGlzLmNvbnRlbnQubXVsdGlwbGUgPT0gdW5kZWZpbmVkKSB0aGlzLmNvbnRlbnQubXVsdGlwbGUgPSBmYWxzZTtcblx0XHRpZiAodGhpcy5jb250ZW50LnNob3dUb29sdGlwID09IHVuZGVmaW5lZCkgdGhpcy5jb250ZW50LnNob3dUb29sdGlwID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuY29udGVudC5zZWxlY3RUb29sdGlwUG9zaXRpb24gPT0gdW5kZWZpbmVkKSB0aGlzLmNvbnRlbnQuc2VsZWN0VG9vbHRpcFBvc2l0aW9uID0gJ2JlbG93Jztcblx0XHRpZiAodGhpcy5jb250ZW50Lm9wdGlvbnNUb29sdGlwUG9zaXRpb24gPT0gdW5kZWZpbmVkKSB0aGlzLmNvbnRlbnQub3B0aW9uc1Rvb2x0aXBQb3NpdGlvbiA9ICdyaWdodCc7XG5cblx0XHRpZiAodGhpcy5jb250ZW50LnNlbGVjdE9wdGlvbnMgPT0gdW5kZWZpbmVkKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLmNvbnRlbnQudmFsdWUgPT0gdW5kZWZpbmVkKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmNvbnRlbnQuc2VsZWN0T3B0aW9ucyA9IFsgXTtcblx0XHRcdH1cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0LyogR2V0cyB0aGUgYGNvbnRlbnQuc2VsZWN0T3B0aW9uc2AgZnJvbSB0aGUgYGNvbnRlbnQudmFsdWVgIGZpZWxkLiAqL1xuXG5cdFx0XHRcdGlmIChpc0FycmF5KHRoaXMuY29udGVudC52YWx1ZSkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLmNvbnRlbnQubXVsdGlwbGUgPSB0cnVlOyAgLyogVGhlIGNvbnRyb2wgbXVzdCBiZSBtdWx0aXBsZS4gKi9cblx0XHRcdFx0XHR0aGlzLmNvbnRlbnQuc2VsZWN0T3B0aW9ucyA9IFsgXTtcblxuXHRcdFx0XHRcdHRoaXMuY29udGVudC52YWx1ZS5mb3JFYWNoKFxuXHRcdFx0XHRcdFx0KG9wdGlvbjogc3RyaW5nKTogdm9pZCA9PiB7XG5cdFx0XHRcdFx0XHRcdCh0aGlzLmNvbnRlbnQuc2VsZWN0T3B0aW9ucyBhcyBTZWxlY3RPcHRpb25bXSkucHVzaCh7XG5cdFx0XHRcdFx0XHRcdFx0J2xhYmVsJzogb3B0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdCd2YWx1ZSc6IG9wdGlvbi50b1VwcGVyQ2FzZSgpXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5jb250ZW50LnNlbGVjdE9wdGlvbnMgPSBbXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdCdsYWJlbCc6IHRoaXMuY29udGVudC52YWx1ZSxcblx0XHRcdFx0XHRcdFx0J3ZhbHVlJzogdGhpcy5jb250ZW50LnZhbHVlLnRvVXBwZXJDYXNlKClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2UgaWYgKGlzQXJyYXkodGhpcy5jb250ZW50LnNlbGVjdE9wdGlvbnMpKVxuXHRcdHtcblx0XHRcdC8qIE5vdGhpbmcgdG8gZG8gaGVyZSwgYnV0IHRoaXMgY2FzZSBtdXN0IGJlIGhlcmUuICovXG5cdFx0fVxuXHRcdGVsc2UgaWYgKHRoaXMuY29udGVudC5zZWxlY3RPcHRpb25zIGluc3RhbmNlb2YgT2JzZXJ2YWJsZSlcblx0XHR7XG5cdFx0XHQvKiBHZXRzIHRoZSBgY29udGVudC5zZWxlY3RPcHRpb25zYCBmcm9tIGFuIGBPYnNlcnZhYmxlYCB3aGVuIGl0IGVtaXRzIHZhbHVlcy4gKi9cblxuXHRcdFx0dGhpcy5fc2VsZWN0T3B0aW9uc19VbnN1YnNjcmlwdGlvbigpO1xuXG5cdFx0XHR0aGlzLl9zZWxlY3RPcHRpb25zU3Vic2NyaXB0aW9uID0gdGhpcy5jb250ZW50LnNlbGVjdE9wdGlvbnMuc3Vic2NyaWJlKFxuXHRcdFx0XHQoc2VsZWN0T3B0aW9uczogU2VsZWN0T3B0aW9uW10pOiB2b2lkID0+IHtcblx0XHRcdFx0XHR0aGlzLmNvbnRlbnQuc2VsZWN0T3B0aW9ucyA9IHNlbGVjdE9wdGlvbnM7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoYEZvciB0aGUgJyR7IElucHV0U2VsZWN0Q29tcG9uZW50Lm5hbWUgfScgY29udHJvbCwgdGhlICdjb250ZW50LnNlbGVjdE9wdGlvbnMnIHR5cGUgdmFsdWUgaGFzIGEgY29uZmlndXJhdGlvbiBlcnJvciBiZWNhdXNlIHRoZSBwcm9ncmFtbWUgZG9lcyBub3Qga25vdyB3aGF0IHRvIGRvIHdpdGggaXQhYCk7XG5cdFx0fVxuXG5cdFx0LyogVGhlIGBzZWxlY3RUb29sdGlwYCB2YWx1ZSBpcyBzZXQgaW4gYG9uU2VsZWN0aW9uQ2hhbmdlYCBtZXRob2Qgd2hlbiBoYXBwZW5pbmcgaW5pdGlhbGl6YXRpb24gb3Igc2VsZWN0aW9uIGNoYW5nZS4gKi9cblx0fVxuXHRcblx0cHJpdmF0ZSBfc2VsZWN0T3B0aW9uc19VbnN1YnNjcmlwdGlvbigpOiB2b2lkXG5cdHtcblx0XHQvKiBEaXNwb3NlcyB0aGUgcmVzb3VyY2VzIGhlbGQgYnkgdGhlIHN1YnNjcmlwdGlvbi4gKi9cblx0XHRpZiAodGhpcy5fc2VsZWN0T3B0aW9uc1N1YnNjcmlwdGlvbilcblx0XHR7XG5cdFx0XHR0aGlzLl9zZWxlY3RPcHRpb25zU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG5cdFx0fVxuXHR9XG5cblx0cHVibGljIG9uU2VsZWN0aW9uQ2hhbmdlKCk6IHZvaWRcblx0e1xuXHRcdC8vIGNvbnNvbGUubG9nKCdDYWxsIGBvblNlbGVjdGlvbkNoYW5nZWAgLSAnLCAnU2VsZWN0IHZhbHVlOiAnLCB0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wudmFsdWUpO1xuXG5cdFx0dGhpcy5fc2V0U2VsZWN0VG9vbHRpcCgpO1xuXG5cdFx0aWYgKCh0aGlzLmNvbnRlbnQuZXh0cmFDb250ZW50KSAmJiAodGhpcy5jb250ZW50LmV4dHJhQ29udGVudC5zZWxlY3Rpb25DaGFuZ2UpKVxuXHRcdHtcblx0XHRcdHRoaXMuY29udGVudC5leHRyYUNvbnRlbnQuc2VsZWN0aW9uQ2hhbmdlKHRoaXMuY29udGVudC5mb3JtQ29udHJvbC52YWx1ZSk7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIERvZXMgdGhlIHRyYW5zbGF0aW9uIGZvciBhIGtleSAob3IgYW4gYXJyYXkgb2Yga2V5cykuIFxuXHQgKiBAcGFyYW0ga2V5IFRoZSBrZXkgKG9yIGFuIGFycmF5IG9mIGtleXMpIHRvIHRyYW5zbGF0ZS4gXG5cdCAqL1xuXHRwcml2YXRlIF9kb1RyYW5zbGF0aW9uKGtleTogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPik6IHZvaWRcblx0e1xuXHRcdGlmIChrZXkubGVuZ3RoID09IDApXG5cdFx0e1xuXHRcdFx0dGhpcy5zZWxlY3RUb29sdGlwID0gJyc7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fdHJhbnNTZXJ2LmdldChrZXkpLnN1YnNjcmliZSgocmVzOiBhbnkpID0+IHtcblx0XHRcdC8vIGNvbnNvbGUubG9nKGtleSwgJyAtLT4gJywgcmVzKTtcblxuXHRcdFx0aWYgKHRoaXMuY29udGVudC5tdWx0aXBsZSlcblx0XHRcdHtcblx0XHRcdFx0LyogYHJlc2AgaXMgYW4gb2JqZWN0IG9mIHRyYW5zbGF0ZWQga2V5cy4gKi9cblxuXHRcdFx0XHRsZXQgdHJhbnNsYXRpb25LZXlzOiBzdHJpbmdbXSA9IE9iamVjdC5rZXlzKHJlcyk7XG5cdFx0XHRcdGxldCBsZW46IG51bWJlciA9IHRyYW5zbGF0aW9uS2V5cy5sZW5ndGg7XG5cblx0XHRcdFx0bGV0IHRyYW5zbGF0aW9uUmVzOiBzdHJpbmcgPSByZXNbdHJhbnNsYXRpb25LZXlzWzBdXTtcblxuXHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IGxlbjsgKytpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dHJhbnNsYXRpb25SZXMgKz0gJ1xcbicgKyByZXNbdHJhbnNsYXRpb25LZXlzW2ldXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMuc2VsZWN0VG9vbHRpcCA9IHRyYW5zbGF0aW9uUmVzO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHQvKiBgcmVzYCBpcyBhIHRyYW5zbGF0ZWQga2V5LiAqL1xuXG5cdFx0XHRcdHRoaXMuc2VsZWN0VG9vbHRpcCA9IHJlcztcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBGaW5kcyB0aGUgbGFiZWwgZm9yIGEgdmFsdWUgKG9yIGFuIGFycmF5IG9mIHZhbHVlcykuIFxuXHQgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIChvciBhbiBhcnJheSBvZiB2YWx1ZXMpIHRvIGZpbmQgdGhlIGxhYmVsLiBcblx0ICogQHJldHVybnMgUmV0dXJucyBhIGxhYmVsIChvciBhbiBhcnJheSBvZiBsYWJlbHMpLiBcblx0ICovXG5cdHByaXZhdGUgX2ZpbmRMYWJlbCh2YWx1ZTogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPik6IHN0cmluZyB8IEFycmF5PHN0cmluZz5cblx0e1xuXHRcdGlmICh0aGlzLmNvbnRlbnQubXVsdGlwbGUpXG5cdFx0e1xuXHRcdFx0bGV0IGxhYmVsOiBBcnJheTxzdHJpbmc+ID0gWyBdO1xuXG5cdFx0XHRmb3IgKGxldCB2YWwgb2YgdmFsdWUpXG5cdFx0XHR7XG5cdFx0XHRcdGZvciAobGV0IG9wdCBvZiAodGhpcy5jb250ZW50LnNlbGVjdE9wdGlvbnMgYXMgU2VsZWN0T3B0aW9uW10pKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKG9wdC52YWx1ZSA9PSB2YWwpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0bGFiZWwucHVzaChvcHQubGFiZWwpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBsYWJlbDtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGxldCBsYWJlbDogc3RyaW5nID0gJyc7XG5cblx0XHRcdGZvciAobGV0IG9wdCBvZiAodGhpcy5jb250ZW50LnNlbGVjdE9wdGlvbnMgYXMgU2VsZWN0T3B0aW9uW10pKVxuXHRcdFx0e1xuXHRcdFx0XHRpZiAob3B0LnZhbHVlID09IHZhbHVlKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGFiZWwgPSBvcHQubGFiZWw7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGxhYmVsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBgc2VsZWN0VG9vbHRpcGAgZmllbGQgdmFsdWUuIFxuXHQgKi9cblx0cHJpdmF0ZSBfc2V0U2VsZWN0VG9vbHRpcCgpOiB2b2lkXG5cdHtcblx0XHRpZiAodGhpcy5jb250ZW50LmZvcm1Db250cm9sLnZhbHVlICE9IHVuZGVmaW5lZClcblx0XHR7XG5cdFx0XHR0aGlzLl9kb1RyYW5zbGF0aW9uKHRoaXMuX2ZpbmRMYWJlbCh0aGlzLmNvbnRlbnQuZm9ybUNvbnRyb2wudmFsdWUpKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuc2VsZWN0VG9vbHRpcCA9ICcnO1xuXHRcdH1cblx0fVxufVxuIl19