/**
 * @fileoverview added by tsickle
 * Generated from: lib/forms/form-field.control.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 *   Copyright (c) 2020 Universidad de Pinar del Río "Hermanos Saíz Montes de Oca"
 *   All rights reserved.
 */
import { Input } from '@angular/core';
import { FormGroup, FormArray, FormControl } from '@angular/forms';
import { IconService } from '../core/services/icon.service';
/** @enum {string} */
const TextAlign = {
    /**
     * The inline contents are aligned to the left edge of the line box. In vertical text,
     * `left` aligns to the edge of the line box that would be the start edge for left-to-right text.
     */
    left: "left",
    /**
     * The inline contents are centered within the line box.
     */
    center: "center",
    /**
     * The inline contents are aligned to the right edge of the line box. In vertical text,
     * `right` aligns to the edge of the line box that would be the end edge for left-to-right text.
     */
    right: "right",
    /**
     * The text is justified.
     */
    justify: "justify",
};
export { TextAlign };
/** @enum {string} */
const ContentPosition = {
    /**
     * Adding the `prefix` option to an element will designate it as the prefix.
     */
    prefix: "matPrefix",
    /**
     * Adding the `suffix` option to an element will designate it as the suffix.
     */
    suffix: "matSuffix",
    /**
     * Adding the `none` option to an element will not show it.
     */
    none: "none",
};
export { ContentPosition };
/** @enum {string} */
const IconSource = {
    /**
     * The icon is obtained from an internal source. In this case, it uses an icon that was copied to
     * the 'assets' folder of the project, and it was registered using the `IconService.registerIcons` method.
     */
    internal: "internal",
    /**
     * The icon is obtained from an external source. In this case,
     * it uses a 'Material Icon' from 'https://fonts.googleapis.com/icon?family=Material+Icons'.
     */
    external: "external",
};
export { IconSource };
/**
 * Data structure for holding an icon.
 */
export class IconValue {
    /**
     * Creates a new instance of the `IconValue` class.
     * @param {?=} s The icon source type. By default, its value is `IconSource.internal`.
     * @param {?=} p The icon position type. By default, its value is `ContentPosition.prefix`.
     * @param {?=} n The icon name. By default, its value is `IconService.defaultIconName`.
     */
    constructor(s = IconSource.internal, p = ContentPosition.prefix, n = IconService.defaultIconName) {
        this.source = s;
        this.position = p;
        this.name = n;
        this.setDefaultValueIfUndefined();
    }
    /**
     * Sets the default value for each undefined value.
     * @return {?}
     */
    setDefaultValueIfUndefined() {
        if (this.source == undefined)
            this.source = IconSource.internal;
        if (this.position == undefined)
            this.position = ContentPosition.prefix;
        if (this.name == undefined)
            this.name = IconService.defaultIconName;
    }
    /**
     * Sets the default value for each undefined value, but the icon position is always set to the specified value.
     * @param {?} iconPosition The icon position to set.
     * @return {?}
     */
    setDefaultValueIfUndefined_setPosition(iconPosition) {
        if (this.source == undefined)
            this.source = IconSource.internal;
        this.position = iconPosition;
        if (this.name == undefined)
            this.name = IconService.defaultIconName;
    }
}
if (false) {
    /**
     * Returns the icon source type.
     * By default, its value is `IconSource.internal`.
     * @type {?}
     */
    IconValue.prototype.source;
    /**
     * Returns the icon position type.
     * By default, its value is `ContentPosition.prefix`.
     * @type {?}
     */
    IconValue.prototype.position;
    /**
     * Returns the icon name.
     * By default, its value is `IconService.defaultIconName`.
     * @type {?}
     */
    IconValue.prototype.name;
}
/** @enum {string} */
const HintPosition = {
    /**
     * Adding the `start` option to a `HintValue` will designate it as start-aligned.
     */
    start: "start",
    /**
     * Adding the `end` option to a `HintValue` will designate it as end-aligned.
     */
    end: "end",
    /**
     * Adding the `none` option to a `HintValue` will not show it.
     */
    none: "none",
};
export { HintPosition };
/**
 * Data structure for holding a hint.
 * A hint label is additional descriptive text that appears below the control's underline.
 */
export class HintValue {
    /**
     * Creates a new instance of the `HintValue` class.
     * @param {?=} p The hint position type. By default, its value is `HintPosition.none`.
     * @param {?=} l The hint label. By default, its value is `''`.
     */
    constructor(p = HintPosition.none, l = '') {
        this.position = p;
        this.label = l;
        this.setDefaultValueIfUndefined();
    }
    /**
     * Sets the default value for each undefined value.
     * @return {?}
     */
    setDefaultValueIfUndefined() {
        if (this.position == undefined)
            this.position = HintPosition.none;
        if (this.label == undefined)
            this.label = '';
    }
    /**
     * Sets the default value for each undefined value, but the hint position is always set to the specified value.
     * @param {?} hintPosition The hint position to set.
     * @return {?}
     */
    setDefaultValueIfUndefined_setPosition(hintPosition) {
        this.position = hintPosition;
        if (this.label == undefined)
            this.label = '';
    }
}
if (false) {
    /**
     * Returns the hint position type.
     * By default, its value is `HintPosition.none`.
     * @type {?}
     */
    HintValue.prototype.position;
    /**
     * Returns the hint label.
     * By default, its value is `''`.
     * @type {?}
     */
    HintValue.prototype.label;
}
/** @enum {string} */
const FormFieldType = {
    /** A button control. */
    action_button: "action_button",
    /** A container control that is showed as a panel. */
    container_panel: "container_panel",
    /** A container control that is showed very simple. */
    container_simple: "container_simple",
    /** A container control that allows the writing of a name of something in different language. */
    container_label_diff_lang: "container_label_diff_lang",
    /** A text control. */
    text: "text",
    /** A textarea control. */
    textarea: "textarea",
    /** A datapicker control. */
    datepicker: "datepicker",
    /** A checkbox control. */
    checkbox: "checkbox",
    /** A url control. */
    url: "url",
    /** An email control. */
    email: "email",
    /** An identifier control. */
    identifier: "identifier",
    /** An issn control. */
    issn: "issn",
    /** A rnps control. */
    rnps: "rnps",
    /** A vocabulary control. */
    vocabulary: "vocabulary",
    vocabulary_tree: "toco-vocabulary-tree",
    /** A term parent control. */
    term_parent: "term_parent",
    /** A select control. */
    select: "select",
    /** A select control. */
    select_expr: "select_expr",
    /** A select with a filter control. */
    select_filter: "select_filter",
    /** A select with a filter control. */
    select_tree: "select_tree",
};
export { FormFieldType };
/**
 * A base interface that represents the content of a `FormFieldControl`.
 * @record
 */
export function FormFieldContent() { }
if (false) {
    /**
     * Returns the parent `ContainerControl` of this control.
     * It is always set internally.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.parentContainerControl;
    /**
     * Returns the parent `FormSection` that represents the parent `FormGroup` or `FormArray` of this control.
     * It is always set internally.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.parentFormSection;
    /**
     * Returns the control's minimum width.
     * The minimum width of the content area, padding area or border area (depending on `box-sizing`)
     * of certain boxes. Allows authors to constrain content width to a centain range.
     * By default, its value is `'15em'`.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.minWidth;
    /**
     * Returns the control's width.
     * The width of the content area, padding area or border area (depending on `box-sizing`) of certain boxes.
     * By default, its value is `minWidth`.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.width;
    /**
     * Returns the control's label.
     * See the `ContainerContent` for the particular interpretation of this field.
     * See the `ActionContent` for the particular interpretation of this field.
     * By default, its value is `''`. Each control sets its own label.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.label;
    /**
     * Returns the control's placeholder.
     * By default, its value is `''`. Each control sets its own placeholder.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.placeholder;
    /**
     * Returns true if the control is required; otherwise, false.
     * See the `ContainerContent` for the particular interpretation of this field.
     * By default, its value is `false`.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.required;
    /**
     * Returns the control's text align.
     * By default, its value is `TextAlign.left`.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.textAlign;
    /**
     * Returns the control's aria-label.
     * Defines a string value that labels the current element.
     * By default, its value is `'Text Input'`. Each control sets its own aria-label.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.ariaLabel;
    /**
     * The control's value.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.value;
    /**
     * This `type` field is deprecated, you must use the `controlType` field.
     * Returns the control's type that is used to create the control.
     * Implementation notes:
     *  - It must be specified; otherwise, an exception is thrown.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.type;
    /**
     * Returns the control's type that is used to create the control.
     * Implementation notes:
     *  - It must be specified; otherwise, an exception is thrown.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.controlType;
    /**
     * Returns the control's name that is used to save the control's value as a name/value pair.
     * Implementation notes:
     *  - It can be used with a JSON string.
     *  - It must be specified; otherwise, an exception is thrown.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.name;
    /**
     * The control's extra content. For any other content needed by an specific `FormFieldControl`.
     * By default, its value is `undefined`.
     * @type {?|undefined}
     */
    FormFieldContent.prototype.extraContent;
}
/**
 * Returns a new object that represents the clone of the specified `FormControl` target.
 * @param {?} target The `FormControl` object to clone.
 * @return {?}
 */
export function cloneFormControl(target) {
    return new FormControl(target.value, target.validator, target.asyncValidator);
}
/**
 * Returns a new object that represents the clone of the specified `FormSection` target.
 * @param {?} target The `FormSection` object to clone.
 * @return {?}
 */
export function cloneFormSection(target) {
    if (target instanceof FormGroup) {
        /* Creates an empty `FormGroup` with its validators. */
        /** @type {?} */
        let result = new FormGroup({}, target.validator, target.asyncValidator);
        /* Adds the controls to `FormGroup`. */
        for (let ctr in target.controls) {
            if ((target.controls[ctr]) instanceof FormControl)
                result.addControl(ctr, cloneFormControl((/** @type {?} */ ((target.controls[ctr])))));
            else
                result.addControl(ctr, cloneFormSection((/** @type {?} */ ((target.controls[ctr])))));
        }
        return result;
    }
    else {
        /* Creates an empty `FormArray` with its validators. */
        /** @type {?} */
        let result = new FormArray([], target.validator, target.asyncValidator);
        /* Adds the controls to the `FormArray`. */
        for (let ctr of target.controls) {
            if (ctr instanceof FormControl)
                result.push(cloneFormControl(ctr));
            else
                result.push(cloneFormSection((/** @type {?} */ (ctr))));
        }
        return result;
    }
}
/**
 * Represents the base abstract class for a control that is treated as a form field.
 * @abstract
 */
export class FormFieldControl {
    /**
     * Constructs a new instance of this class.
     */
    constructor() {
        this.contentPosition = ContentPosition;
        this.iconSource = IconSource;
        /* It must be initialize. */
        this.content = undefined;
        this.isTranslationBuiltByControl = false;
    }
    /**
     * Sets the new language.
     * @protected
     * @param {?} transServ The `TranslateService` instance injected.
     * @return {?}
     */
    setNewLanguage(transServ) {
        /* The `FormFieldControl.currentLang != transServ.currentLang` test is NOT necessary here because it is done in the non-abstract child classes. */
        FormFieldControl.currentLang = transServ.currentLang;
    }
    /**
     * Initializes the `content` input property.
     * @protected
     * @param {?} label The default label to use. It is used if the `content.label` is not specified.
     * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
     * @return {?}
     */
    init(label, placeholder = '') {
        /* Sets the default values. */
        if (this.content == undefined) {
            throw new Error(`For the '${FormFieldControl.name}' control, the 'content' value can not be undefined.`);
        }
        if (this.content.name == undefined) {
            throw new Error(`For the '${FormFieldControl.name}' control, the 'content.name' value can not be undefined.`);
        }
        if (this.content.controlType == undefined) {
            throw new Error(`For the '${this.content.name}' control, the 'content.controlType' value can not be undefined.`);
        }
        if (label == undefined) {
            if (this.content.label == undefined) {
                throw new Error(`For the '${this.content.name}' control, the 'content.label' value can not be undefined. \n
                    You can specify: \n
                    - A default label value when overwriting the 'init' method in the component that represents the control. \n
                    - A label value when defining the content object for the control.`);
            }
            label = this.content.label;
        }
        else {
            if (this.content.label) {
                label = this.content.label;
            }
        }
        /************************** `mat-form-field` properties. **************************/
        if (this.content.minWidth == undefined)
            this.content.minWidth = '15em';
        if (this.content.width == undefined)
            this.content.width = this.content.minWidth;
        /**************************** `mat-label` properties. *****************************/
        if (this.content.label == undefined)
            this.content.label = label;
        if (this.content.placeholder == undefined)
            this.content.placeholder = placeholder;
        /************************** Internal control properties. **************************/
        if (this.content.textAlign == undefined)
            this.content.textAlign = TextAlign.left;
        if (this.content.ariaLabel == undefined)
            this.content.ariaLabel = label;
        if (this.content.value != undefined) /* It does not set the default value here (does not call `getDefaultValue` method here) because in this way it is more consistent. */ {
            /* It also checks if the specified `content.value` is correct. */
            this.initValue();
        }
        /******************************* Other properties. ********************************/
    }
    /**
     * Returns the parent `ContainerControl` of this control.
     * It is always set internally.
     * @return {?}
     */
    get parentContainerControl() {
        return this.content.parentContainerControl;
    }
    /**
     * Adds the specified `control`/`internalControl` as a child
     * to the `content.containerControlChildren`/`content.parentFormSection` respectively.
     * @protected
     * @param {?} control Form control to be added (descendant from `FormFieldControl`).
     * @param {?} internalControl Internal form control to be added (`FormControl`, `FormGroup`, or `FormArray`).
     * @return {?}
     */
    addAsChildControl(control, internalControl) {
        /* Adds the specified `control` as a child to the `content.containerControlChildren`. */
        this.content.parentContainerControl.content.containerControlChildren.push(control);
        /* Adds the specified `internalControl` as a child to the `content.parentFormSection`. */
        if (this.content.parentContainerControl.isFormArray) /* `content.parentFormSection` is an instance of `FormArray`. */ {
            /* The `internalControl`'s name is already correct, that is,
            `content.name` equals the `content.parentFormSection`'s last position
            (because the `internalControl` has a `FormArray` as its parent). */
            ((/** @type {?} */ (this.content.parentFormSection))).push(internalControl);
        }
        else /* `content.parentFormSection` is an instance of `FormGroup`. */ {
            ((/** @type {?} */ (this.content.parentFormSection))).addControl(this.content.name, internalControl);
        }
    }
    /**
     * Returns true if the specified `IconValue` has the specified `ContentPosition` value; otherwise, false.
     * @param {?} icon The `IconValue` to check.
     * @param {?} contentPosition The `ContentPosition` value to check.
     * @return {?}
     */
    iconPositionState(icon, contentPosition) {
        return (icon.position == contentPosition);
    }
    /**
     * Returns true if the specified `IconValue` has the specified `IconSource` value; otherwise, false.
     * @param {?} icon The `IconValue` to check.
     * @param {?} iconSource The `IconSource` value to check.
     * @return {?}
     */
    iconSourceState(icon, iconSource) {
        return (icon.source == iconSource);
    }
}
/**
 * Returns the language currently used.
 * This is a static field.
 */
FormFieldControl.currentLang = '';
FormFieldControl.propDecorators = {
    content: [{ type: Input }]
};
if (false) {
    /**
     * Returns the language currently used.
     * This is a static field.
     * @type {?}
     * @protected
     */
    FormFieldControl.currentLang;
    /**
     * Represents the `ContentPosition` enum for internal use.
     * @type {?}
     */
    FormFieldControl.prototype.contentPosition;
    /**
     * Represents the `IconSource` enum for internal use.
     * @type {?}
     */
    FormFieldControl.prototype.iconSource;
    /**
     * Input field that contains the content of this class.
     * @type {?}
     */
    FormFieldControl.prototype.content;
    /**
     * Returns true if the translation is built by the control; otherwise, false.
     * It is used to select the way the translation is built for the control.
     * By default, its value is `false`.
     * As an example of usage for this field, the `InputNumberComponent` class implements the logic when this value is `true`.
     * @type {?}
     */
    FormFieldControl.prototype.isTranslationBuiltByControl;
    /**
     * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
     * It also checks if the specified `content.value` is correct. For internal use only.
     * @abstract
     * @protected
     * @return {?}
     */
    FormFieldControl.prototype.initValue = function () { };
    /**
     * Returns this instance.
     * @abstract
     * @return {?}
     */
    FormFieldControl.prototype.getInstance = function () { };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1maWVsZC5jb250cm9sLmpzIiwic291cmNlUm9vdCI6Im5nOi8vdG9jby1saWIvIiwic291cmNlcyI6WyJsaWIvZm9ybXMvZm9ybS1maWVsZC5jb250cm9sLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQU1BLE9BQU8sRUFBRSxLQUFLLEVBQVEsTUFBTSxlQUFlLENBQUM7QUFDNUMsT0FBTyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQW1CLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSXBGLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQzs7QUFtQjVELE1BQVksU0FBUztJQUVqQjs7O09BR0c7SUFDSCxJQUFJLFFBQVM7SUFFYjs7T0FFRztJQUNILE1BQU0sVUFBVztJQUVqQjs7O09BR0c7SUFDSCxLQUFLLFNBQVU7SUFFZjs7T0FFRztJQUNILE9BQU8sV0FBWTtFQUN0Qjs7O0FBS0QsTUFBWSxlQUFlO0lBRXZCOztPQUVHO0lBQ0gsTUFBTSxhQUFjO0lBRXBCOztPQUVHO0lBQ0gsTUFBTSxhQUFjO0lBRXBCOztPQUVHO0lBQ0gsSUFBSSxRQUFTO0VBQ2hCOzs7QUFLRCxNQUFZLFVBQVU7SUFFbEI7OztPQUdHO0lBQ0gsUUFBUSxZQUFhO0lBRXJCOzs7T0FHRztJQUNILFFBQVEsWUFBYTtFQUN4Qjs7Ozs7QUFLRCxNQUFNLE9BQU8sU0FBUzs7Ozs7OztJQTBCbEIsWUFDSSxJQUFnQixVQUFVLENBQUMsUUFBUSxFQUNuQyxJQUFxQixlQUFlLENBQUMsTUFBTSxFQUMzQyxJQUFZLFdBQVcsQ0FBQyxlQUFlO1FBRXZDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ2hCLElBQUksQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDO1FBQ2xCLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO1FBRWQsSUFBSSxDQUFDLDBCQUEwQixFQUFFLENBQUM7SUFDdEMsQ0FBQzs7Ozs7SUFLTSwwQkFBMEI7UUFF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TyxDQUFDLElBQUksRUFBRSxlQUFlLENBQUMsQ0FBQztTQUNoRztJQUNSLENBQUM7Ozs7Ozs7SUFPUyxpQkFBaUIsQ0FBQyxJQUFlLEVBQUUsZUFBZ0M7UUFFdEUsT0FBTyxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksZUFBZSxDQUFDLENBQUM7SUFDOUMsQ0FBQzs7Ozs7OztJQU9NLGVBQWUsQ0FBQyxJQUFlLEVBQUUsVUFBc0I7UUFFMUQsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLElBQUksVUFBVSxDQUFDLENBQUM7SUFDdkMsQ0FBQzs7Ozs7O0FBcktnQiw0QkFBVyxHQUFXLEVBQUUsQ0FBQzs7c0JBUHpDLEtBQUs7Ozs7Ozs7OztJQU9OLDZCQUEwQzs7Ozs7SUFqQjFDLDJDQUF3RDs7Ozs7SUFLeEQsc0NBQThDOzs7OztJQUs5QyxtQ0FDaUM7Ozs7Ozs7O0lBY2pDLHVEQUE0Qzs7Ozs7Ozs7SUErRjVDLHVEQUFxQzs7Ozs7O0lBS3JDLHlEQUFvRCIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiAgIENvcHlyaWdodCAoYykgMjAyMCBVbml2ZXJzaWRhZCBkZSBQaW5hciBkZWwgUsOtbyBcIkhlcm1hbm9zIFNhw616IE1vbnRlcyBkZSBPY2FcIlxuICogICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICovXG5cblxuaW1wb3J0IHsgSW5wdXQsIFR5cGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEZvcm1Hcm91cCwgRm9ybUFycmF5LCBBYnN0cmFjdENvbnRyb2wsIEZvcm1Db250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0IHsgVHJhbnNsYXRlU2VydmljZSB9IGZyb20gJ0BuZ3gtdHJhbnNsYXRlL2NvcmUnO1xuXG5pbXBvcnQgeyBQYXJhbXMgfSBmcm9tICcuLi9jb3JlL3V0aWxzL2hlbHBlcnMnO1xuaW1wb3J0IHsgSWNvblNlcnZpY2UgfSBmcm9tICcuLi9jb3JlL3NlcnZpY2VzL2ljb24uc2VydmljZSc7XG5cbmltcG9ydCB7IENvbnRhaW5lckNvbnRyb2wgfSBmcm9tICcuL2NvbnRhaW5lci9jb250YWluZXIuY29udHJvbCc7XG5cbi8qKlxuICogRGVmaW5lcyBhIGZvcm0gc2VjdGlvbiB0aGF0IHJlcHJlc2VudHMgdGhlIGBGb3JtR3JvdXBgIG9yIGBGb3JtQXJyYXlgIGNsYXNzLiBcbiAqL1xuZXhwb3J0IHR5cGUgRm9ybVNlY3Rpb24gPSBGb3JtR3JvdXAgfCBGb3JtQXJyYXk7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGtleS92YWx1ZSBlbGVtZW50cywgd2hlcmUgdGhlIGtleSBpcyB0aGUgdmFsaWRhdG9yIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgdmFsdWUgXG4gKiB0aGF0IHRoZSB2YWxpZGF0b3IgbmVlZHMgdG8gY2hlY2suIFxuICovXG4gZXhwb3J0IHR5cGUgVmFsaWRhdG9yQXJndW1lbnRzID0gUGFyYW1zPGFueT47XG5cbi8qKlxuICogQW4gZW51bSB0aGF0IGRlc2NyaWJlcyBob3cgaW5saW5lIGNvbnRlbnRzIG9mIGEgYmxvY2sgYXJlIGhvcml6b250YWxseSBhbGlnbmVkIGlmIHRoZSBjb250ZW50cyBcbiAqIGRvIG5vdCBjb21wbGV0ZWx5IGZpbGwgdGhlIGxpbmUgYm94LiBcbiAqL1xuZXhwb3J0IGVudW0gVGV4dEFsaWduXG57XG4gICAgLyoqXG4gICAgICogVGhlIGlubGluZSBjb250ZW50cyBhcmUgYWxpZ25lZCB0byB0aGUgbGVmdCBlZGdlIG9mIHRoZSBsaW5lIGJveC4gSW4gdmVydGljYWwgdGV4dCwgXG4gICAgICogYGxlZnRgIGFsaWducyB0byB0aGUgZWRnZSBvZiB0aGUgbGluZSBib3ggdGhhdCB3b3VsZCBiZSB0aGUgc3RhcnQgZWRnZSBmb3IgbGVmdC10by1yaWdodCB0ZXh0LiBcbiAgICAgKi9cbiAgICBsZWZ0ID0gJ2xlZnQnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGlubGluZSBjb250ZW50cyBhcmUgY2VudGVyZWQgd2l0aGluIHRoZSBsaW5lIGJveC4gXG4gICAgICovXG4gICAgY2VudGVyID0gJ2NlbnRlcicsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5saW5lIGNvbnRlbnRzIGFyZSBhbGlnbmVkIHRvIHRoZSByaWdodCBlZGdlIG9mIHRoZSBsaW5lIGJveC4gSW4gdmVydGljYWwgdGV4dCwgXG4gICAgICogYHJpZ2h0YCBhbGlnbnMgdG8gdGhlIGVkZ2Ugb2YgdGhlIGxpbmUgYm94IHRoYXQgd291bGQgYmUgdGhlIGVuZCBlZGdlIGZvciBsZWZ0LXRvLXJpZ2h0IHRleHQuIFxuICAgICAqL1xuICAgIHJpZ2h0ID0gJ3JpZ2h0JyxcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IGlzIGp1c3RpZmllZC4gXG4gICAgICovXG4gICAganVzdGlmeSA9ICdqdXN0aWZ5J1xufVxuXG4vKipcbiAqIEFuIGVudW0gdGhhdCByZXByZXNlbnRzIHRoZSBjb250ZW50IHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgaW5zaWRlIG9mIGEgYEZvcm1GaWVsZENvbnRyb2xgLiBcbiAqL1xuZXhwb3J0IGVudW0gQ29udGVudFBvc2l0aW9uXG57XG4gICAgLyoqXG4gICAgICogQWRkaW5nIHRoZSBgcHJlZml4YCBvcHRpb24gdG8gYW4gZWxlbWVudCB3aWxsIGRlc2lnbmF0ZSBpdCBhcyB0aGUgcHJlZml4LiBcbiAgICAgKi9cbiAgICBwcmVmaXggPSAnbWF0UHJlZml4JyxcblxuICAgIC8qKlxuICAgICAqIEFkZGluZyB0aGUgYHN1ZmZpeGAgb3B0aW9uIHRvIGFuIGVsZW1lbnQgd2lsbCBkZXNpZ25hdGUgaXQgYXMgdGhlIHN1ZmZpeC4gXG4gICAgICovXG4gICAgc3VmZml4ID0gJ21hdFN1ZmZpeCcsXG5cbiAgICAvKipcbiAgICAgKiBBZGRpbmcgdGhlIGBub25lYCBvcHRpb24gdG8gYW4gZWxlbWVudCB3aWxsIG5vdCBzaG93IGl0LiBcbiAgICAgKi9cbiAgICBub25lID0gJ25vbmUnXG59XG5cbi8qKlxuICogQW4gZW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIGljb24gc291cmNlIHR5cGUuIFxuICovXG5leHBvcnQgZW51bSBJY29uU291cmNlXG57XG4gICAgLyoqXG4gICAgICogVGhlIGljb24gaXMgb2J0YWluZWQgZnJvbSBhbiBpbnRlcm5hbCBzb3VyY2UuIEluIHRoaXMgY2FzZSwgaXQgdXNlcyBhbiBpY29uIHRoYXQgd2FzIGNvcGllZCB0byBcbiAgICAgKiB0aGUgJ2Fzc2V0cycgZm9sZGVyIG9mIHRoZSBwcm9qZWN0LCBhbmQgaXQgd2FzIHJlZ2lzdGVyZWQgdXNpbmcgdGhlIGBJY29uU2VydmljZS5yZWdpc3Rlckljb25zYCBtZXRob2QuIFxuICAgICAqL1xuICAgIGludGVybmFsID0gJ2ludGVybmFsJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBpY29uIGlzIG9idGFpbmVkIGZyb20gYW4gZXh0ZXJuYWwgc291cmNlLiBJbiB0aGlzIGNhc2UsIFxuICAgICAqIGl0IHVzZXMgYSAnTWF0ZXJpYWwgSWNvbicgZnJvbSAnaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9pY29uP2ZhbWlseT1NYXRlcmlhbCtJY29ucycuIFxuICAgICAqL1xuICAgIGV4dGVybmFsID0gJ2V4dGVybmFsJ1xufVxuXG4vKipcbiAqIERhdGEgc3RydWN0dXJlIGZvciBob2xkaW5nIGFuIGljb24uIFxuICovXG5leHBvcnQgY2xhc3MgSWNvblZhbHVlXG57XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaWNvbiBzb3VyY2UgdHlwZS4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBJY29uU291cmNlLmludGVybmFsYC4gXG4gICAgICovXG4gICAgcHVibGljIHNvdXJjZTogSWNvblNvdXJjZTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGljb24gcG9zaXRpb24gdHlwZS4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBDb250ZW50UG9zaXRpb24ucHJlZml4YC4gXG4gICAgICovXG4gICAgcHVibGljIHBvc2l0aW9uOiBDb250ZW50UG9zaXRpb247XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpY29uIG5hbWUuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgSWNvblNlcnZpY2UuZGVmYXVsdEljb25OYW1lYC4gXG4gICAgICovXG4gICAgcHVibGljIG5hbWU6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBJY29uVmFsdWVgIGNsYXNzLiBcbiAgICAgKiBAcGFyYW0gcyBUaGUgaWNvbiBzb3VyY2UgdHlwZS4gQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBJY29uU291cmNlLmludGVybmFsYC4gXG4gICAgICogQHBhcmFtIHAgVGhlIGljb24gcG9zaXRpb24gdHlwZS4gQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBDb250ZW50UG9zaXRpb24ucHJlZml4YC4gXG4gICAgICogQHBhcmFtIG4gVGhlIGljb24gbmFtZS4gQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBJY29uU2VydmljZS5kZWZhdWx0SWNvbk5hbWVgLiBcbiAgICAgKi9cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoXG4gICAgICAgIHM6IEljb25Tb3VyY2UgPSBJY29uU291cmNlLmludGVybmFsLFxuICAgICAgICBwOiBDb250ZW50UG9zaXRpb24gPSBDb250ZW50UG9zaXRpb24ucHJlZml4LFxuICAgICAgICBuOiBzdHJpbmcgPSBJY29uU2VydmljZS5kZWZhdWx0SWNvbk5hbWUpXG5cdHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gcDtcbiAgICAgICAgdGhpcy5uYW1lID0gbjtcblxuICAgICAgICB0aGlzLnNldERlZmF1bHRWYWx1ZUlmVW5kZWZpbmVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgZWFjaCB1bmRlZmluZWQgdmFsdWUuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXREZWZhdWx0VmFsdWVJZlVuZGVmaW5lZCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT0gdW5kZWZpbmVkKSB0aGlzLnNvdXJjZSA9IEljb25Tb3VyY2UuaW50ZXJuYWw7XG4gICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IHVuZGVmaW5lZCkgdGhpcy5wb3NpdGlvbiA9IENvbnRlbnRQb3NpdGlvbi5wcmVmaXg7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT0gdW5kZWZpbmVkKSB0aGlzLm5hbWUgPSBJY29uU2VydmljZS5kZWZhdWx0SWNvbk5hbWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgZWFjaCB1bmRlZmluZWQgdmFsdWUsIGJ1dCB0aGUgaWNvbiBwb3NpdGlvbiBpcyBhbHdheXMgc2V0IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUuIFxuICAgICAqIEBwYXJhbSBpY29uUG9zaXRpb24gVGhlIGljb24gcG9zaXRpb24gdG8gc2V0LiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0RGVmYXVsdFZhbHVlSWZVbmRlZmluZWRfc2V0UG9zaXRpb24oaWNvblBvc2l0aW9uOiBDb250ZW50UG9zaXRpb24pOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT0gdW5kZWZpbmVkKSB0aGlzLnNvdXJjZSA9IEljb25Tb3VyY2UuaW50ZXJuYWw7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBpY29uUG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT0gdW5kZWZpbmVkKSB0aGlzLm5hbWUgPSBJY29uU2VydmljZS5kZWZhdWx0SWNvbk5hbWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEFuIGVudW0gdGhhdCByZXByZXNlbnRzIHRoZSBoaW50IHBvc2l0aW9uIG9mIGEgYEhpbnRWYWx1ZWAuIFxuICovXG5leHBvcnQgZW51bSBIaW50UG9zaXRpb25cbntcbiAgICAvKipcbiAgICAgKiBBZGRpbmcgdGhlIGBzdGFydGAgb3B0aW9uIHRvIGEgYEhpbnRWYWx1ZWAgd2lsbCBkZXNpZ25hdGUgaXQgYXMgc3RhcnQtYWxpZ25lZC4gXG4gICAgICovXG4gICAgc3RhcnQgPSAnc3RhcnQnLFxuXG4gICAgLyoqXG4gICAgICogQWRkaW5nIHRoZSBgZW5kYCBvcHRpb24gdG8gYSBgSGludFZhbHVlYCB3aWxsIGRlc2lnbmF0ZSBpdCBhcyBlbmQtYWxpZ25lZC4gXG4gICAgICovXG4gICAgZW5kID0gJ2VuZCcsXG5cbiAgICAvKipcbiAgICAgKiBBZGRpbmcgdGhlIGBub25lYCBvcHRpb24gdG8gYSBgSGludFZhbHVlYCB3aWxsIG5vdCBzaG93IGl0LiBcbiAgICAgKi9cbiAgICBub25lID0gJ25vbmUnXG59XG5cbi8qKlxuICogRGF0YSBzdHJ1Y3R1cmUgZm9yIGhvbGRpbmcgYSBoaW50LiBcbiAqIEEgaGludCBsYWJlbCBpcyBhZGRpdGlvbmFsIGRlc2NyaXB0aXZlIHRleHQgdGhhdCBhcHBlYXJzIGJlbG93IHRoZSBjb250cm9sJ3MgdW5kZXJsaW5lLiBcbiAqL1xuZXhwb3J0IGNsYXNzIEhpbnRWYWx1ZVxue1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhpbnQgcG9zaXRpb24gdHlwZS4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBIaW50UG9zaXRpb24ubm9uZWAuIFxuICAgICAqL1xuICAgIHB1YmxpYyBwb3NpdGlvbjogSGludFBvc2l0aW9uO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaGludCBsYWJlbC4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGAnJ2AuIFxuICAgICAqL1xuICAgIHB1YmxpYyBsYWJlbDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYEhpbnRWYWx1ZWAgY2xhc3MuIFxuICAgICAqIEBwYXJhbSBwIFRoZSBoaW50IHBvc2l0aW9uIHR5cGUuIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgSGludFBvc2l0aW9uLm5vbmVgLiBcbiAgICAgKiBAcGFyYW0gbCBUaGUgaGludCBsYWJlbC4gQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGAnJ2AuIFxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICAgICAgcDogSGludFBvc2l0aW9uID0gSGludFBvc2l0aW9uLm5vbmUsXG4gICAgICAgIGw6IHN0cmluZyA9ICcnKVxuXHR7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwO1xuICAgICAgICB0aGlzLmxhYmVsID0gbDtcblxuICAgICAgICB0aGlzLnNldERlZmF1bHRWYWx1ZUlmVW5kZWZpbmVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgZWFjaCB1bmRlZmluZWQgdmFsdWUuIFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXREZWZhdWx0VmFsdWVJZlVuZGVmaW5lZCgpOiB2b2lkXG4gICAge1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSB1bmRlZmluZWQpIHRoaXMucG9zaXRpb24gPSBIaW50UG9zaXRpb24ubm9uZTtcbiAgICAgICAgaWYgKHRoaXMubGFiZWwgPT0gdW5kZWZpbmVkKSB0aGlzLmxhYmVsID0gJyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZSBmb3IgZWFjaCB1bmRlZmluZWQgdmFsdWUsIGJ1dCB0aGUgaGludCBwb3NpdGlvbiBpcyBhbHdheXMgc2V0IHRvIHRoZSBzcGVjaWZpZWQgdmFsdWUuIFxuICAgICAqIEBwYXJhbSBoaW50UG9zaXRpb24gVGhlIGhpbnQgcG9zaXRpb24gdG8gc2V0LiBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0RGVmYXVsdFZhbHVlSWZVbmRlZmluZWRfc2V0UG9zaXRpb24oaGludFBvc2l0aW9uOiBIaW50UG9zaXRpb24pOiB2b2lkXG4gICAge1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gaGludFBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5sYWJlbCA9PSB1bmRlZmluZWQpIHRoaXMubGFiZWwgPSAnJztcbiAgICB9XG59XG5cbi8qKlxuICogVGhpcyBlbnVtIGlzIGRlcHJlY2F0ZWQuIFxuICogUmVwcmVzZW50cyBhIGZvcm0gZmllbGQgdHlwZS4gXG4gKi9cbmV4cG9ydCBlbnVtIEZvcm1GaWVsZFR5cGVcbntcbiAgICAvKiogQSBidXR0b24gY29udHJvbC4gKi9cbiAgICBhY3Rpb25fYnV0dG9uID0gJ2FjdGlvbl9idXR0b24nLFxuXG5cblxuICAgIC8qKiBBIGNvbnRhaW5lciBjb250cm9sIHRoYXQgaXMgc2hvd2VkIGFzIGEgcGFuZWwuICovXG4gICAgY29udGFpbmVyX3BhbmVsID0gJ2NvbnRhaW5lcl9wYW5lbCcsXG5cbiAgICAvKiogQSBjb250YWluZXIgY29udHJvbCB0aGF0IGlzIHNob3dlZCB2ZXJ5IHNpbXBsZS4gKi9cbiAgICBjb250YWluZXJfc2ltcGxlID0gJ2NvbnRhaW5lcl9zaW1wbGUnLFxuXG5cblxuICAgIC8qKiBBIGNvbnRhaW5lciBjb250cm9sIHRoYXQgYWxsb3dzIHRoZSB3cml0aW5nIG9mIGEgbmFtZSBvZiBzb21ldGhpbmcgaW4gZGlmZmVyZW50IGxhbmd1YWdlLiAqL1xuICAgIGNvbnRhaW5lcl9sYWJlbF9kaWZmX2xhbmcgPSAnY29udGFpbmVyX2xhYmVsX2RpZmZfbGFuZycsXG5cblxuXG4gICAgLyoqIEEgdGV4dCBjb250cm9sLiAqL1xuICAgIHRleHQgPSAndGV4dCcsXG5cbiAgICAvKiogQSB0ZXh0YXJlYSBjb250cm9sLiAqL1xuICAgIHRleHRhcmVhID0gJ3RleHRhcmVhJyxcblxuICAgIC8qKiBBIGRhdGFwaWNrZXIgY29udHJvbC4gKi9cbiAgICBkYXRlcGlja2VyID0gJ2RhdGVwaWNrZXInLFxuXG4gICAgLyoqIEEgY2hlY2tib3ggY29udHJvbC4gKi9cbiAgICBjaGVja2JveCA9ICdjaGVja2JveCcsXG5cbiAgICAvKiogQSB1cmwgY29udHJvbC4gKi9cbiAgICB1cmwgPSAndXJsJyxcblxuICAgIC8qKiBBbiBlbWFpbCBjb250cm9sLiAqL1xuICAgIGVtYWlsID0gJ2VtYWlsJyxcblxuICAgIC8qKiBBbiBpZGVudGlmaWVyIGNvbnRyb2wuICovXG4gICAgaWRlbnRpZmllciA9ICdpZGVudGlmaWVyJyxcblxuICAgIC8qKiBBbiBpc3NuIGNvbnRyb2wuICovXG4gICAgaXNzbiA9ICdpc3NuJyxcblxuICAgIC8qKiBBIHJucHMgY29udHJvbC4gKi9cbiAgICBybnBzID0gJ3JucHMnLFxuXG4gICAgLyoqIEEgdm9jYWJ1bGFyeSBjb250cm9sLiAqL1xuICAgIHZvY2FidWxhcnkgPSAndm9jYWJ1bGFyeScsXG5cbiAgICB2b2NhYnVsYXJ5X3RyZWUgPSAndG9jby12b2NhYnVsYXJ5LXRyZWUnLFxuXG4gICAgLyoqIEEgdGVybSBwYXJlbnQgY29udHJvbC4gKi9cbiAgICB0ZXJtX3BhcmVudCA9ICd0ZXJtX3BhcmVudCcsXG5cbiAgICAvKiogQSBzZWxlY3QgY29udHJvbC4gKi9cbiAgICBzZWxlY3QgPSAnc2VsZWN0JyxcblxuICAgIC8qKiBBIHNlbGVjdCBjb250cm9sLiAqL1xuICAgIHNlbGVjdF9leHByID0gJ3NlbGVjdF9leHByJyxcblxuICAgIC8qKiBBIHNlbGVjdCB3aXRoIGEgZmlsdGVyIGNvbnRyb2wuICovXG4gICAgc2VsZWN0X2ZpbHRlciA9ICdzZWxlY3RfZmlsdGVyJyxcblxuICAgIC8qKiBBIHNlbGVjdCB3aXRoIGEgZmlsdGVyIGNvbnRyb2wuICovXG4gICAgc2VsZWN0X3RyZWUgPSAnc2VsZWN0X3RyZWUnXG59XG5cbi8qKlxuICogQSBiYXNlIGludGVyZmFjZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgb2YgYSBgRm9ybUZpZWxkQ29udHJvbGAuIFxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1GaWVsZENvbnRlbnRcbntcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgYENvbnRhaW5lckNvbnRyb2xgIG9mIHRoaXMgY29udHJvbC4gXG4gICAgICogSXQgaXMgYWx3YXlzIHNldCBpbnRlcm5hbGx5LiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuIFxuICAgICAqL1xuICAgIHBhcmVudENvbnRhaW5lckNvbnRyb2w/OiBDb250YWluZXJDb250cm9sO1xuXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhcmVudCBgRm9ybVNlY3Rpb25gIHRoYXQgcmVwcmVzZW50cyB0aGUgcGFyZW50IGBGb3JtR3JvdXBgIG9yIGBGb3JtQXJyYXlgIG9mIHRoaXMgY29udHJvbC4gXG4gICAgICogSXQgaXMgYWx3YXlzIHNldCBpbnRlcm5hbGx5LiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuIFxuICAgICAqL1xuICAgIHBhcmVudEZvcm1TZWN0aW9uPzogRm9ybVNlY3Rpb247XG5cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udHJvbCdzIG1pbmltdW0gd2lkdGguIFxuICAgICAqIFRoZSBtaW5pbXVtIHdpZHRoIG9mIHRoZSBjb250ZW50IGFyZWEsIHBhZGRpbmcgYXJlYSBvciBib3JkZXIgYXJlYSAoZGVwZW5kaW5nIG9uIGBib3gtc2l6aW5nYCkgXG4gICAgICogb2YgY2VydGFpbiBib3hlcy4gQWxsb3dzIGF1dGhvcnMgdG8gY29uc3RyYWluIGNvbnRlbnQgd2lkdGggdG8gYSBjZW50YWluIHJhbmdlLiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYCcxNWVtJ2AuIFxuICAgICAqL1xuICAgIG1pbldpZHRoPzogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udHJvbCdzIHdpZHRoLiBcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGNvbnRlbnQgYXJlYSwgcGFkZGluZyBhcmVhIG9yIGJvcmRlciBhcmVhIChkZXBlbmRpbmcgb24gYGJveC1zaXppbmdgKSBvZiBjZXJ0YWluIGJveGVzLiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYG1pbldpZHRoYC4gXG4gICAgICovXG4gICAgd2lkdGg/OiBzdHJpbmc7XG5cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udHJvbCdzIGxhYmVsLiBcbiAgICAgKiBTZWUgdGhlIGBDb250YWluZXJDb250ZW50YCBmb3IgdGhlIHBhcnRpY3VsYXIgaW50ZXJwcmV0YXRpb24gb2YgdGhpcyBmaWVsZC4gXG4gICAgICogU2VlIHRoZSBgQWN0aW9uQ29udGVudGAgZm9yIHRoZSBwYXJ0aWN1bGFyIGludGVycHJldGF0aW9uIG9mIHRoaXMgZmllbGQuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgJydgLiBFYWNoIGNvbnRyb2wgc2V0cyBpdHMgb3duIGxhYmVsLiBcbiAgICAgKi9cbiAgICBsYWJlbD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyb2wncyBwbGFjZWhvbGRlci4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGAnJ2AuIEVhY2ggY29udHJvbCBzZXRzIGl0cyBvd24gcGxhY2Vob2xkZXIuIFxuICAgICAqL1xuICAgIHBsYWNlaG9sZGVyPzogc3RyaW5nO1xuXG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY29udHJvbCBpcyByZXF1aXJlZDsgb3RoZXJ3aXNlLCBmYWxzZS4gXG4gICAgICogU2VlIHRoZSBgQ29udGFpbmVyQ29udGVudGAgZm9yIHRoZSBwYXJ0aWN1bGFyIGludGVycHJldGF0aW9uIG9mIHRoaXMgZmllbGQuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgZmFsc2VgLiBcbiAgICAgKi9cbiAgICByZXF1aXJlZD86IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250cm9sJ3MgdGV4dCBhbGlnbi4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBUZXh0QWxpZ24ubGVmdGAuIFxuICAgICAqL1xuICAgIHRleHRBbGlnbj86IFRleHRBbGlnbjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbnRyb2wncyBhcmlhLWxhYmVsLiBcbiAgICAgKiBEZWZpbmVzIGEgc3RyaW5nIHZhbHVlIHRoYXQgbGFiZWxzIHRoZSBjdXJyZW50IGVsZW1lbnQuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgJ1RleHQgSW5wdXQnYC4gRWFjaCBjb250cm9sIHNldHMgaXRzIG93biBhcmlhLWxhYmVsLiBcbiAgICAgKi9cbiAgICBhcmlhTGFiZWw/OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY29udHJvbCdzIHZhbHVlLiBcbiAgICAgKiBCeSBkZWZhdWx0LCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuIFxuICAgICAqL1xuICAgIHZhbHVlPzogYW55O1xuXG5cblxuICAgIC8qKlxuICAgICAqIFRoaXMgYHR5cGVgIGZpZWxkIGlzIGRlcHJlY2F0ZWQsIHlvdSBtdXN0IHVzZSB0aGUgYGNvbnRyb2xUeXBlYCBmaWVsZC4gXG4gICAgICogUmV0dXJucyB0aGUgY29udHJvbCdzIHR5cGUgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY29udHJvbC4gXG4gICAgICogSW1wbGVtZW50YXRpb24gbm90ZXM6IFxuICAgICAqICAtIEl0IG11c3QgYmUgc3BlY2lmaWVkOyBvdGhlcndpc2UsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uIFxuICAgICAqL1xuICAgIHR5cGU/OiBGb3JtRmllbGRUeXBlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udHJvbCdzIHR5cGUgdGhhdCBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgY29udHJvbC4gXG4gICAgICogSW1wbGVtZW50YXRpb24gbm90ZXM6IFxuICAgICAqICAtIEl0IG11c3QgYmUgc3BlY2lmaWVkOyBvdGhlcndpc2UsIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uIFxuICAgICAqL1xuICAgIGNvbnRyb2xUeXBlPzogVHlwZTxhbnk+O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBjb250cm9sJ3MgbmFtZSB0aGF0IGlzIHVzZWQgdG8gc2F2ZSB0aGUgY29udHJvbCdzIHZhbHVlIGFzIGEgbmFtZS92YWx1ZSBwYWlyLiBcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBub3RlczogXG4gICAgICogIC0gSXQgY2FuIGJlIHVzZWQgd2l0aCBhIEpTT04gc3RyaW5nLiBcbiAgICAgKiAgLSBJdCBtdXN0IGJlIHNwZWNpZmllZDsgb3RoZXJ3aXNlLCBhbiBleGNlcHRpb24gaXMgdGhyb3duLiBcblx0ICovXG4gICAgbmFtZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9sJ3MgZXh0cmEgY29udGVudC4gRm9yIGFueSBvdGhlciBjb250ZW50IG5lZWRlZCBieSBhbiBzcGVjaWZpYyBgRm9ybUZpZWxkQ29udHJvbGAuIFxuICAgICAqIEJ5IGRlZmF1bHQsIGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4gXG4gICAgICovXG4gICAgZXh0cmFDb250ZW50PzogYW55O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY2xvbmUgb2YgdGhlIHNwZWNpZmllZCBgRm9ybUNvbnRyb2xgIHRhcmdldC4gXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBgRm9ybUNvbnRyb2xgIG9iamVjdCB0byBjbG9uZS4gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUZvcm1Db250cm9sKHRhcmdldDogRm9ybUNvbnRyb2wpOiBGb3JtQ29udHJvbFxue1xuICAgIHJldHVybiBuZXcgRm9ybUNvbnRyb2wodGFyZ2V0LnZhbHVlLCB0YXJnZXQudmFsaWRhdG9yLCB0YXJnZXQuYXN5bmNWYWxpZGF0b3IpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgY2xvbmUgb2YgdGhlIHNwZWNpZmllZCBgRm9ybVNlY3Rpb25gIHRhcmdldC4gXG4gKiBAcGFyYW0gdGFyZ2V0IFRoZSBgRm9ybVNlY3Rpb25gIG9iamVjdCB0byBjbG9uZS4gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUZvcm1TZWN0aW9uKHRhcmdldDogRm9ybVNlY3Rpb24pOiBGb3JtU2VjdGlvblxue1xuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBGb3JtR3JvdXApXG4gICAge1xuICAgICAgICAvKiBDcmVhdGVzIGFuIGVtcHR5IGBGb3JtR3JvdXBgIHdpdGggaXRzIHZhbGlkYXRvcnMuICovXG4gICAgICAgIGxldCByZXN1bHQ6IEZvcm1Hcm91cCA9IG5ldyBGb3JtR3JvdXAoeyB9LCB0YXJnZXQudmFsaWRhdG9yLCB0YXJnZXQuYXN5bmNWYWxpZGF0b3IpO1xuXG4gICAgICAgIC8qIEFkZHMgdGhlIGNvbnRyb2xzIHRvIGBGb3JtR3JvdXBgLiAqL1xuICAgICAgICBmb3IobGV0IGN0ciBpbiB0YXJnZXQuY29udHJvbHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKCh0YXJnZXQuY29udHJvbHNbY3RyXSkgaW5zdGFuY2VvZiBGb3JtQ29udHJvbCkgcmVzdWx0LmFkZENvbnRyb2woY3RyLCBjbG9uZUZvcm1Db250cm9sKCh0YXJnZXQuY29udHJvbHNbY3RyXSkgYXMgRm9ybUNvbnRyb2wpKTtcbiAgICAgICAgICAgIGVsc2UgcmVzdWx0LmFkZENvbnRyb2woY3RyLCBjbG9uZUZvcm1TZWN0aW9uKCh0YXJnZXQuY29udHJvbHNbY3RyXSkgYXMgRm9ybVNlY3Rpb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICAgIC8qIENyZWF0ZXMgYW4gZW1wdHkgYEZvcm1BcnJheWAgd2l0aCBpdHMgdmFsaWRhdG9ycy4gKi9cbiAgICAgICAgbGV0IHJlc3VsdDogRm9ybUFycmF5ID0gbmV3IEZvcm1BcnJheShbIF0sIHRhcmdldC52YWxpZGF0b3IsIHRhcmdldC5hc3luY1ZhbGlkYXRvcik7XG5cbiAgICAgICAgLyogQWRkcyB0aGUgY29udHJvbHMgdG8gdGhlIGBGb3JtQXJyYXlgLiAqL1xuICAgICAgICBmb3IobGV0IGN0ciBvZiB0YXJnZXQuY29udHJvbHMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlmKGN0ciBpbnN0YW5jZW9mIEZvcm1Db250cm9sKSByZXN1bHQucHVzaChjbG9uZUZvcm1Db250cm9sKGN0cikpO1xuICAgICAgICAgICAgZWxzZSByZXN1bHQucHVzaChjbG9uZUZvcm1TZWN0aW9uKGN0ciBhcyBGb3JtU2VjdGlvbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYmFzZSBhYnN0cmFjdCBjbGFzcyBmb3IgYSBjb250cm9sIHRoYXQgaXMgdHJlYXRlZCBhcyBhIGZvcm0gZmllbGQuIFxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRm9ybUZpZWxkQ29udHJvbFxue1xuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGBDb250ZW50UG9zaXRpb25gIGVudW0gZm9yIGludGVybmFsIHVzZS4gXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IGNvbnRlbnRQb3NpdGlvbjogdHlwZW9mIENvbnRlbnRQb3NpdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgdGhlIGBJY29uU291cmNlYCBlbnVtIGZvciBpbnRlcm5hbCB1c2UuIFxuICAgICAqL1xuICAgIHB1YmxpYyByZWFkb25seSBpY29uU291cmNlOiB0eXBlb2YgSWNvblNvdXJjZTtcblxuICAgIC8qKlxuICAgICAqIElucHV0IGZpZWxkIHRoYXQgY29udGFpbnMgdGhlIGNvbnRlbnQgb2YgdGhpcyBjbGFzcy4gXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY29udGVudDogRm9ybUZpZWxkQ29udGVudDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhbmd1YWdlIGN1cnJlbnRseSB1c2VkLiBcbiAgICAgKiBUaGlzIGlzIGEgc3RhdGljIGZpZWxkLiBcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc3RhdGljIGN1cnJlbnRMYW5nOiBzdHJpbmcgPSAnJztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdHJhbnNsYXRpb24gaXMgYnVpbHQgYnkgdGhlIGNvbnRyb2w7IG90aGVyd2lzZSwgZmFsc2UuIFxuICAgICAqIEl0IGlzIHVzZWQgdG8gc2VsZWN0IHRoZSB3YXkgdGhlIHRyYW5zbGF0aW9uIGlzIGJ1aWx0IGZvciB0aGUgY29udHJvbC4gXG4gICAgICogQnkgZGVmYXVsdCwgaXRzIHZhbHVlIGlzIGBmYWxzZWAuIFxuICAgICAqIEFzIGFuIGV4YW1wbGUgb2YgdXNhZ2UgZm9yIHRoaXMgZmllbGQsIHRoZSBgSW5wdXROdW1iZXJDb21wb25lbnRgIGNsYXNzIGltcGxlbWVudHMgdGhlIGxvZ2ljIHdoZW4gdGhpcyB2YWx1ZSBpcyBgdHJ1ZWAuIFxuICAgICAqL1xuICAgIHB1YmxpYyBpc1RyYW5zbGF0aW9uQnVpbHRCeUNvbnRyb2w6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuIFxuICAgICAqL1xuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpXG4gICAge1xuICAgICAgICB0aGlzLmNvbnRlbnRQb3NpdGlvbiA9IENvbnRlbnRQb3NpdGlvbjtcbiAgICAgICAgdGhpcy5pY29uU291cmNlID0gSWNvblNvdXJjZTtcblxuICAgICAgICAvKiBJdCBtdXN0IGJlIGluaXRpYWxpemUuICovXG4gICAgICAgIHRoaXMuY29udGVudCA9IHVuZGVmaW5lZDtcblxuICAgICAgICB0aGlzLmlzVHJhbnNsYXRpb25CdWlsdEJ5Q29udHJvbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG5ldyBsYW5ndWFnZS4gXG4gICAgICogQHBhcmFtIHRyYW5zU2VydiBUaGUgYFRyYW5zbGF0ZVNlcnZpY2VgIGluc3RhbmNlIGluamVjdGVkLiBcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2V0TmV3TGFuZ3VhZ2UodHJhbnNTZXJ2OiBUcmFuc2xhdGVTZXJ2aWNlKTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogVGhlIGBGb3JtRmllbGRDb250cm9sLmN1cnJlbnRMYW5nICE9IHRyYW5zU2Vydi5jdXJyZW50TGFuZ2AgdGVzdCBpcyBOT1QgbmVjZXNzYXJ5IGhlcmUgYmVjYXVzZSBpdCBpcyBkb25lIGluIHRoZSBub24tYWJzdHJhY3QgY2hpbGQgY2xhc3Nlcy4gKi9cblxuICAgICAgICBGb3JtRmllbGRDb250cm9sLmN1cnJlbnRMYW5nID0gdHJhbnNTZXJ2LmN1cnJlbnRMYW5nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBgY29udGVudGAgaW5wdXQgcHJvcGVydHkuIFxuICAgICAqIEBwYXJhbSBsYWJlbCBUaGUgZGVmYXVsdCBsYWJlbCB0byB1c2UuIEl0IGlzIHVzZWQgaWYgdGhlIGBjb250ZW50LmxhYmVsYCBpcyBub3Qgc3BlY2lmaWVkLiBcbiAgICAgKiBAcGFyYW0gcGxhY2Vob2xkZXIgVGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgdG8gdXNlLiBJdCBpcyB1c2VkIGlmIHRoZSBgY29udGVudC5wbGFjZWhvbGRlcmAgaXMgbm90IHNwZWNpZmllZC4gXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGluaXQobGFiZWw6IHN0cmluZywgcGxhY2Vob2xkZXI6IHN0cmluZyA9ICcnKTogdm9pZFxuICAgIHtcbiAgICAgICAgLyogU2V0cyB0aGUgZGVmYXVsdCB2YWx1ZXMuICovXG5cbiAgICAgICAgaWYgKHRoaXMuY29udGVudCA9PSB1bmRlZmluZWQpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRm9yIHRoZSAnJHsgRm9ybUZpZWxkQ29udHJvbC5uYW1lIH0nIGNvbnRyb2wsIHRoZSAnY29udGVudCcgdmFsdWUgY2FuIG5vdCBiZSB1bmRlZmluZWQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb250ZW50Lm5hbWUgPT0gdW5kZWZpbmVkKVxuICAgICAgICB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvciB0aGUgJyR7IEZvcm1GaWVsZENvbnRyb2wubmFtZSB9JyBjb250cm9sLCB0aGUgJ2NvbnRlbnQubmFtZScgdmFsdWUgY2FuIG5vdCBiZSB1bmRlZmluZWQuYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb250ZW50LmNvbnRyb2xUeXBlID09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3IgdGhlICckeyB0aGlzLmNvbnRlbnQubmFtZSB9JyBjb250cm9sLCB0aGUgJ2NvbnRlbnQuY29udHJvbFR5cGUnIHZhbHVlIGNhbiBub3QgYmUgdW5kZWZpbmVkLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhYmVsID09IHVuZGVmaW5lZClcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5sYWJlbCA9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3IgdGhlICckeyB0aGlzLmNvbnRlbnQubmFtZSB9JyBjb250cm9sLCB0aGUgJ2NvbnRlbnQubGFiZWwnIHZhbHVlIGNhbiBub3QgYmUgdW5kZWZpbmVkLiBcXG5cbiAgICAgICAgICAgICAgICAgICAgWW91IGNhbiBzcGVjaWZ5OiBcXG5cbiAgICAgICAgICAgICAgICAgICAgLSBBIGRlZmF1bHQgbGFiZWwgdmFsdWUgd2hlbiBvdmVyd3JpdGluZyB0aGUgJ2luaXQnIG1ldGhvZCBpbiB0aGUgY29tcG9uZW50IHRoYXQgcmVwcmVzZW50cyB0aGUgY29udHJvbC4gXFxuXG4gICAgICAgICAgICAgICAgICAgIC0gQSBsYWJlbCB2YWx1ZSB3aGVuIGRlZmluaW5nIHRoZSBjb250ZW50IG9iamVjdCBmb3IgdGhlIGNvbnRyb2wuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhYmVsID0gdGhpcy5jb250ZW50LmxhYmVsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5sYWJlbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbCA9IHRoaXMuY29udGVudC5sYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKiBgbWF0LWZvcm0tZmllbGRgIHByb3BlcnRpZXMuICoqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lm1pbldpZHRoID09IHVuZGVmaW5lZCkgdGhpcy5jb250ZW50Lm1pbldpZHRoID0gJzE1ZW0nO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LndpZHRoID09IHVuZGVmaW5lZCkgdGhpcy5jb250ZW50LndpZHRoID0gdGhpcy5jb250ZW50Lm1pbldpZHRoO1xuXG4gICAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqIGBtYXQtbGFiZWxgIHByb3BlcnRpZXMuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LmxhYmVsID09IHVuZGVmaW5lZCkgdGhpcy5jb250ZW50LmxhYmVsID0gbGFiZWw7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQucGxhY2Vob2xkZXIgPT0gdW5kZWZpbmVkKSB0aGlzLmNvbnRlbnQucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKiogSW50ZXJuYWwgY29udHJvbCBwcm9wZXJ0aWVzLiAqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICAgICAgaWYgKHRoaXMuY29udGVudC50ZXh0QWxpZ24gPT0gdW5kZWZpbmVkKSB0aGlzLmNvbnRlbnQudGV4dEFsaWduID0gVGV4dEFsaWduLmxlZnQ7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuYXJpYUxhYmVsID09IHVuZGVmaW5lZCkgdGhpcy5jb250ZW50LmFyaWFMYWJlbCA9IGxhYmVsO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LnZhbHVlICE9IHVuZGVmaW5lZCkgIC8qIEl0IGRvZXMgbm90IHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBoZXJlIChkb2VzIG5vdCBjYWxsIGBnZXREZWZhdWx0VmFsdWVgIG1ldGhvZCBoZXJlKSBiZWNhdXNlIGluIHRoaXMgd2F5IGl0IGlzIG1vcmUgY29uc2lzdGVudC4gKi9cbiAgICAgICAge1xuICAgICAgICAgICAgLyogSXQgYWxzbyBjaGVja3MgaWYgdGhlIHNwZWNpZmllZCBgY29udGVudC52YWx1ZWAgaXMgY29ycmVjdC4gKi9cbiAgICAgICAgICAgIHRoaXMuaW5pdFZhbHVlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBPdGhlciBwcm9wZXJ0aWVzLiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgICB9XG5cblx0LyoqXG5cdCAqIEluaXRpYWxpemVzIHRoZSBjb250cm9sJ3MgdmFsdWUuIEl0IHVzZXMgdGhlIGBjb250ZW50LnZhbHVlYCBhbmQgaXQgaXMgYWxyZWFkeSBkaWZmZXJlbnQgb2YgYHVuZGVmaW5lZGAuIFxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgYGNvbnRlbnQudmFsdWVgIGlzIGNvcnJlY3QuIEZvciBpbnRlcm5hbCB1c2Ugb25seS4gXG5cdCAqL1xuICAgIHByb3RlY3RlZCBhYnN0cmFjdCBpbml0VmFsdWUoKTogdm9pZDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBpbnN0YW5jZS4gXG4gICAgICovXG4gICAgcHVibGljIGFic3RyYWN0IGdldCBnZXRJbnN0YW5jZSgpOiBGb3JtRmllbGRDb250cm9sO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyZW50IGBDb250YWluZXJDb250cm9sYCBvZiB0aGlzIGNvbnRyb2wuIFxuICAgICAqIEl0IGlzIGFsd2F5cyBzZXQgaW50ZXJuYWxseS4gXG4gICAgICovXG4gICAgcHVibGljIGdldCBwYXJlbnRDb250YWluZXJDb250cm9sKCk6IENvbnRhaW5lckNvbnRyb2xcbiAgICB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQucGFyZW50Q29udGFpbmVyQ29udHJvbDtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEFkZHMgdGhlIHNwZWNpZmllZCBgY29udHJvbGAvYGludGVybmFsQ29udHJvbGAgYXMgYSBjaGlsZCBcbiAgICAgKiB0byB0aGUgYGNvbnRlbnQuY29udGFpbmVyQ29udHJvbENoaWxkcmVuYC9gY29udGVudC5wYXJlbnRGb3JtU2VjdGlvbmAgcmVzcGVjdGl2ZWx5LiBcbiAgICAgKiBAcGFyYW0gY29udHJvbCBGb3JtIGNvbnRyb2wgdG8gYmUgYWRkZWQgKGRlc2NlbmRhbnQgZnJvbSBgRm9ybUZpZWxkQ29udHJvbGApLiBcbiAgICAgKiBAcGFyYW0gaW50ZXJuYWxDb250cm9sIEludGVybmFsIGZvcm0gY29udHJvbCB0byBiZSBhZGRlZCAoYEZvcm1Db250cm9sYCwgYEZvcm1Hcm91cGAsIG9yIGBGb3JtQXJyYXlgKS4gXG5cdCAqL1xuXHRwcm90ZWN0ZWQgYWRkQXNDaGlsZENvbnRyb2woY29udHJvbDogYW55LCBpbnRlcm5hbENvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IHZvaWRcblx0e1xuICAgICAgICAvKiBBZGRzIHRoZSBzcGVjaWZpZWQgYGNvbnRyb2xgIGFzIGEgY2hpbGQgdG8gdGhlIGBjb250ZW50LmNvbnRhaW5lckNvbnRyb2xDaGlsZHJlbmAuICovXG5cbiAgICAgICAgdGhpcy5jb250ZW50LnBhcmVudENvbnRhaW5lckNvbnRyb2wuY29udGVudC5jb250YWluZXJDb250cm9sQ2hpbGRyZW4ucHVzaChjb250cm9sKTtcblxuICAgICAgICAvKiBBZGRzIHRoZSBzcGVjaWZpZWQgYGludGVybmFsQ29udHJvbGAgYXMgYSBjaGlsZCB0byB0aGUgYGNvbnRlbnQucGFyZW50Rm9ybVNlY3Rpb25gLiAqL1xuXG4gICAgICAgIGlmKHRoaXMuY29udGVudC5wYXJlbnRDb250YWluZXJDb250cm9sLmlzRm9ybUFycmF5KSAgLyogYGNvbnRlbnQucGFyZW50Rm9ybVNlY3Rpb25gIGlzIGFuIGluc3RhbmNlIG9mIGBGb3JtQXJyYXlgLiAqL1xuICAgICAgICB7XG4gICAgICAgICAgICAvKiBUaGUgYGludGVybmFsQ29udHJvbGAncyBuYW1lIGlzIGFscmVhZHkgY29ycmVjdCwgdGhhdCBpcywgXG4gICAgICAgICAgICBgY29udGVudC5uYW1lYCBlcXVhbHMgdGhlIGBjb250ZW50LnBhcmVudEZvcm1TZWN0aW9uYCdzIGxhc3QgcG9zaXRpb24gXG4gICAgICAgICAgICAoYmVjYXVzZSB0aGUgYGludGVybmFsQ29udHJvbGAgaGFzIGEgYEZvcm1BcnJheWAgYXMgaXRzIHBhcmVudCkuICovXG5cbiAgICAgICAgICAgICh0aGlzLmNvbnRlbnQucGFyZW50Rm9ybVNlY3Rpb24gYXMgRm9ybUFycmF5KS5wdXNoKGludGVybmFsQ29udHJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSAgLyogYGNvbnRlbnQucGFyZW50Rm9ybVNlY3Rpb25gIGlzIGFuIGluc3RhbmNlIG9mIGBGb3JtR3JvdXBgLiAqL1xuICAgICAgICB7XG4gICAgICAgICAgICAodGhpcy5jb250ZW50LnBhcmVudEZvcm1TZWN0aW9uIGFzIEZvcm1Hcm91cCkuYWRkQ29udHJvbCh0aGlzLmNvbnRlbnQubmFtZSwgaW50ZXJuYWxDb250cm9sKTtcbiAgICAgICAgfVxuXHR9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBgSWNvblZhbHVlYCBoYXMgdGhlIHNwZWNpZmllZCBgQ29udGVudFBvc2l0aW9uYCB2YWx1ZTsgb3RoZXJ3aXNlLCBmYWxzZS4gXG4gICAgICogQHBhcmFtIGljb24gVGhlIGBJY29uVmFsdWVgIHRvIGNoZWNrLiBcbiAgICAgKiBAcGFyYW0gY29udGVudFBvc2l0aW9uIFRoZSBgQ29udGVudFBvc2l0aW9uYCB2YWx1ZSB0byBjaGVjay4gXG4gICAgICovXG4gICAgcHVibGljIGljb25Qb3NpdGlvblN0YXRlKGljb246IEljb25WYWx1ZSwgY29udGVudFBvc2l0aW9uOiBDb250ZW50UG9zaXRpb24pOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKGljb24ucG9zaXRpb24gPT0gY29udGVudFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBgSWNvblZhbHVlYCBoYXMgdGhlIHNwZWNpZmllZCBgSWNvblNvdXJjZWAgdmFsdWU7IG90aGVyd2lzZSwgZmFsc2UuIFxuICAgICAqIEBwYXJhbSBpY29uIFRoZSBgSWNvblZhbHVlYCB0byBjaGVjay4gXG4gICAgICogQHBhcmFtIGljb25Tb3VyY2UgVGhlIGBJY29uU291cmNlYCB2YWx1ZSB0byBjaGVjay4gXG4gICAgICovXG4gICAgcHVibGljIGljb25Tb3VyY2VTdGF0ZShpY29uOiBJY29uVmFsdWUsIGljb25Tb3VyY2U6IEljb25Tb3VyY2UpOiBib29sZWFuXG4gICAge1xuICAgICAgICByZXR1cm4gKGljb24uc291cmNlID09IGljb25Tb3VyY2UpO1xuICAgIH1cbn1cbiJdfQ==