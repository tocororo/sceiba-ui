(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/cdk/layout'), require('@angular/material/autocomplete'), require('@angular/material/button'), require('@angular/material/button-toggle'), require('@angular/material/card'), require('@angular/material/checkbox'), require('@angular/material/chips'), require('@angular/material/core'), require('@angular/material/dialog'), require('@angular/material/form-field'), require('@angular/material/grid-list'), require('@angular/material/icon'), require('@angular/material/input'), require('@angular/material/menu'), require('@angular/material/paginator'), require('@angular/material/progress-bar'), require('@angular/material/progress-spinner'), require('@angular/material/select'), require('@angular/material/sidenav'), require('@angular/material/slide-toggle'), require('@angular/material/snack-bar'), require('@angular/material/table'), require('@angular/material'), require('@angular/material/tabs'), require('@angular/material/toolbar'), require('@angular/material/tooltip'), require('@angular/material/expansion'), require('@angular/material/datepicker'), require('@angular/material/list'), require('@angular/material/tree'), require('@angular/material/badge'), require('@angular/material/stepper'), require('@angular/material/divider'), require('@angular/common'), require('@angular/common/http'), require('@angular/forms'), require('@angular/flex-layout'), require('@ngx-translate/core'), require('angular-oauth2-oidc'), require('@angular/router'), require('rxjs'), require('@swimlane/ngx-charts'), require('@angular/platform-browser'), require('util'), require('@angular/cdk/coercion'), require('rxjs/operators'), require('@angular/cdk/tree'), require('@angular/cdk/collections'), require('@angular/material-moment-adapter'), require('moment'), require('@angular/animations'), require('@angular/cdk/stepper')) :
    typeof define === 'function' && define.amd ? define('toco-lib', ['exports', '@angular/core', '@angular/cdk/layout', '@angular/material/autocomplete', '@angular/material/button', '@angular/material/button-toggle', '@angular/material/card', '@angular/material/checkbox', '@angular/material/chips', '@angular/material/core', '@angular/material/dialog', '@angular/material/form-field', '@angular/material/grid-list', '@angular/material/icon', '@angular/material/input', '@angular/material/menu', '@angular/material/paginator', '@angular/material/progress-bar', '@angular/material/progress-spinner', '@angular/material/select', '@angular/material/sidenav', '@angular/material/slide-toggle', '@angular/material/snack-bar', '@angular/material/table', '@angular/material', '@angular/material/tabs', '@angular/material/toolbar', '@angular/material/tooltip', '@angular/material/expansion', '@angular/material/datepicker', '@angular/material/list', '@angular/material/tree', '@angular/material/badge', '@angular/material/stepper', '@angular/material/divider', '@angular/common', '@angular/common/http', '@angular/forms', '@angular/flex-layout', '@ngx-translate/core', 'angular-oauth2-oidc', '@angular/router', 'rxjs', '@swimlane/ngx-charts', '@angular/platform-browser', 'util', '@angular/cdk/coercion', 'rxjs/operators', '@angular/cdk/tree', '@angular/cdk/collections', '@angular/material-moment-adapter', 'moment', '@angular/animations', '@angular/cdk/stepper'], factory) :
    (global = global || self, factory(global['toco-lib'] = {}, global.ng.core, global.ng.cdk.layout, global.ng.material.autocomplete, global.ng.material.button, global.ng.material['button-toggle'], global.ng.material.card, global.ng.material.checkbox, global.ng.material.chips, global.ng.material.core, global.ng.material.dialog, global.ng.material['form-field'], global.ng.material['grid-list'], global.ng.material.icon, global.ng.material.input, global.ng.material.menu, global.ng.material.paginator, global.ng.material['progress-bar'], global.ng.material['progress-spinner'], global.ng.material.select, global.ng.material.sidenav, global.ng.material['slide-toggle'], global.ng.material['snack-bar'], global.ng.material.table, global.ng.material, global.ng.material.tabs, global.ng.material.toolbar, global.ng.material.tooltip, global.ng.material.expansion, global.ng.material.datepicker, global.ng.material.list, global.ng.material.tree, global.ng.material.badge, global.ng.material.stepper, global.ng.material.divider, global.ng.common, global.ng.common.http, global.ng.forms, global.ng['flex-layout'], global.core$2, global.angularOauth2Oidc, global.ng.router, global.rxjs, global.ngxCharts, global.ng.platformBrowser, global.util, global.ng.cdk.coercion, global.rxjs.operators, global.ng.cdk.tree, global.ng.cdk.collections, global.ng['material-moment-adapter'], global.moment, global.ng.animations, global.ng.cdk.stepper));
}(this, (function (exports, core, layout, autocomplete, button, buttonToggle, card, checkbox, chips, core$1, dialog, formField, gridList, icon, input, menu, paginator, progressBar, progressSpinner, select, sidenav, slideToggle, snackBar, table, material, tabs, toolbar, tooltip, expansion, datepicker, list, tree, badge, stepper, divider, common, http, forms, flexLayout, core$2, angularOauth2Oidc, router, rxjs, ngxCharts, platformBrowser, util, coercion, operators, tree$1, collections, materialMomentAdapter, moment, animations, stepper$1) { 'use strict';

    moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __createBinding(o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
    }

    function __exportStar(m, exports) {
        for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/toco-lib.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TocoLibService = /** @class */ (function () {
        function TocoLibService() {
        }
        TocoLibService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        TocoLibService.ctorParameters = function () { return []; };
        /** @nocollapse */ TocoLibService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function TocoLibService_Factory() { return new TocoLibService(); }, token: TocoLibService, providedIn: "root" });
        return TocoLibService;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/toco-lib.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TocoLibComponent = /** @class */ (function () {
        function TocoLibComponent() {
        }
        /**
         * @return {?}
         */
        TocoLibComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
        };
        TocoLibComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'lib-toco-lib',
                        template: "\n    <p>\n      toco-lib works!\n    </p>\n  "
                    }] }
        ];
        /** @nocollapse */
        TocoLibComponent.ctorParameters = function () { return []; };
        return TocoLibComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/toco-lib.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TocoLibModule = /** @class */ (function () {
        function TocoLibModule() {
        }
        TocoLibModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [TocoLibComponent],
                        imports: [],
                        exports: [TocoLibComponent]
                    },] }
        ];
        return TocoLibModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/angular-material/angular-material.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A module that contains all angular material modules that are needed.
     */
    var AngularMaterialModule = /** @class */ (function () {
        function AngularMaterialModule() {
        }
        AngularMaterialModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [
                            layout.LayoutModule,
                            button.MatButtonModule,
                            buttonToggle.MatButtonToggleModule,
                            menu.MatMenuModule,
                            toolbar.MatToolbarModule,
                            tooltip.MatTooltipModule,
                            icon.MatIconModule,
                            card.MatCardModule,
                            input.MatInputModule,
                            checkbox.MatCheckboxModule,
                            formField.MatFormFieldModule,
                            dialog.MatDialogModule,
                            gridList.MatGridListModule,
                            snackBar.MatSnackBarModule,
                            progressBar.MatProgressBarModule,
                            progressSpinner.MatProgressSpinnerModule,
                            sidenav.MatSidenavModule,
                            tabs.MatTabsModule,
                            chips.MatChipsModule,
                            table.MatTableModule,
                            material.MatSortModule,
                            paginator.MatPaginatorModule,
                            slideToggle.MatSlideToggleModule,
                            select.MatSelectModule,
                            core$1.MatOptionModule,
                            autocomplete.MatAutocompleteModule,
                            expansion.MatExpansionModule,
                            datepicker.MatDatepickerModule,
                            core$1.MatNativeDateModule,
                            list.MatListModule,
                            tree.MatTreeModule,
                            badge.MatBadgeModule,
                            stepper.MatStepperModule,
                            core$1.MatRippleModule,
                            divider.MatDividerModule,
                        ],
                        exports: [
                            layout.LayoutModule,
                            button.MatButtonModule,
                            buttonToggle.MatButtonToggleModule,
                            menu.MatMenuModule,
                            toolbar.MatToolbarModule,
                            tooltip.MatTooltipModule,
                            icon.MatIconModule,
                            card.MatCardModule,
                            input.MatInputModule,
                            checkbox.MatCheckboxModule,
                            formField.MatFormFieldModule,
                            dialog.MatDialogModule,
                            gridList.MatGridListModule,
                            snackBar.MatSnackBarModule,
                            progressSpinner.MatProgressSpinnerModule,
                            progressBar.MatProgressBarModule,
                            sidenav.MatSidenavModule,
                            tabs.MatTabsModule,
                            chips.MatChipsModule,
                            table.MatTableModule,
                            material.MatSortModule,
                            paginator.MatPaginatorModule,
                            slideToggle.MatSlideToggleModule,
                            select.MatSelectModule,
                            core$1.MatOptionModule,
                            autocomplete.MatAutocompleteModule,
                            expansion.MatExpansionModule,
                            datepicker.MatDatepickerModule,
                            core$1.MatNativeDateModule,
                            list.MatListModule,
                            tree.MatTreeModule,
                            badge.MatBadgeModule,
                            stepper.MatStepperModule,
                            core$1.MatRippleModule,
                            divider.MatDividerModule,
                        ]
                    },] }
        ];
        return AngularMaterialModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/angular-material/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/shared/shared.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A module that contains all shared modules.
     */
    var SharedModule = /** @class */ (function () {
        function SharedModule() {
        }
        SharedModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [],
                        imports: [
                            common.CommonModule,
                            http.HttpClientModule,
                            forms.FormsModule,
                            flexLayout.FlexLayoutModule,
                            AngularMaterialModule
                        ],
                        exports: [
                            common.CommonModule,
                            http.HttpClientModule,
                            forms.FormsModule,
                            flexLayout.FlexLayoutModule,
                            AngularMaterialModule
                        ],
                        schemas: [
                            core.CUSTOM_ELEMENTS_SCHEMA
                        ]
                    },] }
        ];
        return SharedModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/shared/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/env.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /*
     *   Copyright (c) 2020 Universidad de Pinar del Río "Hermanos Saíz Montes de Oca"
     *   All rights reserved.
     */
    /**
     * @abstract
     */
    var   /**
     * @abstract
     */
    Environment = /** @class */ (function () {
        function Environment() {
        }
        return Environment;
    }());
    if (false) {
        /** @type {?} */
        Environment.prototype.production;
        /** @type {?} */
        Environment.prototype.sceibaHost;
        /** @type {?} */
        Environment.prototype.sceibaApi;
        /** @type {?} */
        Environment.prototype.cuorHost;
        /** @type {?} */
        Environment.prototype.cuorApi;
        /** @type {?} */
        Environment.prototype.appHost;
        /** @type {?} */
        Environment.prototype.appName;
        /** @type {?} */
        Environment.prototype.websiteUsername_Twitter;
        /** @type {?} */
        Environment.prototype.websiteUsername_Facebook;
        /** @type {?} */
        Environment.prototype.oauthRedirectUri;
        /** @type {?} */
        Environment.prototype.oauthClientId;
        /** @type {?} */
        Environment.prototype.oauthScope;
        /** @type {?} */
        Environment.prototype.topOrganizationPID;
        /** @type {?} */
        Environment.prototype.cachableUrls;
        /** @type {?} */
        Environment.prototype.matomoUrl;
        /** @type {?} */
        Environment.prototype.matomoSiteId;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/body/body.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var BodyComponent = /** @class */ (function () {
        function BodyComponent() {
        }
        /**
         * @return {?}
         */
        BodyComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            this.doReplace();
        };
        /**
         * @return {?}
         */
        BodyComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.body) {
                this.doReplace();
            }
        };
        /**
         * @return {?}
         */
        BodyComponent.prototype.doReplace = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var find = "/public/inline-images/";
            /** @type {?} */
            var replace = "/public/inline-images/";
            /** @type {?} */
            var str = this.body.replace(find, replace);
            this.processed = str;
        };
        BodyComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-body',
                        template: "\n<div class=\"container mat-body\">\n  <div class=\"e2e-inner-html-bound  text-align-justify\" [innerHTML]=\"body\"> </div>\n</div>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        BodyComponent.ctorParameters = function () { return []; };
        BodyComponent.propDecorators = {
            body: [{ type: core.Input }]
        };
        return BodyComponent;
    }());
    if (false) {
        /** @type {?} */
        BodyComponent.prototype.body;
        /** @type {?} */
        BodyComponent.prototype.processed;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/error404/error404.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Error404Component = /** @class */ (function () {
        function Error404Component() {
        }
        /**
         * @return {?}
         */
        Error404Component.prototype.ngOnInit = /**
         * @return {?}
         */
        function () { };
        Error404Component.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-error404',
                        template: "<p>\n  error404 works!\n</p>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        Error404Component.ctorParameters = function () { return []; };
        return Error404Component;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/footer/footer.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FooterComponent = /** @class */ (function () {
        function FooterComponent() {
        }
        /**
         * @return {?}
         */
        FooterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.sites == undefined)
                this.sites = new Array();
            if (this.information == undefined)
                this.information = new Array();
        };
        FooterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-footer',
                        template: "<div class=\"alternate-theme-footer\">\n\n    <mat-toolbar class=\"footer-height\" fxLayout='row wrap' fxLayout.mx=\"column\" fxLayoutAlign=\"center center\" color=\"primary\">\n        <ng-container *ngIf=\"image\">\n            <a href=\"/\">\n                <img src=\"{{ image }}\" alt=\"Sceiba\" width=\"150\"\n                    style=\"padding-top: .9em; padding-bottom: .9em;\">\n            </a>\n        </ng-container>\n\n        <mat-toolbar-row \n            fxLayout='row wrap'\n            fxLayout.mx=\"column\"\n            fxLayoutAlign=\"center start\"\n            fxLayoutGap=\"20px\"\n        >\n            <div fxFlex=\"30%\" fxFlex.xs=\"100%\">\n                \n                <div fxLayout='column wrap' fxLayoutAlign=\"center center\" fxLayoutGap=\"1em\">\n\n                    <img src=\"/assets/images/tocororo.png\" alt=\"Tocororo\" width=\"90\" height=\"90\">\n                    <span class=\"text-initial\" style=\"max-width: 30em; text-align: center;\">Proyecto Nacional Tocororo, un esfuerzo por la comunicaci\u00F3n cient\u00EDfica en Cuba. </span>\n\n                    <a mat-raised-button href=\"/sources/new/journal\" color=\"warn\">Incl\u00FAyete</a>\n                </div>\n            </div>\n            <div fxLayout='column wrap' fxFlex=\"30%\" fxFlex.xs=\"100%\">\n                <span class=\"text-large\">Sitios de Inter\u00E9s</span>\n                <ng-container *ngFor=\"let item of sites\">\n                    <a mat-button\n                        class=\"aling-left\"\n                        color=\"warn\"\n                        *ngIf=\"item.useRouterLink\"\n                        [routerLink]=\"[item.url]\"\n                        [ngStyle]=\"{'line-height': 'initial', 'padding': '10px 16px'}\"\n                    >\n                        {{ item.name }}\n                    </a>\n                    <a mat-button\n                        class=\"aling-left\"\n                        color=\"warn\"\n                        *ngIf=\" ! item.useRouterLink\"\n                        href=\"{{ item.url }}\"\n                        target=\"_blank\"\n                        [ngStyle]=\"{'line-height': 'initial', 'padding': '10px 16px'}\"\n                    >\n                        {{ item.name }}\n                    </a>\n                </ng-container>\n            </div>\n            <div fxLayout='column wrap' fxFlex=\"30%\" fxFlex.xs=\"100%\">\n                <span class=\"text-large\">Informaci\u00F3n General</span>\n                <ng-container *ngFor=\"let item of information\">\n                    <a mat-button\n                        class=\"aling-left\"\n                        color=\"warn\"\n                        [routerLink]=\"[item.url]\"\n                        *ngIf=\"item.useRouterLink\"\n                        [ngStyle]=\"{'line-height': 'initial', 'padding': '10px 16px'}\"\n                    >\n                        {{ item.name }}\n                    </a>\n                    <a mat-button\n                        class=\"aling-left\"\n                        color=\"warn\"\n                        *ngIf=\" ! item.useRouterLink\"\n                        href=\"{{ item.url }}\"\n                        target=\"_blank\"\n                        [ngStyle]=\"{'line-height': 'initial', 'padding': '10px 16px'}\"\n                    >\n                        {{ item.name }}\n                    </a>\n                </ng-container>\n            </div>\n        </mat-toolbar-row>\n\n        <!-- <mat-toolbar-row fxLayout='row wrap' fxLayout.mx=\"column\" fxLayoutAlign=\"center center\" fxLayoutGap=\"15px\" style=\"padding-bottom: 15px;\">\n            <a mat-mini-fab matTooltip=\"Facebook\" href=\"https://facebook.com\" color=\"accent\"\n                style=\"font-size: x-large; margin-bottom: 15px !important;\">\n                f\n            </a>\n            <a mat-mini-fab matTooltip=\"Twitter\" href=\"https://twitter.com\" color=\"accent\" \n                style=\"font-size: x-large; margin-bottom: 15px !important;\">\n                t\n            </a>\n        </mat-toolbar-row> -->\n\n    </mat-toolbar>\n\n    <mat-toolbar fxLayout='column wrap' fxLayoutAlign=\"center center\" style=\"padding: 1em;\">\n        <a href=\"https://sceiba-lab.upr.edu.cu\" target=\"_blank\" style=\"color: rgb(0, 0, 0, 0.87); text-decoration: none;\">\n            <img src=\"/assets/images/sceiba-logo.png\" alt=\"Sceiba\" width=\"120\" height=\"50\">\n        </a>\n        <a href=\"https://sceiba-lab.upr.edu.cu\" target=\"_blank\" style=\"color: rgb(0, 0, 0, 0.87); text-decoration: none;\">\n            Portal de publicaciones cientificas cubanas\n        </a>\n    </mat-toolbar>\n</div>",
                        styles: ["mat-toolbar.footer-height{height:auto!important;padding-top:20px;padding-bottom:20px}.mat-toolbar-row,.mat-toolbar-single-row{white-space:normal!important;height:auto!important}.text-small{font-size:small}.text-initial{font-size:initial;line-height:initial}.text-large{font-size:x-large}.aling-left{text-align:left;white-space:normal!important}"]
                    }] }
        ];
        /** @nocollapse */
        FooterComponent.ctorParameters = function () { return []; };
        FooterComponent.propDecorators = {
            sites: [{ type: core.Input }],
            information: [{ type: core.Input }],
            image: [{ type: core.Input }]
        };
        return FooterComponent;
    }());
    if (false) {
        /** @type {?} */
        FooterComponent.prototype.sites;
        /** @type {?} */
        FooterComponent.prototype.information;
        /** @type {?} */
        FooterComponent.prototype.image;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/metadata.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A service that is used to set the title and metadata of a route.
     * This service is important for things like configuring a Content Security Policy,
     * defining browser compatibility and security settings, setting HTTP Headers,
     * defining rich content for social sharing, and Search Engine Optimization (SEO).
     */
    var MetadataService = /** @class */ (function () {
        function MetadataService(bodyTitle, meta, _router, env) {
            this.bodyTitle = bodyTitle;
            this.meta = meta;
            this._router = _router;
            this.env = env;
        }
        /**
         * Sets the page metadata for SEO and standard social networks.
         * @param title The title to set. Maximum length 60-70 characters.
         * @param description The description to set. Maximum length 155 characters.
         * @param image The image to set. If the value is empty, then the image is not set.
         * The image must be at least 280px in width and 150px in height; and must be less than 1Mb in size.
         */
        /**
         * Sets the page metadata for SEO and standard social networks.
         * @param {?} title The title to set. Maximum length 60-70 characters.
         * @param {?} description The description to set. Maximum length 155 characters.
         * @param {?=} image The image to set. If the value is empty, then the image is not set.
         * The image must be at least 280px in width and 150px in height; and must be less than 1Mb in size.
         * @return {?}
         */
        MetadataService.prototype.setStandardMeta = /**
         * Sets the page metadata for SEO and standard social networks.
         * @param {?} title The title to set. Maximum length 60-70 characters.
         * @param {?} description The description to set. Maximum length 155 characters.
         * @param {?=} image The image to set. If the value is empty, then the image is not set.
         * The image must be at least 280px in width and 150px in height; and must be less than 1Mb in size.
         * @return {?}
         */
        function (title, description, image) {
            if (image === void 0) { image = ""; }
            /* The canonical URL for your page. This should be the undecorated URL,
                    without session variables, user identifying parameters, or counters. */
            /** @type {?} */
            var url = this.env.appHost + this._router.url;
            //console.log('The URL for metadata is: ', url);
            image = this.env.appHost + image;
            /* Primary metadata. */
            /* Maximum length 60-70 characters. */
            this.bodyTitle.setTitle(title + " | " + this.env.appName); /* Sets the title of the current HTML document. */
            /* Maximum length 155 characters. */
            this.meta.updateTag({ name: "description", content: description });
            /* Schema.org markup for Google+. */
            this.meta.updateTag({ itemprop: "name", title: title });
            this.meta.updateTag({ itemprop: "description", content: description });
            if (image)
                this.meta.updateTag({ itemprop: "image", content: image });
            /* Twitter Card data */
            this.meta.updateTag({ name: "twitter:card", content: "summary_large_image" });
            /* Non-Essential, but required for analytics tool. */
            this.meta.updateTag({ name: "twitter:site", content: this.env.websiteUsername_Twitter }); /* @website-username */
            this.meta.updateTag({ name: "twitter:title", content: title });
            this.meta.updateTag({ name: "twitter:description", content: description });
            /* Twitter summary card with large image must be at least 280px x 150px. */
            if (image)
                this.meta.updateTag({ name: "twitter:image:src", content: image });
            //        this.meta.updateTag({ name: "twitter:image:alt", content: "Alt text for image..." });
            /* Open Graph data, Twitter, Facebook, and Linkedin. */
            this.meta.updateTag({ property: "og:title", content: title });
            this.meta.updateTag({ property: "og:type", content: "website" });
            this.meta.updateTag({ property: "og:url", content: url });
            if (image)
                this.meta.updateTag({ property: "og:image", content: image });
            this.meta.updateTag({ property: "og:description", content: description });
            this.meta.updateTag({ property: "og:site_name", content: this.env.appName });
        };
        MetadataService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        MetadataService.ctorParameters = function () { return [
            { type: platformBrowser.Title },
            { type: platformBrowser.Meta },
            { type: router.Router },
            { type: Environment }
        ]; };
        /** @nocollapse */ MetadataService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function MetadataService_Factory() { return new MetadataService(core.ɵɵinject(platformBrowser.Title), core.ɵɵinject(platformBrowser.Meta), core.ɵɵinject(router.Router), core.ɵɵinject(Environment)); }, token: MetadataService, providedIn: "root" });
        return MetadataService;
    }());
    if (false) {
        /** @type {?} */
        MetadataService.prototype.bodyTitle;
        /** @type {?} */
        MetadataService.prototype.meta;
        /**
         * @type {?}
         * @private
         */
        MetadataService.prototype._router;
        /** @type {?} */
        MetadataService.prototype.env;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/home/home.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HomeComponent = /** @class */ (function () {
        function HomeComponent(metadata) {
            this.metadata = metadata;
        }
        /**
         * @return {?}
         */
        HomeComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.metadata.setStandardMeta("Inicio", "", "");
        };
        HomeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-home',
                        template: "<p>\n  home works!\n</p>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        HomeComponent.ctorParameters = function () { return [
            { type: MetadataService }
        ]; };
        return HomeComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        HomeComponent.prototype.metadata;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/entities.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var EntitiesModule = /** @class */ (function () {
        function EntitiesModule() {
        }
        EntitiesModule.decorators = [
            { type: core.NgModule, args: [{},] }
        ];
        return EntitiesModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/common.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /*
     *   Copyright (c) 2020 Universidad de Pinar del Río "Hermanos Saíz Montes de Oca"
     *   All rights reserved.
     */
    /**
     * La idea de esta clase es tener un deserializador.
     */
    var   /**
     * La idea de esta clase es tener un deserializador.
     */
    EntityBase = /** @class */ (function (_super) {
        __extends(EntityBase, _super);
        function EntityBase() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @param {?} data
         * @param {?=} exclude
         * @return {?}
         */
        EntityBase.prototype.deepcopy = /**
         * @param {?} data
         * @param {?=} exclude
         * @return {?}
         */
        function (data, exclude) {
            var e_1, _a;
            if (exclude === void 0) { exclude = []; }
            /** @type {?} */
            var keys = Object.keys(this);
            try {
                for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                    var key = keys_1_1.value;
                    if (data[key] && !exclude.includes(key)) {
                        // console.log('DEEEPCOPY OF : ', key, data[key])
                        // if(this.toBoolean(data[key])){
                        //   console.log('TO BOOLEAN IS TRUE !!!!!! ');
                        //   this[key] = data[key].toLowerCase() === 'true';
                        // } else {
                        // if (this[key] instanceof EntityBaseList) {
                        //   console.log('RECUSIVE CALL ON EntityBaseList',  this[key]);
                        //   this[key].deepcopy(data[key], exclude);
                        // } else{
                        if (this[key] instanceof EntityBase) {
                            console.log('RECUSIVE CALL ON EntityBase', this[key]);
                            this[key].deepcopy(data[key], exclude);
                        }
                        else {
                            this[key] = data[key];
                        }
                        // }
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        EntityBase.prototype.toBoolean = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'string' || value instanceof String) {
                console.log('DEEPCOPY ----------  TO BOOLEAN ------------ VAL=', value);
                console.log(value.toLowerCase() === 'true' || value.toLowerCase() === 'false');
                return value.toLowerCase() === 'true' || value.toLowerCase() === 'false';
            }
            return false;
        };
        return EntityBase;
    }(Object));
    // export class EntityBaseList<T extends EntityBase> extends Array<T> {
    //   constructor(private entityType: new () => T ){
    //     super();
    //   }
    //   getNew() : T {
    //     return new this.entityType();
    //   }
    //   public deepcopy(data: any[]): void {
    //     for (let i = 0; i < data.length; i++) {
    //       const element = data[i];
    //       let e  = this.getNew();
    //       e.deepcopy(element);
    //       this.push(e);
    //     }
    //   }
    //   public concat(list: EntityBaseList<T>){
    //     this.concat(list);
    //     return this;
    //   }
    // }
    /**
     * Created by Edel on 02/04/2018.
     */
    var   
    // export class EntityBaseList<T extends EntityBase> extends Array<T> {
    //   constructor(private entityType: new () => T ){
    //     super();
    //   }
    //   getNew() : T {
    //     return new this.entityType();
    //   }
    //   public deepcopy(data: any[]): void {
    //     for (let i = 0; i < data.length; i++) {
    //       const element = data[i];
    //       let e  = this.getNew();
    //       e.deepcopy(element);
    //       this.push(e);
    //     }
    //   }
    //   public concat(list: EntityBaseList<T>){
    //     this.concat(list);
    //     return this;
    //   }
    // }
    /**
     * Created by Edel on 02/04/2018.
     */
    Entity = /** @class */ (function (_super) {
        __extends(Entity, _super);
        function Entity() {
            var _this = _super.call(this) || this;
            _this.id = '';
            /**
             * By default is FALSE. If TRUE, means that the entity does not have valid identifiers or has not been saved to the backend.
             */
            _this.isNew = false;
            // raw_data: String;
            // created_at: String;
            // updated_at: String;
            _this.identifiers = new Array();
            return _this;
        }
        /**
         * @param {?} idtype
         * @return {?}
         */
        Entity.prototype.getIdentifierValue = /**
         * @param {?} idtype
         * @return {?}
         */
        function (idtype) {
            /** @type {?} */
            var id = this.identifiers.find((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return value.idtype == idtype; }));
            return id != undefined ? id.value : '';
        };
        /**
         * @param {?} idtype
         * @param {?} value
         * @return {?}
         */
        Entity.prototype.setIdentifierValue = /**
         * @param {?} idtype
         * @param {?} value
         * @return {?}
         */
        function (idtype, value) {
            if (value != '') {
                /** @type {?} */
                var added = false;
                for (var index = 0; index < this.identifiers.length; index++) {
                    if (this.identifiers[index].idtype == idtype) {
                        this.identifiers[index].value = value;
                        added = true;
                    }
                }
                if (!added) {
                    /** @type {?} */
                    var id = new Identifier();
                    id.idtype = idtype;
                    id.value = value;
                    this.identifiers.push(id);
                }
            }
        };
        /**
         * return JSON.stringify, using a function to exclude object fields id and uuid
         */
        /**
         * return JSON.stringify, using a function to exclude object fields id and uuid
         * @return {?}
         */
        Entity.prototype.entitystringify = /**
         * return JSON.stringify, using a function to exclude object fields id and uuid
         * @return {?}
         */
        function () {
            return JSON.stringify(this, (/**
             * @param {?} k
             * @param {?} v
             * @return {?}
             */
            function (k, v) {
                // if (k !== "id" && k !== "uuid" && k !== "isNew") {
                if (k !== "isNew" && k !== "entityType" && (v != null && v != '' && v != undefined && v != [])) {
                    return v;
                }
            }));
        };
        return Entity;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        Entity.prototype.id;
        /**
         * By default is FALSE. If TRUE, means that the entity does not have valid identifiers or has not been saved to the backend.
         * @type {?}
         */
        Entity.prototype.isNew;
        /** @type {?} */
        Entity.prototype.identifiers;
    }
    /**
     * Entity for `Identifier` based on schema `organization-v1.0.0.json`.
     * Organization Identifier, different from GRID mapping.
     */
    var   /**
     * Entity for `Identifier` based on schema `organization-v1.0.0.json`.
     * Organization Identifier, different from GRID mapping.
     */
    Identifier = /** @class */ (function (_super) {
        __extends(Identifier, _super);
        function Identifier() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Identifier value.
             */
            _this.value = "";
            return _this;
        }
        return Identifier;
    }(EntityBase));
    if (false) {
        /**
         * Identifier type.
         * @type {?}
         */
        Identifier.prototype.idtype;
        /**
         * Identifier value.
         * @type {?}
         */
        Identifier.prototype.value;
    }
    /** @enum {string} */
    var IdentifierSchemas = {
        ark: "ark",
        arxiv: "arxiv",
        doi: "doi",
        bibcode: "bibcode",
        ean8: "ean8",
        ean13: "ean13",
        handle: "handle",
        isbn: "isbn",
        issn_p: "issn_p",
        issn_l: "issn_l",
        issn_e: "issn_e",
        issn_c: "issn_c",
        issn_o: "issn_o",
        istc: "istc",
        lsid: "lsid",
        pmid: "pmid",
        pmcid: "pmcid",
        purl: "purl",
        upc: "upc",
        url: "url",
        urn: "urn",
        orcid: "orcid",
        gnd: "gnd",
        ads: "ads",
        oai: "oai",
        prnps: "prnps",
        ernps: "ernps",
        oaiurl: "oaiurl",
        grid: "grid",
        wkdata: "wkdata",
        ror: "ror",
        isni: "isni",
        fudref: "fudref",
        orgref: "orgref",
        reup: "reup",
    };
    var Links = /** @class */ (function (_super) {
        __extends(Links, _super);
        function Links() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.self = "";
            _this.next = "";
            _this.prev = "";
            return _this;
        }
        return Links;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        Links.prototype.self;
        /** @type {?} */
        Links.prototype.next;
        /** @type {?} */
        Links.prototype.prev;
    }
    var AggrBucket = /** @class */ (function (_super) {
        __extends(AggrBucket, _super);
        function AggrBucket() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.doc_count = 0;
            _this.key = "";
            return _this;
        }
        return AggrBucket;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        AggrBucket.prototype.doc_count;
        /** @type {?} */
        AggrBucket.prototype.key;
    }
    var AggrMeta = /** @class */ (function (_super) {
        __extends(AggrMeta, _super);
        function AggrMeta() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.order = 0;
            _this.title = "";
            return _this;
        }
        return AggrMeta;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        AggrMeta.prototype.order;
        /** @type {?} */
        AggrMeta.prototype.title;
    }
    var Aggr = /** @class */ (function (_super) {
        __extends(Aggr, _super);
        function Aggr() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.buckets = new Array();
            _this.meta = new AggrMeta();
            _this.doc_count_error_upper_bound = 0;
            _this.sum_other_doc_count = 0;
            return _this;
        }
        return Aggr;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        Aggr.prototype.buckets;
        /** @type {?} */
        Aggr.prototype.meta;
        /** @type {?} */
        Aggr.prototype.doc_count_error_upper_bound;
        /** @type {?} */
        Aggr.prototype.sum_other_doc_count;
    }
    /**
     * @template T
     */
    var   /**
     * @template T
     */
    Hit = /** @class */ (function (_super) {
        __extends(Hit, _super);
        function Hit() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.id = "";
            _this.created = "";
            _this.updated = "";
            _this.links = new Links();
            _this.revision = 0;
            return _this;
        }
        return Hit;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        Hit.prototype.id;
        /** @type {?} */
        Hit.prototype.created;
        /** @type {?} */
        Hit.prototype.updated;
        /** @type {?} */
        Hit.prototype.links;
        /** @type {?} */
        Hit.prototype.metadata;
        /** @type {?} */
        Hit.prototype.revision;
        /** @type {?} */
        Hit.prototype.revisions;
    }
    /**
     * @template T
     */
    var   /**
     * @template T
     */
    HitList = /** @class */ (function (_super) {
        __extends(HitList, _super);
        function HitList() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.hits = new Array();
            return _this;
        }
        return HitList;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        HitList.prototype.hits;
        /** @type {?} */
        HitList.prototype.total;
    }
    /**
     * @template T
     */
    var   /**
     * @template T
     */
    SearchResponse = /** @class */ (function (_super) {
        __extends(SearchResponse, _super);
        function SearchResponse() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.aggregations = {};
            _this.hits = new HitList();
            _this.links = new Links();
            return _this;
        }
        return SearchResponse;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        SearchResponse.prototype.aggregations;
        /** @type {?} */
        SearchResponse.prototype.hits;
        /** @type {?} */
        SearchResponse.prototype.links;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/evaluation.entity.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var CategoryQuestionType = {
        /**
         * The `bool` type is the default type. It shows a boolean control.
         */
        bool: "bool",
        /**
         * It shows a numeric control.
         */
        integer: "integer",
        /**
         * It shows a select control.
         */
        select: "select",
    };
    /**
     * Entity for CategoryQuestion based on schema `...-v1.0.0.json`.
     * Represents a survey section category question.
     */
    var   /**
     * Entity for CategoryQuestion based on schema `...-v1.0.0.json`.
     * Represents a survey section category question.
     */
    CategoryQuestion = /** @class */ (function (_super) {
        __extends(CategoryQuestion, _super);
        function CategoryQuestion() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * This field is filled internally.
             * For internal use only.
             */
            _this._inputContent = undefined;
            return _this;
        }
        return CategoryQuestion;
    }(EntityBase));
    if (false) {
        /**
         * Question type.
         * @type {?}
         */
        CategoryQuestion.prototype.type;
        /**
         * Question id.
         * @type {?}
         */
        CategoryQuestion.prototype.id;
        /**
         * Question description.
         * @type {?}
         */
        CategoryQuestion.prototype.desc;
        /**
         * Question hint.
         * @type {?}
         */
        CategoryQuestion.prototype.hint;
        /**
         * Question answer.
         * @type {?}
         */
        CategoryQuestion.prototype.answer;
        /**
         * Possible minimum value. It is used if `type` == CategoryQuestionType.integer.
         * @type {?}
         */
        CategoryQuestion.prototype.min;
        /**
         * Possible maximum value. It is used if `type` == CategoryQuestionType.integer.
         * @type {?}
         */
        CategoryQuestion.prototype.max;
        /**
         * Options list that can be selected. It is used if `type` == CategoryQuestionType.select.
         * @type {?}
         */
        CategoryQuestion.prototype.selectOptions;
        /**
         * This field is filled internally.
         * For internal use only.
         * @type {?}
         */
        CategoryQuestion.prototype._inputContent;
    }
    /**
     * Entity for SectionCategory based on schema `...-v1.0.0.json`.
     * Represents a survey section category.
     */
    var   /**
     * Entity for SectionCategory based on schema `...-v1.0.0.json`.
     * Represents a survey section category.
     */
    SectionCategory = /** @class */ (function (_super) {
        __extends(SectionCategory, _super);
        function SectionCategory() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SectionCategory;
    }(EntityBase));
    if (false) {
        /**
         * Category title.
         * @type {?}
         */
        SectionCategory.prototype.title;
        /**
         * Category desription.
         * @type {?}
         */
        SectionCategory.prototype.desc;
        /**
         * An array of questions associated with the category.
         * @type {?}
         */
        SectionCategory.prototype.questions;
    }
    /**
     * Entity for SurveySection based on schema `...-v1.0.0.json`.
     * Represents a survey section.
     */
    var   /**
     * Entity for SurveySection based on schema `...-v1.0.0.json`.
     * Represents a survey section.
     */
    SurveySection = /** @class */ (function (_super) {
        __extends(SurveySection, _super);
        function SurveySection() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return SurveySection;
    }(EntityBase));
    if (false) {
        /**
         * Section title.
         * @type {?}
         */
        SurveySection.prototype.title;
        /**
         * An array of categories associated with the section.
         * @type {?}
         */
        SurveySection.prototype.categories;
    }
    /**
     * Entity for JournalGeneralData based on schema `...-v1.0.0.json`.
     * Represents the journal general data that a user fills in the first step.
     */
    var   /**
     * Entity for JournalGeneralData based on schema `...-v1.0.0.json`.
     * Represents the journal general data that a user fills in the first step.
     */
    JournalGeneralData = /** @class */ (function (_super) {
        __extends(JournalGeneralData, _super);
        function JournalGeneralData() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return JournalGeneralData;
    }(EntityBase));
    if (false) {
        /**
         * Journal name.
         * @type {?}
         */
        JournalGeneralData.prototype.name;
        /**
         * Journal URL page.
         * @type {?}
         */
        JournalGeneralData.prototype.url;
        /**
         * Journal ISSN.
         * @type {?}
         */
        JournalGeneralData.prototype.issn;
    }
    /**
     * Entity for Evaluation based on schema `...-v1.0.0.json`.
     */
    var   /**
     * Entity for Evaluation based on schema `...-v1.0.0.json`.
     */
    Evaluation = /** @class */ (function (_super) {
        __extends(Evaluation, _super);
        function Evaluation() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Evaluation;
    }(Entity));
    if (false) {
        /**
         * User who made the evaluation.
         * @type {?}
         */
        Evaluation.prototype.user;
        /**
         * Evaluation date.
         * @type {?}
         */
        Evaluation.prototype.date;
        /**
         * Journal Data.
         * @type {?}
         */
        Evaluation.prototype.journalData;
        /**
         * An array of sections associated with the survey.
         * @type {?}
         */
        Evaluation.prototype.sections;
    }
    /**
     * Entity for EvaluationOnlyAnswer based on schema `...-v1.0.0.json`.
     */
    var   /**
     * Entity for EvaluationOnlyAnswer based on schema `...-v1.0.0.json`.
     */
    EvaluationOnlyAnswer = /** @class */ (function (_super) {
        __extends(EvaluationOnlyAnswer, _super);
        function EvaluationOnlyAnswer() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return EvaluationOnlyAnswer;
    }(Entity));
    if (false) {
        /**
         * User who made the evaluation.
         * @type {?}
         */
        EvaluationOnlyAnswer.prototype.user;
        /**
         * Evaluation date.
         * @type {?}
         */
        EvaluationOnlyAnswer.prototype.date;
        /**
         * Journal Data.
         * @type {?}
         */
        EvaluationOnlyAnswer.prototype.journalData;
        /**
         * Journal survey.
         * @type {?}
         */
        EvaluationOnlyAnswer.prototype.survey;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/inst-repo.entity.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Entity for main Institution based on schema `...-v1.0.0.json`.
     */
    var   /**
     * Entity for main Institution based on schema `...-v1.0.0.json`.
     */
    MainInstitution = /** @class */ (function (_super) {
        __extends(MainInstitution, _super);
        function MainInstitution() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return MainInstitution;
    }(EntityBase));
    if (false) {
        /**
         * The name typically used to refer to the institute.
         * @type {?}
         */
        MainInstitution.prototype.name;
        /**
         * Organization Identifiers, different from GRID mapping.
         * @type {?}
         */
        MainInstitution.prototype.identifiers;
    }
    /**
     * Entity for Institutional Repository based on schema `...-v1.0.0.json`.
     */
    var   /**
     * Entity for Institutional Repository based on schema `...-v1.0.0.json`.
     */
    InstitutionalRepository = /** @class */ (function (_super) {
        __extends(InstitutionalRepository, _super);
        function InstitutionalRepository() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return InstitutionalRepository;
    }(Entity));
    if (false) {
        /**
         * Name of the region.
         * @type {?}
         */
        InstitutionalRepository.prototype.name;
        /**
         * Main Institution.
         * @type {?}
         */
        InstitutionalRepository.prototype.mainInst;
        /**
         * URL page for the institute.
         * @type {?}
         */
        InstitutionalRepository.prototype.url;
        /**
         * URL-OAI page for the institute.
         * @type {?}
         */
        InstitutionalRepository.prototype.url_oai;
    }
    /**
     * Represents an object of `MainInstitution` type with all its values set to empty.
     * The `identifiers` array field must have one empty value at least.
     * @type {?}
     */
    var mainInstEmpty = {
        'name': '',
        'identifiers': [{
                'idtype': '',
                'value': ''
            }]
    };
    /**
     * Represents an object of `InstitutionalRepository` type with all its values set to empty.
     * @type {?}
     */
    var instRepoEmpty = {
        'id': '',
        'name': '',
        'mainInst': mainInstEmpty,
        'url': '',
        'url_oai': ''
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/journal_reference.entity.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var JournalReference = /** @class */ (function (_super) {
        __extends(JournalReference, _super);
        function JournalReference() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return JournalReference;
    }(Entity));
    if (false) {
        /** @type {?} */
        JournalReference.prototype.reference;
        /** @type {?} */
        JournalReference.prototype.startdate;
        /** @type {?} */
        JournalReference.prototype.enddate;
        /** @type {?} */
        JournalReference.prototype.url;
    }
    var Reference = /** @class */ (function () {
        function Reference() {
        }
        return Reference;
    }());
    if (false) {
        /** @type {?} */
        Reference.prototype.name;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/organization.entity.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var OrganizationRelationships = {
        PARENT: { label: 'Padre', value: 'parent' },
        CHILD: { label: 'Hija', value: 'child' },
        RELATED: { label: 'Relacionada', value: 'related' },
    };
    /**
     * Entity for `LabelDiffLang` based on schema `organization-v1.0.0.json`.
     * Name of the institute in different language.
     */
    var   /**
     * Entity for `LabelDiffLang` based on schema `organization-v1.0.0.json`.
     * Name of the institute in different language.
     */
    LabelDiffLang = /** @class */ (function (_super) {
        __extends(LabelDiffLang, _super);
        function LabelDiffLang() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Institute name in a language variant.
             */
            _this.label = '';
            /**
             * ISO-639-1 language code.
             */
            _this.iso639 = '';
            return _this;
        }
        return LabelDiffLang;
    }(EntityBase));
    if (false) {
        /**
         * Institute name in a language variant.
         * @type {?}
         */
        LabelDiffLang.prototype.label;
        /**
         * ISO-639-1 language code.
         * @type {?}
         */
        LabelDiffLang.prototype.iso639;
    }
    /**
     * Entity for `Redirected` based on schema `organization-v1.0.0.json`.
     * Which organization redirects.
     */
    var   /**
     * Entity for `Redirected` based on schema `organization-v1.0.0.json`.
     * Which organization redirects.
     */
    Redirected = /** @class */ (function (_super) {
        __extends(Redirected, _super);
        function Redirected() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Institute name in a language variant.
             */
            _this.idtype = '';
            /**
             * ISO-639-1 language code.
             */
            _this.value = '';
            return _this;
        }
        return Redirected;
    }(EntityBase));
    if (false) {
        /**
         * Institute name in a language variant.
         * @type {?}
         */
        Redirected.prototype.idtype;
        /**
         * ISO-639-1 language code.
         * @type {?}
         */
        Redirected.prototype.value;
    }
    /**
     * Entity for `Relationship` based on schema `organization-v1.0.0.json`.
     * A relationship the institute has to other.
     */
    var   /**
     * Entity for `Relationship` based on schema `organization-v1.0.0.json`.
     * A relationship the institute has to other.
     */
    Relationship = /** @class */ (function (_super) {
        __extends(Relationship, _super);
        function Relationship() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Organization Identifiers, different from GRID mapping.
             */
            _this.identifiers = new Array();
            /**
             * Relationship type.
             */
            _this.type = '';
            /**
             * Name of the related institute.
             */
            _this.label = '';
            return _this;
        }
        return Relationship;
    }(Entity));
    if (false) {
        /**
         * Organization Identifiers, different from GRID mapping.
         * @type {?}
         */
        Relationship.prototype.identifiers;
        /**
         * Relationship type.
         * @type {?}
         */
        Relationship.prototype.type;
        /**
         * Name of the related institute.
         * @type {?}
         */
        Relationship.prototype.label;
    }
    /**
     * Entity for `GeoNamesAdmin` based on schema `organization-v1.0.0.json`.
     */
    var   /**
     * Entity for `GeoNamesAdmin` based on schema `organization-v1.0.0.json`.
     */
    GeoNamesAdmin = /** @class */ (function (_super) {
        __extends(GeoNamesAdmin, _super);
        function GeoNamesAdmin() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * ID in the region format.
             */
            _this.id = '';
            /**
             * Name of the region.
             */
            _this.name = '';
            /**
             * Preferred ASCII encoded name for the region.
             */
            _this.ascii_name = '';
            return _this;
        }
        return GeoNamesAdmin;
    }(EntityBase));
    if (false) {
        /**
         * ID in the region format.
         * @type {?}
         */
        GeoNamesAdmin.prototype.id;
        /**
         * Name of the region.
         * @type {?}
         */
        GeoNamesAdmin.prototype.name;
        /**
         * Preferred ASCII encoded name for the region.
         * @type {?}
         */
        GeoNamesAdmin.prototype.ascii_name;
    }
    /**
     * Entity for `GeoNamesCity` based on schema `organization-v1.0.0.json`.
     * The linked GeoNames data.
     */
    var   /**
     * Entity for `GeoNamesCity` based on schema `organization-v1.0.0.json`.
     * The linked GeoNames data.
     */
    GeoNamesCity = /** @class */ (function (_super) {
        __extends(GeoNamesCity, _super);
        function GeoNamesCity() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * GeoNames ID.
             */
            _this.id = 0;
            /**
             * Name of the city.
             */
            _this.city = '';
            /**
             * geonames_admin1.
             */
            _this.geonames_admin1 = undefined;
            /**
             * geonames_admin2.
             */
            _this.geonames_admin2 = undefined;
            /**
             * nuts_level1.
             */
            _this.nuts_level1 = undefined;
            /**
             * nuts_level2.
             */
            _this.nuts_level2 = undefined;
            /**
             * nuts_level3.
             */
            _this.nuts_level3 = undefined;
            return _this;
        }
        return GeoNamesCity;
    }(EntityBase));
    if (false) {
        /**
         * GeoNames ID.
         * @type {?}
         */
        GeoNamesCity.prototype.id;
        /**
         * Name of the city.
         * @type {?}
         */
        GeoNamesCity.prototype.city;
        /**
         * geonames_admin1.
         * @type {?}
         */
        GeoNamesCity.prototype.geonames_admin1;
        /**
         * geonames_admin2.
         * @type {?}
         */
        GeoNamesCity.prototype.geonames_admin2;
        /**
         * nuts_level1.
         * @type {?}
         */
        GeoNamesCity.prototype.nuts_level1;
        /**
         * nuts_level2.
         * @type {?}
         */
        GeoNamesCity.prototype.nuts_level2;
        /**
         * nuts_level3.
         * @type {?}
         */
        GeoNamesCity.prototype.nuts_level3;
    }
    /**
     * Entity for `Address` based on schema `organization-v1.0.0.json`.
     * An address associated with the institute.
     */
    var   /**
     * Entity for `Address` based on schema `organization-v1.0.0.json`.
     * An address associated with the institute.
     */
    Address = /** @class */ (function (_super) {
        __extends(Address, _super);
        function Address() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Name of the city.
             */
            _this.city = '';
            /**
             * Name of the country.
             */
            _this.country = '';
            /**
             * ISO 3166-1 alpha-2 code of the country.
             */
            _this.country_code = '';
            /**
             * Latitute of the institute.
             */
            _this.lat = 0;
            /**
             * Longitude of the institute.
             */
            _this.lng = 0;
            /**
             * First line of the address.
             */
            _this.line_1 = '';
            /**
             * Second line of the address.
             */
            _this.line_2 = '';
            /**
             * Third line of the address.
             */
            _this.line_3 = '';
            /**
             * Postcode/zipcode.
             */
            _this.postcode = '';
            /**
             * If there is more than one address, identifies the main location.
             * This address identifies the main location.
             */
            _this.primary = false;
            /**
             * Name of the state/region.
             */
            _this.state = '';
            /**
             * ISO 3166-2 region code.
             */
            _this.state_code = '';
            /**
             * Name of the municipality.
             */
            _this.municipality = '';
            /**
             * dpa municipality code.
             */
            _this.municipality_dpa = '';
            /**
             * Linked GeoNames data.
             */
            _this.geonames_city = undefined;
            return _this;
        }
        return Address;
    }(EntityBase));
    if (false) {
        /**
         * Name of the city.
         * @type {?}
         */
        Address.prototype.city;
        /**
         * Name of the country.
         * @type {?}
         */
        Address.prototype.country;
        /**
         * ISO 3166-1 alpha-2 code of the country.
         * @type {?}
         */
        Address.prototype.country_code;
        /**
         * Latitute of the institute.
         * @type {?}
         */
        Address.prototype.lat;
        /**
         * Longitude of the institute.
         * @type {?}
         */
        Address.prototype.lng;
        /**
         * First line of the address.
         * @type {?}
         */
        Address.prototype.line_1;
        /**
         * Second line of the address.
         * @type {?}
         */
        Address.prototype.line_2;
        /**
         * Third line of the address.
         * @type {?}
         */
        Address.prototype.line_3;
        /**
         * Postcode/zipcode.
         * @type {?}
         */
        Address.prototype.postcode;
        /**
         * If there is more than one address, identifies the main location.
         * This address identifies the main location.
         * @type {?}
         */
        Address.prototype.primary;
        /**
         * Name of the state/region.
         * @type {?}
         */
        Address.prototype.state;
        /**
         * ISO 3166-2 region code.
         * @type {?}
         */
        Address.prototype.state_code;
        /**
         * Name of the municipality.
         * @type {?}
         */
        Address.prototype.municipality;
        /**
         * dpa municipality code.
         * @type {?}
         */
        Address.prototype.municipality_dpa;
        /**
         * Linked GeoNames data.
         * @type {?}
         */
        Address.prototype.geonames_city;
    }
    /**
     * Entity for `RedirectPropertiesIdtype` based on schema `organization-v1.0.0.json`.
     * An address associated with the institute.
     */
    var   /**
     * Entity for `RedirectPropertiesIdtype` based on schema `organization-v1.0.0.json`.
     * An address associated with the institute.
     */
    RedirectPropertiesIdtype = /** @class */ (function (_super) {
        __extends(RedirectPropertiesIdtype, _super);
        function RedirectPropertiesIdtype() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * description for RedirectPropertiesIdtype.
             */
            _this.description = '';
            /**
             * type of RedirectPropertiesIdtype.
             */
            _this.type = '';
            /**
             * enum for RedirectPropertiesIdtype.
             */
            _this.enum = new Array();
            return _this;
        }
        return RedirectPropertiesIdtype;
    }(EntityBase));
    if (false) {
        /**
         * description for RedirectPropertiesIdtype.
         * @type {?}
         */
        RedirectPropertiesIdtype.prototype.description;
        /**
         * type of RedirectPropertiesIdtype.
         * @type {?}
         */
        RedirectPropertiesIdtype.prototype.type;
        /**
         * enum for RedirectPropertiesIdtype.
         * @type {?}
         */
        RedirectPropertiesIdtype.prototype.enum;
    }
    /**
     * Entity for `RedirectProperties` based on schema `organization-v1.0.0.json`.
     * An address associated with the institute.
     */
    var   /**
     * Entity for `RedirectProperties` based on schema `organization-v1.0.0.json`.
     * An address associated with the institute.
     */
    RedirectProperties = /** @class */ (function (_super) {
        __extends(RedirectProperties, _super);
        function RedirectProperties() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Name of the city.
             */
            _this.idtype = undefined;
            /**
             * Name of the country.
             */
            _this.value = undefined;
            return _this;
        }
        return RedirectProperties;
    }(EntityBase));
    if (false) {
        /**
         * Name of the city.
         * @type {?}
         */
        RedirectProperties.prototype.idtype;
        /**
         * Name of the country.
         * @type {?}
         */
        RedirectProperties.prototype.value;
    }
    /**
     * Entity for `Redirect` based on schema `organization-v1.0.0.json`.
     * An address associated with the institute.
     */
    var   /**
     * Entity for `Redirect` based on schema `organization-v1.0.0.json`.
     * An address associated with the institute.
     */
    Redirect = /** @class */ (function (_super) {
        __extends(Redirect, _super);
        function Redirect() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Type of redirect.
             */
            _this.type = '';
            /**
             * Show additional properties for redirect if true.
             */
            _this.additionalProperties = false;
            /**
             * Properties for redirect.
             */
            _this.properties = undefined;
            return _this;
        }
        return Redirect;
    }(EntityBase));
    if (false) {
        /**
         * Type of redirect.
         * @type {?}
         */
        Redirect.prototype.type;
        /**
         * Show additional properties for redirect if true.
         * @type {?}
         */
        Redirect.prototype.additionalProperties;
        /**
         * Properties for redirect.
         * @type {?}
         */
        Redirect.prototype.properties;
    }
    /**
     * Entity for `Organizations` based on schema `organization-v1.0.0.json`.
     */
    var   /**
     * Entity for `Organizations` based on schema `organization-v1.0.0.json`.
     */
    Organization = /** @class */ (function (_super) {
        __extends(Organization, _super);
        function Organization() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Organization Identifiers, different from GRID mapping.
             */
            _this.identifiers = new Array();
            /**
             * The name typically used to refer to the institute.
             */
            _this.name = '';
            /**
             * For an active institute, this is always set to active.
             */
            _this.status = '';
            /**
             * The list of other names the institute is known as.
             */
            _this.aliases = new Array();
            /**
             * The list of short acronyms the institute is known as (e.g. MRC for the Medical Research Council).
             */
            _this.acronyms = new Array();
            /**
             * The list of types describing the institute.
             */
            _this.types = new Array();
            /**
             * URL of the wikipedia page for the institute.
             */
            _this.wikipedia_url = '';
            /**
             * Contact email address for the institute.
             */
            _this.email_address = '';
            /**
             * The list of IP addresses known to belong to the institute.
             */
            _this.ip_addresses = new Array();
            /**
             * Year the institute opened, CE.
             */
            _this.established = -1;
            /**
             * Year the institute registered on ONEI.
             */
            _this.onei_registry = -1;
            /**
             * If its able for exporting to international organizations systems.
             */
            _this.exportable = false;
            /**
             * The list of URLs linking to things like the homepage for the institute.
             */
            _this.links = new Array();
            /**
             * Name of the institute in different languages.
             */
            _this.labels = new Array();
            /**
             * Any relationships the institute has to others.
             */
            _this.relationships = new Array();
            /**
             * An array of addresses associated with the institute.
             */
            _this.addresses = new Array();
            /**
             * An array of addresses associated with the institute.
             */
            _this.redirect = undefined;
            return _this;
        }
        return Organization;
    }(Entity));
    if (false) {
        /**
         * Organization Identifiers, different from GRID mapping.
         * @type {?}
         */
        Organization.prototype.identifiers;
        /**
         * The name typically used to refer to the institute.
         * @type {?}
         */
        Organization.prototype.name;
        /**
         * For an active institute, this is always set to active.
         * @type {?}
         */
        Organization.prototype.status;
        /**
         * The list of other names the institute is known as.
         * @type {?}
         */
        Organization.prototype.aliases;
        /**
         * The list of short acronyms the institute is known as (e.g. MRC for the Medical Research Council).
         * @type {?}
         */
        Organization.prototype.acronyms;
        /**
         * The list of types describing the institute.
         * @type {?}
         */
        Organization.prototype.types;
        /**
         * URL of the wikipedia page for the institute.
         * @type {?}
         */
        Organization.prototype.wikipedia_url;
        /**
         * Contact email address for the institute.
         * @type {?}
         */
        Organization.prototype.email_address;
        /**
         * The list of IP addresses known to belong to the institute.
         * @type {?}
         */
        Organization.prototype.ip_addresses;
        /**
         * Year the institute opened, CE.
         * @type {?}
         */
        Organization.prototype.established;
        /**
         * Year the institute registered on ONEI.
         * @type {?}
         */
        Organization.prototype.onei_registry;
        /**
         * If its able for exporting to international organizations systems.
         * @type {?}
         */
        Organization.prototype.exportable;
        /**
         * The list of URLs linking to things like the homepage for the institute.
         * @type {?}
         */
        Organization.prototype.links;
        /**
         * Name of the institute in different languages.
         * @type {?}
         */
        Organization.prototype.labels;
        /**
         * Any relationships the institute has to others.
         * @type {?}
         */
        Organization.prototype.relationships;
        /**
         * An array of addresses associated with the institute.
         * @type {?}
         */
        Organization.prototype.addresses;
        /**
         * An array of addresses associated with the institute.
         * @type {?}
         */
        Organization.prototype.redirect;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/person.entity.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Person = /** @class */ (function (_super) {
        __extends(Person, _super);
        function Person() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Person;
    }(Entity));
    if (false) {
        /** @type {?} */
        Person.prototype.institution_id;
        /** @type {?} */
        Person.prototype.name;
        /** @type {?} */
        Person.prototype.secondName;
        /** @type {?} */
        Person.prototype.lastName;
        /** @type {?} */
        Person.prototype.sex;
        /** @type {?} */
        Person.prototype.inicialsName;
        /** @type {?} */
        Person.prototype.userName;
        /** @type {?} */
        Person.prototype.email;
        /** @type {?} */
        Person.prototype.orcid;
        /** @type {?} */
        Person.prototype.phone;
        /** @type {?} */
        Person.prototype.bio;
        /** @type {?} */
        Person.prototype.street;
        /** @type {?} */
        Person.prototype.number;
        /** @type {?} */
        Person.prototype.city;
        /** @type {?} */
        Person.prototype.province;
        /** @type {?} */
        Person.prototype.country;
    }
    var Role = /** @class */ (function () {
        function Role() {
            this.id = '';
            this.name = '';
            this.description = '';
        }
        return Role;
    }());
    if (false) {
        /** @type {?} */
        Role.prototype.id;
        /** @type {?} */
        Role.prototype.name;
        /** @type {?} */
        Role.prototype.description;
    }
    var User = /** @class */ (function () {
        function User() {
            this.id = '';
            this.email = '';
            this.confirmed_at = '';
            this.last_login_at = '';
            this.roles = new Array();
        }
        return User;
    }());
    if (false) {
        /** @type {?} */
        User.prototype.id;
        /** @type {?} */
        User.prototype.email;
        /** @type {?} */
        User.prototype.confirmed_at;
        /** @type {?} */
        User.prototype.last_login_at;
        /** @type {?} */
        User.prototype.roles;
    }
    var UserSourcesRoles = /** @class */ (function () {
        function UserSourcesRoles() {
            this.source_uuid = '';
            this.role = '';
        }
        return UserSourcesRoles;
    }());
    if (false) {
        /** @type {?} */
        UserSourcesRoles.prototype.source_uuid;
        /** @type {?} */
        UserSourcesRoles.prototype.role;
    }
    var UserProfile = /** @class */ (function (_super) {
        __extends(UserProfile, _super);
        function UserProfile() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.biography = '';
            _this.email = '';
            _this.full_name = '';
            _this.id = '';
            _this.institution = '';
            _this.institution_id = -1;
            _this.institution_rol = '';
            _this.username = '';
            _this.avatar = '';
            _this.sources = new Array();
            _this.user = new User();
            return _this;
        }
        /**
         * @return {?}
         */
        UserProfile.prototype.identify = /**
         * @return {?}
         */
        function () {
            return this.full_name + '<' + this.user.email + '>';
        };
        return UserProfile;
    }(Entity));
    if (false) {
        /** @type {?} */
        UserProfile.prototype.biography;
        /** @type {?} */
        UserProfile.prototype.email;
        /** @type {?} */
        UserProfile.prototype.full_name;
        /** @type {?} */
        UserProfile.prototype.id;
        /** @type {?} */
        UserProfile.prototype.institution;
        /** @type {?} */
        UserProfile.prototype.institution_id;
        /** @type {?} */
        UserProfile.prototype.institution_rol;
        /** @type {?} */
        UserProfile.prototype.username;
        /** @type {?} */
        UserProfile.prototype.avatar;
        /** @type {?} */
        UserProfile.prototype.sources;
        /** @type {?} */
        UserProfile.prototype.user;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/source.entity.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var SourceSystems = {
        OJS: { label: 'Open Journal System', value: 'OJS' },
        CMS: { label: 'Content Management System (Wordpress, Joomla, Drupal, etc)', value: 'CMS' },
        DSPACE: { label: 'Dspace', value: 'DSPACE' },
        OTHER: { label: 'Otro', value: 'OTHER' },
    };
    /** @type {?} */
    var SourceTypes = {
        JOURNAL: { label: 'Revista Científica', value: 'JOURNAL' },
        SERIAL: { label: 'Publicación Seriada', value: 'SERIAL' },
        STUDENT: { label: 'Revista Científico Estudiantil', value: 'STUDENT' },
        POPULARIZATION: { label: 'Revista de Divulgación', value: 'POPULARIZATION' },
        REPOSITORY: { label: 'Repositorio Institucional', value: 'REPOSITORY' },
        WEBSITE: { label: 'Sitio Web', value: 'WEBSITE' },
        OTHER: { label: 'Otro', value: 'OTHER' },
    };
    /** @type {?} */
    var SourceOrganizationRole = {
        MAIN: { label: 'Principal', value: 'MAIN' },
        COLABORATOR: { label: 'Colaborador', value: 'COLABORATOR' }
    };
    /** @type {?} */
    var SourcePersonRole = {
        ADMINISTRATOR: { label: 'Administrador', value: 'ADMINISTRATOR' },
        JOURNALMANAGER: { label: 'Gestor de Revista', value: 'JOURNALMANAGER' },
        AUTHOR: { label: 'Autor', value: 'AUTHOR' },
        EDITOR: { label: 'Editor', value: 'EDITOR' },
        SECTIONEDITOR: { label: 'Editor de Sección', value: 'SECTIONEDITOR' },
        REVIEWER: { label: 'Revisor', value: 'REVIEWER' },
        COPYEDITOR: { label: 'Editor de Copias', value: 'COPYEDITOR' },
        LAYOUTEDITOR: { label: 'Editor de Formato', value: 'LAYOUTEDITOR' },
        PROOFREADER: { label: 'Corrector de Pruebas', value: 'PROOFREADER' },
        READER: { label: 'Lector', value: 'READER' }
    };
    /** @type {?} */
    var SourceStatus = {
        APPROVED: { label: 'Aprobado', value: 'APPROVED' },
        TO_REVIEW: { label: 'En revision', value: 'TO_REVIEW' },
        UNOFFICIAL: { label: 'Incluido Extraoficialmente', value: 'UNOFFICIAL' }
    };
    var SourceOrganization = /** @class */ (function (_super) {
        __extends(SourceOrganization, _super);
        function SourceOrganization() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.role = '';
            return _this;
        }
        return SourceOrganization;
    }(Organization));
    if (false) {
        /** @type {?} */
        SourceOrganization.prototype.role;
    }
    var SourceClasification = /** @class */ (function (_super) {
        __extends(SourceClasification, _super);
        function SourceClasification() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.id = '';
            _this.description = '';
            _this.vocabulary = '';
            _this.data = new Object();
            return _this;
        }
        return SourceClasification;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        SourceClasification.prototype.id;
        /** @type {?} */
        SourceClasification.prototype.description;
        /** @type {?} */
        SourceClasification.prototype.vocabulary;
        /** @type {?} */
        SourceClasification.prototype.data;
    }
    var SavingInfoSchema = /** @class */ (function (_super) {
        __extends(SavingInfoSchema, _super);
        function SavingInfoSchema() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.user_id = '';
            _this.comment = '';
            return _this;
        }
        return SavingInfoSchema;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        SavingInfoSchema.prototype.user_id;
        /** @type {?} */
        SavingInfoSchema.prototype.comment;
    }
    var SourceData = /** @class */ (function (_super) {
        __extends(SourceData, _super);
        function SourceData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.name = '';
            _this.title = '';
            _this.description = '';
            // term_sources ?: Array<TermSource> = new Array<TermSource>();
            _this.oaiurl = '';
            _this.source_system = '';
            _this.source_type = '';
            _this.source_status = '';
            _this.organizations = new Array();
            _this.classifications = new Array();
            _this._save_info = new SavingInfoSchema();
            _this.reviewed = false;
            return _this;
            // public deepcopy(data: any, exclude: string[] = []): void {
            //   if (data['organizations'] && data['organizations'].length > 0){
            //     for (let index = 0; index < data['organizations'].length; index++) {
            //       const element = data['organizations'][index];
            //       this.organizations.push(new SourceOrganization());
            //     }
            //   }
            //   if (data['classifications'] && data['classifications'].length > 0){
            //     for (let index = 0; index < data['classifications'].length; index++) {
            //       const element = data['classifications'][index];
            //       this.classifications.push(new SourceClasification());
            //     }
            //   }
            //   super.deepcopy(data, exclude);
            // }
        }
        return SourceData;
    }(Entity));
    if (false) {
        /** @type {?} */
        SourceData.prototype.name;
        /** @type {?} */
        SourceData.prototype.title;
        /** @type {?} */
        SourceData.prototype.description;
        /** @type {?} */
        SourceData.prototype.oaiurl;
        /** @type {?} */
        SourceData.prototype.source_system;
        /** @type {?} */
        SourceData.prototype.source_type;
        /** @type {?} */
        SourceData.prototype.source_status;
        /** @type {?} */
        SourceData.prototype.organizations;
        /** @type {?} */
        SourceData.prototype.classifications;
        /** @type {?} */
        SourceData.prototype._save_info;
        /** @type {?} */
        SourceData.prototype.reviewed;
        /** @type {?} */
        SourceData.prototype.versions;
    }
    // export class TermSource extends EntityBase {
    //     term_id = '';
    //     source_id = '';
    //     data =  new Object();
    //     term ?: Term  = null;
    // }
    var   
    // export class TermSource extends EntityBase {
    //     term_id = '';
    //     source_id = '';
    //     data =  new Object();
    //     term ?: Term  = null;
    // }
    SourceVersion = /** @class */ (function (_super) {
        __extends(SourceVersion, _super);
        function SourceVersion() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.user_id = '';
            _this.source_uuid = '';
            _this.comment = '';
            _this.created_at = new Date();
            _this.is_current = false;
            _this.reviewed = false;
            _this.data = new SourceData();
            _this.userprofile = new UserProfile();
            return _this;
        }
        return SourceVersion;
    }(Entity));
    if (false) {
        /** @type {?} */
        SourceVersion.prototype.user_id;
        /** @type {?} */
        SourceVersion.prototype.source_uuid;
        /** @type {?} */
        SourceVersion.prototype.comment;
        /** @type {?} */
        SourceVersion.prototype.created_at;
        /** @type {?} */
        SourceVersion.prototype.is_current;
        /** @type {?} */
        SourceVersion.prototype.reviewed;
        /** @type {?} */
        SourceVersion.prototype.data;
        /** @type {?} */
        SourceVersion.prototype.userprofile;
    }
    var Source = /** @class */ (function (_super) {
        __extends(Source, _super);
        function Source() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.uuid = '';
            _this.name = '';
            _this.clasifications = new Array(0);
            _this.organizations = new Array();
            _this.aliases = new Array();
            _this.source_type = '';
            _this.source_status = '';
            _this.version_to_review = false;
            _this.versions = new Array();
            _this.data = new SourceData();
            return _this;
        }
        return Source;
    }(Entity));
    if (false) {
        /** @type {?} */
        Source.prototype.uuid;
        /** @type {?} */
        Source.prototype.name;
        /** @type {?} */
        Source.prototype.clasifications;
        /** @type {?} */
        Source.prototype.organizations;
        /** @type {?} */
        Source.prototype.aliases;
        /** @type {?} */
        Source.prototype.source_type;
        /** @type {?} */
        Source.prototype.source_status;
        /** @type {?} */
        Source.prototype.version_to_review;
        /** @type {?} */
        Source.prototype.versions;
        /** @type {?} */
        Source.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/journal.entity.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SocialNetworks = /** @class */ (function (_super) {
        __extends(SocialNetworks, _super);
        function SocialNetworks() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.facebook = '';
            _this.twitter = '';
            _this.linkedin = '';
            return _this;
        }
        return SocialNetworks;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        SocialNetworks.prototype.facebook;
        /** @type {?} */
        SocialNetworks.prototype.twitter;
        /** @type {?} */
        SocialNetworks.prototype.linkedin;
    }
    var IssnOrg = /** @class */ (function (_super) {
        __extends(IssnOrg, _super);
        function IssnOrg() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return IssnOrg;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        IssnOrg.prototype.issn;
        /** @type {?} */
        IssnOrg.prototype.title;
    }
    var ISSN = /** @class */ (function (_super) {
        __extends(ISSN, _super);
        function ISSN() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.p = '';
            _this.e = '';
            _this.l = '';
            _this.issn_org = new IssnOrg();
            return _this;
        }
        return ISSN;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        ISSN.prototype.p;
        /** @type {?} */
        ISSN.prototype.e;
        /** @type {?} */
        ISSN.prototype.l;
        /** @type {?} */
        ISSN.prototype.issn_org;
    }
    var RNPS = /** @class */ (function (_super) {
        __extends(RNPS, _super);
        function RNPS() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.p = '';
            _this.e = '';
            return _this;
        }
        return RNPS;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        RNPS.prototype.p;
        /** @type {?} */
        RNPS.prototype.e;
    }
    var JournalData = /** @class */ (function (_super) {
        __extends(JournalData, _super);
        function JournalData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.subtitle = '';
            _this.shortname = '';
            _this.issn = new ISSN();
            _this.rnps = new RNPS();
            _this.url = '';
            _this.email = '';
            _this.logo = '';
            _this.purpose = '';
            _this.start_year = '';
            _this.end_year = '';
            _this.frequency = '';
            _this.seriadas_cubanas = '';
            _this.socialNetworks = new SocialNetworks();
            return _this;
        }
        return JournalData;
    }(SourceData));
    if (false) {
        /** @type {?} */
        JournalData.prototype.subtitle;
        /** @type {?} */
        JournalData.prototype.shortname;
        /** @type {?} */
        JournalData.prototype.issn;
        /** @type {?} */
        JournalData.prototype.rnps;
        /** @type {?} */
        JournalData.prototype.url;
        /** @type {?} */
        JournalData.prototype.email;
        /** @type {?} */
        JournalData.prototype.logo;
        /** @type {?} */
        JournalData.prototype.purpose;
        /** @type {?} */
        JournalData.prototype.start_year;
        /** @type {?} */
        JournalData.prototype.end_year;
        /** @type {?} */
        JournalData.prototype.frequency;
        /** @type {?} */
        JournalData.prototype.seriadas_cubanas;
        /** @type {?} */
        JournalData.prototype.socialNetworks;
    }
    var Journal = /** @class */ (function (_super) {
        __extends(Journal, _super);
        function Journal() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.data = new JournalData();
            _this.versions = new Array();
            return _this;
        }
        return Journal;
    }(Source));
    if (false) {
        /** @type {?} */
        Journal.prototype.data;
        /** @type {?} */
        Journal.prototype.versions;
    }
    var JournalVersion = /** @class */ (function (_super) {
        __extends(JournalVersion, _super);
        function JournalVersion() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.data = new JournalData();
            return _this;
            // /** WARNING: helper variable in the client side. Do not rely on this unless you know what you are doing */
            // organization?: Term = null;
            // /** WARNING: helper variable in the client side. Do not rely on this unless you know what you are doing */
            // institution?: Term = null;
            // /** WARNING: helper variable in the client side. Do not rely on this unless you know what you are doing */
            // entity?: Term = null;
            // entitystringify(): string  {
            //   return JSON.stringify(this, (k, v) => {
            //     if (k !== 'id' &&
            //         k !== 'uuid' &&
            //         k !== 'isNew' &&
            //         k !== 'organization' &&
            //         k !== 'institution' &&
            //         k !== 'entity' ) {
            //       return v;
            //     }
            //   });
            // }
        }
        return JournalVersion;
    }(SourceVersion));
    if (false) {
        /** @type {?} */
        JournalVersion.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/record.entity.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Record = /** @class */ (function (_super) {
        __extends(Record, _super);
        function Record() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.id = '';
            _this.identifiers = new Array();
            _this.source_repo = new Source();
            _this.spec = new Object();
            _this.title = '';
            _this.creators = new Array();
            _this.keywords = new Array();
            _this.description = '';
            _this.publisher = '';
            _this.sources = new Array();
            _this.rights = new Array();
            _this.types = new Array();
            _this.formats = new Array();
            _this.language = '';
            _this.publication_date = '';
            _this.contributors = new Array();
            _this.references = new Object();
            _this.iroko_terms = new Array();
            _this.status = '';
            return _this;
        }
        return Record;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        Record.prototype.id;
        /** @type {?} */
        Record.prototype.identifiers;
        /** @type {?} */
        Record.prototype.source_repo;
        /** @type {?} */
        Record.prototype.spec;
        /** @type {?} */
        Record.prototype.title;
        /** @type {?} */
        Record.prototype.creators;
        /** @type {?} */
        Record.prototype.keywords;
        /** @type {?} */
        Record.prototype.description;
        /** @type {?} */
        Record.prototype.publisher;
        /** @type {?} */
        Record.prototype.sources;
        /** @type {?} */
        Record.prototype.rights;
        /** @type {?} */
        Record.prototype.types;
        /** @type {?} */
        Record.prototype.formats;
        /** @type {?} */
        Record.prototype.language;
        /** @type {?} */
        Record.prototype.publication_date;
        /** @type {?} */
        Record.prototype.contributors;
        /** @type {?} */
        Record.prototype.references;
        /** @type {?} */
        Record.prototype.iroko_terms;
        /** @type {?} */
        Record.prototype.status;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/repository.entity.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var Repository = /** @class */ (function (_super) {
        __extends(Repository, _super);
        function Repository() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Repository;
    }(Entity));
    if (false) {
        /** @type {?} */
        Repository.prototype.source_id;
        /** @type {?} */
        Repository.prototype.last_run;
        /** @type {?} */
        Repository.prototype.identifier;
        /** @type {?} */
        Repository.prototype.metadata_formats;
        /** @type {?} */
        Repository.prototype.status;
        /** @type {?} */
        Repository.prototype.error_log;
        /** @type {?} */
        Repository.prototype.sets;
        /** @type {?} */
        Repository.prototype.jobId;
    }
    var RepositorySet = /** @class */ (function (_super) {
        __extends(RepositorySet, _super);
        function RepositorySet() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return RepositorySet;
    }(Entity));
    if (false) {
        /** @type {?} */
        RepositorySet.prototype.setSpec;
        /** @type {?} */
        RepositorySet.prototype.setName;
    }
    var HarvestedItem = /** @class */ (function (_super) {
        __extends(HarvestedItem, _super);
        function HarvestedItem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return HarvestedItem;
    }(Entity));
    if (false) {
        /** @type {?} */
        HarvestedItem.prototype.repository_id;
        /** @type {?} */
        HarvestedItem.prototype.identifier;
        /** @type {?} */
        HarvestedItem.prototype.record_uuid;
        /** @type {?} */
        HarvestedItem.prototype.status;
        /** @type {?} */
        HarvestedItem.prototype.error_log;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/taxonomy.entity.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var VocabulariesInmutableNames = {
        CUBAN_INTITUTIONS: "CUBAN_INTITUTIONS",
        SUBJECTS: "SUBJECTS",
        CUBAN_PROVINCES: "CUBAN_PROVINCES",
        // DATABASES = '3',
        // MES_GROUPS = 'MES_GROUPS',
        LICENCES: "LICENCES",
        INDEXES_CLASIFICATION: "INDEXES_CLASIFICATION",
        INDEXES: "INDEXES",
        UNESCO_VOCAB: "UNESCO_VOCAB",
        RECOD_SETS: "RECOD_SETS",
        RECORD_TYPES: "RECORD_TYPES",
        EXTRA_INSTITUTIONS: "EXTRA_INSTITUTIONS",
        SUBJECT_COVER: "SUBJECT_COVER",
        COUNTRIES: "COUNTRIES",
    };
    var Term = /** @class */ (function (_super) {
        __extends(Term, _super);
        function Term() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.uuid = '';
            _this.identifier = '';
            _this.description = '';
            _this.data = new EntityBase();
            _this.vocabulary_id = '';
            _this.parent_id = '';
            _this.clasified_ids = [];
            _this.class_ids = [];
            return _this;
            // deepcopy(data: any){
            //     switch (data['vocabulary_id']) {
            //         case VocabulariesInmutableNames.INTITUTION:
            //             this.data = new TermInstitutionData();
            //             break;
            //         case VocabulariesInmutableNames.LICENCES:
            //             this.data = new TermIndexData();
            //         default:
            //             this.data = new EntityBase();
            //     }
            //     super.deepcopy(data);
            // }
        }
        return Term;
    }(Entity));
    if (false) {
        /** @type {?} */
        Term.prototype.uuid;
        /** @type {?} */
        Term.prototype.identifier;
        /** @type {?} */
        Term.prototype.description;
        /** @type {?} */
        Term.prototype.data;
        /** @type {?} */
        Term.prototype.vocabulary_id;
        /** @type {?} */
        Term.prototype.parent_id;
        /** @type {?} */
        Term.prototype.clasified_ids;
        /** @type {?} */
        Term.prototype.class_ids;
    }
    var TermInstitutionData = /** @class */ (function (_super) {
        __extends(TermInstitutionData, _super);
        function TermInstitutionData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.grid = '';
            _this.email = '';
            _this.website = '';
            _this.address = '';
            return _this;
        }
        return TermInstitutionData;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        TermInstitutionData.prototype.grid;
        /** @type {?} */
        TermInstitutionData.prototype.email;
        /** @type {?} */
        TermInstitutionData.prototype.website;
        /** @type {?} */
        TermInstitutionData.prototype.address;
    }
    var TermIndexData = /** @class */ (function (_super) {
        __extends(TermIndexData, _super);
        function TermIndexData() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.url = '';
            _this.abrev = '';
            _this.initial_cover = '';
            _this.end_cover = '';
            return _this;
        }
        return TermIndexData;
    }(EntityBase));
    if (false) {
        /** @type {?} */
        TermIndexData.prototype.url;
        /** @type {?} */
        TermIndexData.prototype.abrev;
        /** @type {?} */
        TermIndexData.prototype.initial_cover;
        /** @type {?} */
        TermIndexData.prototype.end_cover;
    }
    var Vocabulary = /** @class */ (function (_super) {
        __extends(Vocabulary, _super);
        function Vocabulary() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.name = '';
            _this.description = '';
            _this.human_name = '';
            _this.identifier = '';
            return _this;
        }
        return Vocabulary;
    }(Entity));
    if (false) {
        /** @type {?} */
        Vocabulary.prototype.name;
        /** @type {?} */
        Vocabulary.prototype.description;
        /** @type {?} */
        Vocabulary.prototype.human_name;
        /** @type {?} */
        Vocabulary.prototype.identifier;
    }
    /**
     * File node data with possible child nodes.
     * @record
     */
    function TermNode() { }
    if (false) {
        /** @type {?} */
        TermNode.prototype.term;
        /** @type {?} */
        TermNode.prototype.parent;
        /** @type {?|undefined} */
        TermNode.prototype.children;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/entities/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/info-card/info-card.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var InfoCardComponent = /** @class */ (function () {
        function InfoCardComponent() {
            this.is_avatar_card = false;
            this.is_title_card = false;
            this.is_subtitle_card = false;
            this.is_content_card = false;
            this.is_img_card = false;
            this.is_actions_card = false;
        }
        /**
         * @return {?}
         */
        InfoCardComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (typeof (this.avatar_card) != 'undefined')
                this.is_avatar_card = true;
            if (this.content_card != ' ')
                this.is_content_card = true;
            if (this.title_card != ' ')
                this.is_title_card = true;
            if (this.subtitle_card != ' ')
                this.is_subtitle_card = true;
            if (typeof (this.img_card) != 'undefined')
                this.is_img_card = true;
        };
        InfoCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-info-card',
                        template: "<mat-card>\n  <img mat-card-image src={{img_card}} *ngIf=\"is_img_card\">\n  <mat-card-header>\n\n      <img mat-card-avatar src={{avatar_card}} *ngIf=\"is_avatar_card\" >\n\n\n      <mat-card-title *ngIf=\"is_title_card\">\n        <strong>\n          {{title_card}}\n        </strong>\n      </mat-card-title>\n\n    <mat-card-subtitle *ngIf=\"is_subtitle_card\">\n      {{subtitle_card}}\n    </mat-card-subtitle>\n  </mat-card-header>\n\n\n\n  <mat-card-content *ngIf=\"is_content_card\">\n     <div class=\"e2e-inner-html-bound  text-align-justify\" [innerHTML]=\"content_card\"></div>\n    \n  </mat-card-content>\n\n  <mat-card-actions *ngIf=\"is_actions_card\">\n    <a mat-button color=\"primary\"   routerLink=\"{{router}}/{{entity.id}}\">VER M\u00C1S</a>\n    <!--(click)=\"show_people()\"-->\n  </mat-card-actions>\n\n</mat-card>",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        InfoCardComponent.ctorParameters = function () { return []; };
        InfoCardComponent.propDecorators = {
            avatar_card: [{ type: core.Input }],
            title_card: [{ type: core.Input }],
            subtitle_card: [{ type: core.Input }],
            content_card: [{ type: core.Input }],
            img_card: [{ type: core.Input }],
            router: [{ type: core.Input }],
            entity: [{ type: core.Input }],
            is_actions_card: [{ type: core.Input }]
        };
        return InfoCardComponent;
    }());
    if (false) {
        /** @type {?} */
        InfoCardComponent.prototype.avatar_card;
        /** @type {?} */
        InfoCardComponent.prototype.title_card;
        /** @type {?} */
        InfoCardComponent.prototype.subtitle_card;
        /** @type {?} */
        InfoCardComponent.prototype.content_card;
        /** @type {?} */
        InfoCardComponent.prototype.img_card;
        /** @type {?} */
        InfoCardComponent.prototype.router;
        /** @type {?} */
        InfoCardComponent.prototype.entity;
        /** @type {?} */
        InfoCardComponent.prototype.is_avatar_card;
        /** @type {?} */
        InfoCardComponent.prototype.is_title_card;
        /** @type {?} */
        InfoCardComponent.prototype.is_subtitle_card;
        /** @type {?} */
        InfoCardComponent.prototype.is_content_card;
        /** @type {?} */
        InfoCardComponent.prototype.is_img_card;
        /** @type {?} */
        InfoCardComponent.prototype.is_actions_card;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/journal-card/journal-card.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var JournalCardComponent = /** @class */ (function () {
        function JournalCardComponent() {
        }
        /**
         * @return {?}
         */
        JournalCardComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () { };
        JournalCardComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-journal-card',
                        template: "<p>\n  journal-card works!\n</p>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        JournalCardComponent.ctorParameters = function () { return []; };
        return JournalCardComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/nav/nav.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NavComponent = /** @class */ (function () {
        function NavComponent() {
        }
        /**
         * @return {?}
         */
        NavComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () { };
        NavComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-nav',
                        template: "<header>\n\n  <nav>\n      \n    <div class=\"nav-heder shadows-for-head always-on-top nav-menu-items w-100\" fxLayout=\"row\" fxLayout.xs=\"column\" fxLayoutAlign=\"space-around\">\n\n      <!-- <div class=\"nav-menu-items\" > -->\n        <button mat-flat-button color=\"primary\" *ngFor=\"let item of menuItems\" [routerLink]=\"[item.link]\" routerLinkActive=\"active\">\n          {{item.label}}\n        </button>\n        \n      <!-- </div> -->\n\n\n      <!-- <div class=\"nav-tools\">\n          <div class=\"input-style-for-search\">\n             <mat-icon style=\"margin-left: -45px;z-index: 1;\">pageview</mat-icon> \n          </div>\n          <input type=\"search\" coloaria-label=\"Buscar\" placeholder=\"Buscar\" class=\"input-style\">\n\n        <span class=\"spacer\"></span>\n        <div>\n          <button mat-icon-button [matMenuTriggerFor]=\"menu\" matTooltip=\"Edel Abreu Hern\u00E1ndez\" matTooltipPosition=\"left\">\n            <mat-icon matPrefix>person_pin</mat-icon>\n            pin\n          </button>\n          <mat-menu #menu=\"matMenu\">\n            <button mat-menu-item routerLink=\"/people/show\">\n              <mat-icon>person</mat-icon>\n              <span>Mi Perfil</span>\n            </button>\n            <button mat-menu-item>\n              <mat-icon>lock_open</mat-icon>\n              <span>Salir</span>\n            </button>\n          </mat-menu>\n        </div>\n\n      </div> -->\n\n    </div>\n  </nav>\n</header>",
                        styles: [".menu-items{display:flex;display:-webkit-box;list-style:none;flex-direction:row;justify-content:flex-start}"]
                    }] }
        ];
        /** @nocollapse */
        NavComponent.ctorParameters = function () { return []; };
        NavComponent.propDecorators = {
            menuItems: [{ type: core.Input }]
        };
        return NavComponent;
    }());
    if (false) {
        /** @type {?} */
        NavComponent.prototype.menuItems;
    }
    /**
     * @record
     */
    function MenuItem() { }
    if (false) {
        /** @type {?} */
        MenuItem.prototype.link;
        /** @type {?} */
        MenuItem.prototype.label;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/page-header/page-header.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PageHeaderComponent = /** @class */ (function () {
        function PageHeaderComponent() {
            this.info = [];
            this.is_show_icon = false;
        }
        /**
         * @return {?}
         */
        PageHeaderComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            //this.info = ['Listado de Personas','estas estan en el sitio','esta es otra fila'];
        };
        /**
         * @return {?}
         */
        PageHeaderComponent.prototype.function = /**
         * @return {?}
         */
        function () {
            this.drawer.toggle();
        };
        /**
         * @return {?}
         */
        PageHeaderComponent.prototype.change_icon_show = /**
         * @return {?}
         */
        function () {
            this.is_show_icon = false;
            console.log(this.is_show_icon);
        };
        PageHeaderComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-page-header',
                        template: "<mat-toolbar color=\"primary\">\n\n  <mat-toolbar-row *ngFor=\"let item of info; index as i\" >\n    <!--\n      la condicion especifica q-> si quiero mostrar el icono y es la primera iteracion entonces se muestra\n      esto evita que se repita el icono por cada row del componente\n    -->\n    <div *ngIf=\"is_show_icon && i ==0; then block\"></div>\n    <!--\n      en la sintaxis del \"if\" donde dice \"then block\" quiere decir q cuando se pumpla la condicion ira a ese blocque\n       q esta en otra etiqueta y q se tiene q llamar \"<ng-template #block >\"\n    -->\n    <ng-template #block >\n      <mat-icon class=\"icon-position change-cursor\" (click)=\"function()\">menu</mat-icon>\n    </ng-template>\n\n    <h1><strong>{{item}}</strong></h1>\n\n  </mat-toolbar-row>\n\n</mat-toolbar>",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        PageHeaderComponent.ctorParameters = function () { return []; };
        PageHeaderComponent.propDecorators = {
            drawer: [{ type: core.Input }],
            info: [{ type: core.Input }]
        };
        return PageHeaderComponent;
    }());
    if (false) {
        /** @type {?} */
        PageHeaderComponent.prototype.drawer;
        /** @type {?} */
        PageHeaderComponent.prototype.info;
        /** @type {?} */
        PageHeaderComponent.prototype.is_show_icon;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/page-not-found/page-not-found.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Component that shows information for a page-not-found view.
     */
    var PageNotFoundComponent = /** @class */ (function () {
        function PageNotFoundComponent() {
            this.routerLink = undefined;
            this.imgSource = undefined;
        }
        /**
         * @return {?}
         */
        PageNotFoundComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Specifies the default values. */
            if (this.routerLink == undefined)
                this.routerLink = ['/'];
            /* The default value for `imgSource` is `undefined`. */
        };
        PageNotFoundComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-page-not-found',
                        template: "\n<h1 class=\"mat-display-1 toco-pnf-h1-apology-text\">{{ 'TOCO_NG_PAGINA_NO_ENCONT_DISCULPA' | translate }}</h1>\n<a class=\"toco-pnf-a-redirect\" [routerLink]=\"routerLink\">\n    <h2 class=\"mat-h2 toco-pnf-h2-redirect-text\">{{ 'TOCO_NG_PAGINA_NO_ENCONT_REDIRECCION' | translate }}</h2>\n    <img class=\"toco-pnf-img-redirect\"\n        [src]=\"imgSource\"\n        [alt]=\"'TOCO_NG_PAGINA_NO_ENCONT_IMG_ALT_TEXT' | translate\"\n        style=\"height: 50px;\"\n    />\n</a>\n",
                        styles: [":host{display:block;margin:2em;text-align:center}"]
                    }] }
        ];
        /** @nocollapse */
        PageNotFoundComponent.ctorParameters = function () { return []; };
        PageNotFoundComponent.propDecorators = {
            routerLink: [{ type: core.Input }],
            imgSource: [{ type: core.Input }]
        };
        return PageNotFoundComponent;
    }());
    if (false) {
        /**
         * Input field that contains the router link to reditect.
         * By default, its value is `['/']`.
         * @type {?}
         */
        PageNotFoundComponent.prototype.routerLink;
        /**
         * Input field that contains the image source to show underneath the redirect link.
         * By default, its value is `undefined`.
         * @type {?}
         */
        PageNotFoundComponent.prototype.imgSource;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/core-routing.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ɵ0 = {
        title: 'Inicio'
    };
    /** @type {?} */
    var routes = [{
            path: 'home',
            component: HomeComponent,
            data: ɵ0
        }
    ];
    var CoreRoutingModule = /** @class */ (function () {
        function CoreRoutingModule() {
        }
        CoreRoutingModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [router.RouterModule.forChild(routes)],
                        exports: [router.RouterModule]
                    },] }
        ];
        return CoreRoutingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/utils/road-map/road-map.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var seriesName_English = ['achieved', 'unresolved'];
    /** @type {?} */
    var seriesName_Spanish = ['realizado', 'pendiente'];
    /**
     * An interface that represents the content of a feature object.
     * @record
     */
    function Feature() { }
    if (false) {
        /**
         * The feature's name.
         * @type {?}
         */
        Feature.prototype.name;
        /**
         * The feature's achieved percentage.
         * @type {?}
         */
        Feature.prototype.achieved;
    }
    /**
     * An interface that represents the content of a product object.
     * Its achieved percentage value is calculated from its `features` array field.
     * @record
     */
    function Product() { }
    if (false) {
        /**
         * The product's name.
         * @type {?}
         */
        Product.prototype.name;
        /**
         * The product's features array.
         * @type {?}
         */
        Product.prototype.features;
    }
    /**
     * An interface that represents the content of a result object.
     * @record
     */
    function Result() { }
    if (false) {
        /**
         * The result's name.
         * @type {?}
         */
        Result.prototype.name;
        /**
         * The result's value.
         * @type {?}
         */
        Result.prototype.value;
    }
    /**
     * An interface that represents the content of a chart bar object.
     * Its `series` field is an array of length 2 that contains
     * the achieved/unresolved results; for example,
     * `'series': [
     * {
     * 'name': 'achieved',
     * 'value': 20
     * },
     * {
     * 'name': 'unresolved',
     * 'value': 80
     * }
     * ]`
     * @record
     */
    function ChartBar() { }
    if (false) {
        /**
         * The chart's bar name.
         * @type {?}
         */
        ChartBar.prototype.name;
        /**
         * The results array that makes up the chart's bar.
         * @type {?}
         */
        ChartBar.prototype.series;
    }
    /**
     * An interface that represents the content of an entry element object.
     * @record
     */
    function EntryElement() { }
    if (false) {
        /** @type {?} */
        EntryElement.prototype.name;
        /** @type {?|undefined} */
        EntryElement.prototype.value;
        /** @type {?|undefined} */
        EntryElement.prototype.label;
        /** @type {?|undefined} */
        EntryElement.prototype.series;
    }
    /**
     * Component for displaying a roadmap. It basically displays the products
     * that we are currently working, and the products that we will work in the future.
     * Besides, when a product is selected, its features are displayed.
     * It always shows the achieved/unresolved work in percentage.
     */
    var RoadMapComponent = /** @class */ (function () {
        function RoadMapComponent() {
            /**
             * Returns the -1 value that is used to remove a chart.
             */
            this.removeChart_PosFlag = -1;
            this.withoutProductText = '¡No hay ningún producto!';
            this._isChartVertical = true;
            this.tabLabel_CW = 'Trabajos Actuales';
            this.tabLabel_FW = 'Trabajos Futuros o Pendientes';
            this._selectedTabPos = 0;
            /* The `_gridHeight` value is set when the `legendPosition` value is set. */
            this.chartTitle_P = 'Lista de productos';
            this._isUsingTrick_RepaintChart = false;
            this._products = this._currentProducts = [];
            this._futureProducts = [];
            this._products_Internal = this._currentProducts_Internal = [];
            this._futureProducts_Internal = [];
            this._featuresTotal_Internal = this._currentFeaturesTotal_Internal = [];
            this._futureFeaturesTotal_Internal = [];
            this._features_Internal = this._currentFeatures_Internal = [];
            this._futureFeatures_Internal = [];
            this._activeEntries_P_CW = [];
            this._activeEntries_P_FW = [];
            this.view = [900, 350];
            this.colorScheme_CW = {
                domain: [
                    // '#85E96E',  // green
                    '#6EE9B5',
                    '#E96E70',
                ]
                //			domain: [  // all colors dark
                //   '#2F6E6F',
                //			  '#2F6F40',  // green
                //   '#6B6F2F',  // light green
                //			  '#6F432F',  // red
                //   '#6F2F4F',
                //   '#562F6F',
                //   '#302F6F',
                //   '#2F466F'
                //			]
                // domain: [  // all colors grey
                //	 '#a6a6a6',
                //   '#828282',
                //   '#686868',
                //	 '#555555',
                //   '#4d4d4d',
                //   '#464646',
                //   '#434343',
                //   '#3d3d3d',
                //   '#343434',
                //   '#262626',
                //   '#252525',
                //   '#000000'
                // ]
            };
            this.colorScheme_FW = {
                domain: [
                    '#6F6EE9',
                    '#6EBBE9' // light blue
                ]
            };
            this.gradient = false;
            this.barPadding = 12;
            this.showXAxis = true;
            this.showXAxisLabel = true;
            this.xAxisLabel_P = 'Producto';
            this.maxAxisTickLength = 16;
            this.showYAxis = true;
            this.showYAxisLabel = true;
            this.yAxisLabel_P = 'Realizado / Pendiente En Por Ciento';
            this.showLegend = true;
            this.legendTitle = 'Leyenda';
            this.legendPosition = 'right';
            this._selectedProductPos = this._selectedProductPos_CW = this._selectedProductPos_FW = this.removeChart_PosFlag;
            this._chartTitle_F = this._chartTitle_F_CW = this._chartTitle_F_FW = 'Lista de características del producto seleccionado';
            this.xAxisLabel_F = 'Característica';
            this.yAxisLabel_F = 'Realizado / Pendiente En Por Ciento';
        }
        /**
         * @return {?}
         */
        RoadMapComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () { };
        Object.defineProperty(RoadMapComponent.prototype, "isChartVertical", {
            /**
             * Returns the input field that contains the chart's visualization direction.
             * It is true if the chart is visualized vertically; otherwise, false (horizontally).
             * When this value is set, the `xAxisLabel_P`/`yAxisLabel_P` and `xAxisLabel_F`/`yAxisLabel_F` values are set accordingly.
             * By default, its value is `true`.
             */
            get: /**
             * Returns the input field that contains the chart's visualization direction.
             * It is true if the chart is visualized vertically; otherwise, false (horizontally).
             * When this value is set, the `xAxisLabel_P`/`yAxisLabel_P` and `xAxisLabel_F`/`yAxisLabel_F` values are set accordingly.
             * By default, its value is `true`.
             * @return {?}
             */
            function () {
                return this._isChartVertical;
            },
            /**
             * Sets the input field that contains the chart's visualization direction.
             * It is true if the chart is visualized vertically; otherwise, false (horizontally).
             * When this value is set, the `xAxisLabel_P`/`yAxisLabel_P` and `xAxisLabel_F`/`yAxisLabel_F` values are set accordingly.
             * By default, its value is `true`.
             * @param value The new chart's visualization direction to set.
             */
            set: /**
             * Sets the input field that contains the chart's visualization direction.
             * It is true if the chart is visualized vertically; otherwise, false (horizontally).
             * When this value is set, the `xAxisLabel_P`/`yAxisLabel_P` and `xAxisLabel_F`/`yAxisLabel_F` values are set accordingly.
             * By default, its value is `true`.
             * @param {?} value The new chart's visualization direction to set.
             * @return {?}
             */
            function (value) {
                if (this._isChartVertical != value) {
                    /** @type {?} */
                    var temp = this.xAxisLabel_P;
                    this.xAxisLabel_P = this.yAxisLabel_P;
                    this.yAxisLabel_P = temp;
                    temp = this.xAxisLabel_F;
                    this.xAxisLabel_F = this.yAxisLabel_F;
                    this.yAxisLabel_F = temp;
                    this._isChartVertical = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "gridHeight", {
            /**
             * Returns the grid height.
             * Its value is set depending on the `legendPosition` value.
             */
            get: /**
             * Returns the grid height.
             * Its value is set depending on the `legendPosition` value.
             * @return {?}
             */
            function () {
                return this._gridHeight;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "currentProducts", {
            /**
             * Returns the input field that contains the current products array introduced by the user.
             * From this array is created the `currentProducts_Internal` and `currentFeatures_Internal` arrays.
             * By default, its value is `[]`.
             */
            get: /**
             * Returns the input field that contains the current products array introduced by the user.
             * From this array is created the `currentProducts_Internal` and `currentFeatures_Internal` arrays.
             * By default, its value is `[]`.
             * @return {?}
             */
            function () {
                return this._currentProducts;
            },
            /**
             * Sets the input field that contains the current products array.
             * By default, its value is `[]`.
             * @param value The new current products array to set.
             */
            set: /**
             * Sets the input field that contains the current products array.
             * By default, its value is `[]`.
             * @param {?} value The new current products array to set.
             * @return {?}
             */
            function (value) {
                // console.log('currentProducts: ', value);
                /* Updates the current products/features arrays. */
                this._currentProducts = value || [];
                if (this._isUsingTrick_RepaintChart) {
                    this._isUsingTrick_RepaintChart = false;
                    this._currentProducts_Internal = this._currentProducts_Internal.map((/**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) { return value; }));
                    this._currentFeaturesTotal_Internal = this._currentFeaturesTotal_Internal.map((/**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) { return value.map((/**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) { return value; })); }));
                }
                else {
                    this._currentProducts_Internal = [];
                    this._currentFeaturesTotal_Internal = [];
                    /* Creates the internal arrays that are going to be passed in the template;
                    `_currentProducts_Internal` and `_currentFeaturesTotal_Internal` arrays.
                    The `_currentFeatures_Internal` array references an element in
                    the `_currentFeaturesTotal_Internal` array. This element represents the features
                    of a selected product in the `_currentProducts_Internal` array. */
                    this._createsInternalArrays(this._currentProducts, this._currentProducts_Internal, this._currentFeaturesTotal_Internal);
                }
                this._currentFeatures_Internal = [];
                /* Updates the fields whether there is a selected current product. */
                if (this._selectedProductPos_CW != this.removeChart_PosFlag) {
                    if (this._selectedProductPos_CW < this._currentProducts.length) {
                        /* Updates the fields whether the new `_currentProducts` array has the enough length. */
                        /* The `_selectedProductPos_CW` value is already correct. */
                        this._currentFeatures_Internal = this._currentFeaturesTotal_Internal[this._selectedProductPos_CW];
                        this._set_activeEntries_P_CW(false);
                        this._chartTitle_F_CW = this._chartTitle_F
                            + ((this._chartTitle_F.length == 0) ? '' : ' ')
                            + ("\u201C" + this._currentProducts_Internal[this._selectedProductPos_CW].name + "\u201D");
                    }
                    else {
                        /* Removes the selected current product because the `_currentProducts` array has not the enough length. */
                        this._selectedProductPos_CW = this.removeChart_PosFlag;
                        /* The `_currentFeatures_Internal` array is already correct (an empty array). */
                        this._set_activeEntries_P_CW(true);
                        this._chartTitle_F_CW = this._chartTitle_F;
                    }
                }
                /* Updates the fields whether the selected tab is the current works. */
                if (this._selectedTabPos == 0) {
                    this._setData_CW();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "currentProducts_Internal", {
            /**
             * Returns the current products array displayed in the chart.
             * It is created from the `currentProducts` array.
             * By default, its value is `[]`.
             */
            get: /**
             * Returns the current products array displayed in the chart.
             * It is created from the `currentProducts` array.
             * By default, its value is `[]`.
             * @return {?}
             */
            function () {
                return this._currentProducts_Internal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "currentFeatures_Internal", {
            /**
             * Returns the current features array of a selected product displayed in the chart.
             * It is created from the `currentProducts` array.
             * By default, its value is `[]`.
             */
            get: /**
             * Returns the current features array of a selected product displayed in the chart.
             * It is created from the `currentProducts` array.
             * By default, its value is `[]`.
             * @return {?}
             */
            function () {
                return this._currentFeatures_Internal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "futureProducts", {
            /**
             * Returns the input field that contains the future products array introduced by the user.
             * From this array is created the `futureProducts_Internal` and `futureFeatures_Internal` arrays.
             * By default, its value is `[]`.
             */
            get: /**
             * Returns the input field that contains the future products array introduced by the user.
             * From this array is created the `futureProducts_Internal` and `futureFeatures_Internal` arrays.
             * By default, its value is `[]`.
             * @return {?}
             */
            function () {
                return this._futureProducts;
            },
            /**
             * Sets the input field that contains the future products array.
             * By default, its value is `[]`.
             * @param value The new future products array to set.
             */
            set: /**
             * Sets the input field that contains the future products array.
             * By default, its value is `[]`.
             * @param {?} value The new future products array to set.
             * @return {?}
             */
            function (value) {
                // console.log('futureProducts: ', value);
                /* Updates the future products/features arrays. */
                this._futureProducts = value || [];
                if (this._isUsingTrick_RepaintChart) {
                    this._isUsingTrick_RepaintChart = false;
                    this._futureProducts_Internal = this._futureProducts_Internal.map((/**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) { return value; }));
                    this._futureFeaturesTotal_Internal = this._futureFeaturesTotal_Internal.map((/**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) { return value.map((/**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) { return value; })); }));
                }
                else {
                    this._futureProducts_Internal = [];
                    this._futureFeaturesTotal_Internal = [];
                    /* Creates the internal arrays that are going to be passed in the template;
                    `_futureProducts_Internal` and `_futureFeaturesTotal_Internal` arrays.
                    The `_futureFeatures_Internal` array references an element in
                    the `_futureFeaturesTotal_Internal` array. This element represents the features
                    of a selected product in the `_futureProducts_Internal` array. */
                    this._createsInternalArrays(this._futureProducts, this._futureProducts_Internal, this._futureFeaturesTotal_Internal);
                }
                this._futureFeatures_Internal = [];
                /* Updates the fields whether there is a selected future product. */
                if (this._selectedProductPos_FW != this.removeChart_PosFlag) {
                    if (this._selectedProductPos_FW < this._futureProducts.length) {
                        /* Updates the fields whether the new `_futureProducts` array has the enough length. */
                        /* The `_selectedProductPos_FW` value is already correct. */
                        this._futureFeatures_Internal = this._futureFeaturesTotal_Internal[this._selectedProductPos_FW];
                        this._set_activeEntries_P_FW(false);
                        this._chartTitle_F_FW = this._chartTitle_F
                            + ((this._chartTitle_F.length == 0) ? '' : ' ')
                            + ("\u201C" + this._futureProducts_Internal[this._selectedProductPos_FW].name + "\u201D");
                    }
                    else {
                        /* Removes the selected future product because the `_futureProducts` array has not the enough length. */
                        this._selectedProductPos_FW = this.removeChart_PosFlag;
                        /* The `_futureFeatures_Internal` array is already correct (an empty array). */
                        this._set_activeEntries_P_FW(true);
                        this._chartTitle_F_FW = this._chartTitle_F;
                    }
                }
                /* Updates the fields whether the selected tab is the future works. */
                if (this._selectedTabPos == 1) {
                    this._setData_FW();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "futureProducts_Internal", {
            /**
             * Returns the future products array displayed in the chart.
             * It is created from the `futureProducts` array.
             * By default, its value is `[]`.
             */
            get: /**
             * Returns the future products array displayed in the chart.
             * It is created from the `futureProducts` array.
             * By default, its value is `[]`.
             * @return {?}
             */
            function () {
                return this._futureProducts_Internal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "futureFeatures_Internal", {
            /**
             * Returns the future features array of a selected product displayed in the chart.
             * It is created from the `futureProducts` array.
             * By default, its value is `[]`.
             */
            get: /**
             * Returns the future features array of a selected product displayed in the chart.
             * It is created from the `futureProducts` array.
             * By default, its value is `[]`.
             * @return {?}
             */
            function () {
                return this._futureFeatures_Internal;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "activeEntries_P_CW", {
            /**
             * Returns the current product elements array to highlight displayed in the chart.
             * It is modified dynamically.
             * By default, its value is `[]`.
             */
            get: /**
             * Returns the current product elements array to highlight displayed in the chart.
             * It is modified dynamically.
             * By default, its value is `[]`.
             * @return {?}
             */
            function () {
                return this._activeEntries_P_CW;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the current product elements array to highlight displayed in the chart.
         * @param setEmpty If it is true, then sets the `_activeEntries_P_CW` array to empty.
         */
        /**
         * Sets the current product elements array to highlight displayed in the chart.
         * @private
         * @param {?} setEmpty If it is true, then sets the `_activeEntries_P_CW` array to empty.
         * @return {?}
         */
        RoadMapComponent.prototype._set_activeEntries_P_CW = /**
         * Sets the current product elements array to highlight displayed in the chart.
         * @private
         * @param {?} setEmpty If it is true, then sets the `_activeEntries_P_CW` array to empty.
         * @return {?}
         */
        function (setEmpty) {
            // console.log('Called "_set_activeEntries_P_CW": setEmpty = ', setEmpty);
            if (setEmpty) {
                this._activeEntries_P_CW = [];
            }
            else {
                /** @type {?} */
                var selectedProduct = this._currentProducts_Internal[this._selectedProductPos_CW];
                this._activeEntries_P_CW = [
                    {
                        'name': selectedProduct.series[0].name,
                        'value': selectedProduct.series[0].value,
                        'label': selectedProduct.series[0].name,
                        'series': selectedProduct.name
                    },
                    {
                        'name': selectedProduct.series[1].name,
                        'value': selectedProduct.series[1].value,
                        'label': selectedProduct.series[1].name,
                        'series': selectedProduct.name
                    }
                ];
            }
        };
        Object.defineProperty(RoadMapComponent.prototype, "activeEntries_P_FW", {
            /**
             * Returns the future product elements array to highlight displayed in the chart.
             * It is modified dynamically.
             * By default, its value is `[]`.
             */
            get: /**
             * Returns the future product elements array to highlight displayed in the chart.
             * It is modified dynamically.
             * By default, its value is `[]`.
             * @return {?}
             */
            function () {
                return this._activeEntries_P_FW;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the future product elements array to highlight displayed in the chart.
         * @param setEmpty If it is true, then sets the `_activeEntries_P_FW` array to empty.
         */
        /**
         * Sets the future product elements array to highlight displayed in the chart.
         * @private
         * @param {?} setEmpty If it is true, then sets the `_activeEntries_P_FW` array to empty.
         * @return {?}
         */
        RoadMapComponent.prototype._set_activeEntries_P_FW = /**
         * Sets the future product elements array to highlight displayed in the chart.
         * @private
         * @param {?} setEmpty If it is true, then sets the `_activeEntries_P_FW` array to empty.
         * @return {?}
         */
        function (setEmpty) {
            // console.log('Called "_set_activeEntries_P_FW": setEmpty = ', setEmpty);
            if (setEmpty) {
                this._activeEntries_P_FW = [];
            }
            else {
                /** @type {?} */
                var selectedProduct = this._futureProducts_Internal[this._selectedProductPos_FW];
                this._activeEntries_P_FW = [
                    {
                        'name': selectedProduct.series[0].name,
                        'value': selectedProduct.series[0].value,
                        'label': selectedProduct.series[0].name,
                        'series': selectedProduct.name
                    },
                    {
                        'name': selectedProduct.series[1].name,
                        'value': selectedProduct.series[1].value,
                        'label': selectedProduct.series[1].name,
                        'series': selectedProduct.name
                    }
                ];
            }
        };
        Object.defineProperty(RoadMapComponent.prototype, "legendPosition", {
            /**
             * Returns the input field that contains the chart's legend position. Its value is `'right'` or `'below'`.
             * By default, its value is `'right'`.
             */
            get: /**
             * Returns the input field that contains the chart's legend position. Its value is `'right'` or `'below'`.
             * By default, its value is `'right'`.
             * @return {?}
             */
            function () {
                return this._legendPosition;
            },
            /**
             * Sets the input field that contains the chart's legend position. Its value is `'right'` or `'below'`.
             * By default, its value is `'right'`.
             * @param value The new chart's legend position to set.
             */
            set: /**
             * Sets the input field that contains the chart's legend position. Its value is `'right'` or `'below'`.
             * By default, its value is `'right'`.
             * @param {?} value The new chart's legend position to set.
             * @return {?}
             */
            function (value) {
                if ((this._legendPosition = value) == 'below') {
                    /* Sets the grid height. */
                    this._gridHeight = this.view[1] + 60; /* More 60 to include the legend in the grid. */
                }
                else {
                    /* Sets the grid height. */
                    this._gridHeight = this.view[1];
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "isLegendRight", {
            /**
             * Returns a boolean value that indicates the legend position.
             * It is true if the legend position is `'right'`; otherwise, false (`'below'`).
             * By default, its value is `true`.
             */
            get: /**
             * Returns a boolean value that indicates the legend position.
             * It is true if the legend position is `'right'`; otherwise, false (`'below'`).
             * By default, its value is `true`.
             * @return {?}
             */
            function () {
                return (this.legendPosition == 'right');
            },
            /**
             * Sets a boolean value that indicates the legend position.
             * It is true if the legend position is `'right'`; otherwise, false (`'below'`).
             * By default, its value is `true`.
             * @param value The new boolean value to set.
             */
            set: /**
             * Sets a boolean value that indicates the legend position.
             * It is true if the legend position is `'right'`; otherwise, false (`'below'`).
             * By default, its value is `true`.
             * @param {?} value The new boolean value to set.
             * @return {?}
             */
            function (value) {
                this.legendPosition = (value) ? 'right' : 'below';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "selectedProductPos_CW", {
            /**
             * Returns the selected current product position. Contains the `removeChart_PosFlag` value when
             * there is not any selected current product position.
             */
            get: /**
             * Returns the selected current product position. Contains the `removeChart_PosFlag` value when
             * there is not any selected current product position.
             * @return {?}
             */
            function () {
                return this._selectedProductPos_CW;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "selectedProductPos_FW", {
            /**
             * Returns the selected future product position. Contains the `removeChart_PosFlag` value when
             * there is not any selected future product position.
             */
            get: /**
             * Returns the selected future product position. Contains the `removeChart_PosFlag` value when
             * there is not any selected future product position.
             * @return {?}
             */
            function () {
                return this._selectedProductPos_FW;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "chartTitle_F", {
            /**
             * Returns the input field that contains the chart's title of features.
             * By default, its value is `'Lista de características del producto seleccionado'`.
             */
            get: /**
             * Returns the input field that contains the chart's title of features.
             * By default, its value is `'Lista de características del producto seleccionado'`.
             * @return {?}
             */
            function () {
                return this._chartTitle_F;
            },
            /**
             * Sets the input field that contains the chart's title of features.
             * By default, its value is `'Lista de características del producto seleccionado'`.
             * @param value The new chart's title of features to set.
             */
            set: /**
             * Sets the input field that contains the chart's title of features.
             * By default, its value is `'Lista de características del producto seleccionado'`.
             * @param {?} value The new chart's title of features to set.
             * @return {?}
             */
            function (value) {
                this._chartTitle_F = value || 'Lista de características del producto seleccionado';
                /* Updates all chart's titles of features. */
                this._chartTitle_F_CW = (this._selectedProductPos_CW == this.removeChart_PosFlag)
                    ? (this._chartTitle_F)
                    : (this._chartTitle_F
                        + ((this._chartTitle_F.length == 0) ? '' : ' ')
                        + ("\u201C" + this._currentProducts_Internal[this._selectedProductPos_CW].name + "\u201D"));
                this._chartTitle_F_FW = (this._selectedProductPos_FW == this.removeChart_PosFlag)
                    ? (this._chartTitle_F)
                    : (this._chartTitle_F
                        + ((this._chartTitle_F.length == 0) ? '' : ' ')
                        + ("\u201C" + this._futureProducts_Internal[this._selectedProductPos_FW].name + "\u201D"));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "chartTitle_F_CW", {
            /**
             * Returns the chart's title of working current features.
             * By default, its value is `'Lista de características del producto seleccionado'`.
             */
            get: /**
             * Returns the chart's title of working current features.
             * By default, its value is `'Lista de características del producto seleccionado'`.
             * @return {?}
             */
            function () {
                return this._chartTitle_F_CW;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RoadMapComponent.prototype, "chartTitle_F_FW", {
            /**
             * Returns the chart's title of working future features.
             * By default, its value is `'Lista de características del producto seleccionado'`.
             */
            get: /**
             * Returns the chart's title of working future features.
             * By default, its value is `'Lista de características del producto seleccionado'`.
             * @return {?}
             */
            function () {
                return this._chartTitle_F_FW;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} newPos
         * @return {?}
         */
        RoadMapComponent.prototype.onSelectTab = /**
         * @param {?} newPos
         * @return {?}
         */
        function (newPos) {
            // console.log('onSelectTab pos: ', newPos);
            /* Uses this trick to obligate repainting the chart. */
            this._isUsingTrick_RepaintChart = true;
            if ((this._selectedTabPos = newPos) == 0) {
                this.currentProducts = this.currentProducts.map((/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) { return value; }));
                // this._setData_CW();  /* Better performance: Use this option if you do not use the dynamic legend position or not resize the navigator. */
            }
            else {
                this.futureProducts = this.futureProducts.map((/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) { return value; }));
                // this._setData_FW();  /* Better performance: Use this option if you do not use the dynamic legend position or not resize the navigator. */
            }
        };
        /**
         * @param {?} eventInfo
         * @return {?}
         */
        RoadMapComponent.prototype.onSelect = /**
         * @param {?} eventInfo
         * @return {?}
         */
        function (eventInfo) {
            // console.log('onSelect: ', eventInfo);
            if (util.isObject(eventInfo)) /* It has not clicked a legend item. */ {
                /** @type {?} */
                var tempPos = void 0;
                /** @type {?} */
                var len = this._products_Internal.length;
                /** @type {?} */
                var posAsString = eventInfo.series;
                /* Gets the new selected position. */
                for (tempPos = 0; tempPos < len; tempPos++) {
                    if (this._products_Internal[tempPos].name == posAsString)
                        break;
                }
                /* Updates the `_selectedProductPos_CW`/`_selectedProductPos_FW`. If the new selected
                 * position equals the current selected position, then the chart for displaying
                 * the features list of the selected product will be removed. */
                this._updateProductPos(tempPos);
            }
        };
        /**
         * @param {?} eventInfo
         * @return {?}
         */
        RoadMapComponent.prototype.onActivate = /**
         * @param {?} eventInfo
         * @return {?}
         */
        function (eventInfo) {
            // console.log('onActivate: ', eventInfo);
        };
        /**
         * @param {?} eventInfo
         * @return {?}
         */
        RoadMapComponent.prototype.onDeactivate = /**
         * @param {?} eventInfo
         * @return {?}
         */
        function (eventInfo) {
            // console.log('onDeactivate: ', eventInfo, ', _activeEntries_P_CW = ', this._activeEntries_P_CW, ', _activeEntries_P_FW = ', this._activeEntries_P_FW);
            if (this._isFeaturesChartShowed) {
                if (this._selectedTabPos == 0) {
                    this._activeEntries_P_CW = this._activeEntries_P_CW.map((/**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) { return value; }));
                }
                else {
                    this._activeEntries_P_FW = this._activeEntries_P_FW.map((/**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) { return value; }));
                }
            }
        };
        /**
         * Sets the data of current works.
         */
        /**
         * Sets the data of current works.
         * @private
         * @return {?}
         */
        RoadMapComponent.prototype._setData_CW = /**
         * Sets the data of current works.
         * @private
         * @return {?}
         */
        function () {
            this._products = this._currentProducts;
            this._products_Internal = this._currentProducts_Internal;
            this._featuresTotal_Internal = this._currentFeaturesTotal_Internal;
            this._features_Internal = this._currentFeatures_Internal;
            this._selectedProductPos = this._selectedProductPos_CW;
        };
        /**
         * Sets the data of future works.
         */
        /**
         * Sets the data of future works.
         * @private
         * @return {?}
         */
        RoadMapComponent.prototype._setData_FW = /**
         * Sets the data of future works.
         * @private
         * @return {?}
         */
        function () {
            this._products = this._futureProducts;
            this._products_Internal = this._futureProducts_Internal;
            this._featuresTotal_Internal = this._futureFeaturesTotal_Internal;
            this._features_Internal = this._futureFeatures_Internal;
            this._selectedProductPos = this._selectedProductPos_FW;
        };
        Object.defineProperty(RoadMapComponent.prototype, "_isFeaturesChartShowed", {
            /**
             * Returns true if the features chart is showed; otherwise, false.
             */
            get: /**
             * Returns true if the features chart is showed; otherwise, false.
             * @private
             * @return {?}
             */
            function () {
                return (this._selectedProductPos != this.removeChart_PosFlag);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Updates the `selectedProductPos`. If the new selected position equals the current
         * selected position, then the chart for displaying the features list of the selected product
         * will be removed.
         * @param newSelectedPosition The new selected position.
         */
        /**
         * Updates the `selectedProductPos`. If the new selected position equals the current
         * selected position, then the chart for displaying the features list of the selected product
         * will be removed.
         * @private
         * @param {?} newSelectedPosition The new selected position.
         * @return {?}
         */
        RoadMapComponent.prototype._updateProductPos = /**
         * Updates the `selectedProductPos`. If the new selected position equals the current
         * selected position, then the chart for displaying the features list of the selected product
         * will be removed.
         * @private
         * @param {?} newSelectedPosition The new selected position.
         * @return {?}
         */
        function (newSelectedPosition) {
            /* Updates the `selectedProductPos`. If the new selected position equals the current
             * selected position, then the chart for displaying the features list of the selected product
             * will be removed. */
            if (newSelectedPosition == this._selectedProductPos) {
                if (this._selectedTabPos == 0) {
                    this._selectedProductPos = this._selectedProductPos_CW = this.removeChart_PosFlag;
                    this._features_Internal = this._currentFeatures_Internal = [];
                    this._set_activeEntries_P_CW(true);
                    this._chartTitle_F_CW = this._chartTitle_F;
                }
                else {
                    this._selectedProductPos = this._selectedProductPos_FW = this.removeChart_PosFlag;
                    this._features_Internal = this._futureFeatures_Internal = [];
                    this._set_activeEntries_P_FW(true);
                    this._chartTitle_F_FW = this._chartTitle_F;
                }
            }
            else {
                if (this._selectedTabPos == 0) {
                    this._selectedProductPos = this._selectedProductPos_CW = newSelectedPosition;
                    this._features_Internal = this._currentFeatures_Internal = this._featuresTotal_Internal[newSelectedPosition];
                    this._set_activeEntries_P_CW(false);
                    this._chartTitle_F_CW = this._chartTitle_F
                        + ((this._chartTitle_F.length == 0) ? '' : ' ')
                        + ("\u201C" + this._products_Internal[newSelectedPosition].name + "\u201D");
                }
                else {
                    this._selectedProductPos = this._selectedProductPos_FW = newSelectedPosition;
                    this._features_Internal = this._futureFeatures_Internal = this._featuresTotal_Internal[newSelectedPosition];
                    this._set_activeEntries_P_FW(false);
                    this._chartTitle_F_FW = this._chartTitle_F
                        + ((this._chartTitle_F.length == 0) ? '' : ' ')
                        + ("\u201C" + this._products_Internal[newSelectedPosition].name + "\u201D");
                }
            }
        };
        /**
         * Creates the internal arrays that are going to be passed in the template
         * for the current/future products/features accordingly.
         * @param products The current/future products array introduced by the user.
         * @param products_Internal The current/future products array displayed in the chart.
         * @param featuresTotal_Internal The array that contains all current/future features arrays that can be displayed in the chart.
         */
        /**
         * Creates the internal arrays that are going to be passed in the template
         * for the current/future products/features accordingly.
         * @private
         * @param {?} products The current/future products array introduced by the user.
         * @param {?} products_Internal The current/future products array displayed in the chart.
         * @param {?} featuresTotal_Internal The array that contains all current/future features arrays that can be displayed in the chart.
         * @return {?}
         */
        RoadMapComponent.prototype._createsInternalArrays = /**
         * Creates the internal arrays that are going to be passed in the template
         * for the current/future products/features accordingly.
         * @private
         * @param {?} products The current/future products array introduced by the user.
         * @param {?} products_Internal The current/future products array displayed in the chart.
         * @param {?} featuresTotal_Internal The array that contains all current/future features arrays that can be displayed in the chart.
         * @return {?}
         */
        function (products, products_Internal, featuresTotal_Internal) {
            /* Creates the internal arrays that are going to be passed in the template;
            `_currentProducts_Internal`/`_futureProducts_Internal` and `_currentFeaturesTotal_Internal`/`_futureFeaturesTotal_Internal` arrays.
            The `_currentFeatures_Internal`/`_futureFeatures_Internal` array references an element in
            the `_currentFeaturesTotal_Internal`/`_futureFeaturesTotal_Internal` array. This element represents the features
            of a selected product in the `_currentProducts_Internal`/`_futureProducts_Internal` array. */
            /* Creates the internal arrays that are going to be passed in the template;
                    `_currentProducts_Internal`/`_futureProducts_Internal` and `_currentFeaturesTotal_Internal`/`_futureFeaturesTotal_Internal` arrays.
                    The `_currentFeatures_Internal`/`_futureFeatures_Internal` array references an element in
                    the `_currentFeaturesTotal_Internal`/`_futureFeaturesTotal_Internal` array. This element represents the features
                    of a selected product in the `_currentProducts_Internal`/`_futureProducts_Internal` array. */
            /** @type {?} */
            var i;
            /** @type {?} */
            var j;
            /** @type {?} */
            var len_i = products.length;
            /** @type {?} */
            var len_j;
            /** @type {?} */
            var tempCurrentFeatures_Internal;
            /** @type {?} */
            var tempFeatures;
            /** @type {?} */
            var tempAchieved;
            /* Calculates the achieved percentage of a product. */
            /** @type {?} */
            var achievedPercentage_P;
            /** @type {?} */
            var maxPercentage_F;
            /** @type {?} */
            var achievedPercentage_F;
            for (i = 0; i < len_i; i++) {
                tempCurrentFeatures_Internal = [];
                len_j = ((tempFeatures = products[i].features) ? tempFeatures.length : 0);
                maxPercentage_F = len_j * 100.00;
                achievedPercentage_F = 0;
                for (j = 0; j < len_j; j++) {
                    /* Adds all `achieved` values of the `tempFeatures` array. */
                    achievedPercentage_F += (tempAchieved = tempFeatures[j].achieved);
                    /* Creates the current features array of this product displayed in the chart. */
                    tempCurrentFeatures_Internal.push({
                        'name': tempFeatures[j].name,
                        'series': [
                            {
                                'name': 'realizado',
                                // TODO: Use the `seriesName_English` and `seriesName_Spanish` constants depending on the language selected. 
                                'value': tempAchieved
                            },
                            {
                                'name': 'pendiente',
                                // TODO: Use the `seriesName_English` and `seriesName_Spanish` constants depending on the language selected. 
                                'value': 100.00 - tempAchieved
                            }
                        ]
                    });
                }
                /* Calculates the achieved percentage of this product. */
                achievedPercentage_P = (achievedPercentage_F * 100.00) / maxPercentage_F;
                // achievedPercentage_P = Math.round(((achievedPercentage_F * 100.00) / maxPercentage_F) * 100.00) / 100.00;
                /* Creates the current products array displayed in the chart. */
                products_Internal.push({
                    'name': products[i].name,
                    'series': [
                        {
                            'name': 'realizado',
                            // TODO: Use the `seriesName_English` and `seriesName_Spanish` constants depending on the language selected. 
                            'value': achievedPercentage_P
                        },
                        {
                            'name': 'pendiente',
                            // TODO: Use the `seriesName_English` and `seriesName_Spanish` constants depending on the language selected. 
                            'value': 100.00 - achievedPercentage_P
                        }
                    ]
                });
                /* Creates the array that contains all current features arrays that can be displayed in the chart. */
                featuresTotal_Internal.push(tempCurrentFeatures_Internal);
            }
        };
        /**
         * Removes the chart for displaying the features list of the selected product.
         */
        /**
         * Removes the chart for displaying the features list of the selected product.
         * @return {?}
         */
        RoadMapComponent.prototype.click_RemoveChart = /**
         * Removes the chart for displaying the features list of the selected product.
         * @return {?}
         */
        function () {
            this._updateProductPos(this._selectedProductPos);
        };
        RoadMapComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-road-map',
                        template: "\n<ng-container *ngIf=\"currentProducts_Internal.length; then thenTemplate_Products; else elseTemplate_WithoutProducts\"></ng-container>\n\n<ng-template #thenTemplate_Products>\n\n    <mat-checkbox [(ngModel)]=\"isChartVertical\" [color]=\"'primary'\" [matTooltip]=\"'Visualizar el gr\u00E1fico vertical / horizontal'\" [matTooltipPosition]=\"'left'\">Gr\u00E1fico vertical</mat-checkbox>\n    <mat-checkbox class=\"checkbox-not-first\" [(ngModel)]=\"isLegendRight\" [color]=\"'primary'\" [matTooltip]=\"'Visualizar la leyenda a la derecha / abajo'\" [matTooltipPosition]=\"'right'\">Leyenda a la derecha</mat-checkbox>\n\n    <mat-divider class=\"mat-divider-chart\"></mat-divider>\n\n    <mat-tab-group mat-align-tabs=\"center\" [animationDuration]=\"'1500ms'\" (selectedIndexChange)=\"onSelectTab($event)\">\n        <mat-tab [label]=\"tabLabel_CW\">\n\n            <!---------------------------------------------------------------------------->\n            <!-- Displays the current products list. -->\n            <!---------------------------------------------------------------------------->\n\n            <h3>{{ chartTitle_P }}</h3>\n\n            <mat-grid-list [cols]=\"'1'\" [rowHeight]=\"gridHeight\">\n                <mat-grid-tile>\n                    <ng-container *ngIf=\"isChartVertical; then thenTempl_Ver_NormBarChart_CurProducts; else elseTempl_Hor_NormBarChart_CurProducts\"></ng-container>\n                    <button mat-icon-button\n                        class=\"button-close-product\"\n                        color=\"primary\"\n                        [attr.aria-label]=\"'Cerrar el chart'\"\n                        [matTooltip]=\"'Cerrar el chart'\"        \n                        [matTooltipPosition]=\"'above'\"\n                    >\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </mat-grid-tile>\n            </mat-grid-list>\n\n            <ng-template #thenTempl_Ver_NormBarChart_CurProducts>\n                <ngx-charts-bar-vertical-normalized style=\"display: inline-block\"\n                    [results]=\"currentProducts_Internal\"\n                    [activeEntries]=\"activeEntries_P_CW\"\n                    [view]=\"view\"\n                    [scheme]=\"colorScheme_CW\"\n                    [gradient]=\"gradient\"\n                    [barPadding]=\"barPadding\"\n\n                    [xAxis]=\"showXAxis\"\n                    [showXAxisLabel]=\"showXAxisLabel\"\n                    [xAxisLabel]=\"xAxisLabel_P\"\n                    [maxXAxisTickLength]=\"maxAxisTickLength\"\n\n                    [yAxis]=\"showYAxis\"\n                    [showYAxisLabel]=\"showYAxisLabel\"\n                    [yAxisLabel]=\"yAxisLabel_P\"\n                    [maxYAxisTickLength]=\"maxAxisTickLength\"\n\n                    [legend]=\"showLegend\"\n                    [legendTitle]=\"legendTitle\"\n                    [legendPosition]=\"legendPosition\"\n\n                    (select)=\"onSelect($event)\"\n                    (activate)=\"onActivate($event)\"\n                    (deactivate)=\"onDeactivate($event)\"\n                >\n                </ngx-charts-bar-vertical-normalized>\n            </ng-template>\n\n            <ng-template #elseTempl_Hor_NormBarChart_CurProducts>\n                <ngx-charts-bar-horizontal-normalized style=\"display: inline-block\"\n                    [results]=\"currentProducts_Internal\"\n                    [activeEntries]=\"activeEntries_P_CW\"\n                    [view]=\"view\"\n                    [scheme]=\"colorScheme_CW\"\n                    [gradient]=\"gradient\"\n                    [barPadding]=\"barPadding\"\n\n                    [xAxis]=\"showXAxis\"\n                    [showXAxisLabel]=\"showXAxisLabel\"\n                    [xAxisLabel]=\"xAxisLabel_P\"\n                    [maxXAxisTickLength]=\"maxAxisTickLength\"\n\n                    [yAxis]=\"showYAxis\"\n                    [showYAxisLabel]=\"showYAxisLabel\"\n                    [yAxisLabel]=\"yAxisLabel_P\"\n                    [maxYAxisTickLength]=\"maxAxisTickLength\"\n\n                    [legend]=\"showLegend\"\n                    [legendTitle]=\"legendTitle\"\n                    [legendPosition]=\"legendPosition\"\n\n                    (select)=\"onSelect($event)\"\n                    (activate)=\"onActivate($event)\"\n                    (deactivate)=\"onDeactivate($event)\"\n                >\n                </ngx-charts-bar-horizontal-normalized>\n            </ng-template>\n\n\n            <!---------------------------------------------------------------------------->\n            <!-- Displays the current features list of a selected product. -->\n            <!---------------------------------------------------------------------------->\n\n            <ng-container *ngIf=\"selectedProductPos_CW != removeChart_PosFlag\">\n\n                <mat-divider class=\"mat-divider-chart\"></mat-divider>\n\n                <h3>{{ chartTitle_F_CW }}</h3>\n\n                <mat-grid-list [cols]=\"'1'\" [rowHeight]=\"gridHeight\">\n                    <mat-grid-tile>\n                        <ng-container *ngIf=\"isChartVertical; then thenTempl_Ver_NormBarChart_CurFeatures; else elseTempl_Hor_NormBarChart_CurFeatures\"></ng-container>\n                        <button mat-icon-button\n                            class=\"button-close-feature\"\n                            color=\"primary\"\n                            [attr.aria-label]=\"'Cerrar el chart'\"\n                            [matTooltip]=\"'Cerrar el chart'\"        \n                            [matTooltipPosition]=\"'above'\"\n                            (click)=\"click_RemoveChart()\"\n                        >\n                            <mat-icon>close</mat-icon>\n                        </button>\n                    </mat-grid-tile>\n                </mat-grid-list>\n\n            </ng-container>\n\n            <ng-template #thenTempl_Ver_NormBarChart_CurFeatures>\n                <ngx-charts-bar-vertical-normalized style=\"display: inline-block\"\n                    [results]=\"currentFeatures_Internal\"\n                    [view]=\"view\"\n                    [scheme]=\"colorScheme_CW\"\n                    [gradient]=\"gradient\"\n                    [barPadding]=\"barPadding\"\n\n                    [xAxis]=\"showXAxis\"\n                    [showXAxisLabel]=\"showXAxisLabel\"\n                    [xAxisLabel]=\"xAxisLabel_F\"\n                    [maxXAxisTickLength]=\"maxAxisTickLength\"\n\n                    [yAxis]=\"showYAxis\"\n                    [showYAxisLabel]=\"showYAxisLabel\"\n                    [yAxisLabel]=\"yAxisLabel_F\"\n                    [maxYAxisTickLength]=\"maxAxisTickLength\"\n\n                    [legend]=\"showLegend\"\n                    [legendTitle]=\"legendTitle\"\n                    [legendPosition]=\"legendPosition\"\n                >\n                </ngx-charts-bar-vertical-normalized>\n            </ng-template>\n\n            <ng-template #elseTempl_Hor_NormBarChart_CurFeatures>\n                <ngx-charts-bar-horizontal-normalized style=\"display: inline-block\"\n                    [results]=\"currentFeatures_Internal\"\n                    [view]=\"view\"\n                    [scheme]=\"colorScheme_CW\"\n                    [gradient]=\"gradient\"\n                    [barPadding]=\"barPadding\"\n\n                    [xAxis]=\"showXAxis\"\n                    [showXAxisLabel]=\"showXAxisLabel\"\n                    [xAxisLabel]=\"xAxisLabel_F\"\n                    [maxXAxisTickLength]=\"maxAxisTickLength\"\n\n                    [yAxis]=\"showYAxis\"\n                    [showYAxisLabel]=\"showYAxisLabel\"\n                    [yAxisLabel]=\"yAxisLabel_F\"\n                    [maxYAxisTickLength]=\"maxAxisTickLength\"\n\n                    [legend]=\"showLegend\"\n                    [legendTitle]=\"legendTitle\"\n                    [legendPosition]=\"legendPosition\"\n                >\n                </ngx-charts-bar-horizontal-normalized>\n            </ng-template>\n\n            <mat-divider class=\"mat-divider-chart\"></mat-divider>\n\n        </mat-tab>\n\n        <mat-tab [label]=\"tabLabel_FW\">\n\n            <!---------------------------------------------------------------------------->\n            <!-- Displays the future products list. -->\n            <!---------------------------------------------------------------------------->\n\n            <h3>{{ chartTitle_P }}</h3>\n\n            <mat-grid-list [cols]=\"'1'\" [rowHeight]=\"gridHeight\">\n                <mat-grid-tile>\n                    <ng-container *ngIf=\"isChartVertical; then thenTempl_Ver_NormBarChart_FutProducts; else elseTempl_Hor_NormBarChart_FutProducts\"></ng-container>\n                    <button mat-icon-button\n                        class=\"button-close-product\"\n                        color=\"primary\"\n                        [attr.aria-label]=\"'Cerrar el chart'\"\n                        [matTooltip]=\"'Cerrar el chart'\"        \n                        [matTooltipPosition]=\"'above'\"\n                    >\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </mat-grid-tile>\n            </mat-grid-list>\n\n            <ng-template #thenTempl_Ver_NormBarChart_FutProducts>\n                <ngx-charts-bar-vertical-normalized style=\"display: inline-block\"\n                    [results]=\"futureProducts_Internal\"\n                    [activeEntries]=\"activeEntries_P_FW\"\n                    [view]=\"view\"\n                    [scheme]=\"colorScheme_FW\"\n                    [gradient]=\"gradient\"\n                    [barPadding]=\"barPadding\"\n\n                    [xAxis]=\"showXAxis\"\n                    [showXAxisLabel]=\"showXAxisLabel\"\n                    [xAxisLabel]=\"xAxisLabel_P\"\n                    [maxXAxisTickLength]=\"maxAxisTickLength\"\n\n                    [yAxis]=\"showYAxis\"\n                    [showYAxisLabel]=\"showYAxisLabel\"\n                    [yAxisLabel]=\"yAxisLabel_P\"\n                    [maxYAxisTickLength]=\"maxAxisTickLength\"\n\n                    [legend]=\"showLegend\"\n                    [legendTitle]=\"legendTitle\"\n                    [legendPosition]=\"legendPosition\"\n\n                    (select)=\"onSelect($event)\"\n                    (activate)=\"onActivate($event)\"\n                    (deactivate)=\"onDeactivate($event)\"\n                >\n                </ngx-charts-bar-vertical-normalized>\n            </ng-template>\n\n            <ng-template #elseTempl_Hor_NormBarChart_FutProducts>\n                <ngx-charts-bar-horizontal-normalized style=\"display: inline-block\"\n                    [results]=\"futureProducts_Internal\"\n                    [activeEntries]=\"activeEntries_P_FW\"\n                    [view]=\"view\"\n                    [scheme]=\"colorScheme_FW\"\n                    [gradient]=\"gradient\"\n                    [barPadding]=\"barPadding\"\n\n                    [xAxis]=\"showXAxis\"\n                    [showXAxisLabel]=\"showXAxisLabel\"\n                    [xAxisLabel]=\"xAxisLabel_P\"\n                    [maxXAxisTickLength]=\"maxAxisTickLength\"\n\n                    [yAxis]=\"showYAxis\"\n                    [showYAxisLabel]=\"showYAxisLabel\"\n                    [yAxisLabel]=\"yAxisLabel_P\"\n                    [maxYAxisTickLength]=\"maxAxisTickLength\"\n\n                    [legend]=\"showLegend\"\n                    [legendTitle]=\"legendTitle\"\n                    [legendPosition]=\"legendPosition\"\n\n                    (select)=\"onSelect($event)\"\n                    (activate)=\"onActivate($event)\"\n                    (deactivate)=\"onDeactivate($event)\"\n                >\n                </ngx-charts-bar-horizontal-normalized>\n            </ng-template>\n\n\n            <!---------------------------------------------------------------------------->\n            <!-- Displays the future features list of a selected product. -->\n            <!---------------------------------------------------------------------------->\n\n            <ng-container *ngIf=\"selectedProductPos_FW != removeChart_PosFlag\">\n\n                <mat-divider class=\"mat-divider-chart\"></mat-divider>\n\n                <h3>{{ chartTitle_F_FW }}</h3>\n\n                <mat-grid-list [cols]=\"'1'\" [rowHeight]=\"gridHeight\">\n                    <mat-grid-tile>\n                        <ng-container *ngIf=\"isChartVertical; then thenTempl_Ver_NormBarChart_FutFeatures; else elseTempl_Hor_NormBarChart_FutFeatures\"></ng-container>\n                        <button mat-icon-button\n                            class=\"button-close-feature\"\n                            color=\"primary\"\n                            [attr.aria-label]=\"'Cerrar el chart'\"\n                            [matTooltip]=\"'Cerrar el chart'\"        \n                            [matTooltipPosition]=\"'above'\"\n                            (click)=\"click_RemoveChart()\"\n                        >\n                            <mat-icon>close</mat-icon>\n                        </button>\n                    </mat-grid-tile>\n                </mat-grid-list>\n\n            </ng-container>\n\n            <ng-template #thenTempl_Ver_NormBarChart_FutFeatures>\n                <ngx-charts-bar-vertical-normalized style=\"display: inline-block\"\n                    [results]=\"futureFeatures_Internal\"\n                    [view]=\"view\"\n                    [scheme]=\"colorScheme_FW\"\n                    [gradient]=\"gradient\"\n                    [barPadding]=\"barPadding\"\n\n                    [xAxis]=\"showXAxis\"\n                    [showXAxisLabel]=\"showXAxisLabel\"\n                    [xAxisLabel]=\"xAxisLabel_F\"\n                    [maxXAxisTickLength]=\"maxAxisTickLength\"\n\n                    [yAxis]=\"showYAxis\"\n                    [showYAxisLabel]=\"showYAxisLabel\"\n                    [yAxisLabel]=\"yAxisLabel_F\"\n                    [maxYAxisTickLength]=\"maxAxisTickLength\"\n\n                    [legend]=\"showLegend\"\n                    [legendTitle]=\"legendTitle\"\n                    [legendPosition]=\"legendPosition\"\n                >\n                </ngx-charts-bar-vertical-normalized>\n            </ng-template>\n\n            <ng-template #elseTempl_Hor_NormBarChart_FutFeatures>\n                <ngx-charts-bar-horizontal-normalized style=\"display: inline-block\"\n                    [results]=\"futureFeatures_Internal\"\n                    [view]=\"view\"\n                    [scheme]=\"colorScheme_FW\"\n                    [gradient]=\"gradient\"\n                    [barPadding]=\"barPadding\"\n\n                    [xAxis]=\"showXAxis\"\n                    [showXAxisLabel]=\"showXAxisLabel\"\n                    [xAxisLabel]=\"xAxisLabel_F\"\n                    [maxXAxisTickLength]=\"maxAxisTickLength\"\n\n                    [yAxis]=\"showYAxis\"\n                    [showYAxisLabel]=\"showYAxisLabel\"\n                    [yAxisLabel]=\"yAxisLabel_F\"\n                    [maxYAxisTickLength]=\"maxAxisTickLength\"\n\n                    [legend]=\"showLegend\"\n                    [legendTitle]=\"legendTitle\"\n                    [legendPosition]=\"legendPosition\"\n                >\n                </ngx-charts-bar-horizontal-normalized>\n            </ng-template>\n\n            <mat-divider class=\"mat-divider-chart\"></mat-divider>\n\n        </mat-tab>\n    </mat-tab-group>\n\n    <br />\n\n</ng-template>\n\n\n<ng-template #elseTemplate_WithoutProducts>\n\n    <div class=\"without-product\">{{ withoutProductText }}</div>\n\n</ng-template>\n",
                        styles: [".mat-divider-chart{margin:1em 2em 0}.checkbox-not-first{margin-left:20px}:host ::ng-deep .mat-grid-tile .mat-figure{align-items:start}.button-close-product{visibility:hidden;margin-top:.2em}.button-close-feature{visibility:visible;margin-top:.2em}:host ::ng-deep header.legend-title{text-align:left;font-weight:400}.without-product{margin:6em 0;text-align:center;cursor:default;color:#444;font-size:1.5em;font-weight:lighter}"]
                    }] }
        ];
        /** @nocollapse */
        RoadMapComponent.ctorParameters = function () { return []; };
        RoadMapComponent.propDecorators = {
            withoutProductText: [{ type: core.Input }],
            tabLabel_CW: [{ type: core.Input }],
            tabLabel_FW: [{ type: core.Input }],
            chartTitle_P: [{ type: core.Input }],
            view: [{ type: core.Input }],
            colorScheme_CW: [{ type: core.Input }],
            colorScheme_FW: [{ type: core.Input }],
            gradient: [{ type: core.Input }],
            barPadding: [{ type: core.Input }],
            xAxisLabel_P: [{ type: core.Input }],
            maxAxisTickLength: [{ type: core.Input }],
            yAxisLabel_P: [{ type: core.Input }],
            legendTitle: [{ type: core.Input }],
            xAxisLabel_F: [{ type: core.Input }],
            yAxisLabel_F: [{ type: core.Input }],
            isChartVertical: [{ type: core.Input }],
            currentProducts: [{ type: core.Input }],
            futureProducts: [{ type: core.Input }],
            legendPosition: [{ type: core.Input }],
            chartTitle_F: [{ type: core.Input }]
        };
        return RoadMapComponent;
    }());
    if (false) {
        /**
         * Returns the -1 value that is used to remove a chart.
         * @type {?}
         */
        RoadMapComponent.prototype.removeChart_PosFlag;
        /**
         * Input field that contains the text that is displayed when there is not any product.
         * By default, its value is `'¡No hay ningún producto!'`.
         * @type {?}
         */
        RoadMapComponent.prototype.withoutProductText;
        /**
         * Returns the chart's visualization direction.
         * It is true if the chart is visualized vertically; otherwise, false (horizontally).
         * By default, its value is `true`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._isChartVertical;
        /**
         * Input field that contains the tab's label of current works.
         * By default, its value is `'Trabajos Actuales'`.
         * @type {?}
         */
        RoadMapComponent.prototype.tabLabel_CW;
        /**
         * Input field that contains the tab's label of future works.
         * By default, its value is `'Trabajos Futuros o Pendientes'`.
         * @type {?}
         */
        RoadMapComponent.prototype.tabLabel_FW;
        /**
         * Returns the selected tab position. Its value is set internally.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._selectedTabPos;
        /**
         * Returns the grid height.
         * Its value is set depending on the `legendPosition` value.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._gridHeight;
        /**
         * Input field that contains the chart's title of products.
         * By default, its value is `'Lista de productos'`.
         * @type {?}
         */
        RoadMapComponent.prototype.chartTitle_P;
        /**
         * Returns true if it is using a trick to obligate repainting the chart; otherwise, false.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._isUsingTrick_RepaintChart;
        /**
         * Returns the working products array introduced by the user.
         * It references the `_currentProducts` or `_futureProducts` array.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._products;
        /**
         * Returns the current products array introduced by the user.
         * From this array is created the `_currentProducts_Internal` and `_currentFeatures_Internal` arrays.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._currentProducts;
        /**
         * Returns the future products array introduced by the user.
         * From this array is created the `_futureProducts_Internal` and `_futureFeatures_Internal` arrays.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._futureProducts;
        /**
         * Returns the working products array displayed in the chart.
         * It references the `_currentProducts_Internal` or `_futureProducts_Internal` array.
         * It is created from the `_products` array.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._products_Internal;
        /**
         * Returns the current products array displayed in the chart.
         * It is created from the `_currentProducts` array.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._currentProducts_Internal;
        /**
         * Returns the future products array displayed in the chart.
         * It is created from the `_futureProducts` array.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._futureProducts_Internal;
        /**
         * Returns the array that contains all working features arrays that can be displayed in the chart.
         * This array contains the same length than `_products_Internal` array because
         * each position contains the working features array for a product.
         * It references the `_currentFeaturesTotal_Internal` or `_futureFeaturesTotal_Internal` array.
         * It is created from the `_products` array.
         * This array is for internal use only.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._featuresTotal_Internal;
        /**
         * Returns the array that contains all current features arrays that can be displayed in the chart.
         * This array contains the same length than `_currentProducts_Internal` array because
         * each position contains the current features array for a product.
         * It is created from the `_currentProducts` array.
         * This array is for internal use only.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._currentFeaturesTotal_Internal;
        /**
         * Returns the array that contains all future features arrays that can be displayed in the chart.
         * This array contains the same length than `_futureProducts_Internal` array because
         * each position contains the future features array for a product.
         * It is created from the `_futureProducts` array.
         * This array is for internal use only.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._futureFeaturesTotal_Internal;
        /**
         * Returns the working features array of a selected product displayed in the chart.
         * It references an element in the `_featuresTotal_Internal` array. This element
         * represents the features of a selected product in the `_products_Internal` array.
         * It references the `_currentFeatures_Internal` or `_futureFeatures_Internal` array.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._features_Internal;
        /**
         * Returns the current features array of a selected product displayed in the chart.
         * It references an element in the `_currentFeaturesTotal_Internal` array. This element
         * represents the features of a selected product in the `_currentProducts_Internal` array.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._currentFeatures_Internal;
        /**
         * Returns the future features array of a selected product displayed in the chart.
         * It references an element in the `_futureFeaturesTotal_Internal` array. This element
         * represents the features of a selected product in the `_futureProducts_Internal` array.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._futureFeatures_Internal;
        /**
         * Returns the current product elements array to highlight displayed in the chart.
         * It is modified dynamically.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._activeEntries_P_CW;
        /**
         * Returns the future product elements array to highlight displayed in the chart.
         * It is modified dynamically.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._activeEntries_P_FW;
        /**
         * Input field that contains the chart's dimensions [width, height].
         * By default, its value is `[900, 350]`.
         * @type {?}
         */
        RoadMapComponent.prototype.view;
        /**
         * Input field that contains the chart's color scheme of current works.
         * By default, its value is the following object:
         * `{
         * domain: [
         * '#6EE9B5',  // light green
         * '#E96E70'   // red
         * ]
         * }`
         * @type {?}
         */
        RoadMapComponent.prototype.colorScheme_CW;
        /**
         * Input field that contains the chart's color scheme of future works.
         * By default, its value is the following object:
         * `{
         * domain: [
         * '#6F6EE9',  // blue
         * '#6EBBE9'   // light blue
         * ]
         * }`
         * @type {?}
         */
        RoadMapComponent.prototype.colorScheme_FW;
        /**
         * Input field that indicates to fill chart's elements with a gradient or a solid color.
         * It is true if the chart's elements are filled with a gradient color; otherwise, false (filled with a solid color).
         * By default, its value is `false`.
         * @type {?}
         */
        RoadMapComponent.prototype.gradient;
        /**
         * Input field that contains the chart's padding between bars in px.
         * By default, its value is `12`.
         * @type {?}
         */
        RoadMapComponent.prototype.barPadding;
        /**
         * Shows the chart's x axis.
         * @type {?}
         */
        RoadMapComponent.prototype.showXAxis;
        /**
         * Shows the chart's x axis label.
         * @type {?}
         */
        RoadMapComponent.prototype.showXAxisLabel;
        /**
         * Input field that contains the chart's x axis label text of products.
         * By default, its value is `'Producto'`.
         * @type {?}
         */
        RoadMapComponent.prototype.xAxisLabel_P;
        /**
         * Input field that contains the chart's max length of the ticks (ticks over this length will be trimmed).
         * By default, its value is `16`.
         * @type {?}
         */
        RoadMapComponent.prototype.maxAxisTickLength;
        /**
         * Shows the chart's y axis.
         * @type {?}
         */
        RoadMapComponent.prototype.showYAxis;
        /**
         * Shows the chart's y axis label.
         * @type {?}
         */
        RoadMapComponent.prototype.showYAxisLabel;
        /**
         * Input field that contains the chart's y axis label text of products.
         * By default, its value is `'Realizado / Pendiente En Por Ciento'`.
         * @type {?}
         */
        RoadMapComponent.prototype.yAxisLabel_P;
        /**
         * Shows the chart's legend.
         * @type {?}
         */
        RoadMapComponent.prototype.showLegend;
        /**
         * Input field that contains the chart's legend title.
         * By default, its value is `'Leyenda'`.
         * @type {?}
         */
        RoadMapComponent.prototype.legendTitle;
        /**
         * Input field that contains the chart's legend position. Its value is `'right'` or `'below'`.
         * By default, its value is `'right'`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._legendPosition;
        /**
         * Returns the working product position. Contains the `removeChart_PosFlag` value when
         * there is not any selected working product position.
         * It has the `_selectedProductPos_CW` or `_selectedProductPos_FW` value.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._selectedProductPos;
        /**
         * Returns the selected current product position. Contains the `removeChart_PosFlag` value when
         * there is not any selected current product position.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._selectedProductPos_CW;
        /**
         * Returns the selected future product position. Contains the `removeChart_PosFlag` value when
         * there is not any selected future product position.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._selectedProductPos_FW;
        /**
         * Returns the chart's title of features.
         * This field is updated a little different.
         * By default, its value is `'Lista de características del producto seleccionado'`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._chartTitle_F;
        /**
         * Returns the chart's title of working current features.
         * This field is updated a little different.
         * By default, its value is `'Lista de características del producto seleccionado'`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._chartTitle_F_CW;
        /**
         * Returns the chart's title of working future features.
         * This field is updated a little different.
         * By default, its value is `'Lista de características del producto seleccionado'`.
         * @type {?}
         * @private
         */
        RoadMapComponent.prototype._chartTitle_F_FW;
        /**
         * Input field that contains the chart's x axis label text of features.
         * By default, its value is `'Característica'`.
         * @type {?}
         */
        RoadMapComponent.prototype.xAxisLabel_F;
        /**
         * Input field that contains the chart's y axis label text of features.
         * By default, its value is `'Realizado / Pendiente En Por Ciento'`.
         * @type {?}
         */
        RoadMapComponent.prototype.yAxisLabel_F;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/utils/road-map-sceiba/road-map-sceiba.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RoadMapSceibaComponent = /** @class */ (function () {
        function RoadMapSceibaComponent() {
            this.title = 'Visualización del roadmap del proyecto Sceiba';
            this.currentProducts = [];
            this.futureProducts = [];
        }
        /**
         * @return {?}
         */
        RoadMapSceibaComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            // this.currentProducts = [ ];
            // this.currentProducts = undefined;
            this.currentProducts = [
                {
                    'name': 'Producto-1',
                    /* 'achieved' = 33.33 */
                    'features': [
                        {
                            'name': 'Característica-1',
                            'achieved': 20
                        },
                        {
                            'name': 'Característica-2',
                            'achieved': 50
                        },
                        {
                            'name': 'Característica-3',
                            'achieved': 30
                        }
                    ]
                },
                {
                    'name': 'Producto-2',
                    /* 'achieved' = 51.00 */
                    'features': [
                        {
                            'name': 'Característica-1',
                            'achieved': 5
                        },
                        {
                            'name': 'Característica-2',
                            'achieved': 50
                        },
                        {
                            'name': 'Característica-3',
                            'achieved': 75
                        },
                        {
                            'name': 'Característica-4',
                            'achieved': 30
                        },
                        {
                            'name': 'Característica-5',
                            'achieved': 95
                        }
                    ]
                },
                {
                    'name': 'Producto-3',
                    /* 'achieved' = 100.00 */
                    'features': [
                        {
                            'name': 'Característica-1',
                            'achieved': 100
                        }
                    ]
                },
                {
                    'name': 'Producto-4',
                    /* 'achieved' = 0.00 */
                    'features': [
                        {
                            'name': 'Característica-1',
                            'achieved': 0
                        }
                    ]
                },
                {
                    'name': 'Producto-5',
                    /* 'achieved' = 47.50 */
                    'features': [
                        {
                            'name': 'Característica-1',
                            'achieved': 80
                        },
                        {
                            'name': 'Característica-2',
                            'achieved': 25
                        },
                        {
                            'name': 'Característica-3',
                            'achieved': 95
                        },
                        {
                            'name': 'Característica-4',
                            'achieved': 40
                        },
                        {
                            'name': 'Característica-5',
                            'achieved': 10
                        },
                        {
                            'name': 'Característica-6',
                            'achieved': 15
                        },
                        {
                            'name': 'Característica-7',
                            'achieved': 15
                        },
                        {
                            'name': 'Característica-8',
                            'achieved': 100
                        }
                    ]
                },
                {
                    'name': 'Producto-6',
                    /* 'achieved' = -- */
                    'features': []
                    // 'features': undefined
                }
            ];
            // this.futureProducts = [ ];
            // this.futureProducts = undefined;
            this.futureProducts = [
                {
                    'name': 'Fut-Producto-1',
                    /* 'achieved' = 33.33 */
                    'features': [
                        {
                            'name': 'Fut-Característica-1',
                            'achieved': 80
                        },
                        {
                            'name': 'Fut-Característica-2',
                            'achieved': 50
                        }
                    ]
                },
                {
                    'name': 'Fut-Producto-2',
                    /* 'achieved' = 51.00 */
                    'features': [
                        {
                            'name': 'Fut-Característica-1',
                            'achieved': 0
                        },
                        {
                            'name': 'Fut-Característica-2',
                            'achieved': 5
                        },
                        {
                            'name': 'Fut-Característica-3',
                            'achieved': 0
                        },
                        {
                            'name': 'Fut-Característica-4',
                            'achieved': 0
                        },
                        {
                            'name': 'Fut-Característica-5',
                            'achieved': 0
                        }
                    ]
                },
                {
                    'name': 'Fut-Producto-3',
                    /* 'achieved' = 100.00 */
                    'features': [
                        {
                            'name': 'Fut-Característica-1',
                            'achieved': 100
                        }
                    ]
                },
                {
                    'name': 'Fut-Producto-4',
                    /* 'achieved' = 0.00 */
                    'features': [
                        {
                            'name': 'Fut-Característica-1',
                            'achieved': 0
                        }
                    ]
                },
                {
                    'name': 'Fut-Producto-5',
                    /* 'achieved' = 47.50 */
                    'features': [
                        {
                            'name': 'Fut-Característica-1',
                            'achieved': 0
                        },
                        {
                            'name': 'Fut-Característica-2',
                            'achieved': 100
                        },
                        {
                            'name': 'Fut-Característica-3',
                            'achieved': 50
                        },
                        {
                            'name': 'Fut-Característica-4',
                            'achieved': 20
                        },
                        {
                            'name': 'Fut-Característica-5',
                            'achieved': 80
                        },
                        {
                            'name': 'Fut-Característica-6',
                            'achieved': 0
                        },
                        {
                            'name': 'Fut-Característica-7',
                            'achieved': 0
                        },
                        {
                            'name': 'Fut-Característica-8',
                            'achieved': 0
                        }
                    ]
                },
                {
                    'name': 'Fut-Producto-6',
                    /* 'achieved' = -- */
                    'features': []
                    // 'features': undefined
                }
            ];
        };
        RoadMapSceibaComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-road-map-sceiba',
                        template: "\n<h2 style=\"text-align: center\">{{ title }}</h2>\n\n<div style=\"text-align: center\">\n    <!-- <toco-road-map></toco-road-map> -->\n    <toco-road-map [currentProducts]=\"currentProducts\" [futureProducts]=\"futureProducts\"></toco-road-map>\n</div>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        RoadMapSceibaComponent.ctorParameters = function () { return []; };
        return RoadMapSceibaComponent;
    }());
    if (false) {
        /**
         * Returns the road map's title.
         * By default, its value is `'Visualización del roadmap del proyecto Sceiba'`.
         * @type {?}
         */
        RoadMapSceibaComponent.prototype.title;
        /**
         * Returns the current products array introduced by the user.
         * From this array is created the internal current products array,
         * and the internal current features array for each product.
         * By default, its value is `[]`.
         * @type {?}
         */
        RoadMapSceibaComponent.prototype.currentProducts;
        /**
         * Returns the future products array introduced by the user.
         * From this array is created the internal future products array,
         * and the internal future features array for each product.
         * By default, its value is `[]`.
         * @type {?}
         */
        RoadMapSceibaComponent.prototype.futureProducts;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/utils/get-view-container.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A helper directive to mark valid insertion points in the template.
     * This directive injects the `ViewContainerRef` to gain access to the view container of the element
     * that will host the dynamically components.
     * In the `\@Directive` decorator, notice the selector name, `get-view-container`; that's what you use
     * to apply the directive to the element.
     */
    var GetViewContainerDirective = /** @class */ (function () {
        function GetViewContainerDirective(_viewContainerRef, _componentFactoryResolver) {
            this._viewContainerRef = _viewContainerRef;
            this._componentFactoryResolver = _componentFactoryResolver;
        }
        Object.defineProperty(GetViewContainerDirective.prototype, "viewContainerRef", {
            /**
             * Returns the injected `ViewContainerRef` to gain access to the view container of the element
             * that will host the dynamically components.
             */
            get: /**
             * Returns the injected `ViewContainerRef` to gain access to the view container of the element
             * that will host the dynamically components.
             * @return {?}
             */
            function () {
                return this._viewContainerRef;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GetViewContainerDirective.prototype, "componentFactoryResolver", {
            /**
             * Returns the injected `ComponentFactoryResolver` to gain access to the factory for a given component type.
             */
            get: /**
             * Returns the injected `ComponentFactoryResolver` to gain access to the factory for a given component type.
             * @return {?}
             */
            function () {
                return this._componentFactoryResolver;
            },
            enumerable: true,
            configurable: true
        });
        GetViewContainerDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[get-view-container]'
                    },] }
        ];
        /** @nocollapse */
        GetViewContainerDirective.ctorParameters = function () { return [
            { type: core.ViewContainerRef },
            { type: core.ComponentFactoryResolver }
        ]; };
        return GetViewContainerDirective;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        GetViewContainerDirective.prototype._viewContainerRef;
        /**
         * @type {?}
         * @private
         */
        GetViewContainerDirective.prototype._componentFactoryResolver;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/utils/validator.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a class that contains a boolean property named `required`.
     * @record
     */
    function RequiredProperty() { }
    if (false) {
        /**
         * Returns true if the control is required; otherwise, false.
         * @type {?}
         */
        RequiredProperty.prototype.required;
    }
    /**
     * \@description
     * Provides a set of extra validators that can be used by form controls.
     *
     * A validator is a function that processes a `FormControl` or collection of
     * controls and returns an error map or `null`. A `null` map means that validation has passed.
     *
     * @see [Form Validation](/guide/form-validation)
     */
    var   /**
     * \@description
     * Provides a set of extra validators that can be used by form controls.
     *
     * A validator is a function that processes a `FormControl` or collection of
     * controls and returns an error map or `null`. A `null` map means that validation has passed.
     *
     * @see [Form Validation](/guide/form-validation)
     */
    ExtraValidators = /** @class */ (function () {
        function ExtraValidators() {
        }
        /**
         * @description
         * Validator that requires the length of the control's value to be equal to the
         * provided length. It assumes that the control's value is of string type.
         * This validator is used with Reactive Forms; if you want to use
         * an equivalent validator with Template-driven Form you must use the `equalLength` attribute.
         *
         * @usageNotes
         *
         * ### Validates that the field has a length of 4 characters:
         *
         * ```typescript
         * const control = new FormControl('ng', ExtraValidators.equalLength(4));
         *
         * console.log(control.errors); // { equalLength: { requiredLength: 4, actualLength: 2 } }
         * ```
         *
         * ```html
         * <input name="firstName" ngModel equallength="4">
         * ```
         *
         * @returns A validator function that returns an error map with the `equalLength`
         * if the validation check fails, otherwise `null`.
         */
        /**
         * \@description
         * Validator that requires the length of the control's value to be equal to the
         * provided length. It assumes that the control's value is of string type.
         * This validator is used with Reactive Forms; if you want to use
         * an equivalent validator with Template-driven Form you must use the `equalLength` attribute.
         *
         * \@usageNotes
         *
         * ### Validates that the field has a length of 4 characters:
         *
         * ```typescript
         * const control = new FormControl('ng', ExtraValidators.equalLength(4));
         *
         * console.log(control.errors); // { equalLength: { requiredLength: 4, actualLength: 2 } }
         * ```
         *
         * ```html
         * <input name="firstName" ngModel equallength="4">
         * ```
         *
         * @param {?} equalLength
         * @return {?} A validator function that returns an error map with the `equalLength`
         * if the validation check fails, otherwise `null`.
         */
        ExtraValidators.equalLength = /**
         * \@description
         * Validator that requires the length of the control's value to be equal to the
         * provided length. It assumes that the control's value is of string type.
         * This validator is used with Reactive Forms; if you want to use
         * an equivalent validator with Template-driven Form you must use the `equalLength` attribute.
         *
         * \@usageNotes
         *
         * ### Validates that the field has a length of 4 characters:
         *
         * ```typescript
         * const control = new FormControl('ng', ExtraValidators.equalLength(4));
         *
         * console.log(control.errors); // { equalLength: { requiredLength: 4, actualLength: 2 } }
         * ```
         *
         * ```html
         * <input name="firstName" ngModel equallength="4">
         * ```
         *
         * @param {?} equalLength
         * @return {?} A validator function that returns an error map with the `equalLength`
         * if the validation check fails, otherwise `null`.
         */
        function (equalLength) {
            /** @type {?} */
            var res = (/**
             * @param {?} control
             * @return {?}
             */
            function (control) {
                /** @type {?} */
                var len = control.value ? control.value.length : 0;
                return ((len != 0) && (len != equalLength))
                    ? { 'equalLength': { 'requiredLength': equalLength, 'actualLength': len } }
                    : null;
            });
            return res;
        };
        /**
         * @description
         * Validator that is applied to `FormArray` controls. It requires that the amount of
         * `FormArray`'s child controls to be greater than or equal to the provided minimum length.
         * The validator exists only as a function and not as a directive.
         *
         * @usageNotes
         *
         * ### Validates that the `FormArray` field has a minimum of 2 child controls:
         *
         * ```typescript
         * const formArrayControl = new FormArray([new FormControl('ng')], ExtraValidators.minLength(2));
         *
         * console.log(formArrayControl.errors); // { minLength: { requiredLength: 2, actualLength: 1 } }
         * ```
         *
         * @returns A validator function that returns an error map with the
         * `minLength` if the validation check fails, otherwise `null`.
         */
        /**
         * \@description
         * Validator that is applied to `FormArray` controls. It requires that the amount of
         * `FormArray`'s child controls to be greater than or equal to the provided minimum length.
         * The validator exists only as a function and not as a directive.
         *
         * \@usageNotes
         *
         * ### Validates that the `FormArray` field has a minimum of 2 child controls:
         *
         * ```typescript
         * const formArrayControl = new FormArray([new FormControl('ng')], ExtraValidators.minLength(2));
         *
         * console.log(formArrayControl.errors); // { minLength: { requiredLength: 2, actualLength: 1 } }
         * ```
         *
         * @param {?} minLength
         * @return {?} A validator function that returns an error map with the
         * `minLength` if the validation check fails, otherwise `null`.
         */
        ExtraValidators.minLength = /**
         * \@description
         * Validator that is applied to `FormArray` controls. It requires that the amount of
         * `FormArray`'s child controls to be greater than or equal to the provided minimum length.
         * The validator exists only as a function and not as a directive.
         *
         * \@usageNotes
         *
         * ### Validates that the `FormArray` field has a minimum of 2 child controls:
         *
         * ```typescript
         * const formArrayControl = new FormArray([new FormControl('ng')], ExtraValidators.minLength(2));
         *
         * console.log(formArrayControl.errors); // { minLength: { requiredLength: 2, actualLength: 1 } }
         * ```
         *
         * @param {?} minLength
         * @return {?} A validator function that returns an error map with the
         * `minLength` if the validation check fails, otherwise `null`.
         */
        function (minLength) {
            /** @type {?} */
            var res = (/**
             * @param {?} control
             * @return {?}
             */
            function (control) {
                /** @type {?} */
                var len = control.controls.length;
                return (len < minLength)
                    ? { 'minLength': { 'requiredLength': minLength, 'actualLength': len } }
                    : null;
            });
            return res;
        };
        /**
         * @description
         * Validator that is applied to a control that has an array of child controls.
         * It receives an object that fits the `RequiredProperty` interface and an array of child controls.
         * The behavior of the validator is the following:
         * If the control's value is required, then
         *   - all child controls must be different of empty.
         * If the control's value is not required, then
         *   - all child controls can be empty.
         *   - if there is at least one child control not empty, then all child controls must be different of empty.
         * The validator exists only as a function and not as a directive.
         *
         * @usageNotes
         *
         * ### Validates that the control does not have an empty child control:
         *
         * ```typescript
         * const control = new FormGroup({
         *     'fg': (firstGroup = new FormControl('2049')),
         *     'sg': (secondGroup = new FormControl(''))},
         *     ExtraValidators.requiredAndNotEmpty(this, [firstGroup, secondGroup]));
         *
         * console.log(control.errors); // { requiredAndNotEmpty: { required: true, pos: 1 } }
         * ```
         *
         * @returns A validator function that returns an error map with the `requiredAndNotEmpty`
         * if the validation check fails, otherwise `null`.
         */
        /**
         * \@description
         * Validator that is applied to a control that has an array of child controls.
         * It receives an object that fits the `RequiredProperty` interface and an array of child controls.
         * The behavior of the validator is the following:
         * If the control's value is required, then
         *   - all child controls must be different of empty.
         * If the control's value is not required, then
         *   - all child controls can be empty.
         *   - if there is at least one child control not empty, then all child controls must be different of empty.
         * The validator exists only as a function and not as a directive.
         *
         * \@usageNotes
         *
         * ### Validates that the control does not have an empty child control:
         *
         * ```typescript
         * const control = new FormGroup({
         *     'fg': (firstGroup = new FormControl('2049')),
         *     'sg': (secondGroup = new FormControl(''))},
         *     ExtraValidators.requiredAndNotEmpty(this, [firstGroup, secondGroup]));
         *
         * console.log(control.errors); // { requiredAndNotEmpty: { required: true, pos: 1 } }
         * ```
         *
         * @param {?} requiredProperty
         * @param {?} childControls
         * @return {?} A validator function that returns an error map with the `requiredAndNotEmpty`
         * if the validation check fails, otherwise `null`.
         */
        ExtraValidators.requiredAndNotEmpty = /**
         * \@description
         * Validator that is applied to a control that has an array of child controls.
         * It receives an object that fits the `RequiredProperty` interface and an array of child controls.
         * The behavior of the validator is the following:
         * If the control's value is required, then
         *   - all child controls must be different of empty.
         * If the control's value is not required, then
         *   - all child controls can be empty.
         *   - if there is at least one child control not empty, then all child controls must be different of empty.
         * The validator exists only as a function and not as a directive.
         *
         * \@usageNotes
         *
         * ### Validates that the control does not have an empty child control:
         *
         * ```typescript
         * const control = new FormGroup({
         *     'fg': (firstGroup = new FormControl('2049')),
         *     'sg': (secondGroup = new FormControl(''))},
         *     ExtraValidators.requiredAndNotEmpty(this, [firstGroup, secondGroup]));
         *
         * console.log(control.errors); // { requiredAndNotEmpty: { required: true, pos: 1 } }
         * ```
         *
         * @param {?} requiredProperty
         * @param {?} childControls
         * @return {?} A validator function that returns an error map with the `requiredAndNotEmpty`
         * if the validation check fails, otherwise `null`.
         */
        function (requiredProperty, childControls) {
            /** @type {?} */
            var res = (/**
             * @param {?} control
             * @return {?}
             */
            function (control) {
                /** @type {?} */
                var i = 0;
                /** @type {?} */
                var controlsGroupLength = childControls.length;
                if (requiredProperty.required) {
                    /* Only iterates to the first empty element. */
                    for (; i < controlsGroupLength; i++) {
                        if (!childControls[i].value)
                            break;
                    }
                    return (i == controlsGroupLength)
                        ? null
                        : { 'requiredAndNotEmpty': { 'required': true, 'pos': i } };
                }
                else {
                    /** @type {?} */
                    var hasControlNotEmpty = false;
                    /** @type {?} */
                    var minEmptyPos = -1;
                    /* Iterates to the first empty element. */
                    for (; i < controlsGroupLength; i++) {
                        if (childControls[i].value) {
                            if (minEmptyPos != -1)
                                break;
                            hasControlNotEmpty = true;
                        }
                        else {
                            if (minEmptyPos == -1)
                                minEmptyPos = i;
                            if (hasControlNotEmpty)
                                break;
                        }
                    }
                    return (i == controlsGroupLength)
                        ? null
                        : { 'requiredAndNotEmpty': { 'required': true, 'pos': minEmptyPos } };
                }
            });
            return res;
        };
        /**
         * @description
         * Validator that requires the control's value pass an ISSN validation test (confirm the check digit).
         * Assumes that the code (control's value) is a string of length 11, with the form 'XXXX – XXXX'.
         * The validator exists only as a function and not as a directive.
         *
         * @usageNotes
         *
         * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
         *
         * ```typescript
         * const control = new FormControl('2049 – 3635', ExtraValidators.issnConfirmCheckDigitOneField(11));
         *
         * console.log(control.errors); // { issnConfirmCheckDigitOneField: true }
         * ```
         *
         * @returns A validator function that returns an error map with the `issnConfirmCheckDigitOneField`
         * if the validation check fails, otherwise `null`.
         */
        /**
         * \@description
         * Validator that requires the control's value pass an ISSN validation test (confirm the check digit).
         * Assumes that the code (control's value) is a string of length 11, with the form 'XXXX – XXXX'.
         * The validator exists only as a function and not as a directive.
         *
         * \@usageNotes
         *
         * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
         *
         * ```typescript
         * const control = new FormControl('2049 – 3635', ExtraValidators.issnConfirmCheckDigitOneField(11));
         *
         * console.log(control.errors); // { issnConfirmCheckDigitOneField: true }
         * ```
         *
         * @param {?} codeLength
         * @return {?} A validator function that returns an error map with the `issnConfirmCheckDigitOneField`
         * if the validation check fails, otherwise `null`.
         */
        ExtraValidators.issnConfirmCheckDigitOneField = /**
         * \@description
         * Validator that requires the control's value pass an ISSN validation test (confirm the check digit).
         * Assumes that the code (control's value) is a string of length 11, with the form 'XXXX – XXXX'.
         * The validator exists only as a function and not as a directive.
         *
         * \@usageNotes
         *
         * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
         *
         * ```typescript
         * const control = new FormControl('2049 – 3635', ExtraValidators.issnConfirmCheckDigitOneField(11));
         *
         * console.log(control.errors); // { issnConfirmCheckDigitOneField: true }
         * ```
         *
         * @param {?} codeLength
         * @return {?} A validator function that returns an error map with the `issnConfirmCheckDigitOneField`
         * if the validation check fails, otherwise `null`.
         */
        function (codeLength) {
            /** @type {?} */
            var res = (/**
             * @param {?} control
             * @return {?}
             */
            function (control) {
                if (control.value.length == codeLength) {
                    /** @type {?} */
                    var code = control.value;
                    /** @type {?} */
                    var result = (code.charCodeAt(0) - 48) * 8;
                    result += (code.charCodeAt(1) - 48) * 7;
                    result += (code.charCodeAt(2) - 48) * 6;
                    result += (code.charCodeAt(3) - 48) * 5;
                    /* code[4] = ' ', code[5] = '–', code[6] = ' '. */
                    result += (code.charCodeAt(7) - 48) * 4;
                    result += (code.charCodeAt(8) - 48) * 3;
                    result += (code.charCodeAt(9) - 48) * 2;
                    result += ((code[10] == 'x') || (code[10] == 'X')) ? 10 : code.charCodeAt(10) - 48;
                    return (result % 11)
                        ? { 'issnConfirmCheckDigitOneField': true }
                        : null;
                }
                return null;
            });
            return res;
        };
        /**
         * @description
         * Validator that requires the control's value passes an ISSN validation test (confirms the check digit).
         * The ISSN value is divided in two groups, therefore the control has two child controls and they are
         * arguments of the validator method. It assumes that the control's value is of string type.
         * The validator exists only as a function and not as a directive.
         *
         * @usageNotes
         *
         * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
         *
         * ```typescript
         * const control = new FormGroup({
         *     'fg': (firstGroup = new FormControl('2049')),
         *     'sg': (secondGroup = new FormControl('3635'))},
         *     ExtraValidators.issnConfirmCheckDigitTwoField(firstGroup, secondGroup, 4));
         *
         * console.log(control.errors); // { issnConfirmCheckDigitTwoField: true }
         * ```
         *
         * @returns A validator function that returns an error map with the `issnConfirmCheckDigitTwoField`
         * if the validation check fails, otherwise `null`.
         */
        /**
         * \@description
         * Validator that requires the control's value passes an ISSN validation test (confirms the check digit).
         * The ISSN value is divided in two groups, therefore the control has two child controls and they are
         * arguments of the validator method. It assumes that the control's value is of string type.
         * The validator exists only as a function and not as a directive.
         *
         * \@usageNotes
         *
         * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
         *
         * ```typescript
         * const control = new FormGroup({
         *     'fg': (firstGroup = new FormControl('2049')),
         *     'sg': (secondGroup = new FormControl('3635'))},
         *     ExtraValidators.issnConfirmCheckDigitTwoField(firstGroup, secondGroup, 4));
         *
         * console.log(control.errors); // { issnConfirmCheckDigitTwoField: true }
         * ```
         *
         * @param {?} firstGroup
         * @param {?} secondGroup
         * @param {?} groupLength
         * @return {?} A validator function that returns an error map with the `issnConfirmCheckDigitTwoField`
         * if the validation check fails, otherwise `null`.
         */
        ExtraValidators.issnConfirmCheckDigitTwoField = /**
         * \@description
         * Validator that requires the control's value passes an ISSN validation test (confirms the check digit).
         * The ISSN value is divided in two groups, therefore the control has two child controls and they are
         * arguments of the validator method. It assumes that the control's value is of string type.
         * The validator exists only as a function and not as a directive.
         *
         * \@usageNotes
         *
         * ### Validates that the field matches a valid ISSN pattern (confirms the check digit):
         *
         * ```typescript
         * const control = new FormGroup({
         *     'fg': (firstGroup = new FormControl('2049')),
         *     'sg': (secondGroup = new FormControl('3635'))},
         *     ExtraValidators.issnConfirmCheckDigitTwoField(firstGroup, secondGroup, 4));
         *
         * console.log(control.errors); // { issnConfirmCheckDigitTwoField: true }
         * ```
         *
         * @param {?} firstGroup
         * @param {?} secondGroup
         * @param {?} groupLength
         * @return {?} A validator function that returns an error map with the `issnConfirmCheckDigitTwoField`
         * if the validation check fails, otherwise `null`.
         */
        function (firstGroup, secondGroup, groupLength) {
            /** @type {?} */
            var res = (/**
             * @param {?} control
             * @return {?}
             */
            function (control) {
                if ((firstGroup.value.length == groupLength) && (secondGroup.value.length == groupLength)) {
                    /** @type {?} */
                    var groupValue = firstGroup.value;
                    /** @type {?} */
                    var result = (groupValue.charCodeAt(0) - 48) * 8;
                    result += (groupValue.charCodeAt(1) - 48) * 7;
                    result += (groupValue.charCodeAt(2) - 48) * 6;
                    result += (groupValue.charCodeAt(3) - 48) * 5;
                    result += ((groupValue = secondGroup.value).charCodeAt(0) - 48) * 4;
                    result += (groupValue.charCodeAt(1) - 48) * 3;
                    result += (groupValue.charCodeAt(2) - 48) * 2;
                    result += ((groupValue[3] == 'x') || (groupValue[3] == 'X')) ? 10 : groupValue.charCodeAt(3) - 48;
                    return (result % 11)
                        ? { 'issnConfirmCheckDigitTwoField': true }
                        : null;
                }
                return null;
            });
            return res;
        };
        /**
         * @param {?} internalFormGroup
         * @return {?}
         */
        ExtraValidators.issnValidator = /**
         * @param {?} internalFormGroup
         * @return {?}
         */
        function (internalFormGroup) {
            /** @type {?} */
            var res = (/**
             * @param {?} control
             * @return {?}
             */
            function (control) {
                return (!internalFormGroup.valid)
                    ? { 'issnValidator': { 'requiredValid': internalFormGroup.valid } }
                    : null;
            });
            return res;
        };
        return ExtraValidators;
    }());
    /**
     * \@description
     * A directive that represents a validator that requires the length of the control's value
     * to be equal to the provided length. The control must be marked with the `equalLength` attribute.
     * The directive is provided with the `NG_VALIDATORS` mult-provider list.
     * This validator is used with Template-driven Form; if you want to use an equivalent validator
     * with Reactive Forms you must use the `ExtraValidators.equalLength` method.
     *
     * \@usageNotes
     *
     * ### Validates that the field has a length of 4 characters:
     *
     * The following example shows how to add an equal length validator to an input attached to an
     * ngModel binding.
     *
     * ```html
     * <input name="firstName" ngModel equallength="4">
     * ```
     */
    var EqualLengthDirective = /** @class */ (function () {
        function EqualLengthDirective() {
        }
        /**
         * @description
         * A lifecycle hook method that is called when the directive's inputs change. For internal use only.
         *
         * @param changes An object of key/value pairs for the set of changed inputs.
         */
        /**
         * \@description
         * A lifecycle hook method that is called when the directive's inputs change. For internal use only.
         *
         * @param {?} changes An object of key/value pairs for the set of changed inputs.
         * @return {?}
         */
        EqualLengthDirective.prototype.ngOnChanges = /**
         * \@description
         * A lifecycle hook method that is called when the directive's inputs change. For internal use only.
         *
         * @param {?} changes An object of key/value pairs for the set of changed inputs.
         * @return {?}
         */
        function (changes) {
            if ('equalLength' in changes) {
                this._validator = ExtraValidators.equalLength(parseInt(this.equalLength, 10));
                if (this._onChange)
                    this._onChange();
            }
        };
        /**
         * @description
         * Method that performs synchronous validation against the provided control. It requires the length
         * of the control's value to be equal to the provided `equalLength`.
         *
         * @param control The control to validate against.
         *
         * @returns A map of validation errors if validation fails; otherwise, `null`.
         */
        /**
         * \@description
         * Method that performs synchronous validation against the provided control. It requires the length
         * of the control's value to be equal to the provided `equalLength`.
         *
         * @param {?} control The control to validate against.
         *
         * @return {?} A map of validation errors if validation fails; otherwise, `null`.
         */
        EqualLengthDirective.prototype.validate = /**
         * \@description
         * Method that performs synchronous validation against the provided control. It requires the length
         * of the control's value to be equal to the provided `equalLength`.
         *
         * @param {?} control The control to validate against.
         *
         * @return {?} A map of validation errors if validation fails; otherwise, `null`.
         */
        function (control) {
            return (this.equalLength)
                ? this._validator(control)
                : null;
        };
        /**
         * @description
         * Registers a callback function to call when the validator inputs change.
         *
         * @param fn The callback function to register.
         */
        /**
         * \@description
         * Registers a callback function to call when the validator inputs change.
         *
         * @param {?} fn The callback function to register.
         * @return {?}
         */
        EqualLengthDirective.prototype.registerOnValidatorChange = /**
         * \@description
         * Registers a callback function to call when the validator inputs change.
         *
         * @param {?} fn The callback function to register.
         * @return {?}
         */
        function (fn) {
            this._onChange = fn;
        };
        EqualLengthDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[equalLength]',
                        providers: [{
                                provide: forms.NG_VALIDATORS,
                                useExisting: EqualLengthDirective,
                                multi: true
                            }]
                    },] }
        ];
        EqualLengthDirective.propDecorators = {
            equalLength: [{ type: core.Input }]
        };
        return EqualLengthDirective;
    }());
    if (false) {
        /**
         * \@description
         * Input variable that contains the length to check.
         * @type {?}
         */
        EqualLengthDirective.prototype.equalLength;
        /**
         * @type {?}
         * @private
         */
        EqualLengthDirective.prototype._validator;
        /**
         * @type {?}
         * @private
         */
        EqualLengthDirective.prototype._onChange;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/utils/message-handler.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var HandlerComponent = {
        snackBar: "snackBar",
        dialog: "dialog",
    };
    /** @enum {number} */
    var StatusCode = {
        OK: 200,
        serverError: 500,
        notFound: 400,
    };
    StatusCode[StatusCode.OK] = 'OK';
    StatusCode[StatusCode.serverError] = 'serverError';
    StatusCode[StatusCode.notFound] = 'notFound';
    /**
     * Object that is used with the `DialogContentComponent` component.
     * It contains the different data that are showed in the message.
     */
    var   /**
     * Object that is used with the `DialogContentComponent` component.
     * It contains the different data that are showed in the message.
     */
    DialogMessageData = /** @class */ (function () {
        function DialogMessageData() {
        }
        return DialogMessageData;
    }());
    if (false) {
        /**
         * Message title.
         * @type {?}
         */
        DialogMessageData.prototype.title;
        /**
         * Message content.
         * @type {?}
         */
        DialogMessageData.prototype.content;
    }
    /**
     * Object that is used with the `DialogDeleteConfirmComponent` component.
     * It contains the different data that are showed in the message.
     */
    var   /**
     * Object that is used with the `DialogDeleteConfirmComponent` component.
     * It contains the different data that are showed in the message.
     */
    DialogDeleteConfirmMessageData = /** @class */ (function () {
        function DialogDeleteConfirmMessageData() {
        }
        return DialogDeleteConfirmMessageData;
    }());
    if (false) {
        /**
         * Article of the type to delete.
         * @type {?}
         */
        DialogDeleteConfirmMessageData.prototype.delTypeArt;
        /**
         * Type to delete.
         * @type {?}
         */
        DialogDeleteConfirmMessageData.prototype.delType;
        /**
         * Value to delete.
         * @type {?}
         */
        DialogDeleteConfirmMessageData.prototype.delValue;
    }
    /**
     * Simple dialog message.
     */
    var DialogContentComponent = /** @class */ (function () {
        function DialogContentComponent(data) {
            this.data = data;
        }
        DialogContentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-dialog-message',
                        template: "\n\t\t<h1 mat-dialog-title>\n\t\t\t{{ data.title }}\n\t\t</h1>\n\t\t<mat-dialog-content> {{ data.content }} </mat-dialog-content>\n\t\t<mat-dialog-actions align=\"end\">\n\t\t\t<button mat-stroked-button mat-dialog-close>OK</button>\n\t\t</mat-dialog-actions>\n\t"
                    }] }
        ];
        /** @nocollapse */
        DialogContentComponent.ctorParameters = function () { return [
            { type: DialogMessageData, decorators: [{ type: core.Inject, args: [dialog.MAT_DIALOG_DATA,] }] }
        ]; };
        return DialogContentComponent;
    }());
    if (false) {
        /** @type {?} */
        DialogContentComponent.prototype.data;
    }
    /**
     * Dialog confirm message used to delete something.
     */
    var DialogDeleteConfirmComponent = /** @class */ (function () {
        function DialogDeleteConfirmComponent(data) {
            this.data = data;
        }
        DialogDeleteConfirmComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-dialog-delete-confirm',
                        template: "\n\t\t<h1 mat-dialog-title>\n\t\t\t\u00BFEst\u00E1 usted seguro que desea eliminar {{ data.delTypeArt }} <strong>{{ data.delType }}</strong>?\n\t\t</h1>\n\t\t<mat-dialog-content>\n\t\t\tSu valor es: <em>{{ data.delValue }}</em>\n\t\t</mat-dialog-content>\n\t\t<mat-dialog-actions align=\"end\">\n\t\t\t<button mat-stroked-button mat-dialog-close color=\"warning\">Cancelar</button>\n\t\t\t<button mat-stroked-button [mat-dialog-close]=\"true\" color=\"warning\" cdkFocusInitial>Eliminar</button>\n\t\t</mat-dialog-actions>\n\t"
                    }] }
        ];
        /** @nocollapse */
        DialogDeleteConfirmComponent.ctorParameters = function () { return [
            { type: DialogDeleteConfirmMessageData, decorators: [{ type: core.Inject, args: [dialog.MAT_DIALOG_DATA,] }] }
        ]; };
        return DialogDeleteConfirmComponent;
    }());
    if (false) {
        /** @type {?} */
        DialogDeleteConfirmComponent.prototype.data;
    }
    var MessageHandler = /** @class */ (function () {
        function MessageHandler(_snackBar, dialog) {
            this._snackBar = _snackBar;
            this.dialog = dialog;
        }
        /**
         * @param {?} status
         * @param {?=} message
         * @param {?=} component
         * @param {?=} title
         * @param {?=} width
         * @return {?}
         */
        MessageHandler.prototype.showMessage = /**
         * @param {?} status
         * @param {?=} message
         * @param {?=} component
         * @param {?=} title
         * @param {?=} width
         * @return {?}
         */
        function (status, message, component, title, width) {
            switch (status) {
                case StatusCode.serverError:
                    this.componentHandler(message ? message : 'No se pudo conectar al servidor.', component, title, width);
                    break;
                case StatusCode.notFound:
                    this.componentHandler(message ? message : 'Operación extraviada, no se pudo realizar.', component, title, width);
                    break;
                default:
                    this.componentHandler(message ? message : 'Operación realizada con éxito.', component, title, width);
                    break;
            }
        };
        /**
         * @private
         * @param {?} message
         * @param {?=} handlercomponent
         * @param {?=} title
         * @param {?=} width
         * @return {?}
         */
        MessageHandler.prototype.componentHandler = /**
         * @private
         * @param {?} message
         * @param {?=} handlercomponent
         * @param {?=} title
         * @param {?=} width
         * @return {?}
         */
        function (message, handlercomponent, title, width) {
            if (width === void 0) { width = '300px'; }
            switch (handlercomponent) {
                case HandlerComponent.dialog:
                    this.dialog.open(DialogContentComponent, {
                        width: width,
                        data: { title: title, content: message }
                    });
                    break;
                default:
                    this._snackBar.open(message, null, {
                        duration: 5000,
                        verticalPosition: 'bottom',
                    });
                    break;
            }
        };
        return MessageHandler;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        MessageHandler.prototype._snackBar;
        /** @type {?} */
        MessageHandler.prototype.dialog;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/utils/progress.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // @Component({
    //     selector: 'toco-progress',
    //     template: `
    //     <mat-progress-bar *ngIf="loading"
    //         mode="indeterminate" color="warn" style="z-index: 1001">
    //     </mat-progress-bar>
    //     <div *ngIf="loading && position == 'fixed'" class="overlay-fixed">
    //     </div >
    //     <div *ngIf="loading && position == 'absolute'" class="overlay-absolute">
    //     </div> `,
    //     styles: [
    // `.overlay-fixed {
    //     opacity:    0.4;
    //     background: #000;
    //     width:      100%;
    //     height:     100%;
    //     z-index:    1000;
    //     top:        0;
    //     left:       0;
    //     position:   fixed;
    //   }
    //   .overlay-absolute {
    //     opacity:    0.4;
    //     background: #000;
    //     width:      100%;
    //     height:     100%;
    //     z-index:    1000;
    //     top:        0;
    //     left:       0;
    //     position:   absolute;
    //   }`
    //     ]
    //   })
    var ProgressComponent = /** @class */ (function () {
        function ProgressComponent() {
            this.loading = false;
            this.position = 'fixed';
        }
        ProgressComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-progress',
                        template: "\n    <div class=\"spinner\" *ngIf=\"loading\">\n      <div class=\"bounce1\"></div>\n      <div class=\"bounce2\"></div>\n      <div class=\"bounce3\"></div>\n    </div>\n ",
                        styles: ["\n.overlay-fixed {\n      opacity:    0.4;\n      background: #000;\n      width:      100%;\n      height:     100%;\n      z-index:    1000;\n      top:        0;\n      left:       0;\n      position:   fixed;\n    }\n    .overlay-absolute {\n      opacity:    0.4;\n      background: #000;\n      width:      100%;\n      height:     100%;\n      z-index:    1000;\n      top:        0;\n      left:       0;\n      position:   absolute;\n    }\n\n.spinner {\nmargin: 5px auto 0;\nwidth: 70px;\ntext-align: center;\n}\n\n.spinner > div {\nwidth: 14px;\nheight: 14px;\n\n\nborder-radius: 100%;\ndisplay: inline-block;\n-webkit-animation: sk-bouncedelay 1.4s infinite ease-in-out both;\nanimation: sk-bouncedelay 1.4s infinite ease-in-out both;\n}\n\n.spinner .bounce1 {\nbackground-color:#007e3e;\n-webkit-animation-delay: -0.60s;\nanimation-delay: -0.60s;\n}\n\n.spinner .bounce2 {\nbackground-color: #018d79;\n-webkit-animation-delay: -0.30s;\nanimation-delay: -0.30s;\n}\n\n.spinner .bounce3 {\nbackground-color: #0f6684;\n}\n\n@-webkit-keyframes sk-bouncedelay {\n0%, 80%, 100% { -webkit-transform: scale(0) }\n40% { -webkit-transform: scale(1.0) }\n}\n\n@keyframes sk-bouncedelay {\n0%, 80%, 100% {\n  -webkit-transform: scale(0);\n  transform: scale(0);\n} 40% {\n  -webkit-transform: scale(1.0);\n  transform: scale(1.0);\n}\n}"]
                    }] }
        ];
        /** @nocollapse */
        ProgressComponent.ctorParameters = function () { return []; };
        ProgressComponent.propDecorators = {
            loading: [{ type: core.Input }],
            position: [{ type: core.Input }]
        };
        return ProgressComponent;
    }());
    if (false) {
        /** @type {?} */
        ProgressComponent.prototype.loading;
        /** @type {?} */
        ProgressComponent.prototype.position;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/sceiba-apps/sceiba-apps.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SceibaAppsComponent = /** @class */ (function () {
        function SceibaAppsComponent() {
        }
        /**
         * @return {?}
         */
        SceibaAppsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
        };
        SceibaAppsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-sceiba-apps',
                        template: "<div fxLayout=\"row wrap\" fxLayoutAlign=\"space-around center\">\n  <a href=\"https://sceiba.cu\" target=\"_blank\" class=\"apps\" matTooltip=\"Sceiba\">\n      <img src=\"icons/sceiba.svg\" alt=\"Sceiba\">\n  </a>\n  <a href=\"https://orgs.sceiba.cu\" target=\"_blank\" class=\"apps\" matTooltip=\"Organizaciones\">\n      <img src=\"icons/organizacion.svg\" alt=\"Organizaciones\">\n  </a>\n  <a href=\"https://sceiba.cu\" target=\"_blank\" class=\"apps\" matTooltip=\"Vocabularios\">\n      <img src=\"icons/vocabs.png\" alt=\"Vocabularios\">\n  </a>\n  <a href=\"https://catalogo.sceiba.cu\" target=\"_blank\" class=\"apps\" matTooltip=\"Cat\u00E1logo\">\n      <img src=\"icons/catalog.svg\" alt=\"Cat\u00E1logo\">\n  </a>\n  <mat-divider class=\"w-90\"></mat-divider>\n  <a href=\"https://sceiba.cu\" target=\"_blank\" class=\"apps\">\n      <img class=\"MES\" src=\"icons/mes.svg\" alt=\"Registro de Revistas Cient\u00EDficas del MES\" matTooltip=\"Registro de Revistas Cient\u00EDficas del MES\">\n  </a>\n</div>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        SceibaAppsComponent.ctorParameters = function () { return []; };
        return SceibaAppsComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/core.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CoreModule = /** @class */ (function () {
        function CoreModule(parentModule) {
            //throwIfAlreadyLoaded(parentModule, 'CoreModule');
        }
        CoreModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            BodyComponent,
                            Error404Component,
                            FooterComponent,
                            HomeComponent,
                            InfoCardComponent,
                            JournalCardComponent,
                            NavComponent,
                            PageHeaderComponent,
                            PageNotFoundComponent,
                            RoadMapComponent,
                            RoadMapSceibaComponent,
                            GetViewContainerDirective,
                            EqualLengthDirective,
                            DialogContentComponent,
                            DialogDeleteConfirmComponent,
                            ProgressComponent,
                            SceibaAppsComponent
                        ],
                        imports: [
                            SharedModule,
                            forms.ReactiveFormsModule,
                            core$2.TranslateModule,
                            ngxCharts.NgxChartsModule,
                            CoreRoutingModule
                        ],
                        exports: [
                            BodyComponent,
                            Error404Component,
                            FooterComponent,
                            HomeComponent,
                            InfoCardComponent,
                            JournalCardComponent,
                            NavComponent,
                            PageHeaderComponent,
                            PageNotFoundComponent,
                            RoadMapComponent,
                            RoadMapSceibaComponent,
                            GetViewContainerDirective,
                            EqualLengthDirective,
                            DialogContentComponent,
                            DialogDeleteConfirmComponent,
                            ProgressComponent,
                            SceibaAppsComponent
                        ],
                        entryComponents: [
                            DialogContentComponent,
                            DialogDeleteConfirmComponent
                        ],
                        providers: [
                            MetadataService
                        ]
                    },] }
        ];
        /** @nocollapse */
        CoreModule.ctorParameters = function () { return [
            { type: CoreModule, decorators: [{ type: core.Optional }, { type: core.SkipSelf }] }
        ]; };
        return CoreModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/utils/helpers.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Corresponds to `Number.MAX_SAFE_INTEGER`. Moved out into a variable here due to
     * flaky browser support and the value not being defined in Closure's typings.
     * @type {?}
     */
    var MAX_SAFE_INTEGER = 9007199254740991;
    /**
     * The markdown file extension.
     * @type {?}
     */
    var MARKDOWN_FILE_EXTENSION = '.md';
    /** @enum {string} */
    var ActionText = {
        /**
         * Viewing action.
         */
        view: "view",
        /**
         * Adding action.
         */
        add: "add",
        /**
         * Editing action.
         */
        edit: "edit",
    };
    /** @enum {string} */
    var LanguageTexts = {
        /**
         * The Spanish language.
         */
        Español: "Espa\u00F1ol",
        /**
         * The English language.
         */
        English: "English",
    };
    /** @enum {string} */
    var LanguageAbbrs = {
        /**
         * The Spanish language abbreviation.
         */
        es: "es",
        /**
         * The English language abbreviation.
         */
        en: "en",
    };
    /**
     * The list of language texts.
     * @type {?}
     */
    var LANGUAGE_TEXTS_LIST = [LanguageTexts.Español, LanguageTexts.English];
    /**
     * The list of language text abbreviations.
     * @type {?}
     */
    var LANGUAGE_ABBRS_LIST = [LanguageAbbrs.es, LanguageAbbrs.en];
    /**
     * Converts the language representation from string to number.
     * If the string specified is not registered as a language, then returns -1 number value.
     * The Spanish language is: 0 as number, and 'es' as string.
     * The English language is: 1 as number, and 'en' as string.
     * In other words, it follows the order of `LANGUAGE_TEXTS_LIST` and `LANGUAGE_ABBRS_LIST` enums.
     * @param {?} lang The language text abbreviation to be used.
     * @return {?} Returns the language as a number based on its representation as string.
     * If the string specified is not registered as a language, then returns -1 number value.
     */
    function convertLangFromStringToNumber(lang) {
        switch (lang) {
            case LanguageAbbrs.es: /* Spanish */
                {
                    return 0;
                }
            case LanguageAbbrs.en: /* English */
                {
                    return 1;
                }
        }
        return -1;
    }
    /**
     * Converts the language representation from number to string.
     * If the number specified is not registered as a language, then returns empty string value.
     * The Spanish language is: 0 as number, and 'es' as string.
     * The English language is: 1 as number, and 'en' as string.
     * In other words, it follows the order of `LANGUAGE_TEXTS_LIST` and `LANGUAGE_ABBRS_LIST` enums.
     * @param {?} index The language representation as number.
     * @return {?} Returns the language as a string based on its representation as number.
     * If the number specified is not registered as a language, then returns empty string value.
     */
    function convertLangFromNumberToString(index) {
        switch (index) {
            case 0: /* Spanish */
                {
                    return LanguageAbbrs.es;
                }
            case 1: /* English */
                {
                    return LanguageAbbrs.en;
                }
        }
        return '';
    }
    /**
     * Returns a string that is the result of concatenating the specified `path` argument,
     * the language extension, and the markdown file extension.
     * @param {?} path The path to markdown file without the language extension and the markdown file extension.
     * @param {?} lang The language text abbreviation to be used.
     * @return {?} Returns the correct path to the markdown file.
     */
    function getPathWithLangExtension(path, lang) {
        return (path + '.' + lang + MARKDOWN_FILE_EXTENSION);
    }
    /**
     * Returns true if the specified `possDescendant` is descendant from the specified `ancestorName`;
     * otherwise, false.
     * @param {?} possDescendant Possible descendant.
     * @param {?} ancestorName Ancestor name.
     * Example in usage:
     *  if (isDescendant(target.controlType.__proto__, InputControl.name)) { ... }
     * @return {?}
     */
    function isDescendant(possDescendant, ancestorName) {
        do {
            if (possDescendant.name == ancestorName)
                return true;
        } while ((possDescendant = possDescendant.__proto__).name != '');
        return false;
    }
    /**
     * Returns a new value that represents the clone of the specified `target` value.
     * Implementation notes:
     *  - If `target` is `undefined`, then returns `undefined`.
     *  - If `target` is an object, then returns a cloned object with all its properties cloned.
     *  - If `target` is an array, then returns a cloned array with all its values cloned.
     * @param {?} target The target value to clone.
     * @return {?}
     */
    function cloneValue(target) {
        if (util.isArray(target)) {
            return _cloneValue(target, []);
        }
        else if (util.isRegExp(target)) {
            return target; /* It can return `target` directly because all fields in a `RegExp` are read-only. */
        }
        else if (util.isDate(target)) {
            return new Date(target);
        }
        else if (util.isError(target)) {
            return target; /* It can return `target` directly because an `Error` is extremely dependent of the place where it is created. */
        }
        else if (util.isObject(target)) {
            return _cloneValue(target, {});
        }
        else {
            return target;
        }
    }
    /**
     * @param {?} target
     * @param {?} container
     * @return {?}
     */
    function _cloneValue(target, container) {
        /** @type {?} */
        var temp;
        for (var prop in target) {
            temp = target[prop];
            if (util.isArray(temp)) {
                container[prop] = _cloneValue(temp, []);
            }
            else if (util.isRegExp(temp)) {
                container[prop] = temp; /* It can return `temp` directly because all fields in a `RegExp` are read-only. */
            }
            else if (util.isDate(temp)) {
                container[prop] = new Date(temp);
            }
            else if (util.isError(temp)) {
                container[prop] = temp; /* It can return `temp` directly because an `Error` is extremely dependent of the place where it is created. */
            }
            else if (util.isObject(temp)) {
                container[prop] = _cloneValue(temp, {});
            }
            else {
                container[prop] = temp;
            }
        }
        return container;
    }
    /**
     * Returns a new value that represents the clone of the specified `target` value, and
     * sets all its properties/values of built-in type to `undefined`.
     * Implementation notes:
     *  - If `target` is `undefined`, then returns `undefined`.
     *  - If `target` is an object, then returns an object with all its properties of built-in type to `undefined`.
     *  - If `target` is an array, then returns an array with all its values of built-in type to `undefined`.
     * @param {?} target The target value to clone.
     * @return {?}
     */
    function cloneValueToUndefined(target) {
        if (util.isArray(target)) {
            return _cloneValueToUndefined(target, []);
        }
        else if (util.isRegExp(target)) {
            return undefined;
        }
        else if (util.isDate(target)) {
            return undefined;
        }
        else if (util.isError(target)) {
            return undefined;
        }
        else if (util.isObject(target)) {
            return _cloneValueToUndefined(target, {});
        }
        else {
            return undefined;
        }
    }
    /**
     * @param {?} target
     * @param {?} container
     * @return {?}
     */
    function _cloneValueToUndefined(target, container) {
        /** @type {?} */
        var temp;
        for (var prop in target) {
            temp = target[prop];
            if (util.isArray(temp)) {
                container[prop] = _cloneValueToUndefined(temp, []);
            }
            else if (util.isRegExp(target)) {
                container[prop] = undefined;
            }
            else if (util.isDate(target)) {
                container[prop] = undefined;
            }
            else if (util.isError(target)) {
                container[prop] = undefined;
            }
            else if (util.isObject(temp)) {
                container[prop] = _cloneValueToUndefined(temp, {});
            }
            else {
                container[prop] = undefined;
            }
        }
        return container;
    }
    /**
     * Logs an error notification message to the console.
     * @param {?} operation The operation during the error occurs.
     * @param {?} place The place where the error occurs.
     * @param {?} err The error that occurs.
     * @return {?}
     */
    function logError(operation, place, err) {
        console.log("The observable got an error '" + operation + "' in '" + place + "': " + err + ".");
    }
    /**
     * Logs a complete notification message to the console.
     * @param {?} operation The operation during the complete occurs.
     * @param {?} place The place where the complete occurs.
     * @return {?}
     */
    function logComplete(operation, place) {
        console.log("The observable got a complete notification '" + operation + "' in '" + place + "'.");
    }
    /**
     * Returns a string representation of `HttpEventType` specified.
     * @param {?} httpEventType Type enumeration for the different kinds of `HttpEvent`.
     * @return {?}
     */
    function getHttpEventTypeToString(httpEventType) {
        switch (httpEventType) {
            /* The request was sent out over the wire. */
            case http.HttpEventType.Sent:
                return "'Sent (0)'";
            /* An upload progress event was received. */
            case http.HttpEventType.UploadProgress:
                return "'UploadProgress (1)'";
            /* The response status code and headers were received. */
            case http.HttpEventType.ResponseHeader:
                return "'ResponseHeader (2)'";
            /* A download progress event was received. */
            case http.HttpEventType.DownloadProgress:
                return "'DownloadProgress (3)'";
            /* The full response including the body was received. */
            case http.HttpEventType.Response:
                return "'Response (4)'";
            /* A custom event from an interceptor or a backend. */
            case http.HttpEventType.User:
                return "'User (5)'";
            default:
                return "'It does not know the code'";
        }
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/services/backend-data-source.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var SortDirection = {
        /**
         * Sorts the data in the ascending order.
         */
        asc: "asc",
        /**
         * Sorts the data in the descending order.
         */
        desc: "desc",
        /**
         * Sorts the data in the original order or does not sort them.
         */
        orig: "",
    };
    /**
     * An interface that represents the input data that are used to make a page request.
     * It is the input of `BackendDataSourceFunction` function.
     * @record
     */
    function PageRequest() { }
    if (false) {
        /**
         * The current filter state.
         * @type {?|undefined}
         */
        PageRequest.prototype.filter;
        /**
         * The current sort state.
         * @type {?}
         */
        PageRequest.prototype.sort;
        /**
         * The current paginator state.
         * @type {?}
         */
        PageRequest.prototype.paginator;
    }
    /**
     * An interface that represents the requested page.
     * It is the output of `BackendDataSourceFunction` function.
     * The generic parameter T always refers to the type of data that it is dealing with.
     * @record
     * @template T
     */
    function Page() { }
    if (false) {
        /**
         * Returns the list of items.
         * By default, its value is `[]`.
         * @type {?}
         */
        Page.prototype.data;
        /**
         * Returns the total number of items being paged.
         * By default, its value is `0`.
         * @type {?}
         */
        Page.prototype.totalData;
        /**
         * Returns the zero-based page index of the displayed list of items.
         * By default, its value is `0`.
         * @type {?}
         */
        Page.prototype.pageIndex;
        /**
         * Returns the number of items to display on a page.
         * By default, its value is `50`.
         * @type {?}
         */
        Page.prototype.pageSize;
    }
    /**
     * An interface that represents the function that is used to get the data source from backend.
     * The generic parameter T always refers to the type of data that it is dealing with.
     * @record
     * @template T
     */
    function BackendDataSourceFunction() { }
    /**
     * Checks if a data object matches the data source's filter string. By default, each data object
     * is converted to a string of its properties and returns true if the filter has
     * at least one occurrence in that string. By default, the filter string has its whitespace
     * trimmed and the match is case-insensitive.
     * May be overridden for a custom implementation of filter matching.
     * @template T
     * @param {?} data Data object used to check against the filter.
     * @param {?} filter Filter string that has been set on the data source.
     * @return {?} Returns true whether the filter matches against the data; otherwise, false.
     */
    function filterPredicate(data, filter) {
        /* Transforms the data into a lowercase string of all property values. */
        /** @type {?} */
        var dataStr = Object.keys(data).reduce(((/**
         * @param {?} currentTerm
         * @param {?} key
         * @return {?}
         */
        function (currentTerm, key) {
            /* Use an obscure Unicode character to delimit the words in the concatenated string.
             * This avoids matches where the values of two columns combined will match the user's query
             * (e.g. `Flute` and `Stop` will match `Test`). The character is intended to be something
             * that has a very low chance of being typed in by somebody in a text field. This one in
             * particular is "White up-pointing triangle with dot" from
             * https://en.wikipedia.org/wiki/List_of_Unicode_characters. */
            return currentTerm + data[key] + '◬';
        })), '').toLowerCase();
        /* Transforms the filter by converting it to lowercase and removing whitespace. */
        /** @type {?} */
        var transformedFilter = filter.trim().toLowerCase();
        return (dataStr.indexOf(transformedFilter) != -1);
    }
    /**
     * Data accessor function that is used for accessing data properties for sorting through
     * the default `sortData` function.
     * This default function assumes that the sort header IDs (which defaults to the column name)
     * matches the data's properties (e.g. column Xyz represents data['Xyz']).
     * May be overridden for a custom implementation of different behavior.
     * @template T
     * @param {?} data Data object that is being accessed.
     * @param {?} sortHeaderId The name of the column that represents the data.
     * @return {?}
     */
    function sortingDataAccessor(data, sortHeaderId) {
        /** @type {?} */
        var value = data[sortHeaderId];
        if (coercion._isNumberValue(value)) {
            /** @type {?} */
            var numberValue = Number(value);
            /* Numbers beyond `MAX_SAFE_INTEGER` can't be compared reliably so we
             * leave them as strings. For more info: https://goo.gl/y5vbSg. */
            return (numberValue < MAX_SAFE_INTEGER ? numberValue : value);
        }
        return value;
    }
    /**
     * Gets a sorted copy of the data array based on the state of the `MatSort`. Called
     * after changes are made to the filtered data or when sort changes are emitted from `MatSort`.
     * By default, the function retrieves the active sort and its direction and compares data
     * by retrieving data using the `sortingDataAccessor`.
     * May be overridden for a custom implementation of data ordering.
     * @template T
     * @param {?} data The array of data that should be sorted.
     * @param {?} sort The connected `MatSort` that holds the current sort state.
     * @return {?}
     */
    function sortData(data, sort) {
        /** @type {?} */
        var active = sort.active;
        /** @type {?} */
        var direction = (/** @type {?} */ (sort.direction));
        if ((!active) || (direction == SortDirection.orig))
            return data;
        return data.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        function (a, b) {
            /** @type {?} */
            var valueA = sortingDataAccessor(a, active);
            /** @type {?} */
            var valueB = sortingDataAccessor(b, active);
            /**
             * If both `valueA` and `valueB` exist (truthy), then compare the two. Otherwise, checks if
             * one value exists while the other doesn't. In this case, existing value should come last.
             * This avoids inconsistent results when comparing values to undefined/null.
             * If neither value exists, returns 0 (equal).
             * @type {?}
             */
            var comparatorResult = 0;
            if ((valueA != null) && (valueB != null)) {
                /* Checks if one value is greater than the other one; if equal, `comparatorResult` should remain 0. */
                if (valueA > valueB)
                    comparatorResult = 1;
                else if (valueA < valueB)
                    comparatorResult = -1;
            }
            else if (valueA != null)
                comparatorResult = 1;
            else if (valueB != null)
                comparatorResult = -1;
            return comparatorResult * ((direction == SortDirection.asc) ? 1 : -1);
        }));
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/services/http-interceptor.order.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /* "Barrel" of Http Interceptors.
     * Angular applies interceptors in the order that you provide them. If you provide interceptors A,
     * then B, then C, requests will flow in A->B->C and responses will flow out C->B->A.
     * You cannot change the order or remove interceptors later. If you need to enable and disable
     * an interceptor dynamically, you'll have to build that capability into the interceptor itself. */
    /**
     * Http interceptor providers in order.
     * @type {?}
     */
    var HTTP_INTERCEPTOR_PROVIDERS = [
    // { provide: HTTP_INTERCEPTORS, useClass: AuthenticationService, multi: true },
    //{ provide: HTTP_INTERCEPTORS, useClass: CachingInterceptor, multi: true }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/services/request-cache.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Returns a constant that is used in the `HttpHeaders` to do request although the request exists in cache.
     * @type {?}
     */
    var REFRESH_X_CACHE = 'refresh-x-cache';
    /**
     * Represents the base abstract class for all services that implement the cachable URL request.
     * See `CachableUrl` service.
     * @abstract
     */
    var   /**
     * Represents the base abstract class for all services that implement the cachable URL request.
     * See `CachableUrl` service.
     * @abstract
     */
    Cachable = /** @class */ (function () {
        function Cachable() {
        }
        return Cachable;
    }());
    if (false) {
        /**
         * Returns a number greater than zero if the specified request is cachable;
         * that number represents the maximum cache age in milliseconds.
         * Return zero if the specified request is NOT cachable.
         * @abstract
         * @param {?} req The outgoing request object to handle.
         * @return {?}
         */
        Cachable.prototype.isCachable = function (req) { };
    }
    /**
     * Represents the base abstract class for all services that implement the request cache.
     * See `RequestCacheDifferentTimeWithMap` service.
     * @abstract
     */
    var   /**
     * Represents the base abstract class for all services that implement the request cache.
     * See `RequestCacheDifferentTimeWithMap` service.
     * @abstract
     */
    RequestCache = /** @class */ (function () {
        function RequestCache() {
        }
        return RequestCache;
    }());
    if (false) {
        /**
         * @abstract
         * @param {?} req
         * @return {?}
         */
        RequestCache.prototype.get = function (req) { };
        /**
         * @abstract
         * @param {?} req
         * @param {?} maxAgeInCache
         * @param {?} response
         * @return {?}
         */
        RequestCache.prototype.set = function (req, maxAgeInCache, response) { };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/services/http.interceptor.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /* Note: When you are going to use the Interceptors, make a "Barrel" of Http Interceptors.
     * Angular applies interceptors in the order that you provide them. If you provide interceptors A,
     * then B, then C, requests will flow in A->B->C and responses will flow out C->B->A.
     * You cannot change the order or remove interceptors later. If you need to enable and disable
     * an interceptor dynamically, you'll have to build that capability into the interceptor itself. */
    /**
     * A service that caches certain requests and responses to improve performance.
     * It is delegated to an interceptor without disturbing the existing data services.
     *
     * - If request is cachable (e.g., package search) and response is in cache,
     * then returns the cached response as observable.
     * - If request is cachable and has `REFRESH_X_CACHE` option header in true (or the request is not in cache),
     * then passes request to the following `HttpHandler` and makes a cache from response.
     * - If request is not cachable,
     * then passes request to the following `HttpHandler`.
     */
    var CachingInterceptor = /** @class */ (function () {
        function CachingInterceptor(_cachable, _cache) {
            this._cachable = _cachable;
            this._cache = _cache;
        }
        /**
         * Identifies and handles a given HTTP request.
         * @param req The outgoing request object to handle.
         * @param next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
         * @returns An observable of the event stream.
         */
        /**
         * Identifies and handles a given HTTP request.
         * @param {?} req The outgoing request object to handle.
         * @param {?} next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
         * @return {?} An observable of the event stream.
         */
        CachingInterceptor.prototype.intercept = /**
         * Identifies and handles a given HTTP request.
         * @param {?} req The outgoing request object to handle.
         * @param {?} next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
         * @return {?} An observable of the event stream.
         */
        function (req, next) {
            /** @type {?} */
            var maxAgeInCache;
            /* Continues if not cachable. */
            if (!(maxAgeInCache = this._cachable.isCachable(req))) {
                return next.handle(req);
            }
            /* This option is triggered by the presence of a custom `REFRESH_X_CACHE` header with true value. */
            if (req.headers.get(REFRESH_X_CACHE)) {
                /* fetch. */
                return this._sendRequest(req, maxAgeInCache, true, next);
            }
            /* cache-or-fetch. */
            /** @type {?} */
            var cachedResponse = this._cache.get(req);
            return (cachedResponse
                ? rxjs.of(cachedResponse)
                : this._sendRequest(req, maxAgeInCache, false, next));
        };
        /**
         * Gets server response observable by sending request to `next` argument.
         * It will add the response to the cache on the way out.
         * @param req The outgoing request object to handle.
         * @param maxAgeInCache The maximum cache age in milliseconds.
         * @param hasRefreshXCache It is true if the custom `REFRESH_X_CACHE` header is present; otherwise, false.
         * @param next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
         * @returns An observable of the event stream.
         */
        /**
         * Gets server response observable by sending request to `next` argument.
         * It will add the response to the cache on the way out.
         * @private
         * @param {?} req The outgoing request object to handle.
         * @param {?} maxAgeInCache The maximum cache age in milliseconds.
         * @param {?} hasRefreshXCache It is true if the custom `REFRESH_X_CACHE` header is present; otherwise, false.
         * @param {?} next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
         * @return {?} An observable of the event stream.
         */
        CachingInterceptor.prototype._sendRequest = /**
         * Gets server response observable by sending request to `next` argument.
         * It will add the response to the cache on the way out.
         * @private
         * @param {?} req The outgoing request object to handle.
         * @param {?} maxAgeInCache The maximum cache age in milliseconds.
         * @param {?} hasRefreshXCache It is true if the custom `REFRESH_X_CACHE` header is present; otherwise, false.
         * @param {?} next The next interceptor in the chain, or the backend if no interceptors remain in the chain.
         * @return {?} An observable of the event stream.
         */
        function (req, maxAgeInCache, hasRefreshXCache, next) {
            var _this = this;
            /* Removes the `REFRESH_X_CACHE` custom option from header. */
            /** @type {?} */
            var reqWithoutCustomHeader = (hasRefreshXCache)
                ? req.clone({ headers: (req.headers.delete(REFRESH_X_CACHE)) })
                : req;
            console.log('Req-2: ', reqWithoutCustomHeader.headers);
            return next.handle(reqWithoutCustomHeader).pipe(operators.tap((/**
             * @param {?} event
             * @return {?}
             */
            function (event) {
                /* There may be other events besides the response. */
                if (event instanceof http.HttpResponse) {
                    /* Updates the cache. */
                    _this._cache.set(req, maxAgeInCache, event); /* Cached the original request `req`. */
                }
            })));
        };
        CachingInterceptor.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        CachingInterceptor.ctorParameters = function () { return [
            { type: Cachable },
            { type: RequestCache }
        ]; };
        /** @nocollapse */ CachingInterceptor.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function CachingInterceptor_Factory() { return new CachingInterceptor(core.ɵɵinject(Cachable), core.ɵɵinject(RequestCache)); }, token: CachingInterceptor, providedIn: "root" });
        return CachingInterceptor;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        CachingInterceptor.prototype._cachable;
        /**
         * @type {?}
         * @private
         */
        CachingInterceptor.prototype._cache;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/services/http.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     * @template T
     */
    function Response() { }
    if (false) {
        /** @type {?|undefined} */
        Response.prototype.message;
        /** @type {?|undefined} */
        Response.prototype.status;
        /** @type {?|undefined} */
        Response.prototype.data;
    }
    /** @type {?} */
    var ResponseStatus = {
        SUCCESS: 'success',
        ERROR: 'error'
    };
    var HttpService = /** @class */ (function () {
        function HttpService(http) {
            this.http = http;
        }
        HttpService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        HttpService.ctorParameters = function () { return [
            { type: http.HttpClient }
        ]; };
        return HttpService;
    }());
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        HttpService.prototype.http;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/services/icon.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A service that registers custom svg icons in order to use them through the `mat-icon` component.
     * Which simply registers the custom icons with the `MatIconRegistry` service provided by Angular Material.
     */
    var IconService = /** @class */ (function () {
        function IconService(_matIconRegistry, _domSanitizer) {
            this._matIconRegistry = _matIconRegistry;
            this._domSanitizer = _domSanitizer;
        }
        /**
         * Registers an array of icons.
         * @param iconNames Array of names under which the icons should be registered.
         * @param iconUrl The relative URL path pointing to the location of the icons.
         */
        /**
         * Registers an array of icons.
         * @param {?} iconNames Array of names under which the icons should be registered.
         * @param {?} iconUrl The relative URL path pointing to the location of the icons.
         * @return {?}
         */
        IconService.prototype.registerIcons = /**
         * Registers an array of icons.
         * @param {?} iconNames Array of names under which the icons should be registered.
         * @param {?} iconUrl The relative URL path pointing to the location of the icons.
         * @return {?}
         */
        function (iconNames, iconUrl) {
            var _this = this;
            iconNames.forEach((/**
             * @param {?} iconName
             * @return {?}
             */
            function (iconName) {
                _this._matIconRegistry.addSvgIcon(iconName, _this._domSanitizer.bypassSecurityTrustResourceUrl(iconUrl + "/" + iconName + ".svg"));
            }));
        };
        /**
         * Returns the default icon name. It represents a blank icon.
         * It is used by controls that want to have occupied the icon space, but nothing is showed.
         */
        IconService.defaultIconName = 'outlined-blank-24px';
        IconService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        IconService.ctorParameters = function () { return [
            { type: material.MatIconRegistry },
            { type: platformBrowser.DomSanitizer }
        ]; };
        /** @nocollapse */ IconService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function IconService_Factory() { return new IconService(core.ɵɵinject(icon.MatIconRegistry), core.ɵɵinject(platformBrowser.DomSanitizer)); }, token: IconService, providedIn: "root" });
        return IconService;
    }());
    if (false) {
        /**
         * Returns the default icon name. It represents a blank icon.
         * It is used by controls that want to have occupied the icon space, but nothing is showed.
         * @type {?}
         */
        IconService.defaultIconName;
        /**
         * @type {?}
         * @private
         */
        IconService.prototype._matIconRegistry;
        /**
         * @type {?}
         * @private
         */
        IconService.prototype._domSanitizer;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/services/message.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var MessageService = /** @class */ (function () {
        function MessageService() {
            /**
             * Cache of messages.
             */
            this.messages = [];
        }
        /**
         * Adds the specified message.
         * @param msg The message to add.
         */
        /**
         * Adds the specified message.
         * @param {?} msg The message to add.
         * @return {?}
         */
        MessageService.prototype.add = /**
         * Adds the specified message.
         * @param {?} msg The message to add.
         * @return {?}
         */
        function (msg) {
            console.log(msg);
            this.messages.push(msg);
        };
        /**
         * Deletes all messages.
         */
        /**
         * Deletes all messages.
         * @return {?}
         */
        MessageService.prototype.clear = /**
         * Deletes all messages.
         * @return {?}
         */
        function () {
            this.messages = [];
        };
        MessageService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        MessageService.ctorParameters = function () { return []; };
        /** @nocollapse */ MessageService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function MessageService_Factory() { return new MessageService(); }, token: MessageService, providedIn: "root" });
        return MessageService;
    }());
    if (false) {
        /**
         * Cache of messages.
         * @type {?}
         */
        MessageService.prototype.messages;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/services/request-cache-different-time.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A service that implements the cachable URL request.
     */
    var CachableUrl = /** @class */ (function () {
        function CachableUrl(_env) {
            this._env = _env;
        }
        /**
         * Returns a number greater than zero if the specified request is cachable;
         * that number represents the maximum cache age in milliseconds.
         * Return zero if the specified request is NOT cachable.
         * @param req The outgoing request object to handle.
         */
        /**
         * Returns a number greater than zero if the specified request is cachable;
         * that number represents the maximum cache age in milliseconds.
         * Return zero if the specified request is NOT cachable.
         * @param {?} req The outgoing request object to handle.
         * @return {?}
         */
        CachableUrl.prototype.isCachable = /**
         * Returns a number greater than zero if the specified request is cachable;
         * that number represents the maximum cache age in milliseconds.
         * Return zero if the specified request is NOT cachable.
         * @param {?} req The outgoing request object to handle.
         * @return {?}
         */
        function (req) {
            var _this = this;
            /* Only GET requests are cachable. */
            if (req.method != 'GET')
                return 0;
            Object.keys(this._env.cachableUrls).forEach((/**
             * @param {?} url
             * @return {?}
             */
            function (url) {
                /* Verifies if the request cache is cachable. */
                if (req.url.indexOf(url) > -1)
                    return _this._env.cachableUrls[url];
            }));
            /* It is not cachable. */
            return 0;
        };
        CachableUrl.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        CachableUrl.ctorParameters = function () { return [
            { type: Environment }
        ]; };
        /** @nocollapse */ CachableUrl.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function CachableUrl_Factory() { return new CachableUrl(core.ɵɵinject(Environment)); }, token: CachableUrl, providedIn: "root" });
        return CachableUrl;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        CachableUrl.prototype._env;
    }
    /**
     * Represents the request cache entry.
     * @record
     */
    function RequestCacheEntry() { }
    if (false) {
        /**
         * Returns the request URL.
         * @type {?}
         */
        RequestCacheEntry.prototype.url;
        /**
         * Returns the request cache.
         * @type {?}
         */
        RequestCacheEntry.prototype.response;
        /**
         * Returns the maximum cache age in milliseconds.
         * @type {?}
         */
        RequestCacheEntry.prototype.maxAgeInCache;
        /**
         * Returns the last read of the request URL.
         * @type {?}
         */
        RequestCacheEntry.prototype.lastRead;
    }
    /**
     * A service that implements the request cache with the different time using `Map` collection.
     */
    var RequestCacheDifferentTimeWithMap = /** @class */ (function () {
        function RequestCacheDifferentTimeWithMap(_messageService) {
            this._messageService = _messageService;
            this._cache = new Map();
        }
        /**
         * @param {?} req
         * @return {?}
         */
        RequestCacheDifferentTimeWithMap.prototype.get = /**
         * @param {?} req
         * @return {?}
         */
        function (req) {
            /** @type {?} */
            var cached = this._cache.get(req.urlWithParams);
            if (!cached) {
                return undefined;
            }
            if ((cached.lastRead + cached.maxAgeInCache) < Date.now()) /* Found expired cached. */ {
                this._messageService.add("Found expired cached response for '" + req.urlWithParams + "'.");
                return undefined;
            }
            else {
                this._messageService.add("Found cached response for '" + req.urlWithParams + "'.");
                return cached.response;
            }
        };
        /**
         * @param {?} req
         * @param {?} maxAgeInCache
         * @param {?} response
         * @return {?}
         */
        RequestCacheDifferentTimeWithMap.prototype.set = /**
         * @param {?} req
         * @param {?} maxAgeInCache
         * @param {?} response
         * @return {?}
         */
        function (req, maxAgeInCache, response) {
            var _this = this;
            /** @type {?} */
            var url = req.urlWithParams;
            this._messageService.add("Caching response from '" + url + "'.");
            this._cache.set(url, { url: url, response: response, maxAgeInCache: maxAgeInCache, lastRead: Date.now() });
            /* Removes expired cache entries. */
            this._cache.forEach((/**
             * @param {?} entry
             * @return {?}
             */
            function (entry) {
                if (entry.lastRead < Date.now() - entry.maxAgeInCache) {
                    _this._cache.delete(entry.url);
                }
            }));
            this._messageService.add("Request cache size: " + this._cache.size + ".");
        };
        RequestCacheDifferentTimeWithMap.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        RequestCacheDifferentTimeWithMap.ctorParameters = function () { return [
            { type: MessageService }
        ]; };
        /** @nocollapse */ RequestCacheDifferentTimeWithMap.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function RequestCacheDifferentTimeWithMap_Factory() { return new RequestCacheDifferentTimeWithMap(core.ɵɵinject(MessageService)); }, token: RequestCacheDifferentTimeWithMap, providedIn: "root" });
        return RequestCacheDifferentTimeWithMap;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        RequestCacheDifferentTimeWithMap.prototype._cache;
        /**
         * @type {?}
         * @private
         */
        RequestCacheDifferentTimeWithMap.prototype._messageService;
    }
    /**
     * A provider for the cachable URL request.
     * @type {?}
     */
    var CACHABLE_URL_PROVIDER = [
        { 'provide': Cachable, 'useClass': CachableUrl, 'multi': false }
    ];
    /**
     * A provider for the request cache with the different time using `Map` collection.
     * @type {?}
     */
    var REQUEST_CACHE_DIFFERENT_TIME_WITH_MAP_PROVIDER = [
        { 'provide': RequestCache, 'useClass': RequestCacheDifferentTimeWithMap, 'multi': false }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/services/test-backend-data-source.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function User$1() { }
    if (false) {
        /** @type {?} */
        User$1.prototype.id;
        /** @type {?} */
        User$1.prototype.name;
        /** @type {?} */
        User$1.prototype.username;
        /** @type {?} */
        User$1.prototype.email;
        /** @type {?} */
        User$1.prototype.address;
        /** @type {?} */
        User$1.prototype.phone;
        /** @type {?} */
        User$1.prototype.website;
        /** @type {?} */
        User$1.prototype.company;
        /** @type {?} */
        User$1.prototype.registrationDate;
    }
    /**
     * @record
     */
    function UserQuery() { }
    if (false) {
        /** @type {?} */
        UserQuery.prototype.search;
        /** @type {?} */
        UserQuery.prototype.registration;
    }
    var UserService = /** @class */ (function () {
        function UserService() {
            this.users = [{
                    id: 1,
                    name: "Leanne Graham",
                    registrationDate: new Date(1565575044121),
                    username: "Bret",
                    email: "Sincere@april.biz",
                    address: {
                        street: "Kulas Light",
                        suite: "Apt. 556",
                        city: "Gwenborough",
                        zipcode: "92998-3874",
                        geo: {
                            lat: "-37.3159",
                            lng: "81.1496"
                        }
                    },
                    phone: "1-770-736-8031 x56442",
                    website: "hildegard.org",
                    company: {
                        name: "Romaguera-Crona",
                        catchPhrase: "Multi-layered client-server neural-net",
                        bs: "harness real-time e-markets"
                    }
                },
                {
                    id: 2,
                    name: "Ervin Howell",
                    registrationDate: new Date(1565575044121),
                    username: "Antonette",
                    email: "Shanna@melissa.tv",
                    address: {
                        street: "Victor Plains",
                        suite: "Suite 879",
                        city: "Wisokyburgh",
                        zipcode: "90566-7771",
                        geo: {
                            lat: "-43.9509",
                            lng: "-34.4618"
                        }
                    },
                    phone: "010-692-6593 x09125",
                    website: "anastasia.net",
                    company: {
                        name: "Deckow-Crist",
                        catchPhrase: "Proactive didactic contingency",
                        bs: "synergize scalable supply-chains"
                    }
                },
                {
                    id: 3,
                    name: "Clementine Bauch",
                    registrationDate: new Date(1565575044121),
                    username: "Samantha",
                    email: "Nathan@yesenia.net",
                    address: {
                        street: "Douglas Extension",
                        suite: "Suite 847",
                        city: "McKenziehaven",
                        zipcode: "59590-4157",
                        geo: {
                            lat: "-68.6102",
                            lng: "-47.0653"
                        }
                    },
                    phone: "1-463-123-4447",
                    website: "ramiro.info",
                    company: {
                        name: "Romaguera-Jacobson",
                        catchPhrase: "Face to face bifurcated interface",
                        bs: "e-enable strategic applications"
                    }
                },
                {
                    id: 4,
                    name: "Patricia Lebsack",
                    registrationDate: new Date(1565575044121),
                    username: "Karianne",
                    email: "Julianne.OConner@kory.org",
                    address: {
                        street: "Hoeger Mall",
                        suite: "Apt. 692",
                        city: "South Elvis",
                        zipcode: "53919-4257",
                        geo: {
                            lat: "29.4572",
                            lng: "-164.2990"
                        }
                    },
                    phone: "493-170-9623 x156",
                    website: "kale.biz",
                    company: {
                        name: "Robel-Corkery",
                        catchPhrase: "Multi-tiered zero tolerance productivity",
                        bs: "transition cutting-edge web services"
                    }
                },
                {
                    id: 5,
                    name: "Chelsey Dietrich",
                    registrationDate: new Date(1550478139234),
                    username: "Kamren",
                    email: "Lucio_Hettinger@annie.ca",
                    address: {
                        street: "Skiles Walks",
                        suite: "Suite 351",
                        city: "Roscoeview",
                        zipcode: "33263",
                        geo: {
                            lat: "-31.8129",
                            lng: "62.5342"
                        }
                    },
                    phone: "(254)954-1289",
                    website: "demarco.info",
                    company: {
                        name: "Keebler LLC",
                        catchPhrase: "User-centric fault-tolerant solution",
                        bs: "revolutionize end-to-end systems"
                    }
                },
                {
                    id: 6,
                    name: "Mrs. Dennis Schulist",
                    registrationDate: new Date(1550478139234),
                    username: "Leopoldo_Corkery",
                    email: "Karley_Dach@jasper.info",
                    address: {
                        street: "Norberto Crossing",
                        suite: "Apt. 950",
                        city: "South Christy",
                        zipcode: "23505-1337",
                        geo: {
                            lat: "-71.4197",
                            lng: "71.7478"
                        }
                    },
                    phone: "1-477-935-8478 x6430",
                    website: "ola.org",
                    company: {
                        name: "Considine-Lockman",
                        catchPhrase: "Synchronised bottom-line interface",
                        bs: "e-enable innovative applications"
                    }
                },
                {
                    id: 7,
                    name: "Kurtis Weissnat",
                    registrationDate: new Date(1550478139234),
                    username: "Elwyn.Skiles",
                    email: "Telly.Hoeger@billy.biz",
                    address: {
                        street: "Rex Trail",
                        suite: "Suite 280",
                        city: "Howemouth",
                        zipcode: "58804-1099",
                        geo: {
                            lat: "24.8918",
                            lng: "21.8984"
                        }
                    },
                    phone: "210.067.6132",
                    website: "elvis.io",
                    company: {
                        name: "Johns Group",
                        catchPhrase: "Configurable multimedia task-force",
                        bs: "generate enterprise e-tailers"
                    }
                },
                {
                    id: 8,
                    name: "Nicholas Runolfsdottir V",
                    registrationDate: new Date(1550478139234),
                    username: "Maxime_Nienow",
                    email: "Sherwood@rosamond.me",
                    address: {
                        street: "Ellsworth Summit",
                        suite: "Suite 729",
                        city: "Aliyaview",
                        zipcode: "45169",
                        geo: {
                            lat: "-14.3990",
                            lng: "-120.7677"
                        }
                    },
                    phone: "586.493.6943 x140",
                    website: "jacynthe.com",
                    company: {
                        name: "Abernathy Group",
                        catchPhrase: "Implemented secondary concept",
                        bs: "e-enable extensible e-tailers"
                    }
                },
                {
                    id: 9,
                    name: "Glenna Reichert",
                    registrationDate: new Date(1550478139234),
                    username: "Delphine",
                    email: "Chaim_McDermott@dana.io",
                    address: {
                        street: "Dayna Park",
                        suite: "Suite 449",
                        city: "Bartholomebury",
                        zipcode: "76495-3109",
                        geo: {
                            lat: "24.6463",
                            lng: "-168.8889"
                        }
                    },
                    phone: "(775)976-6794 x41206",
                    website: "conrad.com",
                    company: {
                        name: "Yost and Sons",
                        catchPhrase: "Switchable contextually-based project",
                        bs: "aggregate real-time technologies"
                    }
                },
                {
                    id: 10,
                    name: "Clementina DuBuque",
                    registrationDate: new Date(1550478139234),
                    username: "Moriah.Stanton",
                    email: "Rey.Padberg@karina.biz",
                    address: {
                        street: "Kattie Turnpike",
                        suite: "Suite 198",
                        city: "Lebsackbury",
                        zipcode: "31428-2261",
                        geo: {
                            lat: "-38.2386",
                            lng: "57.2232"
                        }
                    },
                    phone: "024-648-3804",
                    website: "ambrose.net",
                    company: {
                        name: "Hoeger LLC",
                        catchPhrase: "Centralized empowering task-force",
                        bs: "target end-to-end models"
                    }
                }];
        }
        /**
         * @param {?} pageRequest
         * @return {?}
         */
        UserService.prototype.page = /**
         * @param {?} pageRequest
         * @return {?}
         */
        function (pageRequest) {
            /* Fake backend, do your server request here instead. */
            /* Fake backend, do your server request here instead. */
            /** @type {?} */
            var filteredUsers = this.users.slice();
            /* Clones the array. */
            var _a = pageRequest.filter, search = _a.search, registration = _a.registration;
            if (search) {
                search = search.toLowerCase();
                filteredUsers = filteredUsers.filter((
                //({ name, username, email }) => {
                //({ name, username, email }) => {
                /**
                 * @param {?} __0
                 * @return {?}
                 */
                function (_a) {
                    var id = _a.id, name = _a.name, registrationDate = _a.registrationDate;
                    return id.toString(10).includes(search) ||
                        name.toLowerCase().includes(search) /*||
                    registrationDate.toString(10).toLowerCase().includes(search)*/;
                }));
            }
            if (registration) {
                filteredUsers = filteredUsers.filter((/**
                 * @param {?} __0
                 * @return {?}
                 */
                function (_a) {
                    var registrationDate = _a.registrationDate;
                    return registrationDate.getFullYear() === registration.getFullYear() &&
                        registrationDate.getMonth() === registration.getMonth() &&
                        registrationDate.getDate() === registration.getDate();
                }));
            }
            if (pageRequest.sort) {
                filteredUsers = sortData(filteredUsers, pageRequest.sort);
            }
            /** @type {?} */
            var newPageIndex = pageRequest.paginator.pageIndex;
            /** @type {?} */
            var pageSize = pageRequest.paginator.pageSize;
            /** @type {?} */
            var start = 0;
            if (filteredUsers.length != 0) {
                while ((start = newPageIndex * pageSize) >= filteredUsers.length) {
                    newPageIndex--;
                }
            }
            else {
                newPageIndex = 0;
            }
            /** @type {?} */
            var end = start + pageSize;
            /** @type {?} */
            var resultUsers = filteredUsers.slice(start, end);
            /** @type {?} */
            var page = {
                'data': resultUsers,
                'totalData': filteredUsers.length,
                'pageIndex': newPageIndex,
                'pageSize': pageSize /*resultUsers.length*/
            };
            return rxjs.of(page).pipe(operators.delay(2000));
        };
        UserService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: "root"
                    },] }
        ];
        /** @nocollapse */ UserService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function UserService_Factory() { return new UserService(); }, token: UserService, providedIn: "root" });
        return UserService;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        UserService.prototype.users;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/core/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/backend/user-profile.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var UserProfileService = /** @class */ (function () {
        function UserProfileService(env, http) {
            this.env = env;
            this.http = http;
        }
        /**
         * gives information about an user authenticated
         */
        /**
         * gives information about an user authenticated
         * @return {?}
         */
        UserProfileService.prototype.getUserInfo = /**
         * gives information about an user authenticated
         * @return {?}
         */
        function () {
            return this.http.get(this.env.sceibaApi + 'me');
        };
        /**
         * @param {?=} size
         * @param {?=} page
         * @param {?=} query
         * @return {?}
         */
        UserProfileService.prototype.getUsers = /**
         * @param {?=} size
         * @param {?=} page
         * @param {?=} query
         * @return {?}
         */
        function (size, page, query) {
            if (size === void 0) { size = 10; }
            if (page === void 0) { page = 1; }
            if (query === void 0) { query = ''; }
            /** @type {?} */
            var params = new http.HttpParams();
            params = params.set('size', size.toString(10));
            params = params.set('page', page.toString(10));
            params = params.set('query', query);
            /** @type {?} */
            var options = {
                params: params
            };
            return this.http.get(this.env.sceibaApi + 'users/search', options);
        };
        UserProfileService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        UserProfileService.ctorParameters = function () { return [
            { type: Environment },
            { type: http.HttpClient }
        ]; };
        /** @nocollapse */ UserProfileService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function UserProfileService_Factory() { return new UserProfileService(core.ɵɵinject(Environment), core.ɵɵinject(http.HttpClient)); }, token: UserProfileService, providedIn: "root" });
        return UserProfileService;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        UserProfileService.prototype.env;
        /**
         * @type {?}
         * @protected
         */
        UserProfileService.prototype.http;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/authentication/authentication.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var AuthBackend = {
        /**
         * `sceiba` represent the Sceiba's backend
         */
        sceiba: "sceiba",
        /**
         * `cuor` represent the Cuor's backend, The Organizations System
         */
        cuor: "cuor",
    };
    /**
     * This service handles the behavior when a user authentications and
     * gives information about it.
     */
    var OauthAuthenticationService = /** @class */ (function () {
        function OauthAuthenticationService(oauthStorage, http, _router, oauthService, errorHandler, moduleConfig) {
            this.oauthStorage = oauthStorage;
            this.http = http;
            this._router = _router;
            this.oauthService = oauthService;
            this.errorHandler = errorHandler;
            this.moduleConfig = moduleConfig;
            // TODO: this object is `any` because we have two backends with two difrent userprofiles...
            this.authenticationSubject = new rxjs.Subject();
            /**
             * Observer to handles the behavior when a user authenticates
             */
            this.authenticationSubjectObservable = this.authenticationSubject.asObservable();
        }
        /**
         * notifies by an observable if the user is authenticated
         * for the knowledge of who uses it
         * @param islogged 'true' is loggued or 'false' other way
         */
        /**
         * notifies by an observable if the user is authenticated
         * for the knowledge of who uses it
         * @param {?} user
         * @return {?}
         */
        OauthAuthenticationService.prototype.login = /**
         * notifies by an observable if the user is authenticated
         * for the knowledge of who uses it
         * @param {?} user
         * @return {?}
         */
        function (user) {
            console.log('autentication service user:', user);
            this.authenticationSubject.next(user);
        };
        /**
         * @return {?}
         */
        OauthAuthenticationService.prototype.logout = /**
         * @return {?}
         */
        function () {
            this.authenticationSubject.next(null);
        };
        /**
         * gives information about an user authenticated
         */
        /**
         * gives information about an user authenticated
         * @return {?}
         */
        OauthAuthenticationService.prototype.getUserInfo = /**
         * gives information about an user authenticated
         * @return {?}
         */
        function () {
            return this.http.get(this.userInfoEndpoint);
            // if (this.authBackend == AuthBackend.sceiba) {
            //     return this.http.get<any>(this.env.sceibaApi + 'me');
            // } else if (this.authBackend == AuthBackend.cuor){
            //     return this.http.get<any>(this.env.cuorApi + 'me');
            // }
        };
        /**
         * @param {?} next
         * @param {?} state
         * @return {?}
         */
        OauthAuthenticationService.prototype.canActivate = /**
         * @param {?} next
         * @param {?} state
         * @return {?}
         */
        function (next, state) {
            /** @type {?} */
            var user = this.oauthStorage.getItem('user');
            if (user) {
                return true;
            }
            else {
                this._router.navigate(['/']);
                return false;
            }
        };
        /**
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        OauthAuthenticationService.prototype.intercept = /**
         * @param {?} req
         * @param {?} next
         * @return {?}
         */
        function (req, next) {
            var _this = this;
            /** @type {?} */
            var token = this.oauthStorage.getItem('access_token');
            if (token) {
                /** @type {?} */
                var headers = req.headers.set('Authorization', 'Bearer ' + token);
                if (req.method != 'GET') {
                    headers = headers.set('Content-Type', 'application/json');
                    headers = headers.set('Access-Control-Allow-Origin', '*');
                }
                req = req.clone({ headers: headers });
            }
            return next.handle(req).pipe(operators.catchError((/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                /* 401 means the user is not authorized. */
                if (err.status === 401) {
                    _this.oauthService.initImplicitFlow();
                    // this._router.navigateByUrl('/');
                }
                return rxjs.throwError(err);
            })));
        };
        /**
         * Configure, this function is necessary if you will implement your own logic
         * @param authConfig: is the auth configuration.
         * you have to call `oauthService.initImplicitFlow()` in you login function
         * and `oauthService.logOut()` in you logout function
         */
        /**
         * Configure, this function is necessary if you will implement your own logic
         * @param {?} authConfig
         * @return {?}
         */
        OauthAuthenticationService.prototype.configure = /**
         * Configure, this function is necessary if you will implement your own logic
         * @param {?} authConfig
         * @return {?}
         */
        function (authConfig) {
            this.oauthService.configure(authConfig);
            this.oauthService.tokenValidationHandler = new angularOauth2Oidc.JwksValidationHandler();
            this.oauthService.loadDiscoveryDocumentAndTryLogin();
        };
        OauthAuthenticationService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        OauthAuthenticationService.ctorParameters = function () { return [
            { type: angularOauth2Oidc.OAuthStorage },
            { type: http.HttpClient },
            { type: router.Router },
            { type: angularOauth2Oidc.OAuthService },
            { type: angularOauth2Oidc.OAuthResourceServerErrorHandler },
            { type: angularOauth2Oidc.OAuthModuleConfig, decorators: [{ type: core.Optional }] }
        ]; };
        /** @nocollapse */ OauthAuthenticationService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function OauthAuthenticationService_Factory() { return new OauthAuthenticationService(core.ɵɵinject(angularOauth2Oidc.OAuthStorage), core.ɵɵinject(http.HttpClient), core.ɵɵinject(router.Router), core.ɵɵinject(angularOauth2Oidc.OAuthService), core.ɵɵinject(angularOauth2Oidc.OAuthResourceServerErrorHandler), core.ɵɵinject(angularOauth2Oidc.OAuthModuleConfig, 8)); }, token: OauthAuthenticationService, providedIn: "root" });
        return OauthAuthenticationService;
    }());
    if (false) {
        /** @type {?} */
        OauthAuthenticationService.prototype.userInfoEndpoint;
        /**
         * @type {?}
         * @private
         */
        OauthAuthenticationService.prototype.authenticationSubject;
        /**
         * Observer to handles the behavior when a user authenticates
         * @type {?}
         */
        OauthAuthenticationService.prototype.authenticationSubjectObservable;
        /**
         * @type {?}
         * @private
         */
        OauthAuthenticationService.prototype.oauthStorage;
        /**
         * @type {?}
         * @protected
         */
        OauthAuthenticationService.prototype.http;
        /**
         * @type {?}
         * @private
         */
        OauthAuthenticationService.prototype._router;
        /**
         * @type {?}
         * @private
         */
        OauthAuthenticationService.prototype.oauthService;
        /**
         * @type {?}
         * @private
         */
        OauthAuthenticationService.prototype.errorHandler;
        /**
         * @type {?}
         * @private
         */
        OauthAuthenticationService.prototype.moduleConfig;
    }
    var SimpleAuthenticationService = /** @class */ (function () {
        function SimpleAuthenticationService(env, http, _router) {
            this.env = env;
            this.http = http;
            this._router = _router;
            //implements CanActivate {
            this.authBackend = AuthBackend.sceiba;
            this.authenticationSubject = new rxjs.Subject();
            /**
             * Observer to handles the behavior when a user authenticates
             */
            this.authenticationSubjectObservable = this.authenticationSubject.asObservable();
        }
        /**
         * notifies by an observable if the user is authenticated
         * for the knowledge of who uses it
         * @param islogged 'true' is loggued or 'false' other way
         */
        /**
         * notifies by an observable if the user is authenticated
         * for the knowledge of who uses it
         * @param {?} islogged 'true' is loggued or 'false' other way
         * @return {?}
         */
        SimpleAuthenticationService.prototype.logguedChange = /**
         * notifies by an observable if the user is authenticated
         * for the knowledge of who uses it
         * @param {?} islogged 'true' is loggued or 'false' other way
         * @return {?}
         */
        function (islogged) {
            this.authenticationSubject.next(islogged);
        };
        /**
         * gives information about an user authenticated
         */
        /**
         * gives information about an user authenticated
         * @return {?}
         */
        SimpleAuthenticationService.prototype.getUserInfo = /**
         * gives information about an user authenticated
         * @return {?}
         */
        function () {
            if (this.authBackend == AuthBackend.sceiba) {
                return this.http.get(this.env.sceibaApi + 'me');
            }
            else if (this.authBackend == AuthBackend.cuor) {
                return this.http.get(this.env.cuorApi + 'me');
            }
        };
        SimpleAuthenticationService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        SimpleAuthenticationService.ctorParameters = function () { return [
            { type: Environment },
            { type: http.HttpClient },
            { type: router.Router }
        ]; };
        /** @nocollapse */ SimpleAuthenticationService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function SimpleAuthenticationService_Factory() { return new SimpleAuthenticationService(core.ɵɵinject(Environment), core.ɵɵinject(http.HttpClient), core.ɵɵinject(router.Router)); }, token: SimpleAuthenticationService, providedIn: "root" });
        return SimpleAuthenticationService;
    }());
    if (false) {
        /** @type {?} */
        SimpleAuthenticationService.prototype.authBackend;
        /**
         * @type {?}
         * @private
         */
        SimpleAuthenticationService.prototype.authenticationSubject;
        /**
         * Observer to handles the behavior when a user authenticates
         * @type {?}
         */
        SimpleAuthenticationService.prototype.authenticationSubjectObservable;
        /**
         * @type {?}
         * @private
         */
        SimpleAuthenticationService.prototype.env;
        /**
         * @type {?}
         * @protected
         */
        SimpleAuthenticationService.prototype.http;
        /**
         * @type {?}
         * @private
         */
        SimpleAuthenticationService.prototype._router;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/authentication/authentication.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function OauthInfo() { }
    if (false) {
        /** @type {?} */
        OauthInfo.prototype.serverHost;
        /** @type {?} */
        OauthInfo.prototype.loginUrl;
        /** @type {?} */
        OauthInfo.prototype.tokenEndpoint;
        /** @type {?} */
        OauthInfo.prototype.userInfoEndpoint;
        /** @type {?} */
        OauthInfo.prototype.appHost;
        /** @type {?} */
        OauthInfo.prototype.appName;
        /** @type {?} */
        OauthInfo.prototype.oauthRedirectUri;
        /** @type {?} */
        OauthInfo.prototype.oauthClientId;
        /** @type {?} */
        OauthInfo.prototype.oauthScope;
    }
    /**
     * Represents a component used to authenticate.
     *
     * In order to use this component with the correct i18n, you must include
     * (in your i18n translate files that are in the folder `assets\i18n`)
     * a translation key of name "TOCO_AUTHENTICATION" that contains
     * an object as value with the translation needed by this component.
     *
     * In the case of `es.json` file, you must include the following translation key:
     * "TOCO_AUTHENTICATION": {
     * "MAT_CARD_TITLE_AUTH": "Autenticación con",
     * "AUTENTICARSE": "Autenticarse",
     * "H1_HOLA": "Hola",
     * "BUTTON_SALIR": "Salir"
     * }
     *
     * In the case of `en.json` file, you must include the following translation key:
     * "TOCO_AUTHENTICATION": {
     * "MAT_CARD_TITLE_AUTH": "Authentication with",
     * "AUTENTICARSE": "Log in",
     * "H1_HOLA": "Hello,",
     * "BUTTON_SALIR": "Exit"
     * }
     *
     * If you have another language, then you have another `*.json` file,
     * and you must include the "TOCO_AUTHENTICATION" translation key with the correct translation values.
     */
    var AuthenticationComponent = /** @class */ (function () {
        function AuthenticationComponent(userProfileService, env, router, oauthService, oauthStorage, authenticationService, _transServ) {
            var _this = this;
            this.userProfileService = userProfileService;
            this.env = env;
            this.router = router;
            this.oauthService = oauthService;
            this.oauthStorage = oauthStorage;
            this.authenticationService = authenticationService;
            this._transServ = _transServ;
            this.timerAuthenticateSuscription = null;
            this.timerAuthenticateObserver = {
                next: (/**
                 * @param {?} _
                 * @return {?}
                 */
                function (_) {
                    // console.log('next');
                    // this.oauthService.setupAutomaticSilentRefresh();
                    if (_this.oauthStorage.getItem("access_token")) {
                        _this.authenticationService.getUserInfo().subscribe((/**
                         * @param {?} response
                         * @return {?}
                         */
                        function (response) {
                            _this.oauthStorage.setItem("user", JSON.stringify(response));
                            _this.authenticationService.login(response);
                        }), (/**
                         * @param {?} error
                         * @return {?}
                         */
                        function (error) { return console.log(error); }), (/**
                         * @return {?}
                         */
                        function () { }));
                        // this.authenticationService.logguedChange(true);
                    }
                }),
                error: (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    console.log("The observable got an error notification: " + err + ".");
                }),
                complete: (/**
                 * @return {?}
                 */
                function () {
                    console.log("The observable got a complete notification.");
                }),
            };
        }
        /**
         * @return {?}
         */
        AuthenticationComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.isButtonLogin == undefined)
                this.isButtonLogin = false;
            if (this.isButtonLoginIcon == undefined)
                this.isButtonLoginIcon = false;
            if (this.isButtonLoginText == undefined) {
                this._transServ.get('TOCO_AUTHENTICATION.AUTENTICARSE').subscribe((/**
                 * @param {?} res
                 * @return {?}
                 */
                function (res) {
                    _this.isButtonLoginText = res;
                }));
            }
            if (this.oauthInfo.loginUrl == undefined || this.oauthInfo.loginUrl == '') {
                this.oauthInfo.loginUrl = this.oauthInfo.serverHost + "oauth/authorize";
            }
            if (this.oauthInfo.tokenEndpoint == undefined || this.oauthInfo.tokenEndpoint == '') {
                this.oauthInfo.tokenEndpoint = this.oauthInfo.serverHost + "oauth/token";
            }
            this.configure();
        };
        /**
         * @return {?}
         */
        AuthenticationComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            if (this.timerAuthenticateSuscription) {
                this.timerAuthenticateSuscription.unsubscribe();
            }
        };
        /**
         * @return {?}
         */
        AuthenticationComponent.prototype.ngAfterViewInit = /**
         * @return {?}
         */
        function () {
            // this observable is to wait a while for the component to finish loading,
            // because otherwise it fails to notify that the user is authenticated
            this.timerAuthenticateSuscription = rxjs.timer(0).subscribe(this.timerAuthenticateObserver);
        };
        /**
         * Configurations to authenticate
         */
        /**
         * Configurations to authenticate
         * @private
         * @return {?}
         */
        AuthenticationComponent.prototype.configure = /**
         * Configurations to authenticate
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var authConfig = {
                // Url of the Identity Provider
                //issuer: 'https://sceiba-lab.upr.edu.cu',
                loginUrl: this.oauthInfo.loginUrl,
                tokenEndpoint: this.oauthInfo.tokenEndpoint,
                // URL of the SPA to redirect the user to after login
                redirectUri: this.oauthInfo.oauthRedirectUri,
                // The SPA's id. The SPA is registered with this id at the auth-server
                clientId: this.oauthInfo.oauthClientId,
                oidc: false,
                // silentRefreshRedirectUri: this.oauthInfo.sceibaHost + 'oauth/token',
                // timeoutFactor: 0.75,
                sessionChecksEnabled: true,
                // set the scope for the permissions the client should request
                // The first three are defined by OIDC. The 4th is a usecase-specific one
                scope: this.oauthInfo.oauthScope,
            };
            this.oauthService.configure(authConfig);
            // Store user session in storage
            // this.oauthService.setStorage(this.oauthStorage);
            this.oauthService.tokenValidationHandler = new angularOauth2Oidc.JwksValidationHandler();
            // Try to login and if a token was received, request user information
            this.oauthService.tryLogin({
                onTokenReceived: (/**
                 * @param {?} _
                 * @return {?}
                 */
                function (_) {
                    // gives information about user loggued
                    _this.authenticationService.userInfoEndpoint = _this.oauthInfo.userInfoEndpoint;
                    _this.authenticationService.getUserInfo().subscribe((/**
                     * @param {?} response
                     * @return {?}
                     */
                    function (response) {
                        console.log(response);
                        _this.oauthStorage.setItem("user", JSON.stringify(response));
                        _this.authenticationService.login(response);
                    }), (/**
                     * @param {?} error
                     * @return {?}
                     */
                    function (error) { return console.log(error); }), (/**
                     * @return {?}
                     */
                    function () { }));
                }),
                onLoginError: (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    console.log("error in login", err);
                }),
            });
        };
        /**
         * Starts the login flow
         */
        /**
         * Starts the login flow
         * @return {?}
         */
        AuthenticationComponent.prototype.login = /**
         * Starts the login flow
         * @return {?}
         */
        function () {
            var _this = this;
            this.oauthService.initImplicitFlow();
            // this.authenticationService.authBackend = this.authBackend
            // TODO: por que esto aqui, este modulo solo se encarga de la autenticacion y dar la informacion basica del usuario,
            // el perfil es manejado por otro componente
            this.user = new UserProfile();
            this.userProfileService.getUserInfo().subscribe({
                next: (/**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    if (response && response.data && response.data.userprofile) {
                        _this.user.deepcopy(response.data.userprofile);
                        _this.oauthStorage.setItem("user", _this.user.entitystringify());
                    }
                }),
                error: (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    console.log(err);
                }),
                complete: (/**
                 * @return {?}
                 */
                function () { }),
            });
        };
        /**
         * Ends the login flow
         */
        /**
         * Ends the login flow
         * @return {?}
         */
        AuthenticationComponent.prototype.logoff = /**
         * Ends the login flow
         * @return {?}
         */
        function () {
            this.oauthService.logOut();
            this.authenticationService.logout();
        };
        Object.defineProperty(AuthenticationComponent.prototype, "name", {
            /**
             * Gives the user's email if the user is authenticated
             */
            get: /**
             * Gives the user's email if the user is authenticated
             * @return {?}
             */
            function () {
                if (this.oauthStorage.getItem("access_token")) {
                    return this.oauthStorage.getItem("email");
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        AuthenticationComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-authentication",
                        template: "\n<div *ngIf=\"!isButtonLogin;else template_buttonLogin\" fxLayoutAlign=\"center center\" fxLayout=\"row\">\n    <mat-card fxLayoutAlign=\"center center\" fxLayout=\"column\">\n\n        <mat-card-header>\n            <mat-card-title *ngIf=\"!userName\">{{ 'TOCO_AUTHENTICATION.MAT_CARD_TITLE_AUTH' | translate }}</mat-card-title>\n        </mat-card-header>\n\n        <mat-card-content fxLayoutAlign=\"center center\" fxLayout=\"column\">\n            <button *ngIf=\"!userName;else templateName\" mat-raised-button color=\"primary\" style=\"width: 12em\" (click)=\"login()\">\n                <img src=\"https://sceiba-lab.upr.edu.cu/static/images/sceiba-logo-white.png\" alt=\"Sceiba\" width=\"100\" style=\"padding-top: .9em; padding-bottom: .9em\">\n            </button>\n\n            <ng-template #templateName>\n                <h1>{{ 'TOCO_AUTHENTICATION.H1_HOLA' | translate }} {{ userName }}</h1>\n                <button mat-raised-button color=\"primary\" style=\"width: 12em\" (click)=\"logoff()\">\n                    {{ 'TOCO_AUTHENTICATION.BUTTON_SALIR' | translate }}\n                </button>\n            </ng-template>\n\n        </mat-card-content>\n    </mat-card>\n</div>\n\n<ng-template #template_buttonLogin>\n    <button *ngIf=\"isButtonLoginIcon\" mat-icon-button (click)=\"login()\" matTooltip=\"{{ isButtonLoginText }}\">\n        <mat-icon>lock_open</mat-icon>\n    </button>\n    <button *ngIf=\"!isButtonLoginIcon\" mat-raised-button color=\"primary\" (click)=\"login()\">\n        {{ isButtonLoginText }}\n        <mat-icon class=\"mat-18\">lock_open</mat-icon>\n    </button>\n</ng-template>\n",
                        styles: [".card-width{width:25%;min-width:15em}"]
                    }] }
        ];
        /** @nocollapse */
        AuthenticationComponent.ctorParameters = function () { return [
            { type: UserProfileService },
            { type: Environment },
            { type: router.Router },
            { type: angularOauth2Oidc.OAuthService },
            { type: angularOauth2Oidc.OAuthStorage },
            { type: OauthAuthenticationService },
            { type: core$2.TranslateService }
        ]; };
        AuthenticationComponent.propDecorators = {
            isButtonLogin: [{ type: core.Input }],
            isButtonLoginIcon: [{ type: core.Input }],
            isButtonLoginText: [{ type: core.Input }],
            oauthInfo: [{ type: core.Input }]
        };
        return AuthenticationComponent;
    }());
    if (false) {
        /** @type {?} */
        AuthenticationComponent.prototype.isButtonLogin;
        /** @type {?} */
        AuthenticationComponent.prototype.isButtonLoginIcon;
        /** @type {?} */
        AuthenticationComponent.prototype.isButtonLoginText;
        /** @type {?} */
        AuthenticationComponent.prototype.oauthInfo;
        /** @type {?} */
        AuthenticationComponent.prototype.user;
        /** @type {?} */
        AuthenticationComponent.prototype.userName;
        /**
         * @type {?}
         * @private
         */
        AuthenticationComponent.prototype.timerAuthenticateSuscription;
        /**
         * @type {?}
         * @private
         */
        AuthenticationComponent.prototype.timerAuthenticateObserver;
        /**
         * @type {?}
         * @private
         */
        AuthenticationComponent.prototype.userProfileService;
        /**
         * @type {?}
         * @private
         */
        AuthenticationComponent.prototype.env;
        /**
         * @type {?}
         * @private
         */
        AuthenticationComponent.prototype.router;
        /**
         * @type {?}
         * @private
         */
        AuthenticationComponent.prototype.oauthService;
        /**
         * @type {?}
         * @private
         */
        AuthenticationComponent.prototype.oauthStorage;
        /**
         * @type {?}
         * @private
         */
        AuthenticationComponent.prototype.authenticationService;
        /**
         * @type {?}
         * @private
         */
        AuthenticationComponent.prototype._transServ;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/authentication/authentication.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @return {?}
     */
    function storageFactory() {
        return localStorage;
    }
    var AuthenticationModule = /** @class */ (function () {
        function AuthenticationModule() {
        }
        AuthenticationModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            AuthenticationComponent
                        ],
                        imports: [
                            SharedModule,
                            http.HttpClientModule,
                            core$2.TranslateModule,
                            angularOauth2Oidc.OAuthModule.forRoot(),
                        ],
                        exports: [
                            AuthenticationComponent
                        ],
                        //TODO: esto se elimina de aquí y se pone en el fichero `core/services/http-interceptor.order.ts`.
                        providers: [
                            { provide: angularOauth2Oidc.OAuthStorage, useFactory: storageFactory },
                            OauthAuthenticationService,
                            SimpleAuthenticationService,
                            /* TODO: This can not be set here. */
                            {
                                provide: http.HTTP_INTERCEPTORS,
                                useClass: OauthAuthenticationService,
                                multi: true
                            }
                        ]
                    },] }
        ];
        return AuthenticationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/authentication/auth-config.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @type {?} */
    var authConfig = {
        // Url of the Identity Provider
        //issuer: 'https://sceiba-lab.upr.edu.cu',
        loginUrl: 'https://localhost:5000/oauth/authorize',
        tokenEndpoint: 'https://localhost:5000/oauth/token',
        // URL of the SPA to redirect the user to after login
        redirectUri: 'https://127.0.0.1:4200/',
        // The SPA's id. The SPA is registered with this id at the auth-server
        clientId: 'a0QpogRmC5iyrhLbfIqmDEbOhhr9nUzOYYPAhWW1',
        oidc: false,
        timeoutFactor: 0.80,
        // set the scope for the permissions the client should request
        // The first three are defined by OIDC. The 4th is a usecase-specific one
        scope: 'user:email',
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/authentication/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/backend/taxonomy.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // TODO: Poner todos los tipos de datos de retorno de Response.
    // No puede haber en ningun servicio del backend un Response<any>
    var TaxonomyService = /** @class */ (function () {
        function TaxonomyService(env, http$1, oauthStorage) {
            this.env = env;
            this.http = http$1;
            this.oauthStorage = oauthStorage;
            this.prefix = 'vocabularies';
            this.httpOptions = {
                headers: new http.HttpHeaders({
                    'Content-Type': 'application/json',
                })
            };
            this.token = '';
            this.token = this.oauthStorage.getItem('access_token');
        }
        /**
         * @param {?} id
         * @return {?}
         */
        TaxonomyService.prototype.getVocabulary = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/vocabulary/' + id;
            return this.http.get(req);
        };
        /**
         * @param {?} ids
         * @return {?}
         */
        TaxonomyService.prototype.getTermListByIDs = /**
         * @param {?} ids
         * @return {?}
         */
        function (ids) {
            /** @type {?} */
            var p = '';
            ids.forEach((/**
             * @param {?} n
             * @return {?}
             */
            function (n) { return p = p + n.toString(10) + ','; }));
            p = p.substring(0, p.length - 1);
            /** @type {?} */
            var params = new http.HttpParams();
            /** @type {?} */
            var options = {
                params: params.set('ids', p)
            };
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/term/inlist';
            return this.http.get(req, options);
        };
        /**
         * @param {?} termID
         * @param {?=} level
         * @return {?}
         */
        TaxonomyService.prototype.getTermByID = /**
         * @param {?} termID
         * @param {?=} level
         * @return {?}
         */
        function (termID, level) {
            if (level === void 0) { level = 10; }
            /** @type {?} */
            var params = new http.HttpParams();
            /** @type {?} */
            var options = {
                params: params.set('level', level.toString(10))
            };
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/term/id/' + termID;
            return this.http.get(req, options);
        };
        /**
         * @param {?} termUUID
         * @param {?=} level
         * @return {?}
         */
        TaxonomyService.prototype.getTermByUUID = /**
         * @param {?} termUUID
         * @param {?=} level
         * @return {?}
         */
        function (termUUID, level) {
            if (level === void 0) { level = 10; }
            /** @type {?} */
            var params = new http.HttpParams();
            /** @type {?} */
            var options = {
                params: params.set('level', level.toString(10))
            };
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/term/' + termUUID;
            return this.http.get(req, options);
        };
        /**
         * @param {?} vocabId
         * @param {?=} level
         * @return {?}
         */
        TaxonomyService.prototype.getTermsTreeByVocab = /**
         * @param {?} vocabId
         * @param {?=} level
         * @return {?}
         */
        function (vocabId, level) {
            if (level === void 0) { level = 10; }
            /** @type {?} */
            var params = new http.HttpParams();
            /** @type {?} */
            var options = {
                params: params.set('level', level.toString(10))
            };
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/term/tree/' + vocabId;
            return this.http.get(req, options);
        };
        /**
         * @param {?} vocab
         * @return {?}
         */
        TaxonomyService.prototype.newVocabulary = /**
         * @param {?} vocab
         * @return {?}
         */
        function (vocab) {
            this.httpOptions.headers = this.httpOptions.headers.set('Authorization', 'Bearer ' + this.token);
            return this.http.post(this.env.sceibaApi + this.prefix + '/vocabulary/new', vocab.entitystringify(), this.httpOptions);
        };
        /**
         * @param {?} vocab
         * @return {?}
         */
        TaxonomyService.prototype.editVocabulary = /**
         * @param {?} vocab
         * @return {?}
         */
        function (vocab) {
            this.httpOptions.headers = this.httpOptions.headers.set('Authorization', 'Bearer ' + this.token);
            return this.http.post(this.env.sceibaApi + this.prefix + '/vocabulary/edit/' + vocab.id, vocab.entitystringify(), this.httpOptions);
        };
        /**
         * @return {?}
         */
        TaxonomyService.prototype.getVocabularies = /**
         * @return {?}
         */
        function () {
            return this.http.get(this.env.sceibaApi + this.prefix + '/vocabulary/list');
        };
        /**
         * @param {?} term
         * @return {?}
         */
        TaxonomyService.prototype.newTerm = /**
         * @param {?} term
         * @return {?}
         */
        function (term) {
            this.httpOptions.headers = this.httpOptions.headers.set('Authorization', 'Bearer ' + this.token);
            return this.http.post(this.env.sceibaApi + this.prefix + '/term/new', term.entitystringify(), this.httpOptions);
        };
        /**
         * @param {?} term
         * @return {?}
         */
        TaxonomyService.prototype.editTerm = /**
         * @param {?} term
         * @return {?}
         */
        function (term) {
            this.httpOptions.headers = this.httpOptions.headers.set('Authorization', 'Bearer ' + this.token);
            return this.http.post(this.env.sceibaApi + this.prefix + '/term/edit/' + term.uuid, term.entitystringify(), this.httpOptions);
        };
        /**
         * @return {?}
         */
        TaxonomyService.prototype.getCurrentUserPermissions = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/user/permissions';
            this.httpOptions.headers = this.httpOptions.headers.set('Authorization', 'Bearer ' + this.token);
            return this.http.get(req, this.httpOptions);
        };
        TaxonomyService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        TaxonomyService.ctorParameters = function () { return [
            { type: Environment },
            { type: http.HttpClient },
            { type: angularOauth2Oidc.OAuthStorage }
        ]; };
        return TaxonomyService;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        TaxonomyService.prototype.prefix;
        /**
         * @type {?}
         * @private
         */
        TaxonomyService.prototype.httpOptions;
        /**
         * @type {?}
         * @private
         */
        TaxonomyService.prototype.token;
        /**
         * @type {?}
         * @private
         */
        TaxonomyService.prototype.env;
        /**
         * @type {?}
         * @private
         */
        TaxonomyService.prototype.http;
        /**
         * @type {?}
         * @private
         */
        TaxonomyService.prototype.oauthStorage;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/backend/catalog.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CatalogService = /** @class */ (function (_super) {
        __extends(CatalogService, _super);
        function CatalogService(env, http) {
            var _this = _super.call(this, http) || this;
            _this.env = env;
            _this.http = http;
            return _this;
        }
        /**
         * @param {?} count
         * @param {?} page
         * @param {?} parameters
         * @return {?}
         */
        CatalogService.prototype.getJournalsPage = /**
         * @param {?} count
         * @param {?} page
         * @param {?} parameters
         * @return {?}
         */
        function (count, page, parameters) {
            try {
                /** @type {?} */
                var params = new http.HttpParams();
                if (parameters) {
                    for (var i = 0; i < parameters.length; i++) {
                        params = params.set(parameters[i].field, parameters[i].value);
                    }
                }
                /** @type {?} */
                var options = {
                    params: params.set('size', count.toString(10)).set('page', (page).toString(10))
                };
                return this.http.get(this.env.sceibaApi + 'source/journals', options);
            }
            catch (error) {
            }
        };
        /**
         * @return {?}
         */
        CatalogService.prototype.getJournalsCount = /**
         * @return {?}
         */
        function () {
            try {
                return this.http.get(this.env.sceibaApi + 'source/count');
            }
            catch (error) {
            }
        };
        /**
         * @return {?}
         */
        CatalogService.prototype.getJournalsVocab = /**
         * @return {?}
         */
        function () {
            return this.http.get(this.env.sceibaApi + 'taxonomy/vocabulary/list');
        };
        /**
         * @param {?} vocabId
         * @return {?}
         */
        CatalogService.prototype.getTerminosByVocab = /**
         * @param {?} vocabId
         * @return {?}
         */
        function (vocabId) {
            try {
                return this.http.get(this.env.sceibaApi + 'taxonomy/term/list/' + vocabId);
            }
            catch (error) {
            }
        };
        //   getPeople():Observable<People_Response>{
        //     return this.http.get<People_Response>(this.dominio);
        //   }
        //   getPeopleById(id: number):Observable<Person_Response>{
        //         return this.http.get<Person_Response>(this.dominio+'/'+id);
        //     }
        //   getPeoplepaginator(inicio: number, cant: number):Observable<People_Response>{
        //       return this.http.get<People_Response>(this.dominio+'/'+inicio+'/'+cant);
        //   }
        //     addPeople(body):Observable<Response>{
        //       return this.http.post<Response>(this.dominio,body);
        //   }
        //   getPeople():Observable<People_Response>{
        //     return this.http.get<People_Response>(this.dominio);
        //   }
        //   getPeopleById(id: number):Observable<Person_Response>{
        //         return this.http.get<Person_Response>(this.dominio+'/'+id);
        //     }
        //   getPeoplepaginator(inicio: number, cant: number):Observable<People_Response>{
        //       return this.http.get<People_Response>(this.dominio+'/'+inicio+'/'+cant);
        //   }
        //     addPeople(body):Observable<Response>{
        //       return this.http.post<Response>(this.dominio,body);
        //   }
        /**
         * @param {?} uuid
         * @return {?}
         */
        CatalogService.prototype.getSourceByUUID = 
        //   getPeople():Observable<People_Response>{
        //     return this.http.get<People_Response>(this.dominio);
        //   }
        //   getPeopleById(id: number):Observable<Person_Response>{
        //         return this.http.get<Person_Response>(this.dominio+'/'+id);
        //     }
        //   getPeoplepaginator(inicio: number, cant: number):Observable<People_Response>{
        //       return this.http.get<People_Response>(this.dominio+'/'+inicio+'/'+cant);
        //   }
        //     addPeople(body):Observable<Response>{
        //       return this.http.post<Response>(this.dominio,body);
        //   }
        /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            /** @type {?} */
            var req = this.env.sceibaApi + 'source/' + uuid;
            return this.http.get(req);
        };
        /**
         * @param {?} uuid
         * @return {?}
         */
        CatalogService.prototype.getSourcesOrgAggregation = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            /** @type {?} */
            var req = this.env.sceibaApi + 'source/aggs/org/' + uuid;
            return this.http.get(req);
        };
        CatalogService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        CatalogService.ctorParameters = function () { return [
            { type: Environment },
            { type: http.HttpClient }
        ]; };
        return CatalogService;
    }(HttpService));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        CatalogService.prototype.env;
        /**
         * @type {?}
         * @protected
         */
        CatalogService.prototype.http;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/backend/backend.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var BackendModule = /** @class */ (function () {
        function BackendModule() {
        }
        BackendModule.decorators = [
            { type: core.NgModule, args: [{
                        providers: [
                            TaxonomyService,
                            CatalogService
                        ]
                    },] }
        ];
        return BackendModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/backend/notification.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NotificationService = /** @class */ (function (_super) {
        __extends(NotificationService, _super);
        function NotificationService(env, http) {
            var _this = _super.call(this, http) || this;
            _this.env = env;
            _this.http = http;
            return _this;
        }
        /**
         * @param {?} count
         * @param {?} page
         * @return {?}
         */
        NotificationService.prototype.getNotificationsList = /**
         * @param {?} count
         * @param {?} page
         * @return {?}
         */
        function (count, page) {
            return this.http.get(this.env.sceibaApi + 'notification/list');
        };
        /**
         * @param {?} id
         * @return {?}
         */
        NotificationService.prototype.setNotificationViewed = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            return this.http.get(this.env.sceibaApi + 'notification/viewed/' + id);
        };
        NotificationService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NotificationService.ctorParameters = function () { return [
            { type: Environment },
            { type: http.HttpClient }
        ]; };
        return NotificationService;
    }(HttpService));
    if (false) {
        /**
         * @type {?}
         * @private
         */
        NotificationService.prototype.env;
        /**
         * @type {?}
         * @protected
         */
        NotificationService.prototype.http;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/backend/organization.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * The URL to the root api.
     * @type {?}
     */
    var ROOT_API = 'api';
    /**
     * The object with the URLs to the endpoint apis.
     * @type {?}
     */
    var ENDPOINT_APIS = {
        organizations: ROOT_API + '/organizations',
    };
    /**
     * The backend service in order to communicate with a remote server over HTTP.
     */
    var OrganizationService = /** @class */ (function () {
        function OrganizationService(_http, _messageService) {
            this._http = _http;
            this._messageService = _messageService;
            /**
             * The `httpOptions` object that contains the headers and will be passed to every `HttpClient` save method.
             */
            this._httpOptions = {
                headers: new http.HttpHeaders({
                    'Content-Type': 'application/json',
                    'Authorization': 'my-auth-token'
                })
            };
        }
        /**
         * Gets data from the server.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @param url The endpoint api URL.
         * @param optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         */
        /**
         * Gets data from the server.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @template T
         * @param {?} url The endpoint api URL.
         * @param {?} optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         * @return {?}
         */
        OrganizationService.prototype.get = /**
         * Gets data from the server.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @template T
         * @param {?} url The endpoint api URL.
         * @param {?} optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         * @return {?}
         */
        function (url, optionalResult) {
            var _this = this;
            return this._http.get(url).pipe(operators.tap((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _this.log("fetched data from '" + url + "'"); })));
        };
        /**
         * Gets data from the server that meets the specified `query`.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @param url The endpoint api URL.
         * @param query The query to search.
         * @param optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         */
        /**
         * Gets data from the server that meets the specified `query`.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @template T
         * @param {?} url The endpoint api URL.
         * @param {?} query The query to search.
         * @param {?} optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         * @return {?}
         */
        OrganizationService.prototype.search = /**
         * Gets data from the server that meets the specified `query`.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @template T
         * @param {?} url The endpoint api URL.
         * @param {?} query The query to search.
         * @param {?} optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         * @return {?}
         */
        function (url, query, optionalResult) {
            var _this = this;
            return this._http.get(url + "/?" + query).pipe(operators.tap((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _this.log("searched '" + query + "' in '" + url + "'"); })));
        };
        /**
         * Adds `data` to the server. Expects the server to generate an `id` for the new `data`.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @param url The endpoint api URL.
         * @param data The data to add.
         * @param optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         */
        /**
         * Adds `data` to the server. Expects the server to generate an `id` for the new `data`.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @template T
         * @param {?} url The endpoint api URL.
         * @param {?} data The data to add.
         * @param {?} optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         * @return {?}
         */
        OrganizationService.prototype.add = /**
         * Adds `data` to the server. Expects the server to generate an `id` for the new `data`.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @template T
         * @param {?} url The endpoint api URL.
         * @param {?} data The data to add.
         * @param {?} optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         * @return {?}
         */
        function (url, data, optionalResult) {
            /* Expects the server to generate an `id` for the new `data`. */
            var _this = this;
            return this._http.post(url, data, this._httpOptions).pipe(operators.tap((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _this.log("added " + data + " to '" + url + "'"); })));
        };
        /**
         * Updates `data` on the server. Returns an Observable of that `data` if the `data` is inserted (does
         * not exist) on the server; otherwise, returns an Observable of null (if the `data` is only updated).
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @param url The endpoint api URL.
         * @param data The data to update.
         * @param optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         */
        /**
         * Updates `data` on the server. Returns an Observable of that `data` if the `data` is inserted (does
         * not exist) on the server; otherwise, returns an Observable of null (if the `data` is only updated).
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @template T
         * @param {?} url The endpoint api URL.
         * @param {?} data The data to update.
         * @param {?} optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         * @return {?}
         */
        OrganizationService.prototype.update = /**
         * Updates `data` on the server. Returns an Observable of that `data` if the `data` is inserted (does
         * not exist) on the server; otherwise, returns an Observable of null (if the `data` is only updated).
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @template T
         * @param {?} url The endpoint api URL.
         * @param {?} data The data to update.
         * @param {?} optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         * @return {?}
         */
        function (url, data, optionalResult) {
            var _this = this;
            return this._http.put(url, data, this._httpOptions).pipe(operators.tap((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _this.log("updated " + data + " to '" + url + "'"); })));
        };
        /**
         * Deletes data from the server.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @param url The endpoint api URL.
         * @param id The unique identifier that identifies the data to delete.
         * @param optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         */
        /**
         * Deletes data from the server.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @template T
         * @param {?} url The endpoint api URL.
         * @param {?} id The unique identifier that identifies the data to delete.
         * @param {?} optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         * @return {?}
         */
        OrganizationService.prototype.delete = /**
         * Deletes data from the server.
         * If an error occurs, lets the app keep running by returning the specified safe `optionalResult`.
         * @template T
         * @param {?} url The endpoint api URL.
         * @param {?} id The unique identifier that identifies the data to delete.
         * @param {?} optionalResult If an error occurs, lets the app keep running by returning a safe optional value
         * as the observable result.
         * @return {?}
         */
        function (url, id, optionalResult) {
            var _this = this;
            return this._http.delete(url + "/" + id, this._httpOptions).pipe(operators.tap((/**
             * @param {?} _
             * @return {?}
             */
            function (_) { return _this.log("deleted data with id = " + id + " from '" + url + "'"); })));
        };
        /**
         * Logs an `OrganizationService` message with the `MessageService`.
         * @param message The message to log.
         */
        /**
         * Logs an `OrganizationService` message with the `MessageService`.
         * @private
         * @param {?} message The message to log.
         * @return {?}
         */
        OrganizationService.prototype.log = /**
         * Logs an `OrganizationService` message with the `MessageService`.
         * @private
         * @param {?} message The message to log.
         * @return {?}
         */
        function (message) {
            this._messageService.add(OrganizationService.name + ": " + message + ".");
        };
        OrganizationService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        OrganizationService.ctorParameters = function () { return [
            { type: http.HttpClient },
            { type: MessageService }
        ]; };
        /** @nocollapse */ OrganizationService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function OrganizationService_Factory() { return new OrganizationService(core.ɵɵinject(http.HttpClient), core.ɵɵinject(MessageService)); }, token: OrganizationService, providedIn: "root" });
        return OrganizationService;
    }());
    if (false) {
        /**
         * The `httpOptions` object that contains the headers and will be passed to every `HttpClient` save method.
         * @type {?}
         * @private
         */
        OrganizationService.prototype._httpOptions;
        /**
         * @type {?}
         * @private
         */
        OrganizationService.prototype._http;
        /**
         * @type {?}
         * @private
         */
        OrganizationService.prototype._messageService;
    }
    var OrganizationServiceNoAuth = /** @class */ (function () {
        function OrganizationServiceNoAuth(env, handler) {
            this.env = env;
            this.handler = handler;
            this.path = 'organizations';
            this.http = new http.HttpClient(handler);
        }
        /**
         * @param {?} uuid
         * @return {?}
         */
        OrganizationServiceNoAuth.prototype.getOrganizationByUUID = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            // const req = this.env.sceibaApi + this.prefix + "/" + uuid;
            /** @type {?} */
            var req = this.env.sceibaApi + "/pid/organization/" + uuid;
            return this.http.get(req);
        };
        /**
         * @param {?} uuid
         * @param {?=} relType
         * @return {?}
         */
        OrganizationServiceNoAuth.prototype.getOrganizationRelationships = /**
         * @param {?} uuid
         * @param {?=} relType
         * @return {?}
         */
        function (uuid, relType) {
            if (relType === void 0) { relType = null; }
            /** @type {?} */
            var req = this.env.sceibaApi + this.path + '/' + uuid + '/relationships';
            if (relType != null) {
                /** @type {?} */
                var params = new http.HttpParams();
                params = params.set('type', relType);
                /** @type {?} */
                var options = {
                    params: params,
                };
                return this.http.get(req, options);
            }
            else {
                return this.http.get(req);
            }
        };
        /**
         * @param {?} pid
         * @return {?}
         */
        OrganizationServiceNoAuth.prototype.getOrganizationByPID = /**
         * @param {?} pid
         * @return {?}
         */
        function (pid) {
            // const req = this.env.sceibaApi + this.prefix + "/" + uuid;
            /** @type {?} */
            var params = new http.HttpParams();
            params = params.set('value', pid);
            /** @type {?} */
            var options = {
                params: params,
            };
            /** @type {?} */
            var req = this.env.sceibaApi + this.path + '/pid';
            return this.http.get(req, options);
        };
        /**
         * @param {?} params
         * @return {?}
         */
        OrganizationServiceNoAuth.prototype.getOrganizations = /**
         * @param {?} params
         * @return {?}
         */
        function (params) {
            /** @type {?} */
            var options = {
                params: params,
            };
            console.log(params);
            /** @type {?} */
            var req = this.env.sceibaApi + 'search/' + this.path;
            console.log(req);
            return this.http.get(req, options);
        };
        OrganizationServiceNoAuth.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        OrganizationServiceNoAuth.ctorParameters = function () { return [
            { type: Environment },
            { type: http.HttpBackend }
        ]; };
        return OrganizationServiceNoAuth;
    }());
    if (false) {
        /** @type {?} */
        OrganizationServiceNoAuth.prototype.http;
        /** @type {?} */
        OrganizationServiceNoAuth.prototype.path;
        /**
         * @type {?}
         * @private
         */
        OrganizationServiceNoAuth.prototype.env;
        /**
         * @type {?}
         * @private
         */
        OrganizationServiceNoAuth.prototype.handler;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/backend/search.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SearchService = /** @class */ (function () {
        function SearchService(env, handler) {
            // TODO: hay una mejor manera de hacer esto, creando diferentes y propios HttpClients que
            // tengan un comportamiento especifico (eg: sin/con autenticacion)
            // ver: https://github.com/angular/angular/issues/20203#issuecomment-369754776
            // otra solucion seria pasar parametros especiales como {ignore_auth = true} y que el
            // interceptor actue en consecuencia... .
            // https://github.com/angular/angular/issues/18155#issuecomment-382438006
            this.env = env;
            this.handler = handler;
            this.prefix = 'search';
            this.http = new http.HttpClient(handler);
        }
        /**
         * @param {?} field
         * @param {?=} size
         * @return {?}
         */
        SearchService.prototype.getAggregation = /**
         * @param {?} field
         * @param {?=} size
         * @return {?}
         */
        function (field, size) {
            if (size === void 0) { size = 10; }
            /** @type {?} */
            var params = new http.HttpParams();
            /** @type {?} */
            var options = {
                params: params.set('size', size.toString(10))
            };
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/aggs/' + field;
            return this.http.get(req, options);
        };
        /**
         * @param {?} params
         * @return {?}
         */
        SearchService.prototype.getRecords = /**
         * @param {?} params
         * @return {?}
         */
        function (params) {
            /** @type {?} */
            var options = {
                params: params,
            };
            console.log(params);
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/records/';
            return this.http.get(req, options);
        };
        /**
         * @param {?} params
         * @return {?}
         */
        SearchService.prototype.getSources = /**
         * @param {?} params
         * @return {?}
         */
        function (params) {
            /** @type {?} */
            var options = {
                params: params,
            };
            console.log(params);
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/sources';
            return this.http.get(req, options);
        };
        /**
         * @param {?} params
         * @return {?}
         */
        SearchService.prototype.getOrganizations = /**
         * @param {?} params
         * @return {?}
         */
        function (params) {
            /** @type {?} */
            var options = {
                params: params,
            };
            // console.log(params);
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/organizations/';
            // console.log(req);
            return this.http.get(req, options);
        };
        /**
         * @param {?} id
         * @return {?}
         */
        SearchService.prototype.getOrganizationById = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            /** @type {?} */
            var req = this.env.cuorApi + 'organizations/' + id + '/';
            // console.log(req);
            return this.http.get(req);
        };
        /**
         * @param {?} data
         * @return {?}
         */
        SearchService.prototype.updateOrganizations = /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            //TODO: Do this method...
            return rxjs.of(null);
        };
        /**
         * @param {?} uuid
         * @return {?}
         */
        SearchService.prototype.getSourcesOrgAggregation = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            /** @type {?} */
            var req = this.env.sceibaApi + 'source/aggs/org/' + uuid;
            return this.http.get(req);
        };
        SearchService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SearchService.ctorParameters = function () { return [
            { type: Environment },
            { type: http.HttpBackend }
        ]; };
        return SearchService;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        SearchService.prototype.prefix;
        /** @type {?} */
        SearchService.prototype.http;
        /**
         * @type {?}
         * @private
         */
        SearchService.prototype.env;
        /**
         * @type {?}
         * @private
         */
        SearchService.prototype.handler;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/backend/source.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SourceService = /** @class */ (function () {
        function SourceService(env, http$1, handler, oauthStorage) {
            this.env = env;
            this.http = http$1;
            this.handler = handler;
            this.oauthStorage = oauthStorage;
            this.prefix = "source";
            this.httpOptions = {
                headers: new http.HttpHeaders({
                    "Content-Type": "application/json",
                    Authorization: "Bearer ",
                }),
            };
            this.token = "";
            this.token = this.oauthStorage.getItem("access_token");
            // TODO: hay una mejor manera de hacer esto, creando diferentes y propios HttpClients que
            // tengan un comportamiento especifico (eg: sin/con autenticacion)
            // ver: https://github.com/angular/angular/issues/20203#issuecomment-369754776
            // otra solucion seria pasar parametros especiales como {ignore_auth = true} y que el
            // interceptor actue en consecuencia... .
            // https://github.com/angular/angular/issues/18155#issuecomment-382438006
            this.httpSearch = new http.HttpClient(handler);
        }
        /**
         * @param {?=} size
         * @param {?=} page
         * @param {?=} role
         * @return {?}
         */
        SourceService.prototype.getMySources = /**
         * @param {?=} size
         * @param {?=} page
         * @param {?=} role
         * @return {?}
         */
        function (size, page, role) {
            if (size === void 0) { size = 10; }
            if (page === void 0) { page = 1; }
            if (role === void 0) { role = 'manager'; }
            /** @type {?} */
            var params = new http.HttpParams();
            params = params.set("size", size.toString(10));
            params = params.set("page", page.toString(10));
            /** @type {?} */
            var options = {
                params: params,
            };
            // this.httpOptions.headers = this.httpOptions.headers.set('Authorization', 'Bearer ' + this.token);
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + "/me/" + role + "/ALL";
            return this.http.get(req, options);
        };
        /**
         * @return {?}
         */
        SourceService.prototype.getMySourcesAllRoles = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + "/me/ALL";
            return this.http.get(req);
        };
        /**
         * @private
         * @param {?} source
         * @return {?}
         */
        SourceService.prototype.adhocstringgify = /**
         * @private
         * @param {?} source
         * @return {?}
         */
        function (source) {
            /** @type {?} */
            var orgs = JSON.stringify(source.data.organizations);
            console.log("-------------------", orgs);
            /** @type {?} */
            var all = source.entitystringify();
            console.log("-------------------", all);
            /** @type {?} */
            var from = all.search('"organizations"') + 16;
            /** @type {?} */
            var p1 = all.substr(0, from);
            console.log(p1);
            /** @type {?} */
            var p2 = all.substr(from);
            console.log(p2);
            /** @type {?} */
            var len = this.count_to_len(p2);
            console.log(len);
            /** @type {?} */
            var p3 = all.substr(from + len);
            console.log(p3);
            return p1 + orgs + p3;
        };
        /**
         * @private
         * @param {?} p2
         * @return {?}
         */
        SourceService.prototype.count_to_len = /**
         * @private
         * @param {?} p2
         * @return {?}
         */
        function (p2) {
            if (p2[0] == "[") {
                /** @type {?} */
                var len = 1;
                /** @type {?} */
                var count = 1;
                for (var index = 1; index < p2.length; index++) {
                    /** @type {?} */
                    var element = p2[index];
                    len++;
                    if (p2[index] === "[")
                        count++;
                    if (p2[index] === "]")
                        count--;
                    if (count === 0)
                        return len;
                }
            }
        };
        /**
         * @param {?} source
         * @param {?} uuid
         * @return {?}
         */
        SourceService.prototype.editSource = /**
         * @param {?} source
         * @param {?} uuid
         * @return {?}
         */
        function (source, uuid) {
            // this.adhocstringgify(source)
            // console.log(source)
            // let valu = source.entitystringify();
            // console.log("s: ", valu)
            // this.adhocstringgify(source)
            // console.log(source)
            // let valu = source.entitystringify();
            // console.log("s: ", valu)
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + "/" + uuid + "/edit";
            return this.http.post(req, this.adhocstringgify(source), this.httpOptions);
        };
        /**
         * @param {?} source
         * @param {?} uuid
         * @return {?}
         */
        SourceService.prototype.makeSourceAsApproved = /**
         * @param {?} source
         * @param {?} uuid
         * @return {?}
         */
        function (source, uuid) {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + "/" + uuid + "/publish";
            return this.http.post(req, this.adhocstringgify(source), this.httpOptions);
        };
        /**
         * @param {?} source
         * @param {?} uuid
         * @return {?}
         */
        SourceService.prototype.makeSourceAsUnApproved = /**
         * @param {?} source
         * @param {?} uuid
         * @return {?}
         */
        function (source, uuid) {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + "/" + uuid + "/unpublish";
            return this.http.post(req, this.adhocstringgify(source), this.httpOptions);
        };
        /**
         * @param {?} source
         * @param {?} uuid
         * @param {?} role
         * @return {?}
         */
        SourceService.prototype.newSource = /**
         * @param {?} source
         * @param {?} uuid
         * @param {?} role
         * @return {?}
         */
        function (source, uuid, role) {
            /** @type {?} */
            var params = new http.HttpParams();
            params = params.set("pid", uuid.toString());
            params = params.set("role", role.toString());
            /** @type {?} */
            var options = {
                params: params,
            };
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + "/new";
            return this.http.post(req, this.adhocstringgify(source), options);
        };
        /**
         * @param {?} issn
         * @return {?}
         */
        SourceService.prototype.getIssnInfo = /**
         * @param {?} issn
         * @return {?}
         */
        function (issn) {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + "/journal/issn/" + issn;
            return this.http.get(req);
        };
        /**
         * @param {?} uuid
         * @return {?}
         */
        SourceService.prototype.getSourcesByTermUUID = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + "/relations/" + uuid;
            return this.http.get(req);
        };
        /**
         * @param {?} uuid
         * @return {?}
         */
        SourceService.prototype.getSourceVersions = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            this.httpOptions.headers = this.httpOptions.headers.set("Authorization", "Bearer " + this.token);
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + "/" + uuid + "/versions";
            return this.http.get(req, this.httpOptions);
        };
        /**
         * @param {?} uuid
         * @param {?=} level
         * @return {?}
         */
        SourceService.prototype.countSourcesByTerm = /**
         * @param {?} uuid
         * @param {?=} level
         * @return {?}
         */
        function (uuid, level) {
            if (level === void 0) { level = 0; }
            /** @type {?} */
            var params = new http.HttpParams();
            /** @type {?} */
            var options = {
                params: params.set("level", level.toString(10)),
            };
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + "/relations/" + uuid + "/count";
            return this.http.get(req, options);
        };
        /**
         * @param {?} uuid
         * @return {?}
         */
        SourceService.prototype.getSourceByUUID = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            // const req = this.env.sceibaApi + this.prefix + "/" + uuid;
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/' + uuid;
            return this.http.get(req);
        };
        /**
         * @param {?} uuid
         * @return {?}
         */
        SourceService.prototype.permissionGetSourceEditors = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/permission/editor/' + uuid + '/users';
            return this.http.get(req);
        };
        /**
         * @param {?} uuid
         * @param {?} user
         * @param {?=} allow
         * @return {?}
         */
        SourceService.prototype.permissionSetSourceEditor = /**
         * @param {?} uuid
         * @param {?} user
         * @param {?=} allow
         * @return {?}
         */
        function (uuid, user, allow) {
            if (allow === void 0) { allow = false; }
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/permission/' + user + '/editor/' + uuid + ((allow) ? '/allow' : '/deny');
            return this.http.post(req, null, this.httpOptions);
        };
        /**
         * @param {?} uuid
         * @return {?}
         */
        SourceService.prototype.permissionGetSourceManagers = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/permission/manager/' + uuid + '/users';
            return this.http.get(req);
        };
        /**
         * @param {?} uuid
         * @param {?} user
         * @param {?=} allow
         * @return {?}
         */
        SourceService.prototype.permissionSetSourceManager = /**
         * @param {?} uuid
         * @param {?} user
         * @param {?=} allow
         * @return {?}
         */
        function (uuid, user, allow) {
            if (allow === void 0) { allow = false; }
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/permission/' + user + '/manager/' + uuid + ((allow) ? '/allow' : '/deny');
            return this.http.post(req, null, this.httpOptions);
        };
        /**
         * @param {?} uuid
         * @return {?}
         */
        SourceService.prototype.permissionGetOrganizationManagers = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/permission/organization/' + uuid + '/users';
            return this.http.get(req);
        };
        /**
         * @param {?} uuid
         * @param {?} user
         * @param {?=} allow
         * @return {?}
         */
        SourceService.prototype.permissionSetOrganizationManager = /**
         * @param {?} uuid
         * @param {?} user
         * @param {?=} allow
         * @return {?}
         */
        function (uuid, user, allow) {
            if (allow === void 0) { allow = false; }
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/permission/' + user + '/organization/' + uuid + ((allow) ? '/allow' : '/deny');
            return this.http.post(req, null, this.httpOptions);
        };
        /**
         * @param {?} uuid
         * @return {?}
         */
        SourceService.prototype.permissionGetTermManagers = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/permission/term/' + uuid + '/users';
            return this.http.get(req);
        };
        /**
         * @param {?} uuid
         * @param {?} user
         * @param {?=} allow
         * @return {?}
         */
        SourceService.prototype.permissionSetTermManager = /**
         * @param {?} uuid
         * @param {?} user
         * @param {?=} allow
         * @return {?}
         */
        function (uuid, user, allow) {
            if (allow === void 0) { allow = false; }
            /** @type {?} */
            var req = this.env.sceibaApi + this.prefix + '/permission/' + user + '/term/' + uuid + ((allow) ? '/allow' : '/deny');
            return this.http.post(req, null, this.httpOptions);
        };
        SourceService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SourceService.ctorParameters = function () { return [
            { type: Environment },
            { type: http.HttpClient },
            { type: http.HttpBackend },
            { type: angularOauth2Oidc.OAuthStorage }
        ]; };
        return SourceService;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        SourceService.prototype.prefix;
        /**
         * @type {?}
         * @private
         */
        SourceService.prototype.httpOptions;
        /**
         * @type {?}
         * @private
         */
        SourceService.prototype.token;
        /** @type {?} */
        SourceService.prototype.httpSearch;
        /**
         * @type {?}
         * @private
         */
        SourceService.prototype.env;
        /**
         * @type {?}
         * @private
         */
        SourceService.prototype.http;
        /**
         * @type {?}
         * @private
         */
        SourceService.prototype.handler;
        /**
         * @type {?}
         * @private
         */
        SourceService.prototype.oauthStorage;
    }
    var SourceServiceNoAuth = /** @class */ (function () {
        function SourceServiceNoAuth(env, handler) {
            // TODO: hay una mejor manera de hacer esto, creando diferentes y propios HttpClients que
            // tengan un comportamiento especifico (eg: sin/con autenticacion)
            // ver: https://github.com/angular/angular/issues/20203#issuecomment-369754776
            // otra solucion seria pasar parametros especiales como {ignore_auth = true} y que el
            // interceptor actue en consecuencia... .
            // https://github.com/angular/angular/issues/18155#issuecomment-382438006
            this.env = env;
            this.handler = handler;
            this.http = new http.HttpClient(handler);
        }
        /**
         * @param {?} uuid
         * @return {?}
         */
        SourceServiceNoAuth.prototype.getSourceByUUID = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            // const req = this.env.sceibaApi + this.prefix + "/" + uuid;
            /** @type {?} */
            var req = this.env.sceibaApi + "/pid/source/" + uuid;
            return this.http.get(req);
        };
        /**
         * @param {?} issn
         * @return {?}
         */
        SourceServiceNoAuth.prototype.getSourceByISSN = /**
         * @param {?} issn
         * @return {?}
         */
        function (issn) {
            // const req = this.env.sceibaApi + this.prefix + "/" + uuid;
            /** @type {?} */
            var req = this.env.sceibaApi + "source/byissn/" + issn;
            return this.http.get(req);
        };
        /**
         * @param {?} pid
         * @return {?}
         */
        SourceServiceNoAuth.prototype.getSourceByPID = /**
         * @param {?} pid
         * @return {?}
         */
        function (pid) {
            // const req = this.env.sceibaApi + this.prefix + "/" + uuid;
            /** @type {?} */
            var params = new http.HttpParams();
            params = params.set('value', pid);
            /** @type {?} */
            var options = {
                params: params,
            };
            /** @type {?} */
            var req = this.env.sceibaApi + 'source/pid';
            return this.http.get(req, options);
        };
        /**
         * @param {?} params
         * @return {?}
         */
        SourceServiceNoAuth.prototype.getSources = /**
         * @param {?} params
         * @return {?}
         */
        function (params) {
            /** @type {?} */
            var options = {
                params: params,
            };
            console.log(params);
            /** @type {?} */
            var req = this.env.sceibaApi + 'search/sources';
            return this.http.get(req, options);
        };
        /**
         * @param {?} topOrgId
         * @return {?}
         */
        SourceServiceNoAuth.prototype.getSourcesStats = /**
         * @param {?} topOrgId
         * @return {?}
         */
        function (topOrgId) {
            /** @type {?} */
            var params = new http.HttpParams();
            params = params.set('org', topOrgId);
            /** @type {?} */
            var options = {
                params: params,
            };
            /** @type {?} */
            var req = this.env.sceibaApi + 'source/stats';
            return this.http.get(req, options);
        };
        SourceServiceNoAuth.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        SourceServiceNoAuth.ctorParameters = function () { return [
            { type: Environment },
            { type: http.HttpBackend }
        ]; };
        return SourceServiceNoAuth;
    }());
    if (false) {
        /** @type {?} */
        SourceServiceNoAuth.prototype.http;
        /**
         * @type {?}
         * @private
         */
        SourceServiceNoAuth.prototype.env;
        /**
         * @type {?}
         * @private
         */
        SourceServiceNoAuth.prototype.handler;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/backend/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/filter-item.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /*
     *   Copyright (c) 2020 Universidad de Pinar del Río "Hermanos Saíz Montes de Oca"
     *   All rights reserved.
     */
    var FilterItem = /** @class */ (function () {
        function FilterItem(component, data) {
            this.component = component;
            this.data = data;
        }
        return FilterItem;
    }());
    if (false) {
        /** @type {?} */
        FilterItem.prototype.component;
        /** @type {?} */
        FilterItem.prototype.data;
    }
    var FilterHttpMap = /** @class */ (function () {
        function FilterHttpMap(field, value) {
            this.field = field;
            this.value = value;
        }
        return FilterHttpMap;
    }());
    if (false) {
        /** @type {?} */
        FilterHttpMap.prototype.field;
        /** @type {?} */
        FilterHttpMap.prototype.value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/filters.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FiltersService = /** @class */ (function () {
        function FiltersService() {
            this.params = new Array();
            // httpParams: HttpParams = new HttpParams();
            this.autocompleteFilter = new Array();
            this.paramsChanged = new core.EventEmitter();
        }
        /**
         *
         * @param field el nombre del campo que se esta filtrando (title, etc...)
         * @param value el valor del filtro
         * @param emitEvent si se emite o no el evento de cambio de parametros, para los que estan suscritos.
         */
        /**
         *
         * @param {?=} field el nombre del campo que se esta filtrando (title, etc...)
         * @param {?=} value el valor del filtro
         * @param {?=} emitEvent si se emite o no el evento de cambio de parametros, para los que estan suscritos.
         * @return {?}
         */
        FiltersService.prototype.changeFilter = /**
         *
         * @param {?=} field el nombre del campo que se esta filtrando (title, etc...)
         * @param {?=} value el valor del filtro
         * @param {?=} emitEvent si se emite o no el evento de cambio de parametros, para los que estan suscritos.
         * @return {?}
         */
        function (field, value, emitEvent) {
            if (emitEvent === void 0) { emitEvent = true; }
            if (this.params.find((/**
             * @param {?} x
             * @return {?}
             */
            function (x) { return x.field == field; }))) {
                this.params.find((/**
                 * @param {?} x
                 * @return {?}
                 */
                function (x) { return x.field == field; })).value = value;
            }
            else if (field && value) {
                this.params.push(new FilterHttpMap(field, value));
            }
            /*
            crear el httpParams... a partir del params...
            */
            // this.httpParams.set(field, value);
            if (emitEvent)
                this.paramsChanged.emit(this.params);
        };
        /**
         * @param {?} field
         * @return {?}
         */
        FiltersService.prototype.deleteParameter = /**
         * @param {?} field
         * @return {?}
         */
        function (field) {
            /** @type {?} */
            var paramToDelete = this.params.find((/**
             * @param {?} x
             * @return {?}
             */
            function (x) { return x.field == field; }));
            if (paramToDelete) {
                this.params.splice(this.params.indexOf(this.params.find((/**
                 * @param {?} x
                 * @return {?}
                 */
                function (x) { return x.field == field; }))), 1);
                this.paramsChanged.emit(this.params);
            }
        };
        /**
         * Especifico para el filtro de terminos.
         * @param termValue identificador del termino por el cual se esta filtrando
         * @param isdelete especifica si se va a eliminar o adicionar el @param termValue
         */
        /**
         * Especifico para el filtro de terminos.
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        FiltersService.prototype.changeAutocompleteFilter = /**
         * Especifico para el filtro de terminos.
         * @param {?} name
         * @param {?} value
         * @return {?}
         */
        function (name, value) {
            /** @type {?} */
            var isexist = false;
            this.autocompleteFilter.forEach((/**
             * @param {?} filter
             * @return {?}
             */
            function (filter) {
                if (filter.name == name) {
                    filter.value = value;
                    isexist = true;
                }
            }));
            if (!isexist) {
                this.autocompleteFilter.push(new AutocompleteFilter(name, value));
            }
            this.createAutocompleteFilterValue();
        };
        /**
         * @param {?} name
         * @return {?}
         */
        FiltersService.prototype.deleteAutocompleteFilter = /**
         * @param {?} name
         * @return {?}
         */
        function (name) {
            this.autocompleteFilter.splice(this.autocompleteFilter.indexOf(this.autocompleteFilter.find((/**
             * @param {?} x
             * @return {?}
             */
            function (x) { return x.name == name; }))), 1);
            this.createAutocompleteFilterValue();
        };
        /**
         * @return {?}
         */
        FiltersService.prototype.createAutocompleteFilterValue = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var emitValue = this.autocompleteFilter[0].value;
            for (var index = 1; index < this.autocompleteFilter.length; index++) {
                emitValue = emitValue + ',' + this.autocompleteFilter[index].value;
            }
            this.changeFilter('terms', emitValue, true);
        };
        FiltersService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        FiltersService.ctorParameters = function () { return []; };
        FiltersService.propDecorators = {
            paramsChanged: [{ type: core.Output }]
        };
        return FiltersService;
    }());
    if (false) {
        /** @type {?} */
        FiltersService.prototype.params;
        /** @type {?} */
        FiltersService.prototype.autocompleteFilter;
        /** @type {?} */
        FiltersService.prototype.paramsChanged;
    }
    var AutocompleteFilter = /** @class */ (function () {
        function AutocompleteFilter(name, value) {
            this.name = name;
            this.value = value;
        }
        return AutocompleteFilter;
    }());
    if (false) {
        /** @type {?} */
        AutocompleteFilter.prototype.name;
        /** @type {?} */
        AutocompleteFilter.prototype.value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/filter-container.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FilterContainerService = /** @class */ (function () {
        function FilterContainerService() {
            this.emitter = new core.EventEmitter();
        }
        /**
         * @param {?} filterIndex
         * @return {?}
         */
        FilterContainerService.prototype.filterDeleted = /**
         * @param {?} filterIndex
         * @return {?}
         */
        function (filterIndex) {
            this.emitter.emit(filterIndex);
        };
        FilterContainerService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        FilterContainerService.ctorParameters = function () { return []; };
        FilterContainerService.propDecorators = {
            emitter: [{ type: core.Output }]
        };
        return FilterContainerService;
    }());
    if (false) {
        /** @type {?} */
        FilterContainerService.prototype.emitter;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/boolean-filter/boolean-filter.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var BooleanFilterComponent = /** @class */ (function () {
        function BooleanFilterComponent(filterService, filterContainerService) {
            this.filterService = filterService;
            this.filterContainerService = filterContainerService;
            this.operator = true;
            this.direction = 'column';
        }
        /**
         * @return {?}
         */
        BooleanFilterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.operator = this.data.value;
            this.operator_name = this.data.name[0];
            if (this.data.direction) {
                this.direction = 'row';
                this.classDireccion = '-horizontal';
            }
        };
        /**
         * @return {?}
         */
        BooleanFilterComponent.prototype.remove_component = /**
         * @return {?}
         */
        function () {
            this.filterService.deleteParameter(this.data.field);
            this.filterContainerService.filterDeleted(this.data.index);
        };
        /**
         * @return {?}
         */
        BooleanFilterComponent.prototype.change_operator_name = /**
         * @return {?}
         */
        function () {
            this.operator ? this.operator_name = this.data.name[1] : this.operator_name = this.data.name[0];
            /** @type {?} */
            var value = this.operator ? 'OR' : 'AND';
            this.filterService.changeFilter(this.data.field, value);
        };
        /**
         * @return {?}
         */
        BooleanFilterComponent.prototype.changeInterruptor = /**
         * @return {?}
         */
        function () {
            this.operator = !this.operator;
            this.change_operator_name();
        };
        BooleanFilterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-boolean-filter',
                        template: "<!-- <mat-slide-toggle [checked]=\"operator\" [(ngModel)]=\"operator\" (click)=\"change_operator_name()\">{{operator_name}}</mat-slide-toggle>\n\n<div class=\"interruptor-background\">\n    <div class=\"interruptor-selector-down\"></div>\n</div>\n<br> -->\n<div fxLayout=\"{{direction}}\" fxLayoutAlign=\"center center\" fxLayoutGap=\"5px\">\n    <label>{{data.name[0]}}</label>\n    <div class=\"mat-interruptor-background{{classDireccion}}\">\n        <div *ngIf=\"!operator;then content else other_content\"></div>\n        <ng-template #content>\n            <div class=\"mat-interruptor-selector-up{{classDireccion}}\" (click)=\"changeInterruptor()\"></div>\n        </ng-template>\n        <ng-template #other_content>\n            <div class=\"mat-interruptor-selector-down{{classDireccion}}\" (click)=\"changeInterruptor()\"></div>\n        </ng-template>\n    </div>\n    <label>{{data.name[1]}}</label>\n</div>",
                        styles: [".interruptor-background{width:1.01em;height:2.3em;border:.1em solid #000;border-radius:1em;position:relative;display:flex;flex-direction:row;justify-content:center;background:0 0;box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}.interruptor-selector-down,.interruptor-selector-up{width:.9em;height:.9em;border-radius:50%;position:absolute;left:.07em;box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}.interruptor-selector-up{top:.05em}.interruptor-selector-down{bottom:.05em}.mat-interruptor-background,.mat-interruptor-background-horizontal{width:.875em;height:2.3em;background-color:rgba(100,97,96,.5);border-radius:1em;position:relative;display:flex;flex-direction:row;justify-content:center;border:transparent}.mat-interruptor-background-horizontal{height:.875em;width:2.3em}.mat-interruptor-selector-down,.mat-interruptor-selector-down-horizontal,.mat-interruptor-selector-up,.mat-interruptor-selector-up-horizontal{width:1.3em;height:1.3em;border-radius:50%;position:absolute;box-shadow:0 2px 1px -1px rgba(0,0,0,.2),0 1px 1px 0 rgba(0,0,0,.14),0 1px 3px 0 rgba(0,0,0,.12)}.mat-interruptor-selector-up{top:-.1em}.mat-interruptor-selector-down{bottom:-.1em}.mat-interruptor-selector-up-horizontal{left:-.1em;top:-.22em}.mat-interruptor-selector-down-horizontal{right:-.1em;top:-.22em}.mat-interruptor-selector-down-horizontal:hover,.mat-interruptor-selector-down:hover,.mat-interruptor-selector-up-horizontal:hover,.mat-interruptor-selector-up:hover{cursor:pointer}.mat-interruptor-selector-down-horizontal:active,.mat-interruptor-selector-down:active,.mat-interruptor-selector-up-horizontal:active,.mat-interruptor-selector-up:active{cursor:-webkit-grabbing;cursor:grabbing;transition-duration:1s;box-shadow:0 0 2px 8px rgba(248,55,33,.26)}.mat-interruptor-selector-up:active{transform:translate3d(0,16px,0)}.interruptor-selector-down:active{transform:translate3d(0,0,16px)}.mat-interruptor-selector-up-horizontal:active{transform:translate3d(16px,0,0)}.mat-interruptor-selector-down-horizontal:active{transform:translate3d(0,0,0)}"]
                    }] }
        ];
        /** @nocollapse */
        BooleanFilterComponent.ctorParameters = function () { return [
            { type: FiltersService },
            { type: FilterContainerService }
        ]; };
        BooleanFilterComponent.propDecorators = {
            data: [{ type: core.Input }]
        };
        return BooleanFilterComponent;
    }());
    if (false) {
        /** @type {?} */
        BooleanFilterComponent.prototype.data;
        /** @type {?} */
        BooleanFilterComponent.prototype.operator;
        /** @type {?} */
        BooleanFilterComponent.prototype.operator_name;
        /** @type {?} */
        BooleanFilterComponent.prototype.direction;
        /** @type {?} */
        BooleanFilterComponent.prototype.classDireccion;
        /**
         * @type {?}
         * @private
         */
        BooleanFilterComponent.prototype.filterService;
        /**
         * @type {?}
         * @private
         */
        BooleanFilterComponent.prototype.filterContainerService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/filter.directive.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FilterDirective = /** @class */ (function () {
        function FilterDirective(viewContainerRef) {
            this.viewContainerRef = viewContainerRef;
        }
        FilterDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[toco-Filter]'
                    },] }
        ];
        /** @nocollapse */
        FilterDirective.ctorParameters = function () { return [
            { type: core.ViewContainerRef }
        ]; };
        return FilterDirective;
    }());
    if (false) {
        /** @type {?} */
        FilterDirective.prototype.viewContainerRef;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/title-filter/title-filter.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TitleFilterComponent = /** @class */ (function () {
        function TitleFilterComponent(filterService, filterContainerService) {
            this.filterService = filterService;
            this.filterContainerService = filterContainerService;
        }
        /**
         * @return {?}
         */
        TitleFilterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.type = this.data.type;
            this.placeholder = this.data.placeholder;
            this.data.value = '';
        };
        /**
         * @return {?}
         */
        TitleFilterComponent.prototype.remove_component = /**
         * @return {?}
         */
        function () {
            this.filterService.deleteParameter(this.data.field);
            this.filterContainerService.filterDeleted(this.data.index);
        };
        /**
         * @return {?}
         */
        TitleFilterComponent.prototype.onChange = /**
         * @return {?}
         */
        function () {
            this.filterService.changeFilter(this.data.field, this.data.value);
        };
        TitleFilterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-title-filter',
                        template: "<mat-form-field class=\"card-filter\">\n  <input matInput type=\"{{type}}\" placeholder=\"{{placeholder}}\" [(ngModel)]=\"data.value\" required (keyup)=\"onChange()\">\n  <button mat-icon-button color=\"accent\" class=\"delete-filter\" (click)=\"remove_component()\">\n    <mat-icon>close</mat-icon>\n  </button>\n</mat-form-field>\n",
                        styles: [".card-filter{border:2px solid #e4e4e4;border-radius:5px;padding:5px .5em 0;position:relative;box-shadow:2px 3px 10px RGB(0,0,0,.053);width:15em;margin:.4em 0}.delete-filter{position:absolute;top:-1.9em;right:-1.4em;width:2em;height:2em}.delete-filter mat-icon{font-size:medium}"]
                    }] }
        ];
        /** @nocollapse */
        TitleFilterComponent.ctorParameters = function () { return [
            { type: FiltersService },
            { type: FilterContainerService }
        ]; };
        TitleFilterComponent.propDecorators = {
            data: [{ type: core.Input }]
        };
        return TitleFilterComponent;
    }());
    if (false) {
        /** @type {?} */
        TitleFilterComponent.prototype.data;
        /** @type {?} */
        TitleFilterComponent.prototype.type;
        /** @type {?} */
        TitleFilterComponent.prototype.placeholder;
        /** @type {?} */
        TitleFilterComponent.prototype.text;
        /**
         * @type {?}
         * @private
         */
        TitleFilterComponent.prototype.filterService;
        /**
         * @type {?}
         * @private
         */
        TitleFilterComponent.prototype.filterContainerService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/select-filter/select-filter.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SelectFilterOldComponent = /** @class */ (function () {
        function SelectFilterOldComponent(filterService, filterContainerService) {
            this.filterService = filterService;
            this.filterContainerService = filterContainerService;
            this.type = '';
            this.placeholder = '';
            this.text = '';
            this.multiple = false;
            this.selectOptions = [''];
        }
        /**
         * @return {?}
         */
        SelectFilterOldComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.data.type)
                this.type = this.data.type;
            if (this.data.placeholder)
                this.placeholder = this.data.placeholder;
            if (this.multiple)
                this.multiple = true;
            if (this.data.selectOptions)
                this.selectOptions = this.data.selectOptions;
            this.data.value = '';
        };
        /**
         * @return {?}
         */
        SelectFilterOldComponent.prototype.remove_component = /**
         * @return {?}
         */
        function () {
            this.filterService.deleteParameter(this.data.field);
            this.filterContainerService.filterDeleted(this.data.index);
        };
        /**
         * @return {?}
         */
        SelectFilterOldComponent.prototype.optionSelect = /**
         * @return {?}
         */
        function () {
            if (this.multiple) {
                //adaptar el value
            }
            this.filterService.changeFilter(this.data.field, this.data.value);
        };
        SelectFilterOldComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-select-filter-old',
                        template: "<mat-form-field class=\"card-filter\">\n\n  <ng-container *ngIf=\"multiple; else elseTemplate\">\n    <mat-select placeholder=\"{{placeholder}}\" [(ngModel)]=\"selectValue\" multiple>\n        <mat-option *ngFor=\"let topping of selectOptions\" [value]=\"topping\" (click)=\"optionSelect()\">{{topping}}</mat-option>\n      </mat-select>\n  </ng-container>\n  <ng-template #elseTemplate>\n    <mat-select placeholder=\"{{placeholder}}\" [(ngModel)]=\"selectValue\">\n        <mat-option *ngFor=\"let topping of selectOptions\" [value]=\"topping\" (click)=\"optionSelect()\">{{topping}}</mat-option>\n      </mat-select>\n  </ng-template>\n\n  <button mat-icon-button color=\"accent\" class=\"delete-filter\" (click)=\"remove_component()\">\n    <mat-icon>close</mat-icon>\n  </button>\n</mat-form-field>",
                        styles: [".card-filter{border:2px solid #e4e4e4;border-radius:5px;padding:5px .5em 0;position:relative;box-shadow:2px 3px 10px RGB(0,0,0,.053);width:15em;margin:.4em 0}.delete-filter{position:absolute;top:-1.9em;right:-1.4em;width:2em;height:2em}.delete-filter mat-icon{font-size:medium}"]
                    }] }
        ];
        /** @nocollapse */
        SelectFilterOldComponent.ctorParameters = function () { return [
            { type: FiltersService },
            { type: FilterContainerService }
        ]; };
        SelectFilterOldComponent.propDecorators = {
            data: [{ type: core.Input }]
        };
        return SelectFilterOldComponent;
    }());
    if (false) {
        /** @type {?} */
        SelectFilterOldComponent.prototype.data;
        /** @type {?} */
        SelectFilterOldComponent.prototype.type;
        /** @type {?} */
        SelectFilterOldComponent.prototype.placeholder;
        /** @type {?} */
        SelectFilterOldComponent.prototype.text;
        /** @type {?} */
        SelectFilterOldComponent.prototype.multiple;
        /** @type {?} */
        SelectFilterOldComponent.prototype.selectValue;
        /** @type {?} */
        SelectFilterOldComponent.prototype.selectOptions;
        /**
         * @type {?}
         * @private
         */
        SelectFilterOldComponent.prototype.filterService;
        /**
         * @type {?}
         * @private
         */
        SelectFilterOldComponent.prototype.filterContainerService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/select-autocomplete-filter/select-autocomplete-filter.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SelectAutocompleteFilterComponent = /** @class */ (function () {
        function SelectAutocompleteFilterComponent(filterService, filterContainerService) {
            this.filterService = filterService;
            this.filterContainerService = filterContainerService;
            this.type = '';
            this.placeholder = '';
            this.text = '';
            this.multiple = false;
            this.selectOptions = [];
            this.myControl = new forms.FormControl();
            this.chipsList = [];
        }
        /**
         * @return {?}
         */
        SelectAutocompleteFilterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.data.type)
                this.type = this.data.type;
            if (this.data.placeholder)
                this.placeholder = this.data.placeholder;
            if (this.multiple)
                this.multiple = true;
            if (this.data.selectOptions)
                this.selectOptions = this.data.selectOptions;
            this.data.value = '';
            this.filteredOptions = this.myControl.valueChanges.pipe(operators.startWith(''), operators.map((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return _this._filter(value); })));
            this.inputId = this.placeholder.trim().toLowerCase();
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        SelectAutocompleteFilterComponent.prototype._filter = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var filterValue = value.toLowerCase();
            return this.selectOptions.filter((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.name.toLowerCase().includes(filterValue); }));
        };
        /**
         * @return {?}
         */
        SelectAutocompleteFilterComponent.prototype.remove_component = /**
         * @return {?}
         */
        function () {
            this.filterService.deleteParameter(this.data.field);
            this.filterContainerService.filterDeleted(this.data.index);
            this.filterService.changeAutocompleteFilter(this.data.idVocab, 'OR');
        };
        /**
         * @return {?}
         */
        SelectAutocompleteFilterComponent.prototype.optionSelect = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var valueEmiter = 'OR';
            this.chipsList.forEach((/**
             * @param {?} chip
             * @return {?}
             */
            function (chip) {
                valueEmiter = valueEmiter + ',' + chip.id;
            }));
            this.filterService.changeAutocompleteFilter(this.data.idVocab, valueEmiter);
        };
        /**
         * @param {?} value
         * @return {?}
         */
        SelectAutocompleteFilterComponent.prototype.addChips = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this.chipsList.unshift(value);
            this.myControl.setValue('');
            this.filteredOptions = this.myControl.valueChanges.pipe(operators.startWith(''), operators.map((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return _this._filter(value); })));
            document.getElementById(this.inputId).blur();
            this.optionSelect();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        SelectAutocompleteFilterComponent.prototype.removeChip = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.chipsList.splice(index, 1);
            this.optionSelect();
        };
        SelectAutocompleteFilterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-select-autocomplete-filter',
                        template: "<div class=\"card-filter\" >\n  <mat-form-field style=\"width: 100%;\">\n    \n    <input type=\"text\" placeholder=\"{{placeholder}}\" aria-label=\"Number\" matInput [formControl]=\"myControl\" [matAutocomplete]=\"auto\" id=\"{{inputId}}\">\n    <mat-autocomplete #auto=\"matAutocomplete\" >\n      <mat-option *ngFor=\"let option of filteredOptions | async\" [value]=\"option.name\" (click)=\"addChips(option)\" title=\"{{option.name}}\">\n        {{option.name}}\n      </mat-option>\n    </mat-autocomplete>\n\n    <button mat-icon-button color=\"accent\" class=\"delete-filter\" (click)=\"remove_component()\">\n      <mat-icon>close</mat-icon>\n    </button>\n  </mat-form-field>\n  <mat-chip-list fxLayout=\"row\" fxLayoutAlign=\"start center\" style=\"margin-bottom: .5em\" id=\"chiplist\">\n    <mat-chip *ngFor=\"let item of chipsList; let i=index\" (click)=\"removeChip(i)\">{{item.name}}</mat-chip>\n  </mat-chip-list>\n</div>",
                        styles: [".card-filter{border:2px solid #e4e4e4;border-radius:5px;padding:5px .5em 0;position:relative;box-shadow:2px 3px 10px RGB(0,0,0,.053);width:15em;margin:.4em 0}.delete-filter{position:absolute;top:-1.9em;right:-1.4em;width:2em;height:2em}.delete-filter mat-icon{font-size:medium}.mat-option{line-height:35px;font-size:small;height:35px}#mat-chip-list-0>.mat-chip-list-wrapper{max-height:6em;overflow:auto}mat-chip{cursor:pointer}"]
                    }] }
        ];
        /** @nocollapse */
        SelectAutocompleteFilterComponent.ctorParameters = function () { return [
            { type: FiltersService },
            { type: FilterContainerService }
        ]; };
        SelectAutocompleteFilterComponent.propDecorators = {
            data: [{ type: core.Input }]
        };
        return SelectAutocompleteFilterComponent;
    }());
    if (false) {
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.data;
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.type;
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.placeholder;
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.text;
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.multiple;
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.selectValue;
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.selectOptions;
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.myControl;
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.filteredOptions;
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.chipsList;
        /** @type {?} */
        SelectAutocompleteFilterComponent.prototype.inputId;
        /**
         * @type {?}
         * @private
         */
        SelectAutocompleteFilterComponent.prototype.filterService;
        /**
         * @type {?}
         * @private
         */
        SelectAutocompleteFilterComponent.prototype.filterContainerService;
    }
    /**
     * @record
     */
    function ValueInformation() { }
    if (false) {
        /** @type {?} */
        ValueInformation.prototype.id;
        /** @type {?} */
        ValueInformation.prototype.name;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/tree-filter/tree-filter.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function FlatTreeNodeFilter() { }
    if (false) {
        /** @type {?} */
        FlatTreeNodeFilter.prototype.name;
        /** @type {?} */
        FlatTreeNodeFilter.prototype.level;
        /** @type {?} */
        FlatTreeNodeFilter.prototype.expandable;
        /** @type {?} */
        FlatTreeNodeFilter.prototype.term;
    }
    /**
     * @record
     */
    function TreeFilterData() { }
    if (false) {
        /** @type {?} */
        TreeFilterData.prototype.selectOptions;
        /** @type {?} */
        TreeFilterData.prototype.type;
        /** @type {?} */
        TreeFilterData.prototype.placeholder;
        /** @type {?} */
        TreeFilterData.prototype.text;
        /** @type {?} */
        TreeFilterData.prototype.field;
        /** @type {?} */
        TreeFilterData.prototype.index;
        /** @type {?} */
        TreeFilterData.prototype.value;
        /** @type {?} */
        TreeFilterData.prototype.idVocab;
    }
    var TreeFilterComponent = /** @class */ (function () {
        function TreeFilterComponent(filterService, filterContainerService) {
            this.filterService = filterService;
            this.filterContainerService = filterContainerService;
            this.checklistSelection = new collections.SelectionModel(true /* multiple */);
            this.myControl = new forms.FormControl();
            this.treeFlattener = new material.MatTreeFlattener(this.transformer, this.getLevel, this.isExpandable, this.getChildren);
            this.treeControl = new tree$1.FlatTreeControl(this.getLevel, this.isExpandable);
            this.dataSource = new material.MatTreeFlatDataSource(this.treeControl, this.treeFlattener);
        }
        /**
         * @return {?}
         */
        TreeFilterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.data.value = '';
            this.dataSource.data = this.data.selectOptions;
            this.myControl.valueChanges.subscribe((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                _this._filter(value);
            }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) { }), (/**
             * @return {?}
             */
            function () {
            }));
            this.inputId = this.data.placeholder.trim().toLowerCase();
        };
        /**
         * @private
         * @param {?} value
         * @return {?}
         */
        TreeFilterComponent.prototype._filter = /**
         * @private
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            /** @type {?} */
            var filterValue = value.toLowerCase();
            console.log(filterValue);
            /** @type {?} */
            var newData = this.data.selectOptions.filter((/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return _this._include_node(filterValue, node); }));
            this.dataSource.data = newData;
            this._fix_selection();
        };
        /** return true if any children is include, false otherwise */
        /**
         * return true if any children is include, false otherwise
         * @private
         * @param {?} filter
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype._include_node = /**
         * return true if any children is include, false otherwise
         * @private
         * @param {?} filter
         * @param {?} node
         * @return {?}
         */
        function (filter, node) {
            var e_1, _a;
            if (node.term.identifier.toLowerCase().includes(filter)) {
                return true;
            }
            else if (node.children) {
                try {
                    for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        if (this._include_node(filter, child)) {
                            return true;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                return false;
            }
            return false;
        };
        /**
         * @private
         * @return {?}
         */
        TreeFilterComponent.prototype._fix_selection = /**
         * @private
         * @return {?}
         */
        function () {
            var e_2, _a;
            try {
                for (var _b = __values(this.treeControl.dataNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var node = _c.value;
                    console.log(node);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            // if (this.checklistSelection.selected) {
            //   const old = this.checklistSelection.selected.find(
            //     (value: FlatTreeNode, index: number, obj: FlatTreeNode[]) => value.term.id === node.term.id
            //   );
            //   if (old !== undefined) {
            //     this.checklistSelection.deselect(old);
            //     this.checklistSelection.select(result);
            //   }
            // }
        };
        /**
         * @return {?}
         */
        TreeFilterComponent.prototype.remove_component = /**
         * @return {?}
         */
        function () {
            this.filterService.deleteParameter(this.data.field);
            this.filterContainerService.filterDeleted(this.data.index);
        };
        /**
         * @return {?}
         */
        TreeFilterComponent.prototype.onChange = /**
         * @return {?}
         */
        function () {
            this.filterService.changeFilter(this.data.field, this.data.value);
        };
        /**
         * @return {?}
         */
        TreeFilterComponent.prototype.emitSelection = /**
         * @return {?}
         */
        function () {
            console.log(this.checklistSelection.selected);
            /** @type {?} */
            var valueEmiter = 'OR';
            this.checklistSelection.selected.forEach((/**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                valueEmiter = valueEmiter + ',' + node.term.id;
            }));
            this.filterService.changeAutocompleteFilter(this.data.idVocab.toString(10), valueEmiter);
        };
        /** Transform the data to something the tree can read. */
        /**
         * Transform the data to something the tree can read.
         * @param {?} node
         * @param {?} level
         * @return {?}
         */
        TreeFilterComponent.prototype.transformer = /**
         * Transform the data to something the tree can read.
         * @param {?} node
         * @param {?} level
         * @return {?}
         */
        function (node, level) {
            /** @type {?} */
            var result = {
                name: node.term.identifier,
                level: level,
                expandable: (node.children.length > 0),
                term: node.term,
            };
            return result;
        };
        /** Get the level of the node */
        /**
         * Get the level of the node
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.getLevel = /**
         * Get the level of the node
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return node.level;
        };
        /** Get whether the node is expanded or not. */
        /**
         * Get whether the node is expanded or not.
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.isExpandable = /**
         * Get whether the node is expanded or not.
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return node.expandable;
        };
        /** Get whether the node has children or not. */
        /**
         * Get whether the node has children or not.
         * @param {?} index
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.hasChild = /**
         * Get whether the node has children or not.
         * @param {?} index
         * @param {?} node
         * @return {?}
         */
        function (index, node) {
            return node.expandable;
        };
        /** Get the children for the node. */
        /**
         * Get the children for the node.
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.getChildren = /**
         * Get the children for the node.
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return rxjs.of(node.children);
        };
        /** Whether all the descendants of the node are selected. */
        /**
         * Whether all the descendants of the node are selected.
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.descendantsAllSelected = /**
         * Whether all the descendants of the node are selected.
         * @param {?} node
         * @return {?}
         */
        function (node) {
            var _this = this;
            /** @type {?} */
            var descendants = this.treeControl.getDescendants(node);
            /** @type {?} */
            var descAllSelected = descendants.every((/**
             * @param {?} child
             * @return {?}
             */
            function (child) {
                return _this.checklistSelection.isSelected(child);
            }));
            return descAllSelected;
        };
        /** Whether part of the descendants are selected */
        /**
         * Whether part of the descendants are selected
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.descendantsPartiallySelected = /**
         * Whether part of the descendants are selected
         * @param {?} node
         * @return {?}
         */
        function (node) {
            var _this = this;
            /** @type {?} */
            var descendants = this.treeControl.getDescendants(node);
            /** @type {?} */
            var result = descendants.some((/**
             * @param {?} child
             * @return {?}
             */
            function (child) { return _this.checklistSelection.isSelected(child); }));
            return result && !this.descendantsAllSelected(node);
        };
        /** Select/deselect all the descendants node */
        /**
         * Select/deselect all the descendants node
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.itemSelectionToggle = /**
         * Select/deselect all the descendants node
         * @param {?} node
         * @return {?}
         */
        function (node) {
            var _a, _b;
            var _this = this;
            this.checklistSelection.toggle(node);
            /** @type {?} */
            var descendants = this.treeControl.getDescendants(node);
            this.checklistSelection.isSelected(node)
                ? (_a = this.checklistSelection).select.apply(_a, __spread(descendants)) : (_b = this.checklistSelection).deselect.apply(_b, __spread(descendants));
            // Force update for the parent
            descendants.every((/**
             * @param {?} child
             * @return {?}
             */
            function (child) {
                return _this.checklistSelection.isSelected(child);
            }));
            this.checkAllParentsSelection(node);
            this.emitSelection();
        };
        /** Check all the parents to see if they changed */
        /**
         * Check all the parents to see if they changed
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.leafItemSelectionToggle = /**
         * Check all the parents to see if they changed
         * @param {?} node
         * @return {?}
         */
        function (node) {
            this.checklistSelection.toggle(node);
            this.checkAllParentsSelection(node);
            this.emitSelection();
        };
        /* Checks all the parents when a leaf node is selected/unselected */
        /* Checks all the parents when a leaf node is selected/unselected */
        /**
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.checkAllParentsSelection = /* Checks all the parents when a leaf node is selected/unselected */
        /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var parent = this.getParentNode(node);
            while (parent) {
                this.checkRootNodeSelection(parent);
                parent = this.getParentNode(parent);
            }
        };
        /** Check root node checked state and change it accordingly */
        /**
         * Check root node checked state and change it accordingly
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.checkRootNodeSelection = /**
         * Check root node checked state and change it accordingly
         * @param {?} node
         * @return {?}
         */
        function (node) {
            var _this = this;
            /** @type {?} */
            var nodeSelected = this.checklistSelection.isSelected(node);
            /** @type {?} */
            var descendants = this.treeControl.getDescendants(node);
            /** @type {?} */
            var descAllSelected = descendants.every((/**
             * @param {?} child
             * @return {?}
             */
            function (child) {
                return _this.checklistSelection.isSelected(child);
            }));
            if (nodeSelected && !descAllSelected) {
                this.checklistSelection.deselect(node);
            }
            else if (!nodeSelected && descAllSelected) {
                this.checklistSelection.select(node);
            }
        };
        /* Get the parent node of a node */
        /* Get the parent node of a node */
        /**
         * @param {?} node
         * @return {?}
         */
        TreeFilterComponent.prototype.getParentNode = /* Get the parent node of a node */
        /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var currentLevel = this.getLevel(node);
            if (currentLevel < 1) {
                return null;
            }
            /** @type {?} */
            var startIndex = this.treeControl.dataNodes.indexOf(node) - 1;
            for (var i = startIndex; i >= 0; i--) {
                /** @type {?} */
                var currentNode = this.treeControl.dataNodes[i];
                if (this.getLevel(currentNode) < currentLevel) {
                    return currentNode;
                }
            }
            return null;
        };
        /**
         * @param {?} i
         * @return {?}
         */
        TreeFilterComponent.prototype.removeChip = /**
         * @param {?} i
         * @return {?}
         */
        function (i) {
            console.log(i);
        };
        TreeFilterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-tree-filter',
                        template: "<div class=\"card-filter\">\n  <input\n    type=\"text\"\n    placeholder=\"{{ data.placeholder }}\"\n    aria-label=\"Number\"\n    matInput\n    [formControl]=\"myControl\"\n    id=\"{{ inputId }}\"\n  />\n\n  <mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" class=\"padd\">\n    <mat-tree-node\n      class=\"hover\"\n      *matTreeNodeDef=\"let node\"\n      matTreeNodeToggle\n      matTreeNodePadding\n      fxLayout=\"row\"\n      fxLayoutAlign=\"space-between center\"\n    >\n      <div fxLayout=\"row\" fxLayoutAlign=\"start center\">\n        <button mat-icon-button disabled></button>\n        <mat-checkbox\n          class=\"checklist-leaf-node\"\n          [checked]=\"checklistSelection.isSelected(node)\"\n          (change)=\"leafItemSelectionToggle(node)\"\n          matTooltip=\"{{ node.name }}\"\n          >{{ node.name }}</mat-checkbox\n        >\n      </div>\n    </mat-tree-node>\n\n    <mat-tree-node\n      class=\"hover\"\n      *matTreeNodeDef=\"let node; when: hasChild\"\n      matTreeNodePadding\n    >\n      <button\n        mat-icon-button\n        matTreeNodeToggle\n        [attr.aria-label]=\"'toggle ' + node.name\"\n      >\n        <mat-icon class=\"mat-icon-rtl-mirror\">\n          {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n        </mat-icon>\n      </button>\n      <div\n        class=\"item-width\"\n        fxLayout=\"row\"\n        fxLayoutAlign=\"space-between center\"\n      >\n        <mat-checkbox\n          [checked]=\"descendantsAllSelected(node)\"\n          [indeterminate]=\"descendantsPartiallySelected(node)\"\n          (change)=\"itemSelectionToggle(node)\"\n          matTooltip=\"{{ node.name }}\"\n          >{{ node.name }}</mat-checkbox\n        >\n      </div>\n    </mat-tree-node>\n  </mat-tree>\n\n  <button\n    mat-icon-button\n    color=\"accent\"\n    class=\"delete-filter\"\n    (click)=\"remove_component()\"\n  >\n    <mat-icon>close</mat-icon>\n  </button>\n\n  <mat-chip-list\n    fxLayout=\"row\"\n    fxLayoutAlign=\"start center\"\n    style=\"margin-bottom: .5em\"\n    id=\"chiplist\"\n  >\n    <mat-chip\n      *ngFor=\"let item of chipsList; let i = index\"\n      (click)=\"removeChip(i)\"\n      >{{ item.name }}</mat-chip\n    >\n  </mat-chip-list>\n</div>\n",
                        styles: [".card-filter{border:2px solid #e4e4e4;border-radius:5px;padding:5px .5em 0;position:relative;box-shadow:2px 3px 10px RGB(0,0,0,.053);width:15em;margin:.4em 0}.delete-filter{position:absolute;top:-1.9em;right:-1.4em;width:2em;height:2em}.delete-filter mat-icon{font-size:medium}"]
                    }] }
        ];
        /** @nocollapse */
        TreeFilterComponent.ctorParameters = function () { return [
            { type: FiltersService },
            { type: FilterContainerService }
        ]; };
        TreeFilterComponent.propDecorators = {
            data: [{ type: core.Input }]
        };
        return TreeFilterComponent;
    }());
    if (false) {
        /** @type {?} */
        TreeFilterComponent.prototype.data;
        /** @type {?} */
        TreeFilterComponent.prototype.chipsList;
        /** @type {?} */
        TreeFilterComponent.prototype.treeControl;
        /** @type {?} */
        TreeFilterComponent.prototype.treeFlattener;
        /** @type {?} */
        TreeFilterComponent.prototype.dataSource;
        /** @type {?} */
        TreeFilterComponent.prototype.checklistSelection;
        /** @type {?} */
        TreeFilterComponent.prototype.myControl;
        /** @type {?} */
        TreeFilterComponent.prototype.inputId;
        /**
         * @type {?}
         * @private
         */
        TreeFilterComponent.prototype.filterService;
        /**
         * @type {?}
         * @private
         */
        TreeFilterComponent.prototype.filterContainerService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/filter-container/filter-container.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FilterContainerComponent = /** @class */ (function () {
        function FilterContainerComponent(componentFactoryResolver, childrenService) {
            this.componentFactoryResolver = componentFactoryResolver;
            this.childrenService = childrenService;
            this.filter_url = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        FilterContainerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.filters_data = [];
            this.childrenService.emitter.subscribe((/**
             * @param {?} filterIndex
             * @return {?}
             */
            function (filterIndex) {
                _this.deleteFilter(filterIndex);
            }));
        };
        /**
         * @param {?} index
         * @return {?}
         */
        FilterContainerComponent.prototype.addFilter = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            /** @type {?} */
            var data = this.filters_data[index];
            /** @type {?} */
            var viewContainerRef = this.adHost.viewContainerRef;
            data.pos = viewContainerRef.length;
            /** @type {?} */
            var f = this.newFilter(data);
            // this.current_filters.push(f);
            /** @type {?} */
            var componentFactory = this.componentFactoryResolver.resolveComponentFactory(f.component);
            /** @type {?} */
            var componentRef = viewContainerRef.createComponent(componentFactory);
            ((/** @type {?} */ (componentRef.instance))).data = f.data;
            //this.delete_item_of_filters(pos);
            this.filters_data[index].is_enabled = false;
        };
        /**
         * @param {?} data_filter
         * @return {?}
         */
        FilterContainerComponent.prototype.newFilter = /**
         * @param {?} data_filter
         * @return {?}
         */
        function (data_filter) {
            data_filter.viewContainerRef = this.adHost.viewContainerRef;
            /** @type {?} */
            var f = null;
            switch (data_filter.type) {
                case 'select': {
                    f = new FilterItem(SelectFilterOldComponent, data_filter);
                    break;
                }
                case 'boolean': {
                    f = new FilterItem(BooleanFilterComponent, data_filter);
                    break;
                }
                case 'select-autocomplete': {
                    f = new FilterItem(SelectAutocompleteFilterComponent, data_filter);
                    break;
                }
                case 'tree': {
                    f = new FilterItem(TreeFilterComponent, data_filter);
                    break;
                }
                default: f = new FilterItem(TitleFilterComponent, data_filter);
            }
            return f;
        };
        /**
         * @param {?} index
         * @return {?}
         */
        FilterContainerComponent.prototype.deleteFilter = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            /** @type {?} */
            var last_pos = this.filters_data[index].pos;
            this.adHost.viewContainerRef.remove(this.filters_data[index].pos);
            this.filters_data[index].pos = -1;
            this.filters_data[index].is_enabled = true;
            for (var i = 0; i < this.filters_data.length; i++) {
                if (!this.filters_data[i].is_enabled && this.filters_data[i].pos > last_pos) {
                    this.filters_data[i].pos = this.filters_data[i].pos - 1;
                }
            }
        };
        FilterContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-filter-container',
                        template: "<!-- <div fxLayout=\"row wrap\" fxLayoutAlign=\"start center\" fxLayoutAlign.xs=\"center center\" fxLayoutGap=\"1em\" fxLayoutGap.xs=\"0\"> -->\n\n  <ng-template toco-Filter></ng-template>\n\n<!-- </div> -->\n\n<button mat-icon-button [matMenuTriggerFor]=\"menu\">\n    <mat-icon>add</mat-icon>\n</button>\n  <mat-menu #menu=\"matMenu\" >\n    <ng-container *ngFor=\"let item of filters_data,let i=index\">\n        <ng-container *ngIf=\"item.is_enabled\">\n          <button mat-menu-item (click)=\"addFilter(i)\">\n            {{item.name}}\n          </button>\n        </ng-container>\n    </ng-container>\n    \n\n    \n  </mat-menu>",
                        styles: [".width-100{width:100%}.mat-menu-item{height:37px}"]
                    }] }
        ];
        /** @nocollapse */
        FilterContainerComponent.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver },
            { type: FilterContainerService }
        ]; };
        FilterContainerComponent.propDecorators = {
            filter_url: [{ type: core.Output }],
            adHost: [{ type: core.ViewChild, args: [FilterDirective, { static: true },] }]
        };
        return FilterContainerComponent;
    }());
    if (false) {
        /** @type {?} */
        FilterContainerComponent.prototype.filters_data;
        /** @type {?} */
        FilterContainerComponent.prototype.filter_url;
        /** @type {?} */
        FilterContainerComponent.prototype.adHost;
        /**
         * @type {?}
         * @protected
         */
        FilterContainerComponent.prototype.componentFactoryResolver;
        /**
         * @type {?}
         * @protected
         */
        FilterContainerComponent.prototype.childrenService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/filters.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var FiltersModule = /** @class */ (function () {
        function FiltersModule() {
        }
        FiltersModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            BooleanFilterComponent,
                            FilterContainerComponent,
                            SelectAutocompleteFilterComponent,
                            SelectFilterOldComponent,
                            TitleFilterComponent,
                            FilterDirective,
                            TreeFilterComponent
                        ],
                        entryComponents: [
                            BooleanFilterComponent,
                            SelectAutocompleteFilterComponent,
                            SelectFilterOldComponent,
                            TitleFilterComponent,
                            TreeFilterComponent
                        ],
                        imports: [
                            SharedModule,
                            // InfiniteScrollModule,
                            forms.ReactiveFormsModule
                        ],
                        exports: [
                            BooleanFilterComponent,
                            FilterContainerComponent,
                            SelectAutocompleteFilterComponent,
                            SelectFilterOldComponent,
                            TitleFilterComponent,
                            FilterDirective,
                            TreeFilterComponent
                        ],
                        providers: [
                            FiltersService,
                            FilterContainerService
                        ]
                    },] }
        ];
        return FiltersModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/filter.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /*
     *   Copyright (c) 2020 Universidad de Pinar del Río "Hermanos Saíz Montes de Oca"
     *   All rights reserved.
     */
    /**
     * @record
     */
    function FilterComponent() { }
    if (false) {
        /** @type {?} */
        FilterComponent.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/filters/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/form-field.control.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var TextAlign = {
        /**
         * The inline contents are aligned to the left edge of the line box. In vertical text,
         * `left` aligns to the edge of the line box that would be the start edge for left-to-right text.
         */
        left: "left",
        /**
         * The inline contents are centered within the line box.
         */
        center: "center",
        /**
         * The inline contents are aligned to the right edge of the line box. In vertical text,
         * `right` aligns to the edge of the line box that would be the end edge for left-to-right text.
         */
        right: "right",
        /**
         * The text is justified.
         */
        justify: "justify",
    };
    /** @enum {string} */
    var ContentPosition = {
        /**
         * Adding the `prefix` option to an element will designate it as the prefix.
         */
        prefix: "matPrefix",
        /**
         * Adding the `suffix` option to an element will designate it as the suffix.
         */
        suffix: "matSuffix",
        /**
         * Adding the `none` option to an element will not show it.
         */
        none: "none",
    };
    /** @enum {string} */
    var IconSource = {
        /**
         * The icon is obtained from an internal source. In this case, it uses an icon that was copied to
         * the 'assets' folder of the project, and it was registered using the `IconService.registerIcons` method.
         */
        internal: "internal",
        /**
         * The icon is obtained from an external source. In this case,
         * it uses a 'Material Icon' from 'https://fonts.googleapis.com/icon?family=Material+Icons'.
         */
        external: "external",
    };
    /**
     * Data structure for holding an icon.
     */
    var   /**
     * Data structure for holding an icon.
     */
    IconValue = /** @class */ (function () {
        /**
         * Creates a new instance of the `IconValue` class.
         * @param s The icon source type. By default, its value is `IconSource.internal`.
         * @param p The icon position type. By default, its value is `ContentPosition.prefix`.
         * @param n The icon name. By default, its value is `IconService.defaultIconName`.
         */
        function IconValue(s, p, n) {
            if (s === void 0) { s = IconSource.internal; }
            if (p === void 0) { p = ContentPosition.prefix; }
            if (n === void 0) { n = IconService.defaultIconName; }
            this.source = s;
            this.position = p;
            this.name = n;
            this.setDefaultValueIfUndefined();
        }
        /**
         * Sets the default value for each undefined value.
         */
        /**
         * Sets the default value for each undefined value.
         * @return {?}
         */
        IconValue.prototype.setDefaultValueIfUndefined = /**
         * Sets the default value for each undefined value.
         * @return {?}
         */
        function () {
            if (this.source == undefined)
                this.source = IconSource.internal;
            if (this.position == undefined)
                this.position = ContentPosition.prefix;
            if (this.name == undefined)
                this.name = IconService.defaultIconName;
        };
        /**
         * Sets the default value for each undefined value, but the icon position is always set to the specified value.
         * @param iconPosition The icon position to set.
         */
        /**
         * Sets the default value for each undefined value, but the icon position is always set to the specified value.
         * @param {?} iconPosition The icon position to set.
         * @return {?}
         */
        IconValue.prototype.setDefaultValueIfUndefined_setPosition = /**
         * Sets the default value for each undefined value, but the icon position is always set to the specified value.
         * @param {?} iconPosition The icon position to set.
         * @return {?}
         */
        function (iconPosition) {
            if (this.source == undefined)
                this.source = IconSource.internal;
            this.position = iconPosition;
            if (this.name == undefined)
                this.name = IconService.defaultIconName;
        };
        return IconValue;
    }());
    if (false) {
        /**
         * Returns the icon source type.
         * By default, its value is `IconSource.internal`.
         * @type {?}
         */
        IconValue.prototype.source;
        /**
         * Returns the icon position type.
         * By default, its value is `ContentPosition.prefix`.
         * @type {?}
         */
        IconValue.prototype.position;
        /**
         * Returns the icon name.
         * By default, its value is `IconService.defaultIconName`.
         * @type {?}
         */
        IconValue.prototype.name;
    }
    /** @enum {string} */
    var HintPosition = {
        /**
         * Adding the `start` option to a `HintValue` will designate it as start-aligned.
         */
        start: "start",
        /**
         * Adding the `end` option to a `HintValue` will designate it as end-aligned.
         */
        end: "end",
        /**
         * Adding the `none` option to a `HintValue` will not show it.
         */
        none: "none",
    };
    /**
     * Data structure for holding a hint.
     * A hint label is additional descriptive text that appears below the control's underline.
     */
    var   /**
     * Data structure for holding a hint.
     * A hint label is additional descriptive text that appears below the control's underline.
     */
    HintValue = /** @class */ (function () {
        /**
         * Creates a new instance of the `HintValue` class.
         * @param p The hint position type. By default, its value is `HintPosition.none`.
         * @param l The hint label. By default, its value is `''`.
         */
        function HintValue(p, l) {
            if (p === void 0) { p = HintPosition.none; }
            if (l === void 0) { l = ''; }
            this.position = p;
            this.label = l;
            this.setDefaultValueIfUndefined();
        }
        /**
         * Sets the default value for each undefined value.
         */
        /**
         * Sets the default value for each undefined value.
         * @return {?}
         */
        HintValue.prototype.setDefaultValueIfUndefined = /**
         * Sets the default value for each undefined value.
         * @return {?}
         */
        function () {
            if (this.position == undefined)
                this.position = HintPosition.none;
            if (this.label == undefined)
                this.label = '';
        };
        /**
         * Sets the default value for each undefined value, but the hint position is always set to the specified value.
         * @param hintPosition The hint position to set.
         */
        /**
         * Sets the default value for each undefined value, but the hint position is always set to the specified value.
         * @param {?} hintPosition The hint position to set.
         * @return {?}
         */
        HintValue.prototype.setDefaultValueIfUndefined_setPosition = /**
         * Sets the default value for each undefined value, but the hint position is always set to the specified value.
         * @param {?} hintPosition The hint position to set.
         * @return {?}
         */
        function (hintPosition) {
            this.position = hintPosition;
            if (this.label == undefined)
                this.label = '';
        };
        return HintValue;
    }());
    if (false) {
        /**
         * Returns the hint position type.
         * By default, its value is `HintPosition.none`.
         * @type {?}
         */
        HintValue.prototype.position;
        /**
         * Returns the hint label.
         * By default, its value is `''`.
         * @type {?}
         */
        HintValue.prototype.label;
    }
    /** @enum {string} */
    var FormFieldType = {
        /** A button control. */
        action_button: "action_button",
        /** A container control that is showed as a panel. */
        container_panel: "container_panel",
        /** A container control that is showed very simple. */
        container_simple: "container_simple",
        /** A container control that allows the writing of a name of something in different language. */
        container_label_diff_lang: "container_label_diff_lang",
        /** A text control. */
        text: "text",
        /** A textarea control. */
        textarea: "textarea",
        /** A datapicker control. */
        datepicker: "datepicker",
        /** A checkbox control. */
        checkbox: "checkbox",
        /** A url control. */
        url: "url",
        /** An email control. */
        email: "email",
        /** An identifier control. */
        identifier: "identifier",
        /** An issn control. */
        issn: "issn",
        /** A rnps control. */
        rnps: "rnps",
        /** A vocabulary control. */
        vocabulary: "vocabulary",
        vocabulary_tree: "toco-vocabulary-tree",
        /** A term parent control. */
        term_parent: "term_parent",
        /** A select control. */
        select: "select",
        /** A select control. */
        select_expr: "select_expr",
        /** A select with a filter control. */
        select_filter: "select_filter",
        /** A select with a filter control. */
        select_tree: "select_tree",
    };
    /**
     * A base interface that represents the content of a `FormFieldControl`.
     * @record
     */
    function FormFieldContent() { }
    if (false) {
        /**
         * Returns the parent `ContainerControl` of this control.
         * It is always set internally.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.parentContainerControl;
        /**
         * Returns the parent `FormSection` that represents the parent `FormGroup` or `FormArray` of this control.
         * It is always set internally.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.parentFormSection;
        /**
         * Returns the control's minimum width.
         * The minimum width of the content area, padding area or border area (depending on `box-sizing`)
         * of certain boxes. Allows authors to constrain content width to a centain range.
         * By default, its value is `'15em'`.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.minWidth;
        /**
         * Returns the control's width.
         * The width of the content area, padding area or border area (depending on `box-sizing`) of certain boxes.
         * By default, its value is `minWidth`.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.width;
        /**
         * Returns the control's label.
         * See the `ContainerContent` for the particular interpretation of this field.
         * See the `ActionContent` for the particular interpretation of this field.
         * By default, its value is `''`. Each control sets its own label.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.label;
        /**
         * Returns the control's placeholder.
         * By default, its value is `''`. Each control sets its own placeholder.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.placeholder;
        /**
         * Returns true if the control is required; otherwise, false.
         * See the `ContainerContent` for the particular interpretation of this field.
         * By default, its value is `false`.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.required;
        /**
         * Returns the control's text align.
         * By default, its value is `TextAlign.left`.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.textAlign;
        /**
         * Returns the control's aria-label.
         * Defines a string value that labels the current element.
         * By default, its value is `'Text Input'`. Each control sets its own aria-label.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.ariaLabel;
        /**
         * The control's value.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.value;
        /**
         * This `type` field is deprecated, you must use the `controlType` field.
         * Returns the control's type that is used to create the control.
         * Implementation notes:
         *  - It must be specified; otherwise, an exception is thrown.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.type;
        /**
         * Returns the control's type that is used to create the control.
         * Implementation notes:
         *  - It must be specified; otherwise, an exception is thrown.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.controlType;
        /**
         * Returns the control's name that is used to save the control's value as a name/value pair.
         * Implementation notes:
         *  - It can be used with a JSON string.
         *  - It must be specified; otherwise, an exception is thrown.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.name;
        /**
         * The control's extra content. For any other content needed by an specific `FormFieldControl`.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        FormFieldContent.prototype.extraContent;
    }
    /**
     * Returns a new object that represents the clone of the specified `FormControl` target.
     * @param {?} target The `FormControl` object to clone.
     * @return {?}
     */
    function cloneFormControl(target) {
        return new forms.FormControl(target.value, target.validator, target.asyncValidator);
    }
    /**
     * Returns a new object that represents the clone of the specified `FormSection` target.
     * @param {?} target The `FormSection` object to clone.
     * @return {?}
     */
    function cloneFormSection(target) {
        var e_1, _a;
        if (target instanceof forms.FormGroup) {
            /* Creates an empty `FormGroup` with its validators. */
            /** @type {?} */
            var result = new forms.FormGroup({}, target.validator, target.asyncValidator);
            /* Adds the controls to `FormGroup`. */
            for (var ctr in target.controls) {
                if ((target.controls[ctr]) instanceof forms.FormControl)
                    result.addControl(ctr, cloneFormControl((/** @type {?} */ ((target.controls[ctr])))));
                else
                    result.addControl(ctr, cloneFormSection((/** @type {?} */ ((target.controls[ctr])))));
            }
            return result;
        }
        else {
            /* Creates an empty `FormArray` with its validators. */
            /** @type {?} */
            var result = new forms.FormArray([], target.validator, target.asyncValidator);
            try {
                /* Adds the controls to the `FormArray`. */
                for (var _b = __values(target.controls), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var ctr = _c.value;
                    if (ctr instanceof forms.FormControl)
                        result.push(cloneFormControl(ctr));
                    else
                        result.push(cloneFormSection((/** @type {?} */ (ctr))));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        }
    }
    /**
     * Represents the base abstract class for a control that is treated as a form field.
     * @abstract
     */
    var FormFieldControl = /** @class */ (function () {
        /**
         * Constructs a new instance of this class.
         */
        function FormFieldControl() {
            this.contentPosition = ContentPosition;
            this.iconSource = IconSource;
            /* It must be initialize. */
            this.content = undefined;
            this.isTranslationBuiltByControl = false;
        }
        /**
         * Sets the new language.
         * @param transServ The `TranslateService` instance injected.
         */
        /**
         * Sets the new language.
         * @protected
         * @param {?} transServ The `TranslateService` instance injected.
         * @return {?}
         */
        FormFieldControl.prototype.setNewLanguage = /**
         * Sets the new language.
         * @protected
         * @param {?} transServ The `TranslateService` instance injected.
         * @return {?}
         */
        function (transServ) {
            /* The `FormFieldControl.currentLang != transServ.currentLang` test is NOT necessary here because it is done in the non-abstract child classes. */
            FormFieldControl.currentLang = transServ.currentLang;
        };
        /**
         * Initializes the `content` input property.
         * @param label The default label to use. It is used if the `content.label` is not specified.
         * @param placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @return {?}
         */
        FormFieldControl.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @return {?}
         */
        function (label, placeholder) {
            /* Sets the default values. */
            if (placeholder === void 0) { placeholder = ''; }
            if (this.content == undefined) {
                throw new Error("For the '" + FormFieldControl.name + "' control, the 'content' value can not be undefined.");
            }
            if (this.content.name == undefined) {
                throw new Error("For the '" + FormFieldControl.name + "' control, the 'content.name' value can not be undefined.");
            }
            if (this.content.controlType == undefined) {
                throw new Error("For the '" + this.content.name + "' control, the 'content.controlType' value can not be undefined.");
            }
            if (label == undefined) {
                if (this.content.label == undefined) {
                    throw new Error("For the '" + this.content.name + "' control, the 'content.label' value can not be undefined. \n\n                    You can specify: \n\n                    - A default label value when overwriting the 'init' method in the component that represents the control. \n\n                    - A label value when defining the content object for the control.");
                }
                label = this.content.label;
            }
            else {
                if (this.content.label) {
                    label = this.content.label;
                }
            }
            /************************** `mat-form-field` properties. **************************/
            if (this.content.minWidth == undefined)
                this.content.minWidth = '15em';
            if (this.content.width == undefined)
                this.content.width = this.content.minWidth;
            /**************************** `mat-label` properties. *****************************/
            if (this.content.label == undefined)
                this.content.label = label;
            if (this.content.placeholder == undefined)
                this.content.placeholder = placeholder;
            /************************** Internal control properties. **************************/
            if (this.content.textAlign == undefined)
                this.content.textAlign = TextAlign.left;
            if (this.content.ariaLabel == undefined)
                this.content.ariaLabel = label;
            if (this.content.value != undefined) /* It does not set the default value here (does not call `getDefaultValue` method here) because in this way it is more consistent. */ {
                /* It also checks if the specified `content.value` is correct. */
                this.initValue();
            }
            /******************************* Other properties. ********************************/
        };
        Object.defineProperty(FormFieldControl.prototype, "parentContainerControl", {
            /**
             * Returns the parent `ContainerControl` of this control.
             * It is always set internally.
             */
            get: /**
             * Returns the parent `ContainerControl` of this control.
             * It is always set internally.
             * @return {?}
             */
            function () {
                return this.content.parentContainerControl;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds the specified `control`/`internalControl` as a child
         * to the `content.containerControlChildren`/`content.parentFormSection` respectively.
         * @param control Form control to be added (descendant from `FormFieldControl`).
         * @param internalControl Internal form control to be added (`FormControl`, `FormGroup`, or `FormArray`).
         */
        /**
         * Adds the specified `control`/`internalControl` as a child
         * to the `content.containerControlChildren`/`content.parentFormSection` respectively.
         * @protected
         * @param {?} control Form control to be added (descendant from `FormFieldControl`).
         * @param {?} internalControl Internal form control to be added (`FormControl`, `FormGroup`, or `FormArray`).
         * @return {?}
         */
        FormFieldControl.prototype.addAsChildControl = /**
         * Adds the specified `control`/`internalControl` as a child
         * to the `content.containerControlChildren`/`content.parentFormSection` respectively.
         * @protected
         * @param {?} control Form control to be added (descendant from `FormFieldControl`).
         * @param {?} internalControl Internal form control to be added (`FormControl`, `FormGroup`, or `FormArray`).
         * @return {?}
         */
        function (control, internalControl) {
            /* Adds the specified `control` as a child to the `content.containerControlChildren`. */
            this.content.parentContainerControl.content.containerControlChildren.push(control);
            /* Adds the specified `internalControl` as a child to the `content.parentFormSection`. */
            if (this.content.parentContainerControl.isFormArray) /* `content.parentFormSection` is an instance of `FormArray`. */ {
                /* The `internalControl`'s name is already correct, that is,
                `content.name` equals the `content.parentFormSection`'s last position
                (because the `internalControl` has a `FormArray` as its parent). */
                ((/** @type {?} */ (this.content.parentFormSection))).push(internalControl);
            }
            else /* `content.parentFormSection` is an instance of `FormGroup`. */ {
                ((/** @type {?} */ (this.content.parentFormSection))).addControl(this.content.name, internalControl);
            }
        };
        /**
         * Returns true if the specified `IconValue` has the specified `ContentPosition` value; otherwise, false.
         * @param icon The `IconValue` to check.
         * @param contentPosition The `ContentPosition` value to check.
         */
        /**
         * Returns true if the specified `IconValue` has the specified `ContentPosition` value; otherwise, false.
         * @param {?} icon The `IconValue` to check.
         * @param {?} contentPosition The `ContentPosition` value to check.
         * @return {?}
         */
        FormFieldControl.prototype.iconPositionState = /**
         * Returns true if the specified `IconValue` has the specified `ContentPosition` value; otherwise, false.
         * @param {?} icon The `IconValue` to check.
         * @param {?} contentPosition The `ContentPosition` value to check.
         * @return {?}
         */
        function (icon, contentPosition) {
            return (icon.position == contentPosition);
        };
        /**
         * Returns true if the specified `IconValue` has the specified `IconSource` value; otherwise, false.
         * @param icon The `IconValue` to check.
         * @param iconSource The `IconSource` value to check.
         */
        /**
         * Returns true if the specified `IconValue` has the specified `IconSource` value; otherwise, false.
         * @param {?} icon The `IconValue` to check.
         * @param {?} iconSource The `IconSource` value to check.
         * @return {?}
         */
        FormFieldControl.prototype.iconSourceState = /**
         * Returns true if the specified `IconValue` has the specified `IconSource` value; otherwise, false.
         * @param {?} icon The `IconValue` to check.
         * @param {?} iconSource The `IconSource` value to check.
         * @return {?}
         */
        function (icon, iconSource) {
            return (icon.source == iconSource);
        };
        /**
         * Returns the language currently used.
         * This is a static field.
         */
        FormFieldControl.currentLang = '';
        FormFieldControl.propDecorators = {
            content: [{ type: core.Input }]
        };
        return FormFieldControl;
    }());
    if (false) {
        /**
         * Returns the language currently used.
         * This is a static field.
         * @type {?}
         * @protected
         */
        FormFieldControl.currentLang;
        /**
         * Represents the `ContentPosition` enum for internal use.
         * @type {?}
         */
        FormFieldControl.prototype.contentPosition;
        /**
         * Represents the `IconSource` enum for internal use.
         * @type {?}
         */
        FormFieldControl.prototype.iconSource;
        /**
         * Input field that contains the content of this class.
         * @type {?}
         */
        FormFieldControl.prototype.content;
        /**
         * Returns true if the translation is built by the control; otherwise, false.
         * It is used to select the way the translation is built for the control.
         * By default, its value is `false`.
         * As an example of usage for this field, the `InputNumberComponent` class implements the logic when this value is `true`.
         * @type {?}
         */
        FormFieldControl.prototype.isTranslationBuiltByControl;
        /**
         * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
         * It also checks if the specified `content.value` is correct. For internal use only.
         * @abstract
         * @protected
         * @return {?}
         */
        FormFieldControl.prototype.initValue = function () { };
        /**
         * Returns this instance.
         * @abstract
         * @return {?}
         */
        FormFieldControl.prototype.getInstance = function () { };
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/action/action.control.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var OperationAction = {
        back: "back",
        cancel: "cancel",
        reset: "reset",
        delete: "delete",
        submit: "submit",
    };
    /**
     * Returns true if the control is disabled; otherwise, false.
     * This function returns false by definition, that is, the control is enabled.
     * @param {?} sender Control that wants to know its disabled state.
     * @return {?}
     */
    function isDisabledDefault(sender) {
        /* This function returns false by definition, that is, the control is enabled. */
        return false;
    }
    /**
     * This function does nothing by definition.
     * @param {?} sender Control that was clicked.
     * @return {?}
     */
    function clickDefault(sender) {
        /* This function does nothing by definition. */
    }
    /**
     * A base interface that represents the content of an `ActionControl`.
     * @record
     */
    function ActionContent() { }
    if (false) {
        /**
         * Returns the control's icon.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        ActionContent.prototype.icon;
        /**
         * Returns the control's tooltip.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        ActionContent.prototype.tooltip;
        /**
         * Returns the function that is executed for knowing if the control is or is not disabled.
         * By default, its value is `isDisabledDefault`.
         * @type {?|undefined}
         */
        ActionContent.prototype.isDisabled;
        /**
         * Returns the function that is executed when the user clicks the control.
         * By default, its value is `clickDefault`.
         * @type {?|undefined}
         */
        ActionContent.prototype.click;
    }
    /**
     * Represents the base abstract class for a control that executes actions.
     * @abstract
     */
    var ActionControl = /** @class */ (function (_super) {
        __extends(ActionControl, _super);
        /**
         * Constructs a new instance of this class.
         */
        function ActionControl() {
            return _super.call(this) || this;
        }
        /**
         * Initializes the `content` input property.
         * @param label The default label to use. It is used if the `content.label` is not specified.
         * @param placeholder It is NOT used here. Fix that.
         * @param alwaysHint If it is true then there is always a hint start-aligned.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder It is NOT used here. Fix that.
         * @param {?=} alwaysHint If it is true then there is always a hint start-aligned.
         * @return {?}
         */
        ActionControl.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder It is NOT used here. Fix that.
         * @param {?=} alwaysHint If it is true then there is always a hint start-aligned.
         * @return {?}
         */
        function (label, placeholder, alwaysHint) {
            /* Sets the default values. */
            if (placeholder === void 0) { placeholder = ''; }
            if (alwaysHint === void 0) { alwaysHint = true; }
            _super.prototype.init.call(this, label, placeholder);
            /***************************** `mat-icon` properties. *****************************/
            if (this.content.icon != undefined)
                this.content.icon.setDefaultValueIfUndefined_setPosition(ContentPosition.prefix);
            /************************** `mat-form-field` properties. **************************/
            // if (this.content.appearance == undefined) this.content.appearance = TextInputAppearance.standard;
            /**************************** `matTooltip` properties. ****************************/
            if (alwaysHint && (this.content.tooltip == undefined)) {
                this.content.tooltip = new HintValue(HintPosition.start, this.content.label);
            }
            if (this.content.isDisabled == undefined)
                this.content.isDisabled = isDisabledDefault;
            if (this.content.click == undefined)
                this.content.click = clickDefault;
        };
        /**
         * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
         * It also checks if the specified `content.value` is correct. For internal use only.
         */
        /**
         * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
         * It also checks if the specified `content.value` is correct. For internal use only.
         * @protected
         * @return {?}
         */
        ActionControl.prototype.initValue = /**
         * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
         * It also checks if the specified `content.value` is correct. For internal use only.
         * @protected
         * @return {?}
         */
        function () {
            /* It does not need to do something because the child controls are already initialized. */
            // /* In this way, checks if the specified `content.value` is correct. */
            // this.content.formControl.setValue(this.content.value);
            // /* Marks the control as `touched`. */
            // this.content.formControl.markAsTouched({
            //     onlySelf: true
            // });
        };
        Object.defineProperty(ActionControl.prototype, "getInstance", {
            /**
             * Returns this instance.
             */
            get: /**
             * Returns this instance.
             * @return {?}
             */
            function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        ActionControl.propDecorators = {
            content: [{ type: core.Input }]
        };
        return ActionControl;
    }(FormFieldControl));
    if (false) {
        /**
         * Input field that contains the content of this class.
         * @type {?}
         */
        ActionControl.prototype.content;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/action/button/button-action.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a control that executes actions.
     */
    var ActionButtonComponent = /** @class */ (function (_super) {
        __extends(ActionButtonComponent, _super);
        function ActionButtonComponent() {
            return _super.call(this) || this;
        }
        /**
         * @return {?}
         */
        ActionButtonComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init('', '', true);
        };
        ActionButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'action-button',
                        template: "\n<!-- <button mat-icon-button -->\n<button mat-raised-button\n\tclass=\"action-button\"\n\tcolor=\"primary\"\n\t[attr.aria-label]=\"content.ariaLabel\"\n\t[matTooltip]=\"content.tooltip.label\"\n\t[disabled]=\"content.isDisabled(getInstance)\"\n\t(click)=\"content.click(getInstance)\"\n>\n\t<!-- Only renders one of these two `mat-icon` or nothing. -->\n\t<mat-icon *ngIf=\"content.icon && iconSourceState(content.icon, iconSource.internal)\" class=\"mat-icon notranslate\" matPrefix [svgIcon]=\"content.icon.name\"></mat-icon>\n\t<mat-icon *ngIf=\"content.icon && iconSourceState(content.icon, iconSource.external)\" class=\"mat-icon notranslate\" matPrefix>{{ content.icon.name }}</mat-icon>\n\t<!-- <mat-icon>{{ content.icon.name }}</mat-icon> -->\n\t{{ content.label }}\n</button>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        ActionButtonComponent.ctorParameters = function () { return []; };
        return ActionButtonComponent;
    }(ActionControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/component-factory-depr/component-factory-depr.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This component represents a components' factory.
     * This component is deprecated.
     */
    var ComponentFactory_Depr = /** @class */ (function () {
        function ComponentFactory_Depr() {
            this.formFieldType = FormFieldType;
            this.componentsContent = [];
        }
        /**
         * @return {?}
         */
        ComponentFactory_Depr.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            console.log('ComponentFactory_Depr componentsContent: ', this.componentsContent);
        };
        ComponentFactory_Depr.decorators = [
            { type: core.Component, args: [{
                        selector: 'component-factory-depr',
                        template: "\n<div fxLayout=\"row wrap\" fxLayout.xs=\"column\"\nfxLayoutAlign=\"space-between end\" fxLayoutAlign.xs=\"space-between center\"\nfxLayoutGap=\"1em\" class=\"form-field-component\"\n>\n\n    <ng-container *ngFor=\"let componentContent of componentsContent\" [ngSwitch]=\"componentContent.type\">\n\n        <!-- <ng-container \n            *ngSwitchCase=\"formFieldType.checkbox\"\n            [formGroup]=\"componentContent.formGroup\"\n        >\n            <mat-checkbox\n                [style.width]=\"componentContent.width\"\n                [style.minWidth]=\"componentContent.minWidth\"\n                [value]=\"componentContent.value\"\n                (input)=\"$event.target.value\"\n                name=\"{{ componentContent.name }}\"\n                required=\"{{ componentContent.required }}\"\n                [formControlName]=\"componentContent.name\"\n            >\n                {{ componentContent.label }}\n            </mat-checkbox>\n        </ng-container> -->\n<!-- \n        <mat-form-field \n            *ngSwitchCase=\"formFieldType.textarea\"\n            [style.width]=\"componentContent.width\"\n            [style.minWidth]=\"componentContent.minWidth\"\n            [formGroup]=\"componentContent.formGroup\"\n        >\n            <textarea \n                matInput [value]=\"componentContent.value\"\n                (input)=\"$event.target.value\"\n                name=\"{{ componentContent.name }}\"\n                placeholder=\"{{ componentContent.label }}\"\n                required=\"{{ componentContent.required }}\"\n                [formControlName]=\"componentContent.name\"\n                minRows=\"20\"\n            ></textarea>\n        </mat-form-field> -->\n\n\n        <!-- <mat-form-field \n            *ngSwitchCase=\"formFieldType.datepicker\"\n            [style.width]=\"componentContent.width\"\n            [formGroup]=\"componentContent.formGroup\"\n        >\n            <input \n                matInput\n                [value]=\"componentContent.value\"\n                (input)=\"$event.target.value\"\n                [matDatepicker]=\"picker\"\n                name=\"{{ componentContent.name }}\"\n                placeholder=\"{{ componentContent.label }}\"\n                required=\"{{ componentContent.required }}\"\n                [formControlName]=\"componentContent.name\"\n            >\n            <mat-datepicker-toggle\n                matSuffix [for]=\"picker\"\n            ></mat-datepicker-toggle>\n            <mat-datepicker \n                #picker\n                startView=\"multi-year\"\n            ></mat-datepicker>\n        </mat-form-field> -->\n        <toco-checkbox *ngSwitchCase=\"formFieldType.datepicker\" [content]=\"componentContent\"></toco-checkbox>\n        <toco-datepicker *ngSwitchCase=\"formFieldType.datepicker\" [content]=\"componentContent\"></toco-datepicker>\n\n\n        <action-button *ngSwitchCase=\"formFieldType.action_button\" [content]=\"componentContent\"></action-button>\n\n\n        <container-panel *ngSwitchCase=\"formFieldType.container_panel\" [content]=\"componentContent\"></container-panel>\n\n        <container-simple *ngSwitchCase=\"formFieldType.container_simple\" [content]=\"componentContent\"></container-simple>\n\n\n        <container-label-diff-lang *ngSwitchCase=\"formFieldType.container_label_diff_lang\" [content]=\"componentContent\"></container-label-diff-lang>\n\n\n        <input-url *ngSwitchCase=\"formFieldType.url\" [content]=\"componentContent\"></input-url>\n        \n        <input-email *ngSwitchCase=\"formFieldType.email\" [content]=\"componentContent\"></input-email>\n\n        <input-identifier *ngSwitchCase=\"formFieldType.identifier\" [content]=\"componentContent\"></input-identifier>\n\n        <input-issn *ngSwitchCase=\"formFieldType.issn\" [content]=\"componentContent\"></input-issn>\n\n        <input-rnps *ngSwitchCase=\"formFieldType.rnps\" [content]=\"componentContent\"></input-rnps>\n\n        <input-select *ngSwitchCase=\"formFieldType.select\" [content]=\"componentContent\"></input-select>\n\n        <toco-vocabulary *ngSwitchCase=\"formFieldType.vocabulary\" [content]=\"componentContent\"></toco-vocabulary>\n\n        <toco-vocabulary-tree *ngSwitchCase=\"formFieldType.vocabulary_tree\" [content]=\"componentContent\"></toco-vocabulary-tree>\n        \n        <toco-term-parent *ngSwitchCase=\"formFieldType.term_parent\" [content]=\"componentContent\"></toco-term-parent>\n\n        <toco-textarea *ngSwitchCase=\"formFieldType.textarea\" [content]=\"componentContent\"></toco-textarea>\n\n        <toco-select *ngSwitchCase=\"formFieldType.select_expr\" [content]=\"componentContent\"></toco-select>\n\n        <toco-select-filter *ngSwitchCase=\"formFieldType.select_filter\" [content]=\"componentContent\"></toco-select-filter>\n\n        <toco-select-tree *ngSwitchCase=\"formFieldType.select_tree\" [content]=\"componentContent\"></toco-select-tree>\n\n        <input-text *ngSwitchDefault [content]=\"componentContent\"></input-text>\n\n    </ng-container>\n\n</div>\n",
                        styles: [".form-field-component{margin:5px}"]
                    }] }
        ];
        /** @nocollapse */
        ComponentFactory_Depr.ctorParameters = function () { return []; };
        ComponentFactory_Depr.propDecorators = {
            componentsContent: [{ type: core.Input }]
        };
        return ComponentFactory_Depr;
    }());
    if (false) {
        /**
         * Represents the `FormFieldType` enum for internal use.
         * @type {?}
         */
        ComponentFactory_Depr.prototype.formFieldType;
        /**
         * Input field that represents an array of types which types inherit from `FormFieldContent` interface.
         * This array contains the content of the components that the factory is going to create.
         * @type {?}
         */
        ComponentFactory_Depr.prototype.componentsContent;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/container/container.control.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * A base interface that represents the content of a `ContainerControl`.
     * @record
     */
    function ContainerContent() { }
    if (false) {
        /**
         * Returns an array of controls that represents the `ContainerControl`'s child controls that are
         * stored in the `content.formSection`; that is, `content.containerControlChildren` and `content.formSection`
         * have the same length.
         * It is always set internally.
         * By default, its value is `[]`.
         * @type {?|undefined}
         */
        ContainerContent.prototype.containerControlChildren;
        /**
         * Returns the `FormSection` that tracks the value and validity state of the internal
         * child controls that contains this control.
         * Implementation notes:
         *  - Represents the `FormGroup` or `FormArray` that contains the child controls.
         *  - The `content.containerControlChildren` and `content.formSection` have the same length.
         *  - It must be specified; otherwise, an exception is thrown.
         * @type {?|undefined}
         */
        ContainerContent.prototype.formSection;
        /**
         * Returns an array of contents that represents the `ContainerControl`'s child controls that are
         * stored in the `ViewContainer`; that is, `content.formSectionContent` and container's `ViewContainer`
         * have the same length.
         * Implementation notes:
         *  - It must be specified, and must have at least one element; otherwise, an exception is thrown.
         *  - If the `content.formSection` field represents a `FormArray`, then the `name` field
         * of all elements in the `content.formSectionContent` array represents the position
         * in the array like string.
         * @type {?|undefined}
         */
        ContainerContent.prototype.formSectionContent;
        /**
         * Returns true if the container control has a dynamic length, that is, the `content.formSection` field
         * represents a `FormArray` and its length is not fixed; otherwise, false.
         * This field has sense only when the `content.formSection` field represents a `FormArray`.
         * By default, its value is `true`.
         * @type {?|undefined}
         */
        ContainerContent.prototype.isDynamic;
    }
    /**
     * Represents the base abstract class for a control that contains one or more controls.
     * @abstract
     */
    var ContainerControl = /** @class */ (function (_super) {
        __extends(ContainerControl, _super);
        /**
         * Constructs a new instance of this class.
         */
        function ContainerControl() {
            var _this = _super.call(this) || this;
            _this._isFormArray = false;
            _this._formArrayPatternContent = [];
            _this._formArrayPatternValue = undefined;
            _this._formArrayLength = 0;
            return _this;
        }
        /**
         * Returns a `FormGroup` by default.
         * Its value is empty object, and does not have validators.
         */
        /**
         * Returns a `FormGroup` by default.
         * Its value is empty object, and does not have validators.
         * @return {?}
         */
        ContainerControl.getFormGroupByDefault = /**
         * Returns a `FormGroup` by default.
         * Its value is empty object, and does not have validators.
         * @return {?}
         */
        function () {
            return new forms.FormGroup({}, []);
        };
        /**
         * Returns a `FormArray` by default.
         * Its value is empty array, and does not have validators.
         */
        /**
         * Returns a `FormArray` by default.
         * Its value is empty array, and does not have validators.
         * @return {?}
         */
        ContainerControl.getFormArrayByDefault = /**
         * Returns a `FormArray` by default.
         * Its value is empty array, and does not have validators.
         * @return {?}
         */
        function () {
            return new forms.FormArray([], []);
        };
        /**
         * Initializes the `content` input property.
         * @param label The default label to use. It is used if the `content.label` is not specified.
         * @param placeholder It is NOT used here. Fix that.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder It is NOT used here. Fix that.
         * @return {?}
         */
        ContainerControl.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder It is NOT used here. Fix that.
         * @return {?}
         */
        function (label, placeholder) {
            /* Sets the default values. */
            if (placeholder === void 0) { placeholder = ''; }
            _super.prototype.init.call(this, label, placeholder);
            if (this.content.formSection == undefined) {
                throw new Error("For the '" + this.content.name + "' control, the 'content.formSection' value can not be undefined; it must be a 'FormGroup' or 'FormArray' value.");
            }
            if ((this.content.formSectionContent == undefined) || (this.content.formSectionContent.length == 0)) {
                throw new Error("For the '" + this.content.name + "' control, the 'content.formSectionContent' array can not be undefined, and must have at least one element.");
            }
            this._isFormArray = this.content.formSection instanceof forms.FormArray;
            if (this._isFormArray) {
                if (this.content.isDynamic == undefined)
                    this.content.isDynamic = true; /* By default, its value is `true`. */
                if (this.content.required == undefined)
                    this.content.required = false; /* By default, its value is `false`. */
            }
            else {
                if (this.content.isDynamic != undefined)
                    throw new Error("For the '" + this.content.name + "' control, the 'content.isDynamic' value must not exist because the 'content.formSection' value is a 'FormGroup'.");
                if (this.content.required != undefined)
                    throw new Error("For the '" + this.content.name + "' control, the 'content.required' value must not exist because the 'content.formSection' value is a 'FormGroup'.");
                if (this.content.value != undefined)
                    throw new Error("For the '" + this.content.name + "' control, the 'content.value' value must not exist because the 'content.formSection' value is a 'FormGroup'.");
            }
            this._viewContainerRef = this._componentHost.viewContainerRef;
            this._componentFactoryResolver = this._componentHost.componentFactoryResolver;
            /* Initializes the `content.containerControlChildren`. */
            this.content.containerControlChildren = [];
            if (this._isFormArray) {
                if (this.content.value == undefined) {
                    throw new Error("The '" + this.content.name + "' control is constructed dynamically using 'FormArray'. Its 'content.value' array can not be undefined.");
                }
                if ((this.content.value.length == 0) && (!this.content.isDynamic) && (this.content.required)) {
                    throw new Error("The '" + this.content.name + "' control has not sense because its 'content.value' array length is zero, and its 'content.isDynamic' value is false, and its 'content.required' value is true.");
                }
                this.initFormSectionContentToFormArray();
            }
            else {
                /* Sets the parent control to its children. */
                this.setParentToChildren();
            }
            // let temp: string = (isAbbreviation) ? this.content.label : this.content.label.toLowerCase();
            // this.validationError_required = `The ${ temp } can not be empty.`;
            /************************** `mat-form-field` properties. **************************/
            // if (this.content.appearance == undefined) this.content.appearance = TextInputAppearance.standard;
            /***************************** `mat-hint` properties. *****************************/
            // if (alwaysHint && (this.content.startHint == undefined) && (this.content.endHint == undefined))
            // {
            //     this.content.startHint = new HintValue(HintPosition.start, `Write a valid ${ temp }.`);
            // }
            // else
            // {
            //     if (this.content.startHint != undefined) this.content.startHint.setDefaultValueIfUndefined_setPosition(HintPosition.start);
            //     if (this.content.endHint != undefined) this.content.endHint.setDefaultValueIfUndefined_setPosition(HintPosition.end);
            // }
            /* Adds this control as a child to the `content.parentFormSection`.
            It must be called at the end before calling `createChildComponents` method. */
            if (this.content.parentFormSection != undefined) {
                this.addAsChildControl(this, this.content.formSection);
            }
            /* Creates the child components. */
            this.createChildComponents(this.content.formSectionContent);
        };
        /**
         * Initializes the `content.formSectionContent` array correctly depending on the `content.value`.
         * In this case, `content.value` is an array. For each element in the `content.value`, a cloning
         * is done to the `_formArrayPatternContent` array, and it is added in the `content.formSectionContent`;
         * therefore one element is added in the `content.formSection` `FormArray`.
         */
        /**
         * Initializes the `content.formSectionContent` array correctly depending on the `content.value`.
         * In this case, `content.value` is an array. For each element in the `content.value`, a cloning
         * is done to the `_formArrayPatternContent` array, and it is added in the `content.formSectionContent`;
         * therefore one element is added in the `content.formSection` `FormArray`.
         * @protected
         * @return {?}
         */
        ContainerControl.prototype.initFormSectionContentToFormArray = /**
         * Initializes the `content.formSectionContent` array correctly depending on the `content.value`.
         * In this case, `content.value` is an array. For each element in the `content.value`, a cloning
         * is done to the `_formArrayPatternContent` array, and it is added in the `content.formSectionContent`;
         * therefore one element is added in the `content.formSection` `FormArray`.
         * @protected
         * @return {?}
         */
        function () {
            /* At this point, `content.formSectionContent` has at least one element. */
            var e_1, _a;
            /* Saves the pattern content, that is, `content.formSectionContent`.
            It is shared among controls. */
            this._formArrayPatternContent = this.content.formSectionContent;
            /* The `FormArray` is empty initially. */
            this.content.formSectionContent = [];
            /* Saves the pattern value, that is, creates the pattern value following the `_formArrayPatternContent` structure.
            The result value represents a copy of one value that can contain the `content.value` array, and
            sets all its properties/values of built-in type to `undefined`.
            It does not clone a value from the `content.value` array because the array can be empty.
            It creates in deep until the next `FormArray`, then the next `FormArray` creates in deep until the next `FormArray`, and so on.
            It is the first time that the `_formArrayPatternContent` is travelled, therefore the `createValueToUndefined` method does verifications. */
            this._formArrayPatternValue = this.createValueToUndefined();
            /* If the `content.required` field is true, then the container control must have one child control at least. */
            if ((this.content.required) && (this.content.value.length == 0)) {
                /* It can push the `_formArrayPatternValue` and does not push its clone because
                both values have the same properties and there is not problem. */
                this.content.value[0] = this._formArrayPatternValue;
            }
            try {
                /* The `FormArray` will contain one element for each element in the `content.value`. */
                for (var _b = __values(this.content.value), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var val = _c.value;
                    this._initElemFormSectionContentToFormArray(val);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        /**
         * Sets the parent control to its children.
         */
        /**
         * Sets the parent control to its children.
         * @protected
         * @return {?}
         */
        ContainerControl.prototype.setParentToChildren = /**
         * Sets the parent control to its children.
         * @protected
         * @return {?}
         */
        function () {
            this.content.formSectionContent.forEach(this.setParentToChild, this);
        };
        /**
         * Sets the parent control to one child.
         * @param ffc The child to set the parent control.
         */
        /**
         * Sets the parent control to one child.
         * @protected
         * @param {?} ffc The child to set the parent control.
         * @return {?}
         */
        ContainerControl.prototype.setParentToChild = /**
         * Sets the parent control to one child.
         * @protected
         * @param {?} ffc The child to set the parent control.
         * @return {?}
         */
        function (ffc) {
            /* Sets the parent `ContainerControl` to its children. */
            ffc.parentContainerControl = this;
            /* Sets the parent `FormSection` to its children if they have got nothing. */
            ffc.parentFormSection = this.content.formSection;
        };
        /**
         * Returns a new value that is created following the `_formArrayPatternContent` structure.
         * It also sets all its properties/values of built-in type to `undefined`.
         * It creates the value smartly depending on the type of content.
         * It creates in deep until the next `FormArray`, then the next `FormArray` creates in deep until the next `FormArray`, and so on.
         * It is the first time that the `_formArrayPatternContent` is travelled, therefore the `createValueToUndefined` method does verifications.
         */
        /**
         * Returns a new value that is created following the `_formArrayPatternContent` structure.
         * It also sets all its properties/values of built-in type to `undefined`.
         * It creates the value smartly depending on the type of content.
         * It creates in deep until the next `FormArray`, then the next `FormArray` creates in deep until the next `FormArray`, and so on.
         * It is the first time that the `_formArrayPatternContent` is travelled, therefore the `createValueToUndefined` method does verifications.
         * @protected
         * @return {?}
         */
        ContainerControl.prototype.createValueToUndefined = /**
         * Returns a new value that is created following the `_formArrayPatternContent` structure.
         * It also sets all its properties/values of built-in type to `undefined`.
         * It creates the value smartly depending on the type of content.
         * It creates in deep until the next `FormArray`, then the next `FormArray` creates in deep until the next `FormArray`, and so on.
         * It is the first time that the `_formArrayPatternContent` is travelled, therefore the `createValueToUndefined` method does verifications.
         * @protected
         * @return {?}
         */
        function () {
            var e_2, _a;
            /** @type {?} */
            var result;
            /* The `_formArrayPatternContent` array can have one element only with the `content.formSection` field. */
            /** @type {?} */
            var alreadyHasFormSection = false;
            try {
                for (var _b = __values(this._formArrayPatternContent), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var content = _c.value;
                    if (content.formControl) {
                        if (alreadyHasFormSection)
                            throw new Error("For the '" + this.content.name + "' control, the 'content.formSectionContent' array can have one element only with the 'content.formControl' or 'content.formSection' field.");
                        alreadyHasFormSection = true;
                        result = undefined;
                    }
                    else if (content.formSection) {
                        if (alreadyHasFormSection)
                            throw new Error("For the '" + this.content.name + "' control, the 'content.formSectionContent' array can have one element only with the 'content.formControl' or 'content.formSection' field.");
                        alreadyHasFormSection = true;
                        result = this._createValueToUndefined(content);
                    }
                    /* The rest of `content`s do not contain a `value` field of interest. */
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
            if (!alreadyHasFormSection)
                throw new Error("For the '" + this.content.name + "' control, the 'content.formSectionContent' array must have one element only among all with the 'content.formControl' or 'content.formSection' field.");
            return result;
        };
        /**
         * @private
         * @param {?} target
         * @return {?}
         */
        ContainerControl.prototype._createValueToUndefined = /**
         * @private
         * @param {?} target
         * @return {?}
         */
        function (target) {
            var e_3, _a;
            if (target.formSection instanceof forms.FormArray) {
                return [];
            }
            else {
                /** @type {?} */
                var result = {};
                try {
                    for (var _b = __values(target.formSectionContent), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var content = _c.value;
                        if (content.formControl)
                            result[content.name] = undefined;
                        else if (content.formSection)
                            result[content.name] = this._createValueToUndefined(content);
                        /* The rest of `content`s do not contain a `value` field of interest. */
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return result;
            }
        };
        /**
         * Initializes and returns a clone of the `_formArrayPatternContent` array correctly
         * depending on the specified `value`.
         * This clone is also added in the `content.formSectionContent` array.
         * @param value The initial `value` field of each content representing a `FormControl`.
         */
        /**
         * Initializes and returns a clone of the `_formArrayPatternContent` array correctly
         * depending on the specified `value`.
         * This clone is also added in the `content.formSectionContent` array.
         * @private
         * @param {?} value The initial `value` field of each content representing a `FormControl`.
         * @return {?}
         */
        ContainerControl.prototype._initElemFormSectionContentToFormArray = /**
         * Initializes and returns a clone of the `_formArrayPatternContent` array correctly
         * depending on the specified `value`.
         * This clone is also added in the `content.formSectionContent` array.
         * @private
         * @param {?} value The initial `value` field of each content representing a `FormControl`.
         * @return {?}
         */
        function (value) {
            var e_4, _a;
            /* The content array cloned. */
            /** @type {?} */
            var result = [];
            /** @type {?} */
            var refContent;
            try {
                for (var _b = __values(this._formArrayPatternContent), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var content = _c.value;
                    /* Clones in deep until the next `FormArray`, then the next `FormArray` clones in deep until the next `FormArray`, and so on. */
                    if (content.formSection instanceof forms.FormArray) {
                        /* This `content.formSectionContent` will not be cloned because it belongs to a `FormArray` and it will be cloned when the `FormArray` is analyzed in the `ContainerControl` class. */
                        refContent = this._cloneContent(content, undefined /* It is not used in this case. */, false);
                        refContent.value = value;
                    }
                    else {
                        refContent = this._cloneContent(content, value, true);
                    }
                    /* Sets the parent control to its child. */
                    this.setParentToChild(refContent);
                    /* Overwrites some properties for the content cloned. */
                    refContent.name = this._formArrayLength.toString(10); /* The element is added in the `FormArray` after the last position. */
                    /* Overwrites some properties for the content cloned if it contains the `content.formControl` or `content.formSection` field. */
                    if ((content.formControl) || (content.formSection)) {
                        // refContent.label = ((refContent.label == undefined) ? (refContent.name) : (refContent.label + refContent.name));
                        // refContent.ariaLabel = refContent.label;
                    }
                    /* Save the content cloned. */
                    this.content.formSectionContent.push(refContent);
                    result.push(refContent);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_4) throw e_4.error; }
            }
            this._formArrayLength++;
            return result;
        };
        /**
         * Returns a new content that represents the clone of the specified content target.
         * It also sets the initial `value` field of each content representing a `FormControl`.
         * It clones the content smartly depending on the type of property.
         * It clones in deep until the next `FormArray`, then the next `FormArray` clones in deep until the next `FormArray`, and so on.
         * @param target The content object to clone.
         * @param value The initial `value` field of each content representing a `FormControl`.
         * @param canClone It is true if the function can clone the `formSectionContent` field; otherwise, false.
         */
        /**
         * Returns a new content that represents the clone of the specified content target.
         * It also sets the initial `value` field of each content representing a `FormControl`.
         * It clones the content smartly depending on the type of property.
         * It clones in deep until the next `FormArray`, then the next `FormArray` clones in deep until the next `FormArray`, and so on.
         * @private
         * @param {?} target The content object to clone.
         * @param {?} value The initial `value` field of each content representing a `FormControl`.
         * @param {?} canClone It is true if the function can clone the `formSectionContent` field; otherwise, false.
         * @return {?}
         */
        ContainerControl.prototype._cloneContent = /**
         * Returns a new content that represents the clone of the specified content target.
         * It also sets the initial `value` field of each content representing a `FormControl`.
         * It clones the content smartly depending on the type of property.
         * It clones in deep until the next `FormArray`, then the next `FormArray` clones in deep until the next `FormArray`, and so on.
         * @private
         * @param {?} target The content object to clone.
         * @param {?} value The initial `value` field of each content representing a `FormControl`.
         * @param {?} canClone It is true if the function can clone the `formSectionContent` field; otherwise, false.
         * @return {?}
         */
        function (target, value, canClone) {
            var e_5, _a;
            /* The content cloned. */
            /** @type {?} */
            var result = {};
            for (var prop in target) {
                switch (prop) {
                    /* The `formControl` property special case. */
                    case 'formControl':
                        {
                            result[prop] = cloneFormControl(target.formControl);
                            /* If this content (`result`) represents a `FormControl`, then the `value` field is initialized. */
                            result['value'] = value;
                            break;
                        }
                    /* The `formSection` property special case. */
                    case 'formSection':
                        {
                            result[prop] = cloneFormSection(target.formSection);
                            break;
                        }
                    /* The `formSectionContent` property special case. */
                    case 'formSectionContent':
                        {
                            if (canClone) /* Clones the `target.formSectionContent`. */ {
                                result[prop] = [];
                                try {
                                    for (var _b = (e_5 = void 0, __values(target.formSectionContent)), _c = _b.next(); !_c.done; _c = _b.next()) {
                                        var content = _c.value;
                                        if (content.formSection instanceof forms.FormArray) {
                                            content.value = value[content.name];
                                            /* This `content.formSectionContent` will not be cloned because it belongs to a `FormArray` and it will be cloned when the `FormArray` is analyzed in the `ContainerControl` class. */
                                            result[prop].push(this._cloneContent(content, undefined /* It is not used in this case. */, false));
                                            content.value = undefined;
                                        }
                                        else {
                                            result[prop].push(this._cloneContent(content, value[content.name], canClone));
                                        }
                                    }
                                }
                                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                                finally {
                                    try {
                                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                                    }
                                    finally { if (e_5) throw e_5.error; }
                                }
                            }
                            else /* Takes the same `target.formSectionContent` reference because `target` is a `FormArray` and its `formSectionContent` will be taken like a pattern. */ {
                                result[prop] = target.formSectionContent;
                            }
                            break;
                        }
                    /* Copies the property without problem. */
                    default:
                        {
                            result[prop] = target[prop];
                            break;
                        }
                }
            }
            return result;
        };
        /**
         * Creates the child components.
         * @param componentsContent Components content array for creating the components.
         */
        /**
         * Creates the child components.
         * @protected
         * @param {?} componentsContent Components content array for creating the components.
         * @return {?}
         */
        ContainerControl.prototype.createChildComponents = /**
         * Creates the child components.
         * @protected
         * @param {?} componentsContent Components content array for creating the components.
         * @return {?}
         */
        function (componentsContent) {
            var e_6, _a;
            try {
                for (var componentsContent_1 = __values(componentsContent), componentsContent_1_1 = componentsContent_1.next(); !componentsContent_1_1.done; componentsContent_1_1 = componentsContent_1.next()) {
                    var componentContent = componentsContent_1_1.value;
                    /* Creates a child component. */
                    this.createChildComponent(componentContent);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (componentsContent_1_1 && !componentsContent_1_1.done && (_a = componentsContent_1.return)) _a.call(componentsContent_1);
                }
                finally { if (e_6) throw e_6.error; }
            }
        };
        /**
         * Creates a child component.
         * @param componentContent Component content for creating the component.
         */
        /**
         * Creates a child component.
         * @protected
         * @param {?} componentContent Component content for creating the component.
         * @return {?}
         */
        ContainerControl.prototype.createChildComponent = /**
         * Creates a child component.
         * @protected
         * @param {?} componentContent Component content for creating the component.
         * @return {?}
         */
        function (componentContent) {
            this._cr = this._viewContainerRef.createComponent(this._componentFactoryResolver.resolveComponentFactory(componentContent.controlType));
            ((/** @type {?} */ (this._cr.instance))).content = componentContent;
        };
        /**
         * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
         * It also checks if the specified `content.value` is correct. For internal use only.
         */
        /**
         * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
         * It also checks if the specified `content.value` is correct. For internal use only.
         * @protected
         * @return {?}
         */
        ContainerControl.prototype.initValue = /**
         * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
         * It also checks if the specified `content.value` is correct. For internal use only.
         * @protected
         * @return {?}
         */
        function () {
            /* It does not need to do something because the child controls are already initialized. */
            // /* In this way, checks if the specified `content.value` is correct. */
            // this.content.formControl.setValue(this.content.value);
            // /* Marks the control as `touched`. */
            // this.content.formControl.markAsTouched({
            //     onlySelf: true
            // });
        };
        Object.defineProperty(ContainerControl.prototype, "getInstance", {
            /**
             * Returns this instance.
             */
            get: /**
             * Returns this instance.
             * @return {?}
             */
            function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContainerControl.prototype, "containerControlChildren", {
            /**
             * Returns an array of controls that represents the `ContainerControl`'s child controls.
             * It is always set internally.
             */
            get: /**
             * Returns an array of controls that represents the `ContainerControl`'s child controls.
             * It is always set internally.
             * @return {?}
             */
            function () {
                return this.content.containerControlChildren;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContainerControl.prototype, "formArrayPatternContent", {
            /**
             * If the `content.formSection` represents a `FormArray`, then this field returns
             * a pattern content that is `content.formSectionContent[0]` value; otherwise, returns `undefined`.
             * It is shared among controls.
             * It is used for adding a new element in the `content.formSectionContent`, that is,
             * for adding a new control in the `FormArray`.
             * By default, its value is `undefined`.
             */
            get: /**
             * If the `content.formSection` represents a `FormArray`, then this field returns
             * a pattern content that is `content.formSectionContent[0]` value; otherwise, returns `undefined`.
             * It is shared among controls.
             * It is used for adding a new element in the `content.formSectionContent`, that is,
             * for adding a new control in the `FormArray`.
             * By default, its value is `undefined`.
             * @return {?}
             */
            function () {
                return this._formArrayPatternContent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContainerControl.prototype, "formArrayPatternValue", {
            /**
             * If the `content.formSection` represents a `FormArray`, then this field returns
             * a pattern value that is a clone of the `content.value[0]` value, and sets all
             * its properties/values of built-in type to `undefined`; otherwise, returns `undefined`.
             * It is used for adding a new element in the `content.formSectionContent`.
             * By default, its value is `undefined`.
             */
            get: /**
             * If the `content.formSection` represents a `FormArray`, then this field returns
             * a pattern value that is a clone of the `content.value[0]` value, and sets all
             * its properties/values of built-in type to `undefined`; otherwise, returns `undefined`.
             * It is used for adding a new element in the `content.formSectionContent`.
             * By default, its value is `undefined`.
             * @return {?}
             */
            function () {
                return this._formArrayPatternValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContainerControl.prototype, "isDynamic", {
            /**
             * Returns true if the container control has a dynamic length, that is, the `content.formSection` field
             * represents a `FormArray` and its length is not fixed; otherwise, false.
             * This property has sense only when the `content.formSection` field represents a `FormArray`.
             */
            get: /**
             * Returns true if the container control has a dynamic length, that is, the `content.formSection` field
             * represents a `FormArray` and its length is not fixed; otherwise, false.
             * This property has sense only when the `content.formSection` field represents a `FormArray`.
             * @return {?}
             */
            function () {
                return this.content.isDynamic;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContainerControl.prototype, "isFormArray", {
            /**
             * Returns true if the container control is a `FormArray`, that is, the `content.formSection` field
             * represents a `FormArray`; otherwise, false.
             */
            get: /**
             * Returns true if the container control is a `FormArray`, that is, the `content.formSection` field
             * represents a `FormArray`; otherwise, false.
             * @return {?}
             */
            function () {
                return this._isFormArray;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContainerControl.prototype, "isEmpty", {
            /**
             * Returns true if this container is empty; otherwise, false.
             */
            get: /**
             * Returns true if this container is empty; otherwise, false.
             * @return {?}
             */
            function () {
                return (this.content.formSectionContent.length == 0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContainerControl.prototype, "canRemoveFromFormArray", {
            /**
             * Returns true if an element can be removed from the `content.formSection`; otherwise, false.
             * Use along with `removeFromFormArray` and `clearFormArray` methods.
             * The `content.formSection` must be an instance of `FormArray`.
             */
            get: /**
             * Returns true if an element can be removed from the `content.formSection`; otherwise, false.
             * Use along with `removeFromFormArray` and `clearFormArray` methods.
             * The `content.formSection` must be an instance of `FormArray`.
             * @return {?}
             */
            function () {
                /* The method uses the `_formArrayLength` instead of `content.formSection` because
                the first one field is updated first and it has the answer more accurate than the second one field. */
                if (this.content.required) {
                    return (this._formArrayLength > 1);
                }
                else {
                    return (this._formArrayLength != 0);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds an empty element at the end of the `content.formSectionContent`; therefore one element
         * is added at the end of the `content.formSection` `FormArray`.
         * The `content.formSection` must be an instance of `FormArray`.
         */
        /**
         * Adds an empty element at the end of the `content.formSectionContent`; therefore one element
         * is added at the end of the `content.formSection` `FormArray`.
         * The `content.formSection` must be an instance of `FormArray`.
         * @return {?}
         */
        ContainerControl.prototype.addToFormArray = /**
         * Adds an empty element at the end of the `content.formSectionContent`; therefore one element
         * is added at the end of the `content.formSection` `FormArray`.
         * The `content.formSection` must be an instance of `FormArray`.
         * @return {?}
         */
        function () {
            console.log('addToFormArray');
            if (this._isFormArray) {
                this.createChildComponents(this._initElemFormSectionContentToFormArray(this._formArrayPatternValue));
            }
            else {
                throw new Error("For the '" + this.content.name + "' control, the 'content.formSection' value must be an instance of 'FormArray'.");
            }
        };
        /**
         * Removes the element at the given `index` in the `content.formSectionContent`; therefore
         * the element at the given `index` is removed in the `content.formSection` `FormArray`.
         * The `content.formSection` must be an instance of `FormArray`.
         * @param index Index in the array to remove the element.
         */
        /**
         * Removes the element at the given `index` in the `content.formSectionContent`; therefore
         * the element at the given `index` is removed in the `content.formSection` `FormArray`.
         * The `content.formSection` must be an instance of `FormArray`.
         * @param {?} index Index in the array to remove the element.
         * @return {?}
         */
        ContainerControl.prototype.removeFromFormArray = /**
         * Removes the element at the given `index` in the `content.formSectionContent`; therefore
         * the element at the given `index` is removed in the `content.formSection` `FormArray`.
         * The `content.formSection` must be an instance of `FormArray`.
         * @param {?} index Index in the array to remove the element.
         * @return {?}
         */
        function (index) {
            console.log('removeFromFormArray', index);
            if (this._isFormArray) {
                //TODO: la variable `formArrayPatternContentLength` podría ser un campo de la clase. 
                /** @type {?} */
                var formArrayPatternContentLength = this._formArrayPatternContent.length;
                /** @type {?} */
                var i = void 0;
                /** @type {?} */
                var j = void 0;
                /** @type {?} */
                var k = void 0;
                this.content.containerControlChildren.splice(index, 1);
                this.content.formSectionContent.splice((index * formArrayPatternContentLength), formArrayPatternContentLength);
                ((/** @type {?} */ (this.content.formSection))).removeAt(index);
                for (i = formArrayPatternContentLength, j = index * formArrayPatternContentLength; i != 0; i--) {
                    this._viewContainerRef.remove(j);
                }
                this._formArrayLength--;
                /* Updates the elements' index in the `content.formSectionContent` array from
                the specified `index` onwards. */
                for (k = (i = index * formArrayPatternContentLength) + formArrayPatternContentLength, j = this.content.formSectionContent.length; i < j; i++) {
                    if (i == k) {
                        index++;
                        k += formArrayPatternContentLength;
                    }
                    this.content.formSectionContent[i].name = index.toString(10);
                }
            }
            else {
                throw new Error("For the '" + this.content.name + "' control, the 'content.formSection' value must be an instance of 'FormArray'.");
            }
        };
        /**
         * Removes all elements in the `content.formSectionContent`; therefore
         * all elements are removed in the `content.formSection` `FormArray`.
         * The `content.formSection` must be an instance of `FormArray`.
         */
        /**
         * Removes all elements in the `content.formSectionContent`; therefore
         * all elements are removed in the `content.formSection` `FormArray`.
         * The `content.formSection` must be an instance of `FormArray`.
         * @return {?}
         */
        ContainerControl.prototype.clearFormArray = /**
         * Removes all elements in the `content.formSectionContent`; therefore
         * all elements are removed in the `content.formSection` `FormArray`.
         * The `content.formSection` must be an instance of `FormArray`.
         * @return {?}
         */
        function () {
            console.log('clearFormArray');
            if (this._isFormArray) {
                this.content.containerControlChildren = [];
                this.content.formSectionContent = [];
                ((/** @type {?} */ (this.content.formSection))).clear();
                this._viewContainerRef.clear();
                this._formArrayLength = 0;
                if (this.content.required) {
                    /* The `FormArray` always has one element at least. */
                    this.addToFormArray();
                }
            }
            else {
                throw new Error("For the '" + this.content.name + "' control, the 'content.formSection' value must be an instance of 'FormArray'.");
            }
        };
        ContainerControl.propDecorators = {
            content: [{ type: core.Input }],
            _componentHost: [{ type: core.ViewChild, args: [GetViewContainerDirective, { static: true },] }]
        };
        return ContainerControl;
    }(FormFieldControl));
    if (false) {
        /**
         * Input field that contains the content of this class.
         * @type {?}
         */
        ContainerControl.prototype.content;
        /**
         * Returns the helper directive to mark valid insertion point in the `ContainerControl`'s template.
         * @type {?}
         * @protected
         */
        ContainerControl.prototype._componentHost;
        /**
         * Returns the view container of the element that will host the child components in the `ContainerControl`'s template.
         * This field can only be assigned in the `ContainerControl` class.
         * The `content.formSectionContent` and container's `_viewContainerRef` have the same length.
         * @type {?}
         * @protected
         */
        ContainerControl.prototype._viewContainerRef;
        /**
         * Returns the factory for a given component type.
         * This field can only be assigned in the `ContainerControl` class.
         * @type {?}
         * @protected
         */
        ContainerControl.prototype._componentFactoryResolver;
        /**
         * Returns the component created by a `ComponentFactory`.
         * For only internal use by the `createChildComponent` method.
         * @type {?}
         * @protected
         */
        ContainerControl.prototype._cr;
        /**
         * Returns true if the container control is a `FormArray`, that is, the `content.formSection` field
         * represents a `FormArray`; otherwise, false.
         * By default, its value is `false`.
         * @type {?}
         * @private
         */
        ContainerControl.prototype._isFormArray;
        /**
         * If the `content.formSection` represents a `FormArray`, then this field returns
         * a pattern content that is `content.formSectionContent` value; otherwise, returns `undefined`.
         * It is shared among controls.
         * It is used for adding a new element in the `content.formSectionContent`, that is,
         * for adding a new control in the `FormArray`.
         * By default, its value is `[]`.
         * @type {?}
         * @private
         */
        ContainerControl.prototype._formArrayPatternContent;
        /**
         * If the `content.formSection` represents a `FormArray`, then this field returns
         * a pattern value that is a copy of one value that can contain the `content.value` array, and sets all
         * its properties/values of built-in type to `undefined`; otherwise, returns `undefined`.
         * It is used for adding a new element in the `content.formSectionContent`, that is,
         * for adding a new control in the `FormArray`.
         * By default, its value is `undefined`.
         * @type {?}
         * @private
         */
        ContainerControl.prototype._formArrayPatternValue;
        /**
         * Returns the current `FormArray` length.
         * This field has sense only when the `content.formSection` field represents a `FormArray`.
         * By default, its value is `0`.
         * @type {?}
         * @private
         */
        ContainerControl.prototype._formArrayLength;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/container/form-container/form-container.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This interface is deprecated.
     * @record
     */
    function FormContainerAction() { }
    if (false) {
        /**
         * @param {?} data
         * @return {?}
         */
        FormContainerAction.prototype.doit = function (data) { };
    }
    /**
     * This interface is deprecated.
     * An interface that represents the content of an expansion control.
     * @record
     */
    function PanelContent_Depr() { }
    if (false) {
        /**
         * Returns the panel's title.
         * @type {?}
         */
        PanelContent_Depr.prototype.title;
        /**
         * Returns the panel's description.
         * @type {?}
         */
        PanelContent_Depr.prototype.description;
        /**
         * Returns the panel's icon name.
         * @type {?}
         */
        PanelContent_Depr.prototype.iconName;
        /**
         * Returns the action and action labels for each panel.
         * @type {?|undefined}
         */
        PanelContent_Depr.prototype.action;
        /** @type {?|undefined} */
        PanelContent_Depr.prototype.actionLabel;
        /**
         * Returns true is the panel is open; otherwise, false.
         * @type {?|undefined}
         */
        PanelContent_Depr.prototype.open;
    }
    /**
     * This component is deprecated.
     * Represents a control that contains a list of panels and sends that information to the server.
     */
    var FormContainerComponent = /** @class */ (function (_super) {
        __extends(FormContainerComponent, _super);
        function FormContainerComponent() {
            var _this = _super.call(this) || this;
            _this.useAccordion = true;
            _this.useContainer = true;
            _this.actionButtonIsStepperNext = false;
            _this.deleteValuesAfterAction = true;
            /* By default, the first panel is expanded. */
            _this.step = 0;
            return _this;
        }
        /**
         * @private
         * @return {?}
         */
        FormContainerComponent.prototype.setFormGroupToPanels = /**
         * @private
         * @return {?}
         */
        function () {
            this.panelsContent.forEach((/**
             * @param {?} panel
             * @return {?}
             */
            function (panel) {
                panel.formSection = panel.formSection;
            }));
        };
        /**
         * @return {?}
         */
        FormContainerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            console.log("on INIT call", this.panelsContent);
            /* Sets the default values. */
            if (this.panelsContent.length > 0) {
                this.content = {
                    formSection: this.panelsContent[0].formSection,
                    name: "FormContainerComponent",
                    label: "FormContainerComponent_Label",
                    type: undefined,
                    value: "FormContainerComponent",
                    //            'width': '100%',
                    ariaLabel: "FormContainerComponent",
                    formSectionContent: this.panelsContent[0].formSectionContent,
                };
            }
            this.init(undefined);
            // if actionLabel is undefined, means that there is no actionLabel, the user must decide!!!
            // if (this.actionLabel == undefined) this.actionLabel = 'Adicionar';
            this.setFormGroupToPanels();
        };
        /**
         * @return {?}
         */
        FormContainerComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            console.log("on CHANGES call", this.panelsContent);
            this.ngOnInit();
            // this.init(this.content.label, false, false);
            // this.setFormGroupToPanels();
        };
        /**
         * Sets the new expanded panel position.
         * @param newStep The new position.
         */
        /**
         * Sets the new expanded panel position.
         * @param {?} newStep The new position.
         * @return {?}
         */
        FormContainerComponent.prototype.setStep = /**
         * Sets the new expanded panel position.
         * @param {?} newStep The new position.
         * @return {?}
         */
        function (newStep) {
            this.step = newStep;
        };
        /**
         * Sets the expanded panel position to the next position.
         */
        /**
         * Sets the expanded panel position to the next position.
         * @return {?}
         */
        FormContainerComponent.prototype.nextStep = /**
         * Sets the expanded panel position to the next position.
         * @return {?}
         */
        function () {
            this.step++;
        };
        /**
         * Sets the expanded panel position to the previous position.
         */
        /**
         * Sets the expanded panel position to the previous position.
         * @return {?}
         */
        FormContainerComponent.prototype.prevStep = /**
         * Sets the expanded panel position to the previous position.
         * @return {?}
         */
        function () {
            this.step--;
        };
        /**
         * Sends data to the server. Collects all added information from the component.
         * Creates a JSON object based on `form.name` and `form.value` fields.
         */
        /**
         * Sends data to the server. Collects all added information from the component.
         * Creates a JSON object based on `form.name` and `form.value` fields.
         * @return {?}
         */
        FormContainerComponent.prototype.doAction = /**
         * Sends data to the server. Collects all added information from the component.
         * Creates a JSON object based on `form.name` and `form.value` fields.
         * @return {?}
         */
        function () {
            //TODO: poner este method in `ContainerControl`.
            //TODO: poner este method in `ContainerControl`.
            /* Prepares all data. */
            /** @type {?} */
            var data = {};
            this.panelsContent.forEach((/**
             * @param {?} panel
             * @return {?}
             */
            function (panel) {
                panel.formSectionContent.forEach((/**
                 * @param {?} controlContent
                 * @return {?}
                 */
                function (controlContent) {
                    data[controlContent.name] = controlContent.value;
                }));
            }));
            if (this.action) {
                this.action.doit(data);
            }
            if (this.deleteValuesAfterAction) {
                this.panelsContent.forEach((/**
                 * @param {?} panel
                 * @return {?}
                 */
                function (panel) {
                    panel.formSectionContent.forEach((/**
                     * @param {?} controlContent
                     * @return {?}
                     */
                    function (controlContent) {
                        controlContent.value = undefined;
                    }));
                }));
            }
        };
        FormContainerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-form-container",
                        template: "\n<ng-container *ngIf=\"(panelsContent)\">\n\n    <ng-container *ngIf=\"useContainer\">\n        <mat-accordion *ngIf=\"(useAccordion)\" class=\"toco-form-container\" multi=\"true\">\n\n            <mat-expansion-panel *ngFor=\"let panel of panelsContent; let newStep = index; let count=count\"\n                [expanded]=\"panel.open\" (opened)=\"setStep(newStep)\">\n        \n                <mat-expansion-panel-header>\n                    <mat-panel-title>\n                        {{ panel.title }}\n                    </mat-panel-title>\n                    <mat-panel-description>\n                        {{ panel.description }}\n                        <mat-icon>{{ panel.iconName }}</mat-icon>\n                    </mat-panel-description>\n                </mat-expansion-panel-header>\n        \n                <component-factory-depr [componentsContent]=\"panel.formSectionContent\"></component-factory-depr>\n        \n                <mat-action-row *ngIf=\"panel.actionLabel\">\n                    <!-- <button mat-button *ngIf=\"newStep > 0\" color=\"warn\" (click)=\"prevStep()\">Anterior</button>\n                    <button mat-button *ngIf=\"newStep != count-1\" color=\"primary\" (click)=\"nextStep()\">Siguente</button> -->\n        \n                    <button *ngIf=\"panel.actionLabel\" mat-button color=\"accent\" (click)=\"panel.action.doit(newStep)\">{{ panel.actionLabel }}</button>\n                    <!-- <button *ngIf=\"i == l-1 && actionButtonIsStepperNext\" mat-button matStepperNext color=\"primary\" (click)=\"doAction()\">{{actionLabel}}</button> -->\n                </mat-action-row>\n\n            </mat-expansion-panel>\n\n            <button *ngIf=\"actionLabel\" mat-raised-button color=\"primary\" (click)=\"doAction()\">{{actionLabel}}</button>\n        </mat-accordion>\n        \n        <div *ngIf=\"(!useAccordion)\" class=\"toco-form-container\">\n            <div *ngFor=\"let panel of panelsContent; let i=index; let count=count\">\n                <mat-card [ngStyle]=\"{'margin-bottom': '1em'}\">\n                    <mat-card-header>\n                        <mat-card-title>\n                            {{ panel.title }}\n                        </mat-card-title>\n                        <mat-card-subtitle *ngIf=\"panel.description\">\n                            {{ panel.description }}\n                            <mat-icon>{{ panel.iconName }}</mat-icon>\n                        </mat-card-subtitle>\n                    </mat-card-header>\n            \n                    <mat-card-content>\n                        <component-factory-depr [componentsContent]=\"panel.formSectionContent\"></component-factory-depr>\n                    </mat-card-content>\n            \n                    <mat-card-actions *ngIf=\"i == count-1 && actionLabel\" fxLayout=\"row\" fxLayoutAlign=\"end center\">\n                        <button mat-button color=\"primary\" (click)=\"doAction()\">{{ actionLabel }}</button>\n                    </mat-card-actions>\n                </mat-card>\n            </div>\n        </div>\n    </ng-container>\n\n    <div fxLayout=\"column\" *ngIf=\"!useContainer\">\n        <div *ngFor=\"let panel of panelsContent; let i=index; let count=count\" class=\"toco-form-container\">\n            <component-factory-depr [componentsContent]=\"panel.formSectionContent\"></component-factory-depr>\n        </div>\n        <div  *ngIf=\"actionLabel\" fxLayout=\"row\" fxLayoutAlign=\"end center\">\n            <button mat-button color=\"primary\" (click)=\"doAction()\">{{ actionLabel }}</button>\n        </div>\n    </div>\n\n</ng-container>\n",
                        styles: [".toco-form-container{width:100%;margin-bottom:1em}"]
                    }] }
        ];
        /** @nocollapse */
        FormContainerComponent.ctorParameters = function () { return []; };
        FormContainerComponent.propDecorators = {
            panelsContent: [{ type: core.Input }],
            useAccordion: [{ type: core.Input }],
            useContainer: [{ type: core.Input }],
            actionButtonIsStepperNext: [{ type: core.Input }],
            action: [{ type: core.Input }],
            actionLabel: [{ type: core.Input }],
            deleteValuesAfterAction: [{ type: core.Input }]
        };
        return FormContainerComponent;
    }(ContainerControl));
    if (false) {
        /**
         * Input field that contains the content of this class. The array of panels to show.
         * @type {?}
         */
        FormContainerComponent.prototype.panelsContent;
        /** @type {?} */
        FormContainerComponent.prototype.useAccordion;
        /** @type {?} */
        FormContainerComponent.prototype.useContainer;
        /** @type {?} */
        FormContainerComponent.prototype.actionButtonIsStepperNext;
        /** @type {?} */
        FormContainerComponent.prototype.action;
        /**
         * An string that represents the action label of the last panel.
         * @type {?}
         */
        FormContainerComponent.prototype.actionLabel;
        /** @type {?} */
        FormContainerComponent.prototype.deleteValuesAfterAction;
        /**
         * The current expanded panel position.
         * @type {?}
         */
        FormContainerComponent.prototype.step;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/container/panel/panel-container.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * An interface that represents the content of a panel control.
     * @record
     */
    function PanelContent() { }
    if (false) {
        /**
         * Returns the panel's description.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        PanelContent.prototype.description;
        /**
         * Returns the panel's icon name.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        PanelContent.prototype.iconName;
    }
    /**
     * Represents a container control that is showed as a panel.
     * Usage notes:
     *  - It can be used as:
     * <container-panel [content]="panelContent"></container-panel>
     * Where `content.formSection` is created, for example, as this:
     * this.content.formSection = new FormGroup({ }, [ ]);
     */
    var ContainerPanelComponent = /** @class */ (function (_super) {
        __extends(ContainerPanelComponent, _super);
        function ContainerPanelComponent() {
            return _super.call(this) || this;
        }
        /**
         * @return {?}
         */
        ContainerPanelComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init('');
        };
        /**
         * Initializes the `content` input property.
         * @param label The default label to use. It is used if the `content.label` is not specified.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @return {?}
         */
        ContainerPanelComponent.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @return {?}
         */
        function (label) {
            /* Sets the default values. */
            _super.prototype.init.call(this, label);
            /* The `content.description`, and `content.iconName` fields
            have the `undefined` value by default. */
        };
        ContainerPanelComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'container-panel',
                        template: "<mat-card\n  class=\"container-panel-mat-card\"\n  [formGroup]=\"content.formSection\"\n  [attr.aria-label]=\"content.ariaLabel\"\n>\n  <mat-card-header>\n    <mat-card-title *ngIf=\"content.label\">\n      {{ content.label }}\n    </mat-card-title>\n    <mat-card-subtitle *ngIf=\"content.description\">\n      {{ content.description }}\n      <mat-icon>{{ content.iconName }}</mat-icon>\n    </mat-card-subtitle>\n  </mat-card-header>\n\n  <mat-card-content\n    fxLayout=\"row wrap\"\n    fxLayout.xs=\"column\"\n    fxLayoutAlign=\"space-between end\"\n    fxLayoutAlign.xs=\"space-between center\"\n    fxLayoutGap=\"1em\"\n    class=\"form-field-component\"\n  >\n    <ng-template get-view-container></ng-template>\n  </mat-card-content>\n\n  <mat-card-actions *ngIf=\"content.isDynamic\">\n    <button mat-raised-button color=\"primary\" (click)=\"addToFormArray()\">\n      <!-- <mat-icon>add box</mat-icon> -->\n      <mat-icon>add_circle</mat-icon>\n      Add new item\n    </button>\n    <button\n      mat-raised-button\n      color=\"primary\"\n      [disabled]=\"!canRemoveFromFormArray\"\n      (click)=\"clearFormArray()\"\n    >\n      <!-- <mat-icon>remove box</mat-icon> -->\n      <mat-icon>remove_circle</mat-icon>\n      Clear all\n    </button>\n  </mat-card-actions>\n</mat-card>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        ContainerPanelComponent.ctorParameters = function () { return []; };
        ContainerPanelComponent.propDecorators = {
            content: [{ type: core.Input }]
        };
        return ContainerPanelComponent;
    }(ContainerControl));
    if (false) {
        /**
         * Input field that contains the content of this class.
         * @type {?}
         */
        ContainerPanelComponent.prototype.content;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/container/simple/simple-container.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a container control that is showed very simple.
     * Usage notes:
     *  - It can be used as:
     * <container-simple [content]="simpleContent"></container-simple>
     * Where `content.formSection` is created, for example, as this:
     * this.content.formSection = new FormGroup({ }, [ ]);
     */
    var ContainerSimpleComponent = /** @class */ (function (_super) {
        __extends(ContainerSimpleComponent, _super);
        function ContainerSimpleComponent() {
            return _super.call(this) || this;
        }
        /**
         * @return {?}
         */
        ContainerSimpleComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init('');
        };
        /**
         * Initializes the `content` input property.
         * @param label The default label to use. It is used if the `content.label` is not specified.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @return {?}
         */
        ContainerSimpleComponent.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @return {?}
         */
        function (label) {
            /* Sets the default values. */
            _super.prototype.init.call(this, label);
        };
        ContainerSimpleComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'container-simple',
                        template: "\n<!-- TODO: En dependencia del valor de `appearance`, se aplican las clases CSS para lograr la apariencia deseada. \n     Actualmente, `appearance = 'outline'` es el \u00FAnico que est\u00E1 hecho. -->\n<fieldset class=\"container-simple-form-field\" [formGroup]=\"content.formSection\" [attr.aria-label]=\"content.ariaLabel\">\n    <legend class=\"container-simple-form-field-legend\">{{ content.label }}</legend>\n\n    <ng-template get-view-container></ng-template>\n\n    <ng-container *ngIf=\"content.isDynamic\">\n        <button mat-raised-button color=\"primary\" (click)=\"addToFormArray()\">\n            <!-- <mat-icon>add box</mat-icon> -->\n            <mat-icon>add_circle</mat-icon>\n            Add new item\n        </button>\n        <button mat-raised-button color=\"primary\" [disabled]=\"!canRemoveFromFormArray\" (click)=\"clearFormArray()\">\n            <!-- <mat-icon>remove box</mat-icon> -->\n            <mat-icon>remove_circle</mat-icon>\n            Clear all\n        </button>\n    </ng-container>\n\n</fieldset>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".container-simple-form-field{margin:-4px 0 24px;padding:0 10px 14px;cursor:default;background-color:#fff;border:1px solid rgba(0,0,0,.12);border-radius:4px}.container-simple-form-field-legend{padding:0 4px;background-color:#fff;color:rgba(0,0,0,.6);font-size:10px}"]
                    }] }
        ];
        /** @nocollapse */
        ContainerSimpleComponent.ctorParameters = function () { return []; };
        return ContainerSimpleComponent;
    }(ContainerControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/container/table/table.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var CellContentWrap = {
        /**
         * The `break` wrap breaks the content when reaching the end of a line.
         */
        break: 0,
        /**
         * The `ellipsis` wrap clips the remaining content and renders an ellipsis ("...")
         * to represent the clipped content.
         */
        ellipsis: 1,
        /**
         * The `responsible` wrap is the default style. It only applies the responsible styles
         * that are defined in the table.
         */
        responsible: 2,
    };
    CellContentWrap[CellContentWrap.break] = 'break';
    CellContentWrap[CellContentWrap.ellipsis] = 'ellipsis';
    CellContentWrap[CellContentWrap.responsible] = 'responsible';
    /**
     * @record
     */
    function TableAction() { }
    if (false) {
        /** @type {?} */
        TableAction.prototype.icon;
        /** @type {?} */
        TableAction.prototype.route;
        /** @type {?} */
        TableAction.prototype.tooltip;
    }
    /**
     * A interface that represents the content of a table control.
     * The generic parameter T always refers to the type of data that it is dealing with.
     * @record
     * @template T
     */
    function TableContent() { }
    if (false) {
        /**
         * Returns the array of strings that indicates the object property name of the columns.
         * By default, its value is `[]`.
         * @type {?|undefined}
         */
        TableContent.prototype.columnsObjectProperty;
        /**
         * Returns the array of strings that indicates the header text of the columns.
         * By default, its value is `[]`.
         * @type {?|undefined}
         */
        TableContent.prototype.columnsHeaderText;
        /**
         * Returns the array of strings that indicates the width of the columns.
         * By default, its value is `[]`.
         * @type {?|undefined}
         */
        TableContent.prototype.columnsWidth;
        /**
         * Returns the array of `CellContentWrap` that indicates how to wrap the content of the columns.
         * By default, its value is `[]`.
         * @type {?|undefined}
         */
        TableContent.prototype.columnContentWrap;
        /**
         * Returns a function that creates the list of CSS classes to apply to the table rows.
         * In order to take effect these classes, the table CSS file must have defined these classes.
         * By default, its value is `undefined`.
         * \@param rowData The data that is contained in the row.
         * @type {?|undefined}
         */
        TableContent.prototype.createCssClassesForRow;
        /**
         * Returns the property name of the data contained in `page` that is used to identify that data.
         * By default, its value is `''`.
         * @type {?|undefined}
         */
        TableContent.prototype.propertyNameToIdentify;
        /**
         * The current filter state.
         * By default, its value is `{}`.
         * @type {?|undefined}
         */
        TableContent.prototype.filter;
        /**
         * The current sort state.
         * By default, its value is `{ 'active': propertyNameToIdentify, 'direction': SortDirection.asc }`.
         * @type {?|undefined}
         */
        TableContent.prototype.sort;
        /**
         * Returns the length of the total number of items that are being paginated.
         * By default, its value is `0`.
         * @type {?|undefined}
         */
        TableContent.prototype.length;
        /**
         * Returns the zero-based page index of the displayed list of items.
         * By default, its value is `0`.
         * @type {?|undefined}
         */
        TableContent.prototype.pageIndex;
        /**
         * Returns the number of items to display on a page.
         * By default, its value is `50`.
         * @type {?|undefined}
         */
        TableContent.prototype.pageSize;
        /**
         * Returns the set of provided page size options to display to the user.
         * By default, its value is `[10, 20, 50]`.
         * @type {?|undefined}
         */
        TableContent.prototype.pageSizeOptions;
        /**
         * Returns true if it hides the page size selection UI from the user; otherwise, false.
         * By default, its value is `false`.
         * @type {?|undefined}
         */
        TableContent.prototype.hidePageSize;
        /**
         * Returns true if it shows the first/last buttons UI to the user; otherwise, false.
         * By default, its value is `false`.
         * @type {?|undefined}
         */
        TableContent.prototype.showFirstLastButtons;
        /**
         * Returns the function that is used to get the data source from backend.
         * The generic parameter T always refers to the type of data that it is dealing with.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        TableContent.prototype.endpoint;
        /** @type {?|undefined} */
        TableContent.prototype.actions;
    }
    /**
     * Returns a new object that represents the default `TableContent`.
     * @return {?}
     */
    function defaultTableContent() {
        return {
            'columnsObjectProperty': [],
            'columnsHeaderText': [],
            'columnsWidth': [],
            'columnContentWrap': [],
            'createCssClassesForRow': undefined,
            'propertyNameToIdentify': '',
            'filter': {},
            'sort': {
                'active': this._content.propertyNameToIdentify,
                'direction': SortDirection.asc
            },
            'length': 0,
            'pageIndex': 0,
            'pageSize': 50,
            'pageSizeOptions': [10, 20, 50],
            'hidePageSize': false,
            'showFirstLastButtons': false,
            'endpoint': undefined
        };
    }
    /**
     * \@description
     * Represents a table control.
     */
    var TableComponent = /** @class */ (function () {
        function TableComponent(_router, _activatedRoute) {
            this._router = _router;
            this._activatedRoute = _activatedRoute;
            /* By default, its value is `0`, means the component is NOT loading the data source. */
            this._countBackendSubscriptions = 0;
            this._page = new rxjs.Subject();
            this._pageAsObservable = this._page.asObservable();
            this._dataSource = new material.MatTableDataSource();
            this._selectedRow = undefined;
            this._filterValuesChange = new rxjs.Subject();
            this._filterValues = {};
            this._filterValuesSubscription = {};
            this._renderChangesSubscription = rxjs.Subscription.EMPTY;
        }
        /**
         * @return {?}
         */
        TableComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values only if the `_content` has not been set yet. */
            if (this._content == undefined) {
                this.init();
            }
        };
        /**
         * @return {?}
         */
        TableComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /* Disposes the resources held by the subscription. */
            Object.keys(this._filterValuesSubscription).forEach((/**
             * @param {?} name
             * @return {?}
             */
            function (name) {
                _this._filterValuesSubscription[name].unsubscribe();
            }));
            /* Disposes the resources held by the subscription. */
            this._renderChangesSubscription.unsubscribe();
        };
        Object.defineProperty(TableComponent.prototype, "isEmpty", {
            /**
             * Returns true if the data source is empty; otherwise, false.
             */
            get: /**
             * Returns true if the data source is empty; otherwise, false.
             * @return {?}
             */
            function () {
                return (this._dataSource.data.length == 0);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Initializes the component.
         */
        /**
         * Initializes the component.
         * @protected
         * @return {?}
         */
        TableComponent.prototype.init = /**
         * Initializes the component.
         * @protected
         * @return {?}
         */
        function () {
            this._initContent();
            this._updateChangeSubscription();
        };
        /**
         * Initializes the `content` input property.
         */
        /**
         * Initializes the `content` input property.
         * @private
         * @return {?}
         */
        TableComponent.prototype._initContent = /**
         * Initializes the `content` input property.
         * @private
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            if (this._content == undefined)
                this._content = {}; /* This code line must be here. */
            /**************************** `mat-cell` properties. ******************************/
            if (this._content.columnsObjectProperty == undefined)
                this._content.columnsObjectProperty = [];
            if (this._content.columnsHeaderText == undefined)
                this._content.columnsHeaderText = [];
            if (this._content.columnsWidth == undefined)
                this._content.columnsWidth = [];
            if (this._content.columnContentWrap == undefined)
                this._content.columnContentWrap = [];
            if (this._content.createCssClassesForRow == undefined)
                this._content.createCssClassesForRow = this.defaultCreateCssClassesForRow.bind(this);
            /**************************** `mat-row` properties. *******************************/
            if (this._content.propertyNameToIdentify == undefined)
                this._content.propertyNameToIdentify = '';
            /**************************** `filter` properties. ********************************/
            if (this._content.filter == undefined)
                this._content.filter = {};
            /***************************** `sort` properties. *********************************/
            if (this._content.sort == undefined)
                this._content.sort = {
                    'active': this._content.propertyNameToIdentify,
                    'direction': SortDirection.asc
                };
            /************************* `mat-paginator` properties. ****************************/
            if (this._content.length == undefined)
                this._content.length = 0;
            if (this._content.pageIndex == undefined)
                this._content.pageIndex = 0;
            if (this._content.pageSize == undefined)
                this._content.pageSize = 50;
            if (this._content.pageSizeOptions == undefined)
                this._content.pageSizeOptions = [10, 20, 50];
            if (this._content.hidePageSize == undefined)
                this._content.hidePageSize = false;
            if (this._content.showFirstLastButtons == undefined)
                this._content.showFirstLastButtons = false;
            /************************** Internal control properties. **************************/
            /******************************* Other properties. ********************************/
            /* The `_content.endpoint` field is `undefined` by default. */
            /************************ Must be the last initialization. ************************/
            this.checkColumn();
        };
        /**
         * Updates the fields related to the filter component.
         */
        /**
         * Updates the fields related to the filter component.
         * @private
         * @return {?}
         */
        TableComponent.prototype._updateFilter = /**
         * Updates the fields related to the filter component.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            /* For each filter property. */
            Object.keys(this._content.filter).forEach((/**
             * @param {?} filterName
             * @return {?}
             */
            function (filterName) {
                /* Saves the initial values. */
                _this._filterValues[filterName] = _this._content.filter[filterName].content.formControl.value;
                /* Disposes the resources held by the subscription. */
                if (_this._filterValuesSubscription[filterName] != undefined)
                    _this._filterValuesSubscription[filterName].unsubscribe();
                /* Subscribes to observe the changes in the control value when there is an external change. */
                _this._filterValuesSubscription[filterName] = _this._content.filter[filterName].content.formControl.valueChanges.pipe(
                /* Waits 500ms after each keystroke before considering the term. */
                operators.debounceTime(500), 
                /* Ignores new term if same as previous term. */
                operators.distinctUntilChanged())
                    .subscribe((/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) {
                    _this.applyFilter(filterName, value);
                }));
            }));
        };
        /**
         * Updates the fields related to sorting.
         * @param sortEvent The new sorting to set.
         */
        /**
         * Updates the fields related to sorting.
         * @private
         * @param {?} sortEvent The new sorting to set.
         * @return {?}
         */
        TableComponent.prototype._updateSort = /**
         * Updates the fields related to sorting.
         * @private
         * @param {?} sortEvent The new sorting to set.
         * @return {?}
         */
        function (sortEvent) {
            /* In this case, `_content` is updated with the new values; the `MatSort` already has them. */
            this._content.sort.active = sortEvent.active;
            this._content.sort.direction = sortEvent.direction;
        };
        /**
         * Sets the `MatSort` initial values.
         * The filter component and `MatPaginator` are initialized in a different way.
         */
        /**
         * Sets the `MatSort` initial values.
         * The filter component and `MatPaginator` are initialized in a different way.
         * @private
         * @return {?}
         */
        TableComponent.prototype._setMatSortInitialValue = /**
         * Sets the `MatSort` initial values.
         * The filter component and `MatPaginator` are initialized in a different way.
         * @private
         * @return {?}
         */
        function () {
            /* Saves the initial values. */
            this._sort.active = this._content.sort.active;
            this._sort.direction = this._content.sort.direction;
        };
        /**
         * Updates the fields related to pagination.
         * @param newPage The new page to set. Its type is `Page<any>` or `PageEvent`.
         */
        /**
         * Updates the fields related to pagination.
         * @private
         * @param {?} newPage The new page to set. Its type is `Page<any>` or `PageEvent`.
         * @return {?}
         */
        TableComponent.prototype._updatePaginator = /**
         * Updates the fields related to pagination.
         * @private
         * @param {?} newPage The new page to set. Its type is `Page<any>` or `PageEvent`.
         * @return {?}
         */
        function (newPage) {
            /* In this case, `_content` is updated with the new values, then the `MatPaginator`
             * takes the values via property binding from `_content` (through the template). */
            this._content.length = (newPage.totalData || newPage.length);
            this._content.pageIndex = newPage.pageIndex;
            this._content.pageSize = newPage.pageSize;
        };
        /**
         * Sets the `MatSort` and `MatPaginator` disabled or not.
         * @param disabled Whether the `MatSort` and `MatPaginator` are disabled.
         */
        /**
         * Sets the `MatSort` and `MatPaginator` disabled or not.
         * @private
         * @param {?} disabled Whether the `MatSort` and `MatPaginator` are disabled.
         * @return {?}
         */
        TableComponent.prototype._disabledSortPaginator = /**
         * Sets the `MatSort` and `MatPaginator` disabled or not.
         * @private
         * @param {?} disabled Whether the `MatSort` and `MatPaginator` are disabled.
         * @return {?}
         */
        function (disabled) {
            this._sort.disabled = disabled;
            this._paginator.disabled = disabled;
        };
        /**
         * Subscribes to changes that should trigger an update to the table's rendered rows. When the
         * changes occur, process the current state of the filter, sort, and pagination along with
         * the provided base data and send it to the table for rendering.
         */
        /**
         * Subscribes to changes that should trigger an update to the table's rendered rows. When the
         * changes occur, process the current state of the filter, sort, and pagination along with
         * the provided base data and send it to the table for rendering.
         * @private
         * @return {?}
         */
        TableComponent.prototype._updateChangeSubscription = /**
         * Subscribes to changes that should trigger an update to the table's rendered rows. When the
         * changes occur, process the current state of the filter, sort, and pagination along with
         * the provided base data and send it to the table for rendering.
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            if (this._content.endpoint == undefined)
                return;
            /* Disposes the resources held by the subscription. */
            this._renderChangesSubscription.unsubscribe();
            /* Updates the fields related to the filter component; the `MatSort` and `MatPaginator` are updated later. */
            this._updateFilter();
            /* Sets the `MatSort` initial values; the filter component and `MatPaginator` are initialized in a different way. */
            this._setMatSortInitialValue();
            /* The `_filterValuesChange` is always present; although the user decides if it is used or not.
             * Also, `MatSort` and `MatPaginator` are always present because they are managed by the component completely.
             * Subscribes to get the values when there is a change in the filtering, sorting, or pagination of the data. */
            this._renderChangesSubscription = rxjs.combineLatest([
                this._filterValuesChange.pipe(
                /* Emits the first value. Filters using the initial values. The operators must be called in this order. */
                operators.startWith(this._filterValues)),
                this._sort.sortChange.pipe(
                /* Emits the first value. Sorts using the initial values. The operators must be called in this order. */
                operators.startWith(this._content.sort)),
                this._paginator.page.pipe(
                /* Emits the first value. Paginates using the initial values. */
                operators.startWith({
                    'pageIndex': this._content.pageIndex,
                    'pageSize': this._content.pageSize,
                    'length': 0 /* In the first value, it is not important. */
                }))
            ]).pipe(
            /* Switches to new search observable each time the term changes. */
            operators.switchMap((/**
             * @param {?} __0
             * @return {?}
             */
            function (_a) {
                var _b = __read(_a, 3), filterEvent = _b[0], sortEvent = _b[1], pageEvent = _b[2];
                /* Adds the new backend subscription. It begins/continues the loading of the data.
                 * In this way, it shows the loading progress control. */
                _this._countBackendSubscriptions++;
                console.log('Call _countBackendSubscriptions: ', _this._countBackendSubscriptions);
                /* Erases the data from the table. */
                _this._setDataBeforeCallEndpoint(sortEvent, pageEvent);
                return _this._content.endpoint({
                    'filter': filterEvent,
                    'sort': sortEvent,
                    'paginator': pageEvent
                }).pipe(operators.finalize((/**
                 * @return {?}
                 */
                function () {
                    /* Removes the last backend subscription. In this way, when its value is `0`,
                     * means the component is NOT loading the data source; it then hides the loading progress control. */
                    _this._countBackendSubscriptions--;
                })));
            }))).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                //console.log('Endpoint Response: ', response);
                /* Sets the new data on the table. */
                _this._setDataAfterCallEndpoint(response);
                /* Emits the new page for someone that wants to know it. */
                _this._page.next(response);
            }));
        };
        /**
         * Returns the list of CSS classes to apply to the table rows. This method must be only overwrite,
         * but must never be called for performance reason; it is called in the correct places internally.
         * In order to take effect these classes, the table CSS file must have defined these classes.
         * @param rowData The data that is contained in the row.
         */
        /**
         * Returns the list of CSS classes to apply to the table rows. This method must be only overwrite,
         * but must never be called for performance reason; it is called in the correct places internally.
         * In order to take effect these classes, the table CSS file must have defined these classes.
         * @protected
         * @param {?} rowData The data that is contained in the row.
         * @return {?}
         */
        TableComponent.prototype.defaultCreateCssClassesForRow = /**
         * Returns the list of CSS classes to apply to the table rows. This method must be only overwrite,
         * but must never be called for performance reason; it is called in the correct places internally.
         * In order to take effect these classes, the table CSS file must have defined these classes.
         * @protected
         * @param {?} rowData The data that is contained in the row.
         * @return {?}
         */
        function (rowData) {
            return {
                'selected-row': (rowData[this._content.propertyNameToIdentify]) == this._selectedRow
            };
        };
        /**
         * Returns the list of CSS styles to apply to the table headers. This method must never be called
         * because it is for internal use only; it is called in the correct places internally.
         * @param pos The column position.
         */
        /**
         * Returns the list of CSS styles to apply to the table headers. This method must never be called
         * because it is for internal use only; it is called in the correct places internally.
         * @param {?} pos The column position.
         * @return {?}
         */
        TableComponent.prototype._createCssStylesForHeader = /**
         * Returns the list of CSS styles to apply to the table headers. This method must never be called
         * because it is for internal use only; it is called in the correct places internally.
         * @param {?} pos The column position.
         * @return {?}
         */
        function (pos) {
            /** @type {?} */
            var result = {};
            this._addCssStyles_CellWidth(result, pos);
            return result;
        };
        /**
         * Returns the list of CSS styles to apply to the table cells. This method must never be called
         * because it is for internal use only; it is called in the correct places internally.
         * @param pos The column position.
         */
        /**
         * Returns the list of CSS styles to apply to the table cells. This method must never be called
         * because it is for internal use only; it is called in the correct places internally.
         * @param {?} pos The column position.
         * @return {?}
         */
        TableComponent.prototype._createCssStylesForCell = /**
         * Returns the list of CSS styles to apply to the table cells. This method must never be called
         * because it is for internal use only; it is called in the correct places internally.
         * @param {?} pos The column position.
         * @return {?}
         */
        function (pos) {
            /** @type {?} */
            var result = {};
            this._addCssStyles_CellWidth(result, pos);
            this._addCssStyles_CellContentWrap(result, pos);
            return result;
        };
        /**
         * @private
         * @param {?} cssStyles
         * @param {?} pos
         * @return {?}
         */
        TableComponent.prototype._addCssStyles_CellWidth = /**
         * @private
         * @param {?} cssStyles
         * @param {?} pos
         * @return {?}
         */
        function (cssStyles, pos) {
            cssStyles['flex'] = '0 0 ' + this._content.columnsWidth[pos];
            cssStyles['width'] = this._content.columnsWidth[pos];
        };
        /**
         * @private
         * @param {?} cssStyles
         * @param {?} pos
         * @return {?}
         */
        TableComponent.prototype._addCssStyles_CellContentWrap = /**
         * @private
         * @param {?} cssStyles
         * @param {?} pos
         * @return {?}
         */
        function (cssStyles, pos) {
            switch (this._content.columnContentWrap[pos]) {
                case CellContentWrap.break:
                    {
                        cssStyles['word-wrap'] = 'break-word' /*!important*/;
                        cssStyles['white-space'] = 'unset' /*!important*/;
                        cssStyles['overflow-wrap'] = 'break-word';
                        cssStyles['word-break'] = 'break-word';
                        cssStyles['-ms-hyphens'] = 'auto';
                        cssStyles['-moz-hyphens'] = 'auto';
                        cssStyles['-webkit-hyphens'] = 'auto';
                        cssStyles['hyphens'] = 'auto';
                        break;
                    }
                case CellContentWrap.ellipsis:
                    {
                        cssStyles['overflow'] = 'hidden';
                        cssStyles['text-overflow'] = 'ellipsis';
                        cssStyles['white-space'] = 'nowrap';
                        break;
                    }
                default: /* CellContentWrap.responsible */
                    {
                        /* The `responsible` wrap is the default style. It only applies the responsible styles
                         * that are defined in the table. */
                        break;
                    }
            }
        };
        Object.defineProperty(TableComponent.prototype, "isLoading", {
            /**
             * Returns true if it is loading the data source; otherwise, false.
             */
            get: /**
             * Returns true if it is loading the data source; otherwise, false.
             * @return {?}
             */
            function () {
                /* When the `_countBackendSubscriptions` value is different of 0,
                 * means the component is loading the data source. */
                return (this._countBackendSubscriptions != 0);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "selectedRow", {
            /**
             * Returns the selected row.
             */
            get: /**
             * Returns the selected row.
             * @return {?}
             */
            function () {
                return this._selectedRow;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "content", {
            /**
             * Returns the input field that contains the content of this class (the table control content to show).
             */
            get: /**
             * Returns the input field that contains the content of this class (the table control content to show).
             * @return {?}
             */
            function () {
                return this._content;
            },
            /**
             * Sets the input field that contains the content of this class (the table control content to show).
             * In this way, the component is updated correctly.
             * @param newContent The new content to set.
             * If the value is null, sets to `defaultTableContent`.
             */
            set: /**
             * Sets the input field that contains the content of this class (the table control content to show).
             * In this way, the component is updated correctly.
             * @param {?} newContent The new content to set.
             * If the value is null, sets to `defaultTableContent`.
             * @return {?}
             */
            function (newContent) {
                this._content = newContent;
                this.init();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TableComponent.prototype, "page", {
            /**
             * Returns the stream that emits the page that should be rendered by the table,
             * when there is a change in the filtering, sorting, or pagination of the data. Each object
             * in the `data` field represents one row. This is made for someone that wants to know it.
             */
            get: /**
             * Returns the stream that emits the page that should be rendered by the table,
             * when there is a change in the filtering, sorting, or pagination of the data. Each object
             * in the `data` field represents one row. This is made for someone that wants to know it.
             * @return {?}
             */
            function () {
                return this._pageAsObservable;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Sets the page that should be rendered by the table, it erases the data. For internal use only.
         * @param sortEvent The current sort state.
         * @param pageEvent The current paginator state.
         */
        /**
         * Sets the page that should be rendered by the table, it erases the data. For internal use only.
         * @private
         * @param {?} sortEvent The current sort state.
         * @param {?} pageEvent The current paginator state.
         * @return {?}
         */
        TableComponent.prototype._setDataBeforeCallEndpoint = /**
         * Sets the page that should be rendered by the table, it erases the data. For internal use only.
         * @private
         * @param {?} sortEvent The current sort state.
         * @param {?} pageEvent The current paginator state.
         * @return {?}
         */
        function (sortEvent, pageEvent) {
            /* Erases the data from the table. */
            this._dataSource.data = [];
            /* Updates the fields related to sorting and pagination; the filter component is updated in a different way. */
            this._updateSort(sortEvent);
            this._updatePaginator(pageEvent);
            /* The `MatSort` and `MatPaginator` are always enabled. */
            this._disabledSortPaginator(false);
        };
        /**
         * Sets the page that should be rendered by the table, where each object in the `newPage.data`
         * represents one row. For internal use only.
         * @param newPage The new page to set.
         */
        /**
         * Sets the page that should be rendered by the table, where each object in the `newPage.data`
         * represents one row. For internal use only.
         * @private
         * @param {?} newPage The new page to set.
         * @return {?}
         */
        TableComponent.prototype._setDataAfterCallEndpoint = /**
         * Sets the page that should be rendered by the table, where each object in the `newPage.data`
         * represents one row. For internal use only.
         * @private
         * @param {?} newPage The new page to set.
         * @return {?}
         */
        function (newPage) {
            /* In `_dataSource`, needs to update the data only. */
            this._dataSource.data = newPage.data;
            /* Updates the fields related to pagination; the filter component and sorting do not need to update. */
            this._updatePaginator(newPage);
            /* The `MatSort` and `MatPaginator` are disabled if the table is empty. */
            this._disabledSortPaginator(this.isEmpty);
        };
        Object.defineProperty(TableComponent.prototype, "_getDataSource", {
            /**
             * Returns the data source to render. If the data source is empty, then returns the default data source
             * that contains only one empty element (it is used to show one row that contains the empty
             * table information). For internal use only.
             */
            get: /**
             * Returns the data source to render. If the data source is empty, then returns the default data source
             * that contains only one empty element (it is used to show one row that contains the empty
             * table information). For internal use only.
             * @return {?}
             */
            function () {
                if (this.isEmpty)
                    return TableComponent._defaultDataSource;
                return this._dataSource;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Checks column. Logs a warn to the console is the array of columns is empty.
         */
        /**
         * Checks column. Logs a warn to the console is the array of columns is empty.
         * @return {?}
         */
        TableComponent.prototype.checkColumn = /**
         * Checks column. Logs a warn to the console is the array of columns is empty.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var len = this._content.columnsObjectProperty.length;
            if ((len == 0)
                || (len != this._content.columnsHeaderText.length)
                || (len != this._content.columnsWidth.length)
                || (len != this._content.columnContentWrap.length)) {
                console.warn("The 'columnsObjectProperty', 'columnsHeaderText', 'columnsWidth' and 'columnContentWrap' arrays must be different of empty, and must have the same amount of elements.");
            }
        };
        /**
         * Navigates to the view that shows information about the specified `rowData`.
         * @param relativeUrl The relative URL to navigate.
         * @param rowData The data that is contained in the row.
         */
        /**
         * Navigates to the view that shows information about the specified `rowData`.
         * @param {?} relativeUrl The relative URL to navigate.
         * @param {?} rowData The data that is contained in the row.
         * @return {?}
         */
        TableComponent.prototype.navigateTo = /**
         * Navigates to the view that shows information about the specified `rowData`.
         * @param {?} relativeUrl The relative URL to navigate.
         * @param {?} rowData The data that is contained in the row.
         * @return {?}
         */
        function (relativeUrl, rowData) {
            /* Selects the specified row. */
            this.selectRow(rowData);
            /* Navigates to the specified view. */
            this._router.navigate([rowData[this._content.propertyNameToIdentify], relativeUrl], { relativeTo: this._activatedRoute });
        };
        /**
         * Selects the specified row.
         * @param rowData The data that is contained in the row.
         */
        /**
         * Selects the specified row.
         * @param {?} rowData The data that is contained in the row.
         * @return {?}
         */
        TableComponent.prototype.selectRow = /**
         * Selects the specified row.
         * @param {?} rowData The data that is contained in the row.
         * @return {?}
         */
        function (rowData) {
            /* Saves the selected row. */
            this._selectedRow = rowData[this._content.propertyNameToIdentify];
        };
        /**
         * Applies the filter model that should be used to filter out objects from the data source.
         * Assumes that the backend will call the `trim()` method over its properties.
         * This method is accepting a partial representation of the filter model.
         * It combines the specified filter with the last one. This way old filter properties
         * won't be overridden when only one property is updated.
         * @param filter The partial representation of the filter model to combine.
         */
        /**
         * Applies the filter model that should be used to filter out objects from the data source.
         * Assumes that the backend will call the `trim()` method over its properties.
         * This method is accepting a partial representation of the filter model.
         * It combines the specified filter with the last one. This way old filter properties
         * won't be overridden when only one property is updated.
         * @param {?} filter The partial representation of the filter model to combine.
         * @return {?}
         */
        TableComponent.prototype.applyFilters = /**
         * Applies the filter model that should be used to filter out objects from the data source.
         * Assumes that the backend will call the `trim()` method over its properties.
         * This method is accepting a partial representation of the filter model.
         * It combines the specified filter with the last one. This way old filter properties
         * won't be overridden when only one property is updated.
         * @param {?} filter The partial representation of the filter model to combine.
         * @return {?}
         */
        function (filter) {
            /* This method is accepting a partial representation of the filter model.
             * It combines the specified filter with the last one by merging both filters
             * via the spread operator. This way old filter properties won't be overridden
             * when only one property is updated.
             * It is not necessary to call the `trim()` method over its properties because it is called
             * in the backend internally. */
            this._filterValues = __assign({}, this._filterValues, filter);
            this._filterValuesChange.next(this._filterValues);
        };
        /**
         * Applies the filter model that should be used to filter out objects from the data source.
         * Assumes that the backend will call the `trim()` method over its properties.
         * It combines the specified filter property with the last one. This way old filter properties
         * won't be overridden when only one property is updated.
         * @param name The filter name.
         * @param value The filter value.
         */
        /**
         * Applies the filter model that should be used to filter out objects from the data source.
         * Assumes that the backend will call the `trim()` method over its properties.
         * It combines the specified filter property with the last one. This way old filter properties
         * won't be overridden when only one property is updated.
         * @param {?} name The filter name.
         * @param {?} value The filter value.
         * @return {?}
         */
        TableComponent.prototype.applyFilter = /**
         * Applies the filter model that should be used to filter out objects from the data source.
         * Assumes that the backend will call the `trim()` method over its properties.
         * It combines the specified filter property with the last one. This way old filter properties
         * won't be overridden when only one property is updated.
         * @param {?} name The filter name.
         * @param {?} value The filter value.
         * @return {?}
         */
        function (name, value) {
            /* It combines the specified filter property with the last one by merging both filters
             * via the spread operator. This way old filter properties won't be overridden
             * when only one property is updated.
             * It is not necessary to call the `trim()` method over its properties because it is called
             * in the backend internally. */
            this._filterValues = __assign({}, this._filterValues);
            this._filterValues[name] = value;
            this._filterValuesChange.next(this._filterValues);
        };
        /* Returns a data source with only one empty element. */
        TableComponent._defaultDataSource = new material.MatTableDataSource([{}]);
        TableComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-table',
                        template: "\n<table mat-table matSort class=\"mat-elevation-z8\" [dataSource]=\"_getDataSource\" multiTemplateDataRows>\n\n    <!-- The content that is showed when the `dataSource` is not empty. -->\n    <ng-container *ngFor=\"let column of content.columnsObjectProperty; let pos = index\" [matColumnDef]=\"column\">\n        <th mat-header-cell *matHeaderCellDef mat-sort-header [ngStyle]=\"_createCssStylesForHeader(pos)\">\n            {{ content.columnsHeaderText[pos] }}\n        </th>\n\n        <td mat-cell [ngClass]=\"content.createCssClassesForRow(element)\" *matCellDef=\"let element\" [ngStyle]=\"_createCssStylesForCell(pos)\">\n            <!-- Adds the notification icon in the first column if there is 'version to review'. -->\n            <mat-icon *ngIf=\"pos == 0 && element[content.columnsObjectProperty[2]]\" class=\"mat-cell-mat-icon\">new_releases</mat-icon>\n            <!-- Adds the cell text if is not the third column. -->\n            <ng-container *ngIf=\"pos != 2\">{{ element[column] }}</ng-container>\n            <!-- Adds the view and edit buttons in the third column. -->\n            <div *ngIf=\"pos == 2\" class=\"div-mat-button-actions\">\n                <ng-container *ngIf=\"content.actions\">\n                    <button \n                        *ngFor=\"let action of content.actions\"\n                        mat-icon-button class=\"div-mat-button\" \n                        [attr.aria-label]=\"action.tooltip\" \n                        (click)=\"navigateTo(action.route, element)\"\n                        matTooltip=\"{{ action.tooltip }}\"\n                    >\n                        <mat-icon>{{ action.icon }}</mat-icon>\n                    </button>\n                </ng-container>\n                 \n                <!-- <button mat-icon-button class=\"div-mat-button\" [attr.aria-label]=\"'Show the data'\" (click)=\"navigateTo(element[content.propertyNameToIdentify], element)\">\n                    <mat-icon>description</mat-icon>\n                </button>\n                <button mat-icon-button class=\"div-mat-button\" [attr.aria-label]=\"'Edit the data'\" (click)=\"navigateTo('edit', element)\">\n                    <mat-icon>edit</mat-icon>\n                </button> -->\n\n            </div>\n        </td>\n    </ng-container>\n\n    <!-- The `otherInformation` represents the content that is showed when the `dataSource` is empty \n         or the `dataSource` is loading. The information row is made up of this one column that spans \n         across all columns. -->\n    <ng-container [matColumnDef]=\"'otherInformation'\">\n        <td mat-cell *matCellDef=\"let element\" [attr.colspan]=\"content.columnsObjectProperty.length\">\n            <ng-container *ngIf=\"isLoading; then thenTemplate_IsLoading; else elseTemplate_IsEmpty\"></ng-container>\n            \n            <ng-template #thenTemplate_IsLoading>\n                <mat-progress-spinner class=\"loading-table-information\" mode=\"indeterminate\"></mat-progress-spinner>\n            </ng-template>\n\n            <ng-template #elseTemplate_IsEmpty>\n                <div class=\"empty-table-information\">There is not any data source!</div>\n            </ng-template>\n        </td>\n    </ng-container>\n\n    <tr mat-header-row *matHeaderRowDef=\"content.columnsObjectProperty; sticky: true\"></tr>\n    <!-- When it is `loading`, it is `empty`, too. -->\n    <ng-container *ngIf=\"isEmpty; then thenTemplate_OtherInformation; else elseTemplate_IsNotEmpty\"></ng-container>\n\n    <ng-template #thenTemplate_OtherInformation>\n        <tr mat-row class=\"row-other-information\" *matRowDef=\"let row; columns: ['otherInformation']\"></tr>\n    </ng-template>\n\n    <ng-template #elseTemplate_IsNotEmpty>\n        <tr mat-row class=\"row-data\" *matRowDef=\"let row; columns: content.columnsObjectProperty;\" (click)=\"selectRow(row)\"></tr>\n    </ng-template>\n\n</table>\n\n<mat-paginator\n    [length]=\"content.length\"\n    [pageIndex]=\"content.pageIndex\"\n    [pageSize]=\"content.pageSize\"\n    [pageSizeOptions]=\"content.pageSizeOptions\"\n    [hidePageSize]=\"content.hidePageSize\"\n    [showFirstLastButtons]=\"content.showFirstLastButtons\">\n</mat-paginator>\n",
                        styles: ["table{table-layout:fixed;width:100%;padding:2em 1em 0}tr.mat-header-row{height:54px}tr.mat-footer-row,tr.mat-row{height:46px}.div-mat-button-actions{display:inline-block;margin-bottom:5px}.div-mat-button{margin-top:5px;margin-right:5px;vertical-align:middle;box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.mat-cell-mat-icon{margin-top:5px;margin-right:5px;margin-bottom:5px;vertical-align:middle}th{padding-right:10px!important;padding-left:10px!important;background-color:#f5f7f7!important;border-top:1px solid #bdc3c7;border-bottom:1px solid transparent}td:first-of-type,th:first-of-type{border-left:1px solid #bdc3c7}td:last-of-type,th:last-of-type{border-right:1px solid #bdc3c7}th:not(:last-of-type)::before{content:\" \";position:absolute;top:0;right:0;height:28px;margin-top:12px;text-indent:-2000px;border-right:1px solid #bdc3c7;outline:0}td{padding-right:10px!important;padding-left:10px!important;border-top:1px solid transparent;border-right:1px solid transparent;border-left:1px solid transparent;border-bottom:1px solid #d9dcde;transition:.3s ease-out}tr:first-of-type td{border-top:1px solid #bdc3c7}tr:last-of-type td{border-bottom:1px solid #bdc3c7}td.new-release{color:#f83821}td.selected-row{background-color:#d7d7d7!important;color:#10f!important;border-top:1px solid #10f!important;border-right:1px solid #10f!important;border-bottom:1px solid #10f!important}td.selected-row:first-of-type{border-left:1px solid #10f!important}.loading-table-information{margin:3em auto;cursor:default}.empty-table-information{margin:6em 0;text-align:center;cursor:default}tr.row-data{cursor:pointer}tr.row-data:hover td{background-color:#eee;border-top:1px solid #10f;border-right:1px solid #10f;border-bottom:1px solid #10f}tr.row-data:hover td:first-of-type{border-left:1px solid #10f}tr.row-data:active{background-color:#eee}:host ::ng-deep .mat-sort-header-container{justify-content:center}th.mat-sort-header-sorted{color:#f01}"]
                    }] }
        ];
        /** @nocollapse */
        TableComponent.ctorParameters = function () { return [
            { type: router.Router },
            { type: router.ActivatedRoute }
        ]; };
        TableComponent.propDecorators = {
            _sort: [{ type: core.ViewChild, args: [material.MatSort, { static: true },] }],
            _paginator: [{ type: core.ViewChild, args: [material.MatPaginator, { static: true },] }],
            content: [{ type: core.Input }]
        };
        return TableComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        TableComponent._defaultDataSource;
        /**
         * Returns the amount of backend subscriptions.
         * When its value is different of 0, means the component is loading the data source.
         * In this way, it shows/hides the loading progress control.
         * By default, its value is `0`.
         * @type {?}
         * @private
         */
        TableComponent.prototype._countBackendSubscriptions;
        /**
         * @type {?}
         * @private
         */
        TableComponent.prototype._content;
        /**
         * Returns the stream that emits the page that should be rendered by the table,
         * when there is a change in the filtering, sorting, or pagination of the data. Each object
         * in the `data` field represents one row. This is made for someone that wants to know it.
         * @type {?}
         * @private
         */
        TableComponent.prototype._page;
        /**
         * @type {?}
         * @private
         */
        TableComponent.prototype._pageAsObservable;
        /**
         * @type {?}
         * @private
         */
        TableComponent.prototype._dataSource;
        /**
         * @type {?}
         * @private
         */
        TableComponent.prototype._selectedRow;
        /**
         * Stream that emits when a new filter is set on the data source.
         * Because of the behavior and appearance of the component, it is necessary to use
         * `Subject` instead of `BehaviorSubject` to represent the `_filterValuesChange`.
         * @type {?}
         * @private
         */
        TableComponent.prototype._filterValuesChange;
        /**
         * @type {?}
         * @private
         */
        TableComponent.prototype._filterValues;
        /**
         * @type {?}
         * @private
         */
        TableComponent.prototype._filterValuesSubscription;
        /**
         * @type {?}
         * @private
         */
        TableComponent.prototype._sort;
        /**
         * @type {?}
         * @private
         */
        TableComponent.prototype._paginator;
        /**
         * Subscription to the changes that should trigger an update to the table's rendered rows, such
         * as filtering, sorting, or pagination.
         * @type {?}
         * @private
         */
        TableComponent.prototype._renderChangesSubscription;
        /**
         * @type {?}
         * @private
         */
        TableComponent.prototype._router;
        /**
         * @type {?}
         * @private
         */
        TableComponent.prototype._activatedRoute;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/container-specific/label-diff-lang/label-diff-lang-container.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a container control that allows the writing of a name of something in different language.
     */
    var ContainerLabelDiffLangComponent = /** @class */ (function (_super) {
        __extends(ContainerLabelDiffLangComponent, _super);
        function ContainerLabelDiffLangComponent() {
            return _super.call(this) || this;
        }
        /**
         * @return {?}
         */
        ContainerLabelDiffLangComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init(undefined);
        };
        /**
         * Initializes the `content` input property.
         * @param label The label to set. If the value is `undefined`, sets the label to `content.label`.
         * @param isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param alwaysHint If it is true then there is always at leat one hint start-aligned.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The label to set. If the value is `undefined`, sets the label to `content.label`.
         * @return {?}
         */
        ContainerLabelDiffLangComponent.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The label to set. If the value is `undefined`, sets the label to `content.label`.
         * @return {?}
         */
        function (label) {
            /* Sets the default values. */
            _super.prototype.init.call(this, label);
        };
        ContainerLabelDiffLangComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'container-label-diff-lang',
                        template: "\n<!-- TODO: En dependencia del valor de `appearance`, se aplican las clases CSS para lograr la apariencia deseada. \n     Actualmente, `appearance = 'outline'` es el \u00FAnico que est\u00E1 hecho. -->\n<fieldset class=\"container-simple-form-field\" [formGroup]=\"content.formSection\" [attr.aria-label]=\"content.ariaLabel\">\n    <legend class=\"container-simple-form-field-legend\">{{ content.label }}</legend>\n\n    <ng-template get-view-container></ng-template>\n    <!-- <button mat-raised-button color=\"primary\" (click)=\"content.parentFormSection.removeFromFormArray(content.name)\">\n        <mat-icon>remove_circle</mat-icon>\n    </button> -->\n\n</fieldset>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".container-simple-form-field{margin:-4px 0 0;padding:0 12px;cursor:default;background-color:#fff;border:1px solid rgba(0,0,0,.12);border-radius:4px}.container-simple-form-field-legend{padding:0 4px;background-color:#fff;color:rgba(0,0,0,.6);font-size:10px}"]
                    }] }
        ];
        /** @nocollapse */
        ContainerLabelDiffLangComponent.ctorParameters = function () { return []; };
        return ContainerLabelDiffLangComponent;
    }(ContainerControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/input.control.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var TextInputAppearance = {
        /**
         * The `standard` appearance is the default style. It shows the input box with an underline underneath it.
         */
        standard: "standard",
        /**
         * The `fill` appearance displays the form field with a filled background box in addition to the underline.
         */
        fill: "fill",
        /**
         * The `outline` appearance shows the form field with a border all the way around, not just an underline.
         */
        outline: "outline",
    };
    /**
     * A base interface that represents the content of an `InputControl`.
     * @record
     */
    function InputContent() { }
    if (false) {
        /**
         * Returns the `FormControl` that tracks the value and validity state of the internal control that contains the text input.
         * Implementation notes: There are two cases:
         *  - You only have the `content.formControl` field as the `InputEmailComponent` class.
         *  - You have the `content.formControl` and `InputControl.internalComponent` fields as the `InputIssnComponent` class.
         *  - It must be specified; otherwise, an exception is thrown.
         * @type {?|undefined}
         */
        InputContent.prototype.formControl;
        /**
         * Returns the control's appearance.
         * By default, its value is `TextInputAppearance.standard`.
         * @type {?|undefined}
         */
        InputContent.prototype.appearance;
        /**
         * Returns the control's prefix icon.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        InputContent.prototype.prefixIcon;
        /**
         * Returns the control's suffix icon.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        InputContent.prototype.suffixIcon;
        /**
         * Returns the control's prefix text.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        InputContent.prototype.prefixText;
        /**
         * Returns the control's suffix text.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        InputContent.prototype.suffixText;
        /**
         * Returns the control's start hint.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        InputContent.prototype.startHint;
        /**
         * Returns the control's end hint.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        InputContent.prototype.endHint;
    }
    /**
     * An interface which allows to manipulate the internal component that contains the text input.
     * This interface is implemented when it is created a custom `MatFormFieldControl`.
     * @record
     */
    function IInternalComponent() { }
    if (false) {
        /**
         * Tracks the value and validity state of the internal control that contains the text input.
         * @type {?}
         */
        IInternalComponent.prototype.formControl;
        /**
         * Returns or sets the value of the control.
         * @type {?}
         */
        IInternalComponent.prototype.value;
        /**
         * Returns true if the control is empty; otherwise, false.
         * A control is empty if its value is `undefined` or empty string.
         * @type {?}
         */
        IInternalComponent.prototype.empty;
        /**
         * Returns true if the control is in an error state; otherwise, false.
         * @type {?}
         */
        IInternalComponent.prototype.errorState;
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        IInternalComponent.prototype.getErrorMessage = function () { };
    }
    /**
     * Represents the base abstract class for a control that allows the writing/selection of a text.
     * @abstract
     */
    var InputControl = /** @class */ (function (_super) {
        __extends(InputControl, _super);
        /**
         * Constructs a new instance of this class.
         */
        function InputControl() {
            var _this = _super.call(this) || this;
            _this.validationError_required = '';
            return _this;
        }
        /**
         * Returns a `FormControl` by default.
         * Its value is empty, and does not have validators.
         * @param validatorArguments A collection of key/value elements, where the key is the validator name
         * and the value is the value that the validator needs to check.
         */
        /**
         * Returns a `FormControl` by default.
         * Its value is empty, and does not have validators.
         * @param {?=} validatorArguments A collection of key/value elements, where the key is the validator name
         * and the value is the value that the validator needs to check.
         * @return {?}
         */
        InputControl.getFormControlByDefault = /**
         * Returns a `FormControl` by default.
         * Its value is empty, and does not have validators.
         * @param {?=} validatorArguments A collection of key/value elements, where the key is the validator name
         * and the value is the value that the validator needs to check.
         * @return {?}
         */
        function (validatorArguments) {
            if (validatorArguments === void 0) { validatorArguments = undefined; }
            return new forms.FormControl('', []);
        };
        /**
         * Sets the new language.
         * @param transServ The `TranslateService` instance injected.
         */
        /**
         * Sets the new language.
         * @protected
         * @param {?} transServ The `TranslateService` instance injected.
         * @return {?}
         */
        InputControl.prototype.setNewLanguage = /**
         * Sets the new language.
         * @protected
         * @param {?} transServ The `TranslateService` instance injected.
         * @return {?}
         */
        function (transServ) {
            /* The `InputControl.currentLang != transServ.currentLang` test is NOT necessary here because it is done in the non-abstract child classes. */
            _super.prototype.setNewLanguage.call(this, transServ);
            /* The `InputControl.currentLang` value is updated correctly in the parent class. */
            transServ.get('TOCO_NG_ERROR_MSG_REQUERIDO').subscribe((/**
             * @param {?} res
             * @return {?}
             */
            function (res) {
                InputControl.toco_ng_Error_Msg_Requerido = res;
            }));
        };
        /**
         * Initializes the `content` input property.
         * @param label The default label to use. It is used if the `content.label` is not specified.
         * @param placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param alwaysHint If it is true then there is always at leat one hint start-aligned.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
         * @return {?}
         */
        InputControl.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
         * @return {?}
         */
        function (label, placeholder, isAbbreviation, alwaysHint) {
            /* Sets the default values. */
            if (placeholder === void 0) { placeholder = ''; }
            if (isAbbreviation === void 0) { isAbbreviation = false; }
            if (alwaysHint === void 0) { alwaysHint = true; }
            _super.prototype.init.call(this, label, placeholder);
            if (this.content.formControl == undefined) {
                if (this.internalComponent == undefined)
                    throw new Error("For the '" + this.content.name + "' control, the 'content.formControl' value can not be undefined; it must be a 'FormControl' value.");
                this.content.formControl = this.internalComponent.formControl;
            }
            // let temp: string = (isAbbreviation) ? this.content.label : this.content.label.toLowerCase();
            this.validationError_required = 'TOCO_NG_ERROR_MSG_REQUERIDO';
            /************************** Internal control properties. **************************/
            if (this.content.required == undefined)
                this.content.required = false;
            /************************** `mat-form-field` properties. **************************/
            if (this.content.appearance == undefined)
                this.content.appearance = TextInputAppearance.standard;
            /***************************** `mat-icon` properties. *****************************/
            if (this.content.prefixIcon != undefined)
                this.content.prefixIcon.setDefaultValueIfUndefined_setPosition(ContentPosition.prefix);
            if (this.content.suffixIcon != undefined)
                this.content.suffixIcon.setDefaultValueIfUndefined_setPosition(ContentPosition.suffix);
            /***************************** `mat-hint` properties. *****************************/
            if (alwaysHint && (this.content.startHint == undefined) && (this.content.endHint == undefined)) {
                this.content.startHint = new HintValue(HintPosition.start, 'TOCO_NG_HINT_TEXTO_POR_DEFECTO');
            }
            else {
                if (this.content.startHint != undefined)
                    this.content.startHint.setDefaultValueIfUndefined_setPosition(HintPosition.start);
                if (this.content.endHint != undefined)
                    this.content.endHint.setDefaultValueIfUndefined_setPosition(HintPosition.end);
            }
            /* Adds this control as a child to the `content.parentFormSection`.
            It must be called at the end. */
            if (this.content.parentFormSection != undefined) {
                console.log('addAsChildControl(this.content.formControl)');
                this.addAsChildControl(this, this.content.formControl);
            }
        };
        /**
         * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
         * It also checks if the specified `content.value` is correct. For internal use only.
         */
        /**
         * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
         * It also checks if the specified `content.value` is correct. For internal use only.
         * @protected
         * @return {?}
         */
        InputControl.prototype.initValue = /**
         * Initializes the control's value. It uses the `content.value` and it is already different of `undefined`.
         * It also checks if the specified `content.value` is correct. For internal use only.
         * @protected
         * @return {?}
         */
        function () {
            /* In this way, checks if the specified `content.value` is correct. */
            this.content.formControl.setValue(this.content.value);
            /* Marks the control as `touched`. */
            this.content.formControl.markAsTouched({
                onlySelf: true
            });
        };
        Object.defineProperty(InputControl.prototype, "getInstance", {
            /**
             * Returns this instance.
             */
            get: /**
             * Returns this instance.
             * @return {?}
             */
            function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputControl.prototype, "empty", {
            /**
             * Returns true if the control is empty; otherwise, false.
             * A control is empty if its value is `undefined` or empty string.
             */
            get: /**
             * Returns true if the control is empty; otherwise, false.
             * A control is empty if its value is `undefined` or empty string.
             * @return {?}
             */
            function () {
                if (this.internalComponent == undefined)
                    return ((util.isNullOrUndefined(this.content.formControl.value)) || (this.content.formControl.value === ''));
                return this.internalComponent.empty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputControl.prototype, "hintState", {
            /**
             * Returns true if the control is in a hint state; otherwise, false.
             */
            get: /**
             * Returns true if the control is in a hint state; otherwise, false.
             * @return {?}
             */
            function () {
                return this.empty;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputControl.prototype, "errorState", {
            /**
             * Returns true if the control is in an error state; otherwise, false.
             */
            get: /**
             * Returns true if the control is in an error state; otherwise, false.
             * @return {?}
             */
            function () {
                /* The control does not display errors before the user has a
                 * chance to edit the form. The checks for dirty and touched prevent errors
                 * from showing until the user does one of two things: changes the value,
                 * turning the control dirty; or blurs the form control element, setting the
                 * control to touched.
                 * Thus, it reveals an error message only if the control is invalid and
                 * the control is either dirty or touched. */
                if (this.internalComponent == undefined)
                    return ((this.content.formControl.invalid) && (this.content.formControl.dirty || this.content.formControl.touched));
                return this.internalComponent.errorState;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Handler method that is called when the control's value changes in the UI. For internal use only.
         * If a derived class wants to do some specific handling then it must overwrite
         * the `handleSpecificInput` method.
         */
        /**
         * Handler method that is called when the control's value changes in the UI. For internal use only.
         * If a derived class wants to do some specific handling then it must overwrite
         * the `handleSpecificInput` method.
         * @return {?}
         */
        InputControl.prototype.handleInput = /**
         * Handler method that is called when the control's value changes in the UI. For internal use only.
         * If a derived class wants to do some specific handling then it must overwrite
         * the `handleSpecificInput` method.
         * @return {?}
         */
        function () {
            /* Calls the specific handling of the input that the derived class wants to do. */
            this.handleSpecificInput();
            // TODO: hacer la salva del valor del control para `this.content.value` de una mejor forma 
            // porque hacerlo aquí genera inconsistencias. Una mejor forma sería proporcionar un method que 
            // haga la función de salvar el valor y entonces es llamado cuando haga falta. 
            /* If the control does not have error ... */
            if (!this.errorState) {
                /* ... sets the new value of the control in the `content`. */
                this.content.value = this.content.formControl.value;
            }
            /* If the control is not marked as `touched` ... */
            if (this.content.formControl.untouched) {
                /* ... marks the control as `touched`. */
                this.content.formControl.markAsTouched({
                    onlySelf: true
                });
            }
        };
        Object.defineProperty(InputControl.prototype, "getDefaultValue", {
            /**
             * Returns the control's default value.
             * This function can be overwrite in the derived class.
             */
            get: /**
             * Returns the control's default value.
             * This function can be overwrite in the derived class.
             * @return {?}
             */
            function () {
                /* By default, its implementation is returning the empty string. */
                return '';
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * This function can be overwrite in the derived class.
         */
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * This function can be overwrite in the derived class.
         * @return {?}
         */
        InputControl.prototype.getErrorMessage = /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * This function can be overwrite in the derived class.
         * @return {?}
         */
        function () {
            /* By default, its implementation is returning the error of the `internalComponent.getErrorMessage`
             * method or returning the text errors. */
            if (this.internalComponent != undefined)
                return this.internalComponent.getErrorMessage();
            /** @type {?} */
            var validationErrors = this.content.formControl.errors;
            /* Shows the text errors. */
            if (validationErrors) {
                if (validationErrors[forms.Validators.required.name]) {
                    return ((this.isTranslationBuiltByControl) ? InputControl.toco_ng_Error_Msg_Requerido : this.validationError_required);
                }
            }
            return '';
        };
        /**
         * Handler method that is called by the internal logic when the control's value changes in the UI.
         * This method contains the specific handling of the input that the derived class wants to do.
         * This function can be overwrite in the derived class.
         */
        /**
         * Handler method that is called by the internal logic when the control's value changes in the UI.
         * This method contains the specific handling of the input that the derived class wants to do.
         * This function can be overwrite in the derived class.
         * @return {?}
         */
        InputControl.prototype.handleSpecificInput = /**
         * Handler method that is called by the internal logic when the control's value changes in the UI.
         * This method contains the specific handling of the input that the derived class wants to do.
         * This function can be overwrite in the derived class.
         * @return {?}
         */
        function () {
            /* By default, its implementation has nothing to do. */
        };
        InputControl.toco_ng_Error_Msg_Requerido = '';
        InputControl.propDecorators = {
            content: [{ type: core.Input }],
            internalComponent: [{ type: core.ViewChild, args: ['internalComponent', { static: true },] }]
        };
        return InputControl;
    }(FormFieldControl));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        InputControl.toco_ng_Error_Msg_Requerido;
        /**
         * Input field that contains the content of this class.
         * @type {?}
         */
        InputControl.prototype.content;
        /**
         * Tracks the value and validity state of the internal component that contains the text input.
         * Implementation notes: There are two cases:
         *  - You only have the `content.formControl` field as the `InputEmailComponent` class.
         *  - You have the `content.formControl` and `internalComponent` fields as the `InputIssnComponent` class.
         * @type {?}
         * @protected
         */
        InputControl.prototype.internalComponent;
        /**
         * Represents the validation error of required. Its default value can be overwritten.
         * @type {?}
         * @protected
         */
        InputControl.prototype.validationError_required;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/bool/bool-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a control that allows to select true or false value.
     */
    var InputBoolComponent = /** @class */ (function (_super) {
        __extends(InputBoolComponent, _super);
        function InputBoolComponent() {
            return _super.call(this) || this;
        }
        /**
         * @return {?}
         */
        InputBoolComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init('', '', false, true);
            this.onSelectionChange();
        };
        /**
         * Initializes the `content` input property.
         * @param label The default label to use. It is used if the `content.label` is not specified.
         * @param placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param alwaysHint If it is true then there is always at leat one hint start-aligned.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
         * @return {?}
         */
        InputBoolComponent.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
         * @return {?}
         */
        function (label, placeholder, isAbbreviation, alwaysHint) {
            /* Sets the default values. */
            if (placeholder === void 0) { placeholder = ''; }
            _super.prototype.init.call(this, label, placeholder, isAbbreviation, alwaysHint);
            if (!util.isBoolean(this.content.value) && !util.isNullOrUndefined(this.content.value))
                throw new Error("For the '" + this.content.name + "' control, the 'content.value' value must have a boolean type.");
            if (this.content.startHint != undefined) {
                if (this.content.startHint.label == 'TOCO_NG_HINT_TEXTO_POR_DEFECTO')
                    this.content.startHint.label = 'TOCO_NG_HINT_TEXTO_SELECC_POR_DEFECTO';
            }
            else
                this.content.startHint = new HintValue(HintPosition.start, 'TOCO_NG_HINT_TEXTO_SELECC_POR_DEFECTO');
        };
        /**
         * @return {?}
         */
        InputBoolComponent.prototype.onSelectionChange = /**
         * @return {?}
         */
        function () {
            if ((this.content.extraContent) && (this.content.extraContent.selectionChange)) {
                this.content.extraContent.selectionChange(this.content.formControl.value);
            }
            // console.log('Select value: ', this.content.formControl.value);
        };
        InputBoolComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'input-bool',
                        template: "\n<mat-form-field\n\tclass=\"select-mat-form-field\"\n\t[appearance]=\"content.appearance\"\n>\n\n\t<mat-label>\n\t\t{{ content.label | translate }}\n\t</mat-label>\n\n\t<mat-select\n\t\t[formControl]=\"content.formControl\"\n\t\t[required]=\"content.required\"\n\t\t[style.textAlign]=\"content.textAlign\"\n\t\t[attr.aria-label]=\"content.ariaLabel | translate\"\n\t\t[(value)]=\"content.value\"\n\t\t[multiple]=\"'false'\"\n\t\t(selectionChange)=\"onSelectionChange()\"\n\t>\n\t\t<mat-option [value]=\"true\">\n\t\t\t{{ 'TOCO_NG_VERDADERO' | translate }}\n\t\t</mat-option>\n\t\t<mat-option [value]=\"false\">\n\t\t\t{{ 'TOCO_NG_FALSO' | translate }}\n\t\t</mat-option>\n\t</mat-select>\n\n\t<mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".select-mat-form-field{width:100%}"]
                    }] }
        ];
        /** @nocollapse */
        InputBoolComponent.ctorParameters = function () { return []; };
        return InputBoolComponent;
    }(InputControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/email/email-value.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Data structure for holding an email.
     */
    var EmailValue = /** @class */ (function () {
        function EmailValue(e) {
            this.email = e;
        }
        /**
         * Returns a string representation of this `EmailValue` object.
         */
        /**
         * Returns a string representation of this `EmailValue` object.
         * @return {?}
         */
        EmailValue.prototype.toString = /**
         * Returns a string representation of this `EmailValue` object.
         * @return {?}
         */
        function () {
            return EmailValue.email_Label + ' ' + this.email;
        };
        /**
         * Represents the email label.
         */
        EmailValue.email_Label = 'Email';
        /**
         * Represents the email placeholder.
         */
        EmailValue.email_Placeholder = 'nick@gmail.com';
        return EmailValue;
    }());
    if (false) {
        /**
         * Represents the email label.
         * @type {?}
         */
        EmailValue.email_Label;
        /**
         * Represents the email placeholder.
         * @type {?}
         */
        EmailValue.email_Placeholder;
        /**
         * The email value.
         * @type {?}
         */
        EmailValue.prototype.email;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/email/email-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a control that allows the writing of an email.
     * It uses the `EmailValue.email_Label` as a label if the `content.label` is not specified.
     * It uses the `EmailValue.email_Placeholder` as a placeholder if the `content.placeholder` is not specified.
     */
    var InputEmailComponent = /** @class */ (function (_super) {
        __extends(InputEmailComponent, _super);
        function InputEmailComponent() {
            return _super.call(this) || this;
        }
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputEmailComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         */
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputEmailComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         * @param {?=} validatorArguments
         * @return {?}
         */
        InputEmailComponent.getFormControlByDefault = /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputEmailComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         * @param {?=} validatorArguments
         * @return {?}
         */
        function (validatorArguments) {
            if (validatorArguments === void 0) { validatorArguments = undefined; }
            return new forms.FormControl('', [
                forms.Validators.email
            ]);
        };
        /**
         * @return {?}
         */
        InputEmailComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init(EmailValue.email_Label, EmailValue.email_Placeholder, false, true);
        };
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         */
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        InputEmailComponent.prototype.getErrorMessage = /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var validationErrors = this.content.formControl.errors;
            /* Shows the email errors. */
            if (validationErrors) {
                if (validationErrors[forms.Validators.required.name]) {
                    return this.validationError_required;
                }
                else {
                    /* It is `validationErrors[Validators.email.name]`. */
                    return 'TOCO_NG_ERROR_MSG_CORREO_INVAL';
                }
            }
            return '';
        };
        InputEmailComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'input-email',
                        template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
                    }] }
        ];
        /** @nocollapse */
        InputEmailComponent.ctorParameters = function () { return []; };
        return InputEmailComponent;
    }(InputControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/identifier/identifier-value.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Data structure for holding an identifier.
     */
    var IdentifierValue = /** @class */ (function () {
        function IdentifierValue(id) {
            this.identifier = id;
        }
        /**
         * Returns a string representation of this `IdentifierValue` object.
         */
        /**
         * Returns a string representation of this `IdentifierValue` object.
         * @return {?}
         */
        IdentifierValue.prototype.toString = /**
         * Returns a string representation of this `IdentifierValue` object.
         * @return {?}
         */
        function () {
            return IdentifierValue.identifier_Label + ' ' + this.identifier;
        };
        /**
         * Represents the identifier label.
         */
        IdentifierValue.identifier_Label = 'TOCO_NG_ID';
        return IdentifierValue;
    }());
    if (false) {
        /**
         * Represents the identifier label.
         * @type {?}
         */
        IdentifierValue.identifier_Label;
        /**
         * The identifier value.
         * @type {?}
         */
        IdentifierValue.prototype.identifier;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/identifier/identifier-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a control that allows the writing of an identifier.
     * It uses the `IdentifierValue.identifier_Label` as a label if the `content.label` is not specified.
     */
    var InputIdentifierComponent = /** @class */ (function (_super) {
        __extends(InputIdentifierComponent, _super);
        function InputIdentifierComponent() {
            return _super.call(this) || this;
        }
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputIdentifierComponent`'s `content.formControl` value by default.
         * @param validatorArguments An object that has only one field of `pattern` name and its value is a string.
         * The `pattern` name is the validator name and the value is the value that the validator needs to check.
         * For example, you can call the `getFormControlByDefault` method in this way:
         * InputIdentifierComponent.getFormControlByDefault({ 'pattern': '^[a-zA-Z\_][a-zA-Z\-\_0-9]*$' });
         * If this argument is not specified, by default its value is { 'pattern': '^[a-zA-Z\-\_]*$' }.
         */
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputIdentifierComponent`'s `content.formControl` value by default.
         * @param {?=} validatorArguments An object that has only one field of `pattern` name and its value is a string.
         * The `pattern` name is the validator name and the value is the value that the validator needs to check.
         * For example, you can call the `getFormControlByDefault` method in this way:
         * InputIdentifierComponent.getFormControlByDefault({ 'pattern': '^[a-zA-Z\_][a-zA-Z\-\_0-9]*$' });
         * If this argument is not specified, by default its value is { 'pattern': '^[a-zA-Z\-\_]*$' }.
         * @return {?}
         */
        InputIdentifierComponent.getFormControlByDefault = /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputIdentifierComponent`'s `content.formControl` value by default.
         * @param {?=} validatorArguments An object that has only one field of `pattern` name and its value is a string.
         * The `pattern` name is the validator name and the value is the value that the validator needs to check.
         * For example, you can call the `getFormControlByDefault` method in this way:
         * InputIdentifierComponent.getFormControlByDefault({ 'pattern': '^[a-zA-Z\_][a-zA-Z\-\_0-9]*$' });
         * If this argument is not specified, by default its value is { 'pattern': '^[a-zA-Z\-\_]*$' }.
         * @return {?}
         */
        function (validatorArguments) {
            if (validatorArguments === void 0) { validatorArguments = undefined; }
            return new forms.FormControl('', [
                (((validatorArguments) && (validatorArguments.pattern)) ? forms.Validators.pattern(validatorArguments.pattern) : forms.Validators.pattern('^[a-zA-Z\-\_]*$'))
                // Validators.pattern(/((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/i)
            ]);
        };
        /**
         * @return {?}
         */
        InputIdentifierComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init(IdentifierValue.identifier_Label, '', false, true);
        };
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         */
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        InputIdentifierComponent.prototype.getErrorMessage = /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var validationErrors = this.content.formControl.errors;
            /* Shows the identifier errors. */
            if (validationErrors) {
                if (validationErrors[forms.Validators.required.name]) {
                    return this.validationError_required;
                }
                else {
                    /* It is `validationErrors[Validators.pattern.name]`. */
                    return 'TOCO_NG_ERROR_MSG_ID_INVAL';
                }
            }
            return '';
        };
        InputIdentifierComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'input-identifier',
                        template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
                    }] }
        ];
        /** @nocollapse */
        InputIdentifierComponent.ctorParameters = function () { return []; };
        return InputIdentifierComponent;
    }(InputControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/issn/issn-value.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var IssnType_Abbreviation = {
        /**
         * The ISSN abbreviation by default.
         */
        ISSN: "ISSN",
        /**
         * The ISSN abbreviation for the print media (paper) version of a serial.
         * Usually it is the "default media", so the "default ISSN".
         */
        p_ISSN: "p-ISSN",
        /**
         * The ISSN abbreviation for the electronic media (online) version of a serial.
         */
        e_ISSN: "e-ISSN",
        /**
         * The ISSN abbreviation for the linking ISSN.
         * It is a specific ISSN that groups the different media of the same serial publication.
         * A single ISSN-L is designated for all media of a serial publication, irrespective of how many there are.
         * A serial publication is associated with a single ISSN-L.
         */
        ISSN_L: "ISSN-L",
    };
    /** @enum {string} */
    var IssnType_Label = {
        /**
         * The ISSN label.
         */
        ISSN: "TOCO_NG_ISSN",
        /**
         * The ISSN label for the print ISSN.
         */
        p_ISSN: "TOCO_NG_P_ISSN",
        /**
         * The ISSN label for the electronic ISSN.
         */
        e_ISSN: "TOCO_NG_E_ISSN",
        /**
         * The ISSN label for the linking ISSN.
         */
        ISSN_L: "TOCO_NG_ISSN_L",
    };
    /**
     * Data structure for holding an ISSN.
     * An ISSN (International Standard Serial Number) is an 8-digit code.
     * This control stores the code as a string of length 11, with the form 'XXXX – XXXX'.
     * It is used to identify newspapers, journals, magazines and periodicals
     * of all kinds and on all media–print and electronic. For more information
     * follow the link: https://www.issn.org/understanding-the-issn/what-is-an-issn/.
     */
    var IssnValue = /** @class */ (function () {
        function IssnValue(c) {
            this.code = IssnValue.convertIssnToLength_11(c);
        }
        /**
         * General purpose method.
         * Converts the specified ISSN code to a code with length 11 with the form 'XXXX – XXXX'.
         * @param code The code to convert.
         */
        /**
         * General purpose method.
         * Converts the specified ISSN code to a code with length 11 with the form 'XXXX – XXXX'.
         * @param {?} code The code to convert.
         * @return {?}
         */
        IssnValue.convertIssnToLength_11 = /**
         * General purpose method.
         * Converts the specified ISSN code to a code with length 11 with the form 'XXXX – XXXX'.
         * @param {?} code The code to convert.
         * @return {?}
         */
        function (code) {
            /** @type {?} */
            var fg;
            /** @type {?} */
            var sg;
            if (code.length == 8) {
                fg = code.slice(0, 4);
                sg = code.slice(4, 7);
                return (fg + ' ' + IssnValue.codeGroupSeparator + ' ' + sg + ((code[7] == 'x') ? 'X' : code[7]));
            }
            else if (code.length == 9) {
                fg = code.slice(0, 4);
                sg = code.slice(5, 8);
                return (fg + ' ' + IssnValue.codeGroupSeparator + ' ' + sg + ((code[8] == 'x') ? 'X' : code[8]));
            }
            else /* The code length is 11. */ {
                fg = code.slice(0, 5);
                sg = code.slice(6, 10);
                return (fg + IssnValue.codeGroupSeparator + sg + ((code[10] == 'x') ? 'X' : code[10]));
            }
        };
        /**
         * General purpose method.
         * Converts the specified ISSN code to a code with length 9 with the form 'XXXX–XXXX'.
         * @param code The code to convert.
         */
        /**
         * General purpose method.
         * Converts the specified ISSN code to a code with length 9 with the form 'XXXX–XXXX'.
         * @param {?} code The code to convert.
         * @return {?}
         */
        IssnValue.convertIssnToLength_9 = /**
         * General purpose method.
         * Converts the specified ISSN code to a code with length 9 with the form 'XXXX–XXXX'.
         * @param {?} code The code to convert.
         * @return {?}
         */
        function (code) {
            /** @type {?} */
            var fg;
            /** @type {?} */
            var sg;
            if (code.length == 8) {
                fg = code.slice(0, 4);
                sg = code.slice(4, 7);
                return (fg + IssnValue.codeGroupSeparator + sg + ((code[7] == 'x') ? 'X' : code[7]));
            }
            else if (code.length == 9) {
                fg = code.slice(0, 4);
                sg = code.slice(5, 8);
                return (fg + IssnValue.codeGroupSeparator + sg + ((code[8] == 'x') ? 'X' : code[8]));
            }
            else /* The code length is 11. */ {
                fg = code.slice(0, 4);
                sg = code.slice(7, 10);
                return (fg + IssnValue.codeGroupSeparator + sg + ((code[10] == 'x') ? 'X' : code[10]));
            }
        };
        /**
         * General purpose method.
         * Converts the specified ISSN code to a code with length 8 with the form 'XXXXXXXX'.
         * @param code The code to convert.
         */
        /**
         * General purpose method.
         * Converts the specified ISSN code to a code with length 8 with the form 'XXXXXXXX'.
         * @param {?} code The code to convert.
         * @return {?}
         */
        IssnValue.convertIssnToLength_8 = /**
         * General purpose method.
         * Converts the specified ISSN code to a code with length 8 with the form 'XXXXXXXX'.
         * @param {?} code The code to convert.
         * @return {?}
         */
        function (code) {
            /** @type {?} */
            var fg;
            /** @type {?} */
            var sg;
            if (code.length == 9) {
                fg = code.slice(0, 4);
                sg = code.slice(5, 8);
                return (fg + sg + ((code[8] == 'x') ? 'X' : code[8]));
            }
            if (code.length == 11) {
                fg = code.slice(0, 4);
                sg = code.slice(7, 10);
                return (fg + sg + ((code[10] == 'x') ? 'X' : code[10]));
            }
            else /* The code length is 8. */ {
                return code;
            }
        };
        /**
         * Returns true if the ISSN is complete; otherwise, false.
         * It is complete if the code of characters has the correct length. It does not check if the ISSN has
         * the correct digits.
         */
        /**
         * Returns true if the ISSN is complete; otherwise, false.
         * It is complete if the code of characters has the correct length. It does not check if the ISSN has
         * the correct digits.
         * @return {?}
         */
        IssnValue.prototype.isComplete = /**
         * Returns true if the ISSN is complete; otherwise, false.
         * It is complete if the code of characters has the correct length. It does not check if the ISSN has
         * the correct digits.
         * @return {?}
         */
        function () {
            return (this.code.length == IssnValue.codeLength);
        };
        /**
         * Returns a string representation of this `IssnValue` object.
         * @param acronym The acronym to use.
         */
        /**
         * Returns a string representation of this `IssnValue` object.
         * @param {?} acronym The acronym to use.
         * @return {?}
         */
        IssnValue.prototype.toString = /**
         * Returns a string representation of this `IssnValue` object.
         * @param {?} acronym The acronym to use.
         * @return {?}
         */
        function (acronym) {
            return acronym + ' ' + this.code;
        };
        /**
         * Represents the ISSN placeholder.
         */
        IssnValue.issn_Placeholder = 'XXXX – XXXX';
        /**
         * The amount of characters in the code.
         */
        IssnValue.codeLength = 11;
        /**
         * The amount of characters in the code as string value.
         */
        IssnValue.codeLengthAsString = IssnValue.codeLength.toString(10);
        /**
         * The character that represents the code group separator.
         */
        IssnValue.codeGroupSeparator = '–';
        /**
         * The string that represents the code group separator with space.
         */
        IssnValue.codeGroupSeparatorWithSpace = ' ' + IssnValue.codeGroupSeparator + ' ';
        /**
         * The regular expression that matches an ISSN code as a string of length 11, with the form 'XXXX – XXXX'.
         */
        IssnValue.regExpIssnWithLength_11 = '^[0-9]{4} ' + IssnValue.codeGroupSeparator + ' [0-9]{3}[0-9xX]$';
        /**
         * The regular expression that matches an ISSN code as a string of length 9, with the form 'XXXX–XXXX'.
         */
        IssnValue.regExpIssnWithLength_9 = '^[0-9]{4}' + IssnValue.codeGroupSeparator + '[0-9]{3}[0-9xX]$';
        /**
         * The regular expression that matches an ISSN code as a string of length 8, with the form 'XXXXXXXX'.
         */
        IssnValue.regExpIssnWithLength_8 = '^[0-9]{7}[0-9xX]$';
        return IssnValue;
    }());
    if (false) {
        /**
         * Represents the ISSN placeholder.
         * @type {?}
         */
        IssnValue.issn_Placeholder;
        /**
         * The amount of characters in the code.
         * @type {?}
         */
        IssnValue.codeLength;
        /**
         * The amount of characters in the code as string value.
         * @type {?}
         */
        IssnValue.codeLengthAsString;
        /**
         * The character that represents the code group separator.
         * @type {?}
         */
        IssnValue.codeGroupSeparator;
        /**
         * The string that represents the code group separator with space.
         * @type {?}
         */
        IssnValue.codeGroupSeparatorWithSpace;
        /**
         * The regular expression that matches an ISSN code as a string of length 11, with the form 'XXXX – XXXX'.
         * @type {?}
         */
        IssnValue.regExpIssnWithLength_11;
        /**
         * The regular expression that matches an ISSN code as a string of length 9, with the form 'XXXX–XXXX'.
         * @type {?}
         */
        IssnValue.regExpIssnWithLength_9;
        /**
         * The regular expression that matches an ISSN code as a string of length 8, with the form 'XXXXXXXX'.
         * @type {?}
         */
        IssnValue.regExpIssnWithLength_8;
        /**
         * The code of `IssnValue.codeLength` characters.
         * @type {?}
         */
        IssnValue.prototype.code;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/issn/issn-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a control that allows the writing of an ISSN.
     * An ISSN (International Standard Serial Number) is an 8-digit code.
     * This control stores the code as a string of length 11, with the form 'XXXX – XXXX'.
     * It is used to identify newspapers, journals, magazines and periodicals
     * of all kinds and on all media–print and electronic. For more information
     * follow the link: https://www.issn.org/understanding-the-issn/what-is-an-issn/.
     * It uses the `IssnType_Abbreviation.ISSN` as a label if the `content.label` is not specified.
     * It uses the `IssnValue.issn_Placeholder` as a placeholder if the `content.placeholder` is not specified.
     */
    var InputIssnComponent = /** @class */ (function (_super) {
        __extends(InputIssnComponent, _super);
        function InputIssnComponent() {
            var _this = _super.call(this) || this;
            _this._codeOldValue = undefined;
            return _this;
        }
        /* Note: Before, this control worked well with a 'width' = '310px' or '285px'. */
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputIssnComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         */
        /* Note: Before, this control worked well with a 'width' = '310px' or '285px'. */
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputIssnComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         * @param {?=} validatorArguments
         * @return {?}
         */
        InputIssnComponent.getFormControlByDefault = /* Note: Before, this control worked well with a 'width' = '310px' or '285px'. */
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputIssnComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         * @param {?=} validatorArguments
         * @return {?}
         */
        function (validatorArguments) {
            if (validatorArguments === void 0) { validatorArguments = undefined; }
            /** @type {?} */
            var res = new forms.FormControl('', [
                ExtraValidators.equalLength(IssnValue.codeLength),
                forms.Validators.pattern(IssnValue.regExpIssnWithLength_11),
                ExtraValidators.issnConfirmCheckDigitOneField(IssnValue.codeLength)
            ]);
            return res;
        };
        /**
         * @return {?}
         */
        InputIssnComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init(IssnType_Abbreviation.ISSN, IssnValue.issn_Placeholder, true, true);
            if ((typeof this.content.value !== 'string') && (typeof this.content.value !== 'undefined')) {
                throw new Error("For the '" + this.content.name + "' control, the 'content.value' value must be of string type.");
            }
            /* The '_codeOldValue' must be set after the 'content.formControl.value' is set. */
            this.handleSpecificInput();
        };
        /**
          * Returns an error string if the control is in an error state; otherwise, empty string.
          */
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        InputIssnComponent.prototype.getErrorMessage = /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var result = '';
            /** @type {?} */
            var result_alreadyHaveErrorInfo = false;
            /** @type {?} */
            var validationErrors = this.content.formControl.errors;
            /* Shows the code errors. */
            if (validationErrors) {
                if ((validationErrors[ExtraValidators.equalLength.name]) || (validationErrors[forms.Validators.required.name])) {
                    result = 'TOCO_NG_ERROR_MSG_ISSN_LONG_INVAL';
                    result_alreadyHaveErrorInfo = true;
                }
                if (validationErrors[forms.Validators.pattern.name]) {
                    if (result_alreadyHaveErrorInfo) {
                        result = 'TOCO_NG_ERROR_MSG_ISSN_LONG_Y_DIG_INVAL';
                    }
                    else {
                        result = 'TOCO_NG_ERROR_MSG_ISSN_DIG_INVAL';
                    }
                    result_alreadyHaveErrorInfo = true;
                }
            }
            /* Only shows the `issnConfirmCheckDigitOneField` error if there isn't any previous error. */
            if (!result_alreadyHaveErrorInfo) {
                if (validationErrors) {
                    if (validationErrors[ExtraValidators.issnConfirmCheckDigitOneField.name]) {
                        result = 'TOCO_NG_ERROR_MSG_ISSN_DIG_CHEQUEO_INVAL';
                        result_alreadyHaveErrorInfo = true;
                    }
                }
            }
            return result;
        };
        /**
         * Handler method that is called by the internal logic when the control's value changes in the UI.
         * This method contains the specific handling of the input that the derived class wants to do.
         */
        /**
         * Handler method that is called by the internal logic when the control's value changes in the UI.
         * This method contains the specific handling of the input that the derived class wants to do.
         * @return {?}
         */
        InputIssnComponent.prototype.handleSpecificInput = /**
         * Handler method that is called by the internal logic when the control's value changes in the UI.
         * This method contains the specific handling of the input that the derived class wants to do.
         * @return {?}
         */
        function () {
            /* Forma de entrada del código ISSN por parte del usuario:
             * El control ISSN permite copiar códigos ISSN con el separador de menos (-) o con
             * el separador de raya (–), y son copiados correctamente para un código ISSN
             * con el separador de raya (–); es decir, los siguientes ejemplos muestran
             * el resultado de copiar una forma de código en particular.
             *  - Si se copia 01234560, entonces se muestra 0123 – 4560
             *  - Si se copia 0123-4560, entonces se muestra 0123 – 4560
             *  - Si se copia 0123 - 4560, entonces se muestra 0123 – 4560
             *  - Si se copia 0123–4560, entonces se muestra 0123 – 4560
             *  - Si se copia 0123 – 4560, entonces se muestra 0123 – 4560
             *  - Si se copia 0123 – 45601, entonces se muestra 0123 – 4560
             *  - Si se copia un código ISSN con más de 8 dígitos en la forma que sea,
             *    entonces no se copia y se sigue mostrando el código anterior.
             * Recuerde que el caracter 'x' or 'X' puede aparecer solamente en la última
             * posición del código ISSN. Además, aunque los dos caracteres significan lo mismo,
             * siempre se trata de mostrar el caracter 'X' en mayúscula.
             */
            /* Forma de entrada del código ISSN por parte del usuario:
                     * El control ISSN permite copiar códigos ISSN con el separador de menos (-) o con
                     * el separador de raya (–), y son copiados correctamente para un código ISSN
                     * con el separador de raya (–); es decir, los siguientes ejemplos muestran
                     * el resultado de copiar una forma de código en particular.
                     *  - Si se copia 01234560, entonces se muestra 0123 – 4560
                     *  - Si se copia 0123-4560, entonces se muestra 0123 – 4560
                     *  - Si se copia 0123 - 4560, entonces se muestra 0123 – 4560
                     *  - Si se copia 0123–4560, entonces se muestra 0123 – 4560
                     *  - Si se copia 0123 – 4560, entonces se muestra 0123 – 4560
                     *  - Si se copia 0123 – 45601, entonces se muestra 0123 – 4560
                     *  - Si se copia un código ISSN con más de 8 dígitos en la forma que sea,
                     *    entonces no se copia y se sigue mostrando el código anterior.
                     * Recuerde que el caracter 'x' or 'X' puede aparecer solamente en la última
                     * posición del código ISSN. Además, aunque los dos caracteres significan lo mismo,
                     * siempre se trata de mostrar el caracter 'X' en mayúscula.
                     */
            /** @type {?} */
            var tempCode = this.content.formControl.value;
            /** @type {?} */
            var len = tempCode.length;
            /* Checks that the code length can not be longer than `IssnValue.codeLength`. */
            if (len > IssnValue.codeLength) /* This case is used for code with length 11. */ {
                /* Sets the old value. */
                this.content.formControl.setValue(this._codeOldValue);
                return;
            }
            /** @type {?} */
            var i;
            /** @type {?} */
            var newCode = '';
            /** @type {?} */
            var alreadyHasSpace = false;
            /** @type {?} */
            var count = 0;
            for (i = 0; i < len; i++) {
                switch (tempCode[i]) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                    case '8':
                    case '9':
                        {
                            if (((++count) == 4) && (!alreadyHasSpace)) {
                                alreadyHasSpace = true;
                                newCode += tempCode[i] + IssnValue.codeGroupSeparatorWithSpace;
                            }
                            else {
                                newCode += tempCode[i];
                            }
                            break;
                        }
                    case 'x':
                    case 'X':
                        {
                            if ((i + 1) == len) /* The 'x' or 'X' character can only appear in the last position. */ {
                                count++;
                                newCode += 'X';
                            }
                            break;
                        }
                    case ' ':
                        {
                            if (!alreadyHasSpace) {
                                alreadyHasSpace = true;
                                newCode += IssnValue.codeGroupSeparatorWithSpace;
                            }
                            break;
                        }
                }
            }
            /* Checks that the code length can not be longer than `IssnValue.codeLength`. */
            if (count > 8) /* This case is used for code with length 8 and 9. */ {
                /* Sets the old value. */
                this.content.formControl.setValue(this._codeOldValue);
            }
            else {
                /* Sets the new value, and updates the old value. */
                this.content.formControl.setValue((this._codeOldValue = newCode));
            }
        };
        InputIssnComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'input-issn',
                        template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
                    }] }
        ];
        /** @nocollapse */
        InputIssnComponent.ctorParameters = function () { return []; };
        return InputIssnComponent;
    }(InputControl));
    if (false) {
        /**
         * It is used by `handleSpecificInput` method.
         * @type {?}
         * @private
         */
        InputIssnComponent.prototype._codeOldValue;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/number/number-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a control that allows the writing of a number.
     */
    var InputNumberComponent = /** @class */ (function (_super) {
        __extends(InputNumberComponent, _super);
        function InputNumberComponent(_transServ) {
            var _this = _super.call(this) || this;
            _this._transServ = _transServ;
            /* The translation is built by the control. */
            _this.isTranslationBuiltByControl = true;
            return _this;
        }
        // TODO: Puedo hacer que este control sea más general, que permita la entrada de valores 
        // enteros y doubles haciendo las siguientes modificaciones: 
        //  * Inicializar el `Validators.pattern('----')` con un patrón para double values según valor que recibe en 
        //    `validatorArguments` que dice si integer o double. 
        //  * Hacer tratamiento de error correctamente em método `getErrorMessage()`. 
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputNumberComponent`'s `content.formControl` value by default.
         * @param validatorArguments A collection of key/value elements, where the key is the validator name
         * and the value is the value that the validator needs to check.
         * In the `validatorArguments` argument, you can specify an object with the minimum and maximum possible
         * values for the number that holds the control.
         * For example: If the minimum possible value is 0 and maximum is 50, you can call the `getFormControlByDefault`
         * method in this way:
         * InputNumberComponent.getFormControlByDefault({ 'min': 0, 'max': 50 });
         */
        // TODO: Puedo hacer que este control sea más general, que permita la entrada de valores 
        // enteros y doubles haciendo las siguientes modificaciones: 
        //  * Inicializar el `Validators.pattern('----')` con un patrón para double values según valor que recibe en 
        //    `validatorArguments` que dice si integer o double. 
        //  * Hacer tratamiento de error correctamente em método `getErrorMessage()`. 
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputNumberComponent`'s `content.formControl` value by default.
         * @param {?=} validatorArguments A collection of key/value elements, where the key is the validator name
         * and the value is the value that the validator needs to check.
         * In the `validatorArguments` argument, you can specify an object with the minimum and maximum possible
         * values for the number that holds the control.
         * For example: If the minimum possible value is 0 and maximum is 50, you can call the `getFormControlByDefault`
         * method in this way:
         * InputNumberComponent.getFormControlByDefault({ 'min': 0, 'max': 50 });
         * @return {?}
         */
        InputNumberComponent.getFormControlByDefault = 
        // TODO: Puedo hacer que este control sea más general, que permita la entrada de valores 
        // enteros y doubles haciendo las siguientes modificaciones: 
        //  * Inicializar el `Validators.pattern('----')` con un patrón para double values según valor que recibe en 
        //    `validatorArguments` que dice si integer o double. 
        //  * Hacer tratamiento de error correctamente em método `getErrorMessage()`. 
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputNumberComponent`'s `content.formControl` value by default.
         * @param {?=} validatorArguments A collection of key/value elements, where the key is the validator name
         * and the value is the value that the validator needs to check.
         * In the `validatorArguments` argument, you can specify an object with the minimum and maximum possible
         * values for the number that holds the control.
         * For example: If the minimum possible value is 0 and maximum is 50, you can call the `getFormControlByDefault`
         * method in this way:
         * InputNumberComponent.getFormControlByDefault({ 'min': 0, 'max': 50 });
         * @return {?}
         */
        function (validatorArguments) {
            if (validatorArguments === void 0) { validatorArguments = undefined; }
            return new forms.FormControl(0, [
                forms.Validators.pattern('^-?[0-9]+$'),
                forms.Validators.min(((validatorArguments) && (validatorArguments.min != undefined)) ? validatorArguments.min : Number.MIN_SAFE_INTEGER),
                forms.Validators.max(((validatorArguments) && (validatorArguments.max != undefined)) ? validatorArguments.max : Number.MAX_SAFE_INTEGER),
            ]);
        };
        /**
         * @return {?}
         */
        InputNumberComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            /* This needs to be called at first. */
            this.setNewLanguage(this._transServ);
            /* Sets the default values. */
            this.init('', '', false, false);
            /* Changes the translation when the language changes. */
            this._transServ.onLangChange.subscribe((/**
             * @param {?} params
             * @return {?}
             */
            function (params) {
                _this.setNewLanguage(_this._transServ);
            }));
        };
        /**
         * Sets the new language.
         * @param transServ The `TranslateService` instance injected.
         */
        /**
         * Sets the new language.
         * @protected
         * @param {?} transServ The `TranslateService` instance injected.
         * @return {?}
         */
        InputNumberComponent.prototype.setNewLanguage = /**
         * Sets the new language.
         * @protected
         * @param {?} transServ The `TranslateService` instance injected.
         * @return {?}
         */
        function (transServ) {
            /* First, do this test for optimization. */
            if (InputNumberComponent.currentLang != transServ.currentLang) {
                _super.prototype.setNewLanguage.call(this, transServ);
                /* The `InputNumberComponent.currentLang` value is updated correctly in the parent class. */
                transServ.get(['TOCO_NG_ERROR_MSG_NUM_INVAL', 'TOCO_NG_ERROR_MSG_NUM_MINIMO', 'TOCO_NG_ERROR_MSG_NUM_MAXIMO']).subscribe((/**
                 * @param {?} res
                 * @return {?}
                 */
                function (res) {
                    InputNumberComponent.toco_ng_Error_Msg_Num_Inval = res.TOCO_NG_ERROR_MSG_NUM_INVAL;
                    InputNumberComponent.toco_ng_Error_Msg_Num_Minimo = res.TOCO_NG_ERROR_MSG_NUM_MINIMO;
                    InputNumberComponent.toco_ng_Error_Msg_Num_Maximo = res.TOCO_NG_ERROR_MSG_NUM_MAXIMO;
                }));
            }
        };
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         */
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        InputNumberComponent.prototype.getErrorMessage = /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var validationErrors = this.content.formControl.errors;
            /* Shows the code errors. */
            if (validationErrors) {
                if (validationErrors[forms.Validators.required.name]) {
                    return InputNumberComponent.toco_ng_Error_Msg_Requerido;
                }
                if (validationErrors[forms.Validators.pattern.name]) {
                    return InputNumberComponent.toco_ng_Error_Msg_Num_Inval;
                }
                if (validationErrors[forms.Validators.min.name]) {
                    return InputNumberComponent.toco_ng_Error_Msg_Num_Minimo + validationErrors[forms.Validators.min.name].min + '.';
                }
                if (validationErrors[forms.Validators.max.name]) {
                    return InputNumberComponent.toco_ng_Error_Msg_Num_Maximo + validationErrors[forms.Validators.max.name].max + '.';
                }
            }
            return '';
        };
        InputNumberComponent.toco_ng_Error_Msg_Num_Inval = '';
        InputNumberComponent.toco_ng_Error_Msg_Num_Minimo = '';
        InputNumberComponent.toco_ng_Error_Msg_Num_Maximo = '';
        InputNumberComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'input-number',
                        template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
                    }] }
        ];
        /** @nocollapse */
        InputNumberComponent.ctorParameters = function () { return [
            { type: core$2.TranslateService }
        ]; };
        return InputNumberComponent;
    }(InputControl));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        InputNumberComponent.toco_ng_Error_Msg_Num_Inval;
        /**
         * @type {?}
         * @protected
         */
        InputNumberComponent.toco_ng_Error_Msg_Num_Minimo;
        /**
         * @type {?}
         * @protected
         */
        InputNumberComponent.toco_ng_Error_Msg_Num_Maximo;
        /**
         * @type {?}
         * @private
         */
        InputNumberComponent.prototype._transServ;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/rnps/rnps-value.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Data structure for holding an RNPS.
     * An RNPS (Registro Nacional de Publicaciones Seriadas) is an 4-digit code used to control
     * las publicaciones seriadas autorizadas a editarse, imprimirse y circular en Cuba.
     * For more information follow the link: http://www.seriadas.cult.cu/.
     */
    var RnpsValue = /** @class */ (function () {
        function RnpsValue(c) {
            this.code = c;
        }
        /**
         * Returns true if the RNPS is complete; otherwise, false.
         * It is complete if the code of digits has the correct length. It does not check if the RNPS has
         * the correct digits.
         */
        /**
         * Returns true if the RNPS is complete; otherwise, false.
         * It is complete if the code of digits has the correct length. It does not check if the RNPS has
         * the correct digits.
         * @return {?}
         */
        RnpsValue.prototype.isComplete = /**
         * Returns true if the RNPS is complete; otherwise, false.
         * It is complete if the code of digits has the correct length. It does not check if the RNPS has
         * the correct digits.
         * @return {?}
         */
        function () {
            return (this.code.length == RnpsValue.codeLength);
        };
        /**
         * Returns a string representation of this `RnpsValue` object.
         */
        /**
         * Returns a string representation of this `RnpsValue` object.
         * @return {?}
         */
        RnpsValue.prototype.toString = /**
         * Returns a string representation of this `RnpsValue` object.
         * @return {?}
         */
        function () {
            return RnpsValue.rnps_Abbreviation + ' ' + this.code;
        };
        /**
         * Represents the RNPS placeholder.
         */
        RnpsValue.rnps_Placeholder = 'XXXX';
        /**
         * The amount of digits in the code.
         */
        RnpsValue.codeLength = 4;
        /**
         * The amount of digits in the code as string value.
         */
        RnpsValue.codeLengthAsString = RnpsValue.codeLength.toString(10);
        /**
         * Represents the RNPS abbreviation.
         */
        RnpsValue.rnps_Abbreviation = 'RNPS';
        /**
         * Represents the RNPS label.
         */
        RnpsValue.rnps_Label = 'TOCO_NG_RNPS';
        return RnpsValue;
    }());
    if (false) {
        /**
         * Represents the RNPS placeholder.
         * @type {?}
         */
        RnpsValue.rnps_Placeholder;
        /**
         * The amount of digits in the code.
         * @type {?}
         */
        RnpsValue.codeLength;
        /**
         * The amount of digits in the code as string value.
         * @type {?}
         */
        RnpsValue.codeLengthAsString;
        /**
         * Represents the RNPS abbreviation.
         * @type {?}
         */
        RnpsValue.rnps_Abbreviation;
        /**
         * Represents the RNPS label.
         * @type {?}
         */
        RnpsValue.rnps_Label;
        /**
         * The code of `RnpsValue.codeLength` digits.
         * @type {?}
         */
        RnpsValue.prototype.code;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/rnps/rnps-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a control that allows the writing of an RNPS.
     * An RNPS (Registro Nacional de Publicaciones Seriadas) is an 4-digit code used to control
     * the serial publications authorized to be edited, printed and circulated in Cuba.
     * For more information follow the link: http://www.seriadas.cult.cu/.
     * It uses the `RnpsValue.rnps_Abbreviation` as a label if the `content.label` is not specified.
     * It uses the `RnpsValue.rnps_Placeholder` as a placeholder if the `content.placeholder` is not specified.
     */
    var InputRnpsComponent = /** @class */ (function (_super) {
        __extends(InputRnpsComponent, _super);
        function InputRnpsComponent() {
            var _this = _super.call(this) || this;
            _this._codeOldValue = undefined;
            return _this;
        }
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputRnpsComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         */
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputRnpsComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         * @param {?=} validatorArguments
         * @return {?}
         */
        InputRnpsComponent.getFormControlByDefault = /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputRnpsComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         * @param {?=} validatorArguments
         * @return {?}
         */
        function (validatorArguments) {
            if (validatorArguments === void 0) { validatorArguments = undefined; }
            return new forms.FormControl('', [
                ExtraValidators.equalLength(RnpsValue.codeLength),
                forms.Validators.pattern('^[0-9]*$')
            ]);
        };
        /**
         * @return {?}
         */
        InputRnpsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init(RnpsValue.rnps_Abbreviation, RnpsValue.rnps_Placeholder, true, true);
            /* The '_codeOldValue' must be set after the 'content.formControl.value' is set. */
            this.handleSpecificInput();
        };
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         */
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        InputRnpsComponent.prototype.getErrorMessage = /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var result = '';
            /** @type {?} */
            var result_alreadyHaveErrorInfo = false;
            /** @type {?} */
            var validationErrors = this.content.formControl.errors;
            /* Shows the code errors. */
            if (validationErrors) {
                if ((validationErrors[ExtraValidators.equalLength.name]) || (validationErrors[forms.Validators.required.name])) {
                    result = 'TOCO_NG_ERROR_MSG_RNPS_LONG_INVAL';
                    result_alreadyHaveErrorInfo = true;
                }
                if (validationErrors[forms.Validators.pattern.name]) {
                    if (result_alreadyHaveErrorInfo) {
                        result = 'TOCO_NG_ERROR_MSG_RNPS_LONG_Y_DIG_INVAL';
                    }
                    else {
                        result = 'TOCO_NG_ERROR_MSG_RNPS_DIG_INVAL';
                    }
                    result_alreadyHaveErrorInfo = true;
                }
            }
            return result;
        };
        /**
         * Handler method that is called by the internal logic when the control's value changes in the UI.
         * This method contains the specific handling of the input that the derived class wants to do.
         */
        /**
         * Handler method that is called by the internal logic when the control's value changes in the UI.
         * This method contains the specific handling of the input that the derived class wants to do.
         * @return {?}
         */
        InputRnpsComponent.prototype.handleSpecificInput = /**
         * Handler method that is called by the internal logic when the control's value changes in the UI.
         * This method contains the specific handling of the input that the derived class wants to do.
         * @return {?}
         */
        function () {
            if (this.content.formControl.value.length > RnpsValue.codeLength) {
                /* Sets the old value. */
                this.content.formControl.setValue(this._codeOldValue);
            }
            else {
                /* Updates the old values. */
                this._codeOldValue = this.content.formControl.value;
            }
        };
        InputRnpsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'input-rnps',
                        template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
                    }] }
        ];
        /** @nocollapse */
        InputRnpsComponent.ctorParameters = function () { return []; };
        return InputRnpsComponent;
    }(InputControl));
    if (false) {
        /**
         * It is used by `handleSpecificInput` method.
         * @type {?}
         * @private
         */
        InputRnpsComponent.prototype._codeOldValue;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/select/select-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * An interface that represents a selectable option.
     * @record
     */
    function SelectOption() { }
    if (false) {
        /**
         * Returns the label that is showed.
         * @type {?}
         */
        SelectOption.prototype.label;
        /**
         * Returns the value that is stored internally.
         * @type {?}
         */
        SelectOption.prototype.value;
    }
    /**
     * An interface that represents the content of a select control.
     * @record
     */
    function SelectContent() { }
    if (false) {
        /**
         * Returns the options list that can be selected.
         * This field can be set using three ways:
         *  - Its value is `undefined`, then it takes the options from the `content.value` field.
         *  - Its value is a `SelectOption[]`, then it already contains the options.
         *  - Its value is an `Observable<SelectOption[]>`, then it takes the options when the observable emits values.
         * By default, its value is `[]`.
         * @type {?|undefined}
         */
        SelectContent.prototype.selectOptions;
        /**
         * Returns true if the selection can be multiple; otherwise, false.
         * By default, its value is `false`.
         * @type {?|undefined}
         */
        SelectContent.prototype.multiple;
        /**
         * Returns true if the tooltip is showed; otherwise, false.
         * By default, its value is `false`.
         * @type {?|undefined}
         */
        SelectContent.prototype.showTooltip;
        /**
         * Returns a value that allows the user to define the position of the tooltip for the select control.
         * It is used if the `showTooltip` field value is `true`.
         * By default, its value is `'below'`.
         * Its value can be one of these values: 'left', 'right', 'above', 'below', 'after', 'before'
         * @type {?|undefined}
         */
        SelectContent.prototype.selectTooltipPosition;
        /**
         * Returns a value that allows the user to define the position of the tooltip for the select control's options.
         * It is used if the `showTooltip` field value is `true`.
         * By default, its value is `'right'`.
         * Its value can be one of these values: 'left', 'right', 'above', 'below', 'after', 'before'
         * @type {?|undefined}
         */
        SelectContent.prototype.optionsTooltipPosition;
    }
    /**
     * Represents a control that allows to select one value or multiple values.
     * Implementation notes:
     * The `extraContent` recibe una funcion llamada getOptions() que se encarga de contruir un SelectOption[].
     * Si es multiple, entonces el `value` es un array de valores.
     */
    var InputSelectComponent = /** @class */ (function (_super) {
        __extends(InputSelectComponent, _super);
        function InputSelectComponent(_transServ) {
            var _this = _super.call(this) || this;
            _this._transServ = _transServ;
            _this._selectOptionsSubscription = null;
            _this.selectTooltip = '';
            return _this;
        }
        /**
         * @return {?}
         */
        InputSelectComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init('', '', false, true);
            /* The `selectTooltip` value is set in `onSelectionChange` method when happening initialization or selection change. */
            this.onSelectionChange();
        };
        /**
         * @return {?}
         */
        InputSelectComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
            /* Disposes the resources held by the subscription. */
            this._selectOptions_Unsubscription();
        };
        /**
         * Initializes the `content` input property.
         * @param label The default label to use. It is used if the `content.label` is not specified.
         * @param placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param alwaysHint If it is true then there is always at leat one hint start-aligned.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
         * @return {?}
         */
        InputSelectComponent.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
         * @return {?}
         */
        function (label, placeholder, isAbbreviation, alwaysHint) {
            var _this = this;
            if (placeholder === void 0) { placeholder = ''; }
            /* Changes the translation when the language changes. */
            this._transServ.onLangChange.subscribe((/**
             * @param {?} params
             * @return {?}
             */
            function (params) {
                _this._setSelectTooltip();
            }));
            /* Sets the default values. */
            _super.prototype.init.call(this, label, placeholder, isAbbreviation, alwaysHint);
            if (this.content.startHint != undefined) {
                if (this.content.startHint.label == 'TOCO_NG_HINT_TEXTO_POR_DEFECTO')
                    this.content.startHint.label = 'TOCO_NG_HINT_TEXTO_SELECC_POR_DEFECTO';
            }
            else
                this.content.startHint = new HintValue(HintPosition.start, 'TOCO_NG_HINT_TEXTO_SELECC_POR_DEFECTO');
            if (this.content.multiple == undefined)
                this.content.multiple = false;
            if (this.content.showTooltip == undefined)
                this.content.showTooltip = false;
            if (this.content.selectTooltipPosition == undefined)
                this.content.selectTooltipPosition = 'below';
            if (this.content.optionsTooltipPosition == undefined)
                this.content.optionsTooltipPosition = 'right';
            if (this.content.selectOptions == undefined) {
                if (this.content.value == undefined) {
                    this.content.selectOptions = [];
                }
                else {
                    /* Gets the `content.selectOptions` from the `content.value` field. */
                    if (util.isArray(this.content.value)) {
                        this.content.multiple = true; /* The control must be multiple. */
                        this.content.selectOptions = [];
                        this.content.value.forEach((/**
                         * @param {?} option
                         * @return {?}
                         */
                        function (option) {
                            ((/** @type {?} */ (_this.content.selectOptions))).push({
                                'label': option,
                                'value': option.toUpperCase()
                            });
                        }));
                    }
                    else {
                        this.content.selectOptions = [
                            {
                                'label': this.content.value,
                                'value': this.content.value.toUpperCase()
                            }
                        ];
                    }
                }
            }
            else if (util.isArray(this.content.selectOptions)) {
                /* Nothing to do here, but this case must be here. */
            }
            else if (this.content.selectOptions instanceof rxjs.Observable) {
                /* Gets the `content.selectOptions` from an `Observable` when it emits values. */
                this._selectOptions_Unsubscription();
                this._selectOptionsSubscription = this.content.selectOptions.subscribe((/**
                 * @param {?} selectOptions
                 * @return {?}
                 */
                function (selectOptions) {
                    _this.content.selectOptions = selectOptions;
                }));
            }
            else {
                throw new Error("For the '" + InputSelectComponent.name + "' control, the 'content.selectOptions' type value has a configuration error because the programme does not know what to do with it!");
            }
            /* The `selectTooltip` value is set in `onSelectionChange` method when happening initialization or selection change. */
        };
        /**
         * @private
         * @return {?}
         */
        InputSelectComponent.prototype._selectOptions_Unsubscription = /**
         * @private
         * @return {?}
         */
        function () {
            /* Disposes the resources held by the subscription. */
            if (this._selectOptionsSubscription) {
                this._selectOptionsSubscription.unsubscribe();
            }
        };
        /**
         * @return {?}
         */
        InputSelectComponent.prototype.onSelectionChange = /**
         * @return {?}
         */
        function () {
            // console.log('Call `onSelectionChange` - ', 'Select value: ', this.content.formControl.value);
            this._setSelectTooltip();
            if ((this.content.extraContent) && (this.content.extraContent.selectionChange)) {
                this.content.extraContent.selectionChange(this.content.formControl.value);
            }
        };
        /**
         * Does the translation for a key (or an array of keys).
         * @param key The key (or an array of keys) to translate.
         */
        /**
         * Does the translation for a key (or an array of keys).
         * @private
         * @param {?} key The key (or an array of keys) to translate.
         * @return {?}
         */
        InputSelectComponent.prototype._doTranslation = /**
         * Does the translation for a key (or an array of keys).
         * @private
         * @param {?} key The key (or an array of keys) to translate.
         * @return {?}
         */
        function (key) {
            var _this = this;
            if (key.length == 0) {
                this.selectTooltip = '';
                return;
            }
            this._transServ.get(key).subscribe((/**
             * @param {?} res
             * @return {?}
             */
            function (res) {
                // console.log(key, ' --> ', res);
                if (_this.content.multiple) {
                    /* `res` is an object of translated keys. */
                    /** @type {?} */
                    var translationKeys = Object.keys(res);
                    /** @type {?} */
                    var len = translationKeys.length;
                    /** @type {?} */
                    var translationRes = res[translationKeys[0]];
                    for (var i = 1; i < len; ++i) {
                        translationRes += '\n' + res[translationKeys[i]];
                    }
                    _this.selectTooltip = translationRes;
                }
                else {
                    /* `res` is a translated key. */
                    _this.selectTooltip = res;
                }
            }));
        };
        /**
         * Finds the label for a value (or an array of values).
         * @param value The value (or an array of values) to find the label.
         * @returns Returns a label (or an array of labels).
         */
        /**
         * Finds the label for a value (or an array of values).
         * @private
         * @param {?} value The value (or an array of values) to find the label.
         * @return {?} Returns a label (or an array of labels).
         */
        InputSelectComponent.prototype._findLabel = /**
         * Finds the label for a value (or an array of values).
         * @private
         * @param {?} value The value (or an array of values) to find the label.
         * @return {?} Returns a label (or an array of labels).
         */
        function (value) {
            var e_1, _a, e_2, _b, e_3, _c;
            if (this.content.multiple) {
                /** @type {?} */
                var label = [];
                try {
                    for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                        var val = value_1_1.value;
                        try {
                            for (var _d = (e_2 = void 0, __values(((/** @type {?} */ (this.content.selectOptions))))), _e = _d.next(); !_e.done; _e = _d.next()) {
                                var opt = _e.value;
                                if (opt.value == val) {
                                    label.push(opt.label);
                                    break;
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_e && !_e.done && (_b = _d.return)) _b.call(_d);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return label;
            }
            else {
                /** @type {?} */
                var label = '';
                try {
                    for (var _f = __values(((/** @type {?} */ (this.content.selectOptions)))), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var opt = _g.value;
                        if (opt.value == value) {
                            label = opt.label;
                            break;
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_c = _f.return)) _c.call(_f);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                return label;
            }
        };
        /**
         * Sets the `selectTooltip` field value.
         */
        /**
         * Sets the `selectTooltip` field value.
         * @private
         * @return {?}
         */
        InputSelectComponent.prototype._setSelectTooltip = /**
         * Sets the `selectTooltip` field value.
         * @private
         * @return {?}
         */
        function () {
            if (this.content.formControl.value != undefined) {
                this._doTranslation(this._findLabel(this.content.formControl.value));
            }
            else {
                this.selectTooltip = '';
            }
        };
        InputSelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'input-select',
                        template: "\n<mat-form-field\n\tclass=\"select-mat-form-field\"\n\t[appearance]=\"content.appearance\"\n>\n\n\t<mat-label>\n\t\t{{ content.label | translate }}\n\t</mat-label>\n\n\t<ng-container *ngIf=\"content.showTooltip; then thenTemplate_Tooltip; else elseTemplate_WithoutTooltip\"></ng-container>\n\n\t<ng-template #thenTemplate_Tooltip>\n\t\t<mat-select \n\t\t\t[formControl]=\"content.formControl\"\n\t\t\t[required]=\"content.required\"\n\t\t\t[style.textAlign]=\"content.textAlign\"\n\t\t\t[attr.aria-label]=\"content.ariaLabel | translate\"\n\t\t\t[(value)]=\"content.value\"\n\t\t\t[multiple]=\"content.multiple\"\n\t\t\t(selectionChange)=\"onSelectionChange()\"\n\t\t\t[matTooltip]=\"selectTooltip\" [matTooltipPosition]=\"content.selectTooltipPosition\" [matTooltipClass]=\"'tooltip-multiple-lines'\"\n\t\t>\n\t\t\t<mat-option \n\t\t\t\t*ngFor=\"let option of content.selectOptions\" \n\t\t\t\t[value]=\"option.value\"\n\t\t\t\t[matTooltip]=\"option.label | translate\" [matTooltipPosition]=\"content.optionsTooltipPosition\"\n\t\t\t>\n\t\t\t\t{{ option.label | translate }}\n\t\t\t</mat-option>\n\t\t</mat-select>\n\t</ng-template>\n\n\t<ng-template #elseTemplate_WithoutTooltip>\n\t\t<mat-select \n\t\t\t[formControl]=\"content.formControl\"\n\t\t\t[required]=\"content.required\"\n\t\t\t[style.textAlign]=\"content.textAlign\"\n\t\t\t[attr.aria-label]=\"content.ariaLabel | translate\"\n\t\t\t[(value)]=\"content.value\"\n\t\t\t[multiple]=\"content.multiple\"\n\t\t\t(selectionChange)=\"onSelectionChange()\"\n\t\t>\n\t\t\t<mat-option \n\t\t\t\t*ngFor=\"let option of content.selectOptions\" \n\t\t\t\t[value]=\"option.value\"\n\t\t\t>\n\t\t\t\t{{ option.label | translate }}\n\t\t\t</mat-option>\n\t\t</mat-select>\n\t</ng-template>\n\n\t<mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".select-mat-form-field{width:100%}::ng-deep .tooltip-multiple-lines{white-space:pre-line!important}"]
                    }] }
        ];
        /** @nocollapse */
        InputSelectComponent.ctorParameters = function () { return [
            { type: core$2.TranslateService }
        ]; };
        InputSelectComponent.propDecorators = {
            content: [{ type: core.Input }]
        };
        return InputSelectComponent;
    }(InputControl));
    if (false) {
        /**
         * Input field that contains the content of this class.
         * @type {?}
         */
        InputSelectComponent.prototype.content;
        /**
         * Returns the current selected option tooltip.
         * If nothing is selected, then its value is `''`.
         * @type {?}
         */
        InputSelectComponent.prototype.selectTooltip;
        /**
         * @type {?}
         * @private
         */
        InputSelectComponent.prototype._selectOptionsSubscription;
        /**
         * @type {?}
         * @private
         */
        InputSelectComponent.prototype._transServ;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/text/text-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a control that allows the writing of a text.
     */
    var InputTextComponent = /** @class */ (function (_super) {
        __extends(InputTextComponent, _super);
        function InputTextComponent() {
            return _super.call(this) || this;
        }
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputTextComponent`'s `content.formControl` value by default.
         * @param validatorArguments An object that has only one field of `pattern` name and its value is a string.
         * The `pattern` name is the validator name and the value is the value that the validator needs to check.
         * For example, you can call the `getFormControlByDefault` method in this way:
         * InputTextComponent.getFormControlByDefault({ 'pattern': '^[a-zA-Z][a-zA-Z\-\_\ 0-9]*$' });
         * If this argument is not specified, by default its value is `undefined`.
         */
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputTextComponent`'s `content.formControl` value by default.
         * @param {?=} validatorArguments An object that has only one field of `pattern` name and its value is a string.
         * The `pattern` name is the validator name and the value is the value that the validator needs to check.
         * For example, you can call the `getFormControlByDefault` method in this way:
         * InputTextComponent.getFormControlByDefault({ 'pattern': '^[a-zA-Z][a-zA-Z\-\_\ 0-9]*$' });
         * If this argument is not specified, by default its value is `undefined`.
         * @return {?}
         */
        InputTextComponent.getFormControlByDefault = /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputTextComponent`'s `content.formControl` value by default.
         * @param {?=} validatorArguments An object that has only one field of `pattern` name and its value is a string.
         * The `pattern` name is the validator name and the value is the value that the validator needs to check.
         * For example, you can call the `getFormControlByDefault` method in this way:
         * InputTextComponent.getFormControlByDefault({ 'pattern': '^[a-zA-Z][a-zA-Z\-\_\ 0-9]*$' });
         * If this argument is not specified, by default its value is `undefined`.
         * @return {?}
         */
        function (validatorArguments) {
            if (validatorArguments === void 0) { validatorArguments = undefined; }
            return new forms.FormControl('', (((validatorArguments) && (validatorArguments.pattern)) ? [forms.Validators.pattern(validatorArguments.pattern)] : []));
        };
        /**
         * @return {?}
         */
        InputTextComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init('', '', false, true);
        };
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         */
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        InputTextComponent.prototype.getErrorMessage = /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var validationErrors = this.content.formControl.errors;
            /* Shows the identifier errors. */
            if (validationErrors) {
                if (validationErrors[forms.Validators.required.name]) {
                    return this.validationError_required;
                }
                else {
                    /* It is `validationErrors[Validators.pattern.name]`. */
                    return 'TOCO_NG_ERROR_MSG_TEXTO_INVAL';
                }
            }
            return '';
        };
        InputTextComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'input-text',
                        template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
                    }] }
        ];
        /** @nocollapse */
        InputTextComponent.ctorParameters = function () { return []; };
        return InputTextComponent;
    }(InputControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/url/url-value.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Data structure for holding an url.
     */
    var UrlValue = /** @class */ (function () {
        function UrlValue(u) {
            this.url = u;
        }
        /**
         * Returns a string representation of this `UrlValue` object.
         */
        /**
         * Returns a string representation of this `UrlValue` object.
         * @return {?}
         */
        UrlValue.prototype.toString = /**
         * Returns a string representation of this `UrlValue` object.
         * @return {?}
         */
        function () {
            return UrlValue.url_Label + ' ' + this.url;
        };
        /**
         * Represents the url label.
         */
        UrlValue.url_Label = 'Url';
        /**
         * Represents the url placeholder.
         */
        UrlValue.url_Placeholder = 'https://www.google.com/';
        return UrlValue;
    }());
    if (false) {
        /**
         * Represents the url label.
         * @type {?}
         */
        UrlValue.url_Label;
        /**
         * Represents the url placeholder.
         * @type {?}
         */
        UrlValue.url_Placeholder;
        /**
         * The url value.
         * @type {?}
         */
        UrlValue.prototype.url;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/input/url/url-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a control that allows the writing of a url.
     * It uses the `UrlValue.url_Label` as a label if the `content.label` is not specified.
     * It uses the `UrlValue.url_Placeholder` as a placeholder if the `content.placeholder` is not specified.
     */
    var InputUrlComponent = /** @class */ (function (_super) {
        __extends(InputUrlComponent, _super);
        function InputUrlComponent() {
            return _super.call(this) || this;
        }
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputUrlComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         */
        /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputUrlComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         * @param {?=} validatorArguments
         * @return {?}
         */
        InputUrlComponent.getFormControlByDefault = /**
         * Returns a `FormControl` by default.
         * It is used to initialized the `InputUrlComponent`'s `content.formControl` value by default.
         * In this case, the `validatorArguments` argument is always `undefined`.
         * @param {?=} validatorArguments
         * @return {?}
         */
        function (validatorArguments) {
            if (validatorArguments === void 0) { validatorArguments = undefined; }
            // const reg = '/(^|\s)((https?:\/\/)?[\w-]+(\.[\w-]+)+\.?(:\d+)?(\/\S*)?)/gi';
            // const reg2 = '[a-z.]*';
            /** @type {?} */
            var reg3 = '(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?';
            return new forms.FormControl('', [
                forms.Validators.pattern(reg3)
                // Validators.pattern('/(^|\s)((https?:\/\/)?[\w-]+(\.[\w-]+)+\.?(:\d+)?(\/\S*)?)/i')
                // Validators.pattern(/((([A-Za-z]{3,9}:(?:\/\/)?)(?:[\-;:&=\+\$,\w]+@)?[A-Za-z0-9\.\-]+|(?:www\.|[\-;:&=\+\$,\w]+@)[A-Za-z0-9\.\-]+)((?:\/[\+~%\/\.\w\-_]*)?\??(?:[\-\+=&;%@\.\w_]*)#?(?:[\.\!\/\\\w]*))?)/i)
            ]);
        };
        /**
         * @return {?}
         */
        InputUrlComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init(UrlValue.url_Label, UrlValue.url_Placeholder, false, true);
        };
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         */
        /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        InputUrlComponent.prototype.getErrorMessage = /**
         * Returns an error string if the control is in an error state; otherwise, empty string.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var validationErrors = this.content.formControl.errors;
            /* Shows the url errors. */
            if (validationErrors) {
                if (validationErrors[forms.Validators.required.name]) {
                    return this.validationError_required;
                }
                else {
                    /* It is `validationErrors[Validators.pattern.name]`. */
                    return 'TOCO_NG_ERROR_MSG_URL_INVAL';
                }
            }
            return '';
        };
        InputUrlComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'input-url',
                        template: "\n<mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\">\n<!-- <mat-form-field class=\"text-mat-form-field\" [appearance]=\"content.appearance\" [formGroup]=\"content.parentFormSection\"> -->\n\n    <mat-label>{{ content.label | translate }}</mat-label>\n\n    <input matInput [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" />\n    <!-- <input matInput id=\"inputId-{{ content.name }}\" class=\"input-text-element\" [formControl]=\"content.formControl\" [required]=\"content.required\" [placeholder]=\"content.placeholder | translate\" [style.textAlign]=\"content.textAlign\" [attr.aria-label]=\"content.ariaLabel | translate\" (input)=\"handleInput()\" [formControlName]=\"content.name\" /> -->\n\n    <!-- At the moment of writing this code (2019-08-03), I think that there is an error in `ng-container` or \n        `mat-icon` or something related because I can not put the `mat-icon` tag within an `ng-container` tag \n        because the normal layout of `mat-icon` is modified. This is a contradiction because the `ng-container` \n        does not interfere with styles or layout. -->\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.internal)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix [svgIcon]=\"content.prefixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.prefixIcon && iconSourceState(content.prefixIcon, iconSource.external)\" class=\"text-mat-icon-prefix mat-icon {{ content.appearance }} notranslate\" matPrefix>{{ content.prefixIcon.name }}</mat-icon>\n\n    <!-- Only renders one of these two `mat-icon` or nothing. -->\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.internal)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix [svgIcon]=\"content.suffixIcon.name\"></mat-icon>\n    <mat-icon *ngIf=\"content.suffixIcon && iconSourceState(content.suffixIcon, iconSource.external)\" class=\"text-mat-icon-suffix mat-icon {{ content.appearance }} notranslate\" matSuffix>{{ content.suffixIcon.name }}</mat-icon>\n\n    <span *ngIf=\"content.prefixText\" matPrefix><pre class=\"content.appearance\">{{ content.prefixText }}</pre></span>\n    <span *ngIf=\"content.suffixText\" matSuffix><pre class=\"content.appearance\">{{ content.suffixText }}</pre></span>\n\n    <mat-hint *ngIf=\"hintState && content.startHint\" [align]=\"'start'\">{{ content.startHint.label | translate }}</mat-hint>\n    <mat-hint *ngIf=\"hintState && content.endHint\" [align]=\"'end'\">{{ content.endHint.label | translate }}</mat-hint>\n    <mat-error *ngIf=\"errorState\">\n        <ng-container *ngIf=\"isTranslationBuiltByControl; then thenTemplate_BuildTranslation; else elseTemplate_NotBuildTranslation\"></ng-container>\n\n        <ng-template #thenTemplate_BuildTranslation>{{ getErrorMessage() }}</ng-template>\n\n        <ng-template #elseTemplate_NotBuildTranslation>{{ getErrorMessage() | translate }}</ng-template>\n    </mat-error>\n\n</mat-form-field>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".text-mat-form-field{width:100%;cursor:text}.text-mat-icon-prefix{margin-right:8px}.text-mat-icon-prefix.standard{position:relative;top:4px}.text-mat-icon-suffix{margin-left:8px}.text-mat-icon-suffix.standard{position:relative;top:4px}pre{margin:0}pre.outline{position:relative;bottom:4px}"]
                    }] }
        ];
        /** @nocollapse */
        InputUrlComponent.ctorParameters = function () { return []; };
        return InputUrlComponent;
    }(InputControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/vocabulary/vocabulary.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function VocabularyComponentExtraContent() { }
    if (false) {
        /** @type {?} */
        VocabularyComponentExtraContent.prototype.multiple;
        /** @type {?} */
        VocabularyComponentExtraContent.prototype.selectedTermsIds;
        /** @type {?} */
        VocabularyComponentExtraContent.prototype.excludeTermsIds;
        /** @type {?} */
        VocabularyComponentExtraContent.prototype.level;
        /** @type {?} */
        VocabularyComponentExtraContent.prototype.vocab;
    }
    /**
     * A control to select a term or terms in a vocabulary.
     */
    var VocabularyComponent = /** @class */ (function (_super) {
        __extends(VocabularyComponent, _super);
        function VocabularyComponent(service) {
            var _this = _super.call(this) || this;
            _this.service = service;
            // internalControl = new FormControl();
            //this control is used by the chips,not necessary to expose it
            _this.chipsFormControl = new forms.FormControl();
            _this.chipsList = [];
            _this.selectOptions = [];
            _this.terms = [];
            _this.loading = true;
            // selectedTermsIds = [];
            _this.searchText = "Seleccione las opciones";
            _this.termsTreeObserver = {
                next: (/**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    console.log("VOCABULARY COMPONENT RESPONSE ", response);
                    console.log(response.data.tree);
                    _this.terms = response.data.tree.term_node;
                    _this.terms.forEach((/**
                     * @param {?} element
                     * @return {?}
                     */
                    function (element) {
                        _this.selectOptions = _this.selectOptions.concat(_this._get_terms(element));
                    }));
                }),
                error: (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    console.log("The observable got an error notification: " + err + ".");
                }),
                complete: (/**
                 * @return {?}
                 */
                function () {
                    console.log("The observable got a complete notification.");
                    _this.loading = !_this.loading;
                })
            };
            return _this;
        }
        /**
         * @return {?}
         */
        VocabularyComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.init('', '', false, true);
            // (this.content.parentFormSection as FormGroup).addControl(
            //   this.content.name,
            //   this.internalControl
            // );
            if (this.content.required) {
                this.content.formControl.setValidators((/**
                 * @param {?} control
                 * @return {?}
                 */
                function (control) {
                    return !_this.content.value || _this.content.value.length == 0
                        ? { requiredTerms: "No Terms Selected" }
                        : null;
                }));
            }
            this.inputId = this.content.label.trim().toLowerCase();
            if (this.content.extraContent) {
                this.extraContent = this.content.extraContent;
                // if (this.extraContent.multiple !== null) {
                //   this.multiple = this.extraContent.multiple;
                // }
                // if (this.extraContent.selectedTermsIds) {
                //   this.content.value = this.extraContent.selectedTermsIds;
                // } else {
                //   this.content.value = [];
                // }
                // already selected terms
                if (!this.extraContent.selectedTermsIds) {
                    this.extraContent.selectedTermsIds = [];
                }
                // terms ids to exclude of the possible options.
                if (!this.extraContent.excludeTermsIds) {
                    this.extraContent.excludeTermsIds = [];
                }
                this.content.value = [];
                if (this.extraContent.level == undefined) {
                    this.extraContent.level = 10;
                }
                if (this.extraContent.vocab) {
                    // this.vocab = this.extraContent.vocab;
                    this.service
                        .getTermsTreeByVocab(this.extraContent.vocab, this.extraContent.level)
                        .subscribe(this.termsTreeObserver);
                }
                //   else if(this.extraContent.termID){
                //     this.service.getTermByUUID(this.extraContent.termID, this.extraContent.level)
                //     .subscribe(this.termsTreeObserver);
                // }
                this._updateFilteredOptions();
            }
        };
        /**
         * @private
         * @return {?}
         */
        VocabularyComponent.prototype.setValidation = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.content.formControl.valid) {
                this.chipsFormControl.setErrors(null);
            }
            else {
                this.chipsFormControl.setErrors({ requiered: true });
            }
        };
        /**
         * @private
         * @param {?} term
         * @return {?}
         */
        VocabularyComponent.prototype.addTermToValue = /**
         * @private
         * @param {?} term
         * @return {?}
         */
        function (term) {
            if (this.extraContent.multiple) {
                this.content.value.unshift(term);
            }
            else {
                this.content.value = [term];
            }
            this.content.formControl.setValue(this.content.value);
            this.setValidation();
        };
        /**
         * @private
         * @param {?} term
         * @return {?}
         */
        VocabularyComponent.prototype.removeTermFromValue = /**
         * @private
         * @param {?} term
         * @return {?}
         */
        function (term) {
            this.content.value = ((/** @type {?} */ (this.content.value))).filter((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return e.id !== term.id; }));
            this.content.formControl.setValue(this.content.value);
            this.setValidation();
        };
        /**
         * @private
         * @return {?}
         */
        VocabularyComponent.prototype._updateFilteredOptions = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.filteredOptions = this.chipsFormControl.valueChanges.pipe(operators.startWith(""), operators.map((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var filterValue = value ? value.toLowerCase() : "";
                console.log('************************************');
                console.log(_this.selectOptions);
                console.log('************************************');
                return _this.selectOptions.filter((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) {
                    return option.term.identifier.toLowerCase().includes(filterValue);
                }));
            })));
        };
        /**
         * @private
         * @param {?} node
         * @param {?=} parent
         * @return {?}
         */
        VocabularyComponent.prototype._get_terms = /**
         * @private
         * @param {?} node
         * @param {?=} parent
         * @return {?}
         */
        function (node, parent) {
            var _this = this;
            if (parent === void 0) { parent = null; }
            /** @type {?} */
            var result = [];
            node.parent = parent;
            // if is in selected terms ids list, then is part of the value
            if (((/** @type {?} */ (this.extraContent.selectedTermsIds))).some((/**
             * @param {?} id
             * @return {?}
             */
            function (id) { return id === node.term.uuid; }))) {
                this.addTermToValue(node.term);
                this.chipsList.push(node);
            }
            else {
                // if is not in any of the exclude term ids, then push
                if (!((/** @type {?} */ (this.extraContent.excludeTermsIds))).some((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return id === node.term.uuid; }))) {
                    result.push(node);
                }
            }
            if (node.children) {
                node.children.forEach((/**
                 * @param {?} child
                 * @return {?}
                 */
                function (child) {
                    result = result.concat(_this._get_terms(child, node));
                }));
            }
            return result;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        VocabularyComponent.prototype.addChips = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.extraContent.multiple) {
                this.chipsList.unshift(value);
            }
            else {
                // if not is multiple, then the element in the chipsList goes back to the options
                if (this.chipsList.length > 0) {
                    this.selectOptions.push(this.chipsList[0]);
                }
                this.chipsList = [value];
            }
            this.addTermToValue(value.term);
            this.selectOptions = this.selectOptions.filter((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.term.id !== value.term.id; }));
            this.chipsFormControl.setValue("");
            // document.getElementById(this.inputId).blur();
            this._updateFilteredOptions();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        VocabularyComponent.prototype.removeChip = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.selectOptions.push(this.chipsList[index]);
            this.removeTermFromValue(this.chipsList[index].term);
            this.chipsList.splice(index, 1);
            this._updateFilteredOptions();
        };
        /**
         * @param {?} node
         * @return {?}
         */
        VocabularyComponent.prototype.getTermNameInATree = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            if (node.parent != null) {
                return this.getTermNameInATree(node.parent) + " / " + node.term.description;
            }
            else {
                return node.term.description;
            }
        };
        VocabularyComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-vocabulary",
                        template: "<mat-card>\n\n  <mat-progress-bar *ngIf=\"loading\"\n    mode=\"indeterminate\">\n  </mat-progress-bar>\n\n    <mat-card-subtitle *ngIf=\"!loading\">\n    <mat-form-field style=\"width: 100%;\">\n\n      <mat-label> {{content.label}} <span *ngIf=\"content.required\">*</span></mat-label>\n      <input\n        matInput\n        id=\"'inputId-'{{content.name}}\"\n        type=\"text\"\n        [formControl]=\"chipsFormControl\"\n        [matAutocomplete]=\"auto\"\n          aria-label=\"Number\"\n      />\n\n      <mat-hint *ngIf=\"content.startHint\" [align]=\"'start'\">{{ content.startHint.label }}</mat-hint>\n      <mat-hint *ngIf=\"!content.startHint\" [align]=\"'start'\">{{ searchText }}</mat-hint>\n\n      <mat-autocomplete #auto=\"matAutocomplete\">\n        <mat-option *ngFor=\"let option of filteredOptions | async\" [value]=\"option.term.description\" (click)=\"addChips(option)\"\n          [title]=\"option.term.description\">\n          {{ option.term.description }}\n        </mat-option>\n      </mat-autocomplete>\n\n      <!-- <button mat-icon-button color=\"accent\" class=\"delete-filter\" (click)=\"remove_component()\">\n      <mat-icon>close</mat-icon>\n    </button> -->\n    </mat-form-field>\n  </mat-card-subtitle>\n  <mat-card-content *ngIf=\"!loading\">\n    <mat-chip-list class=\"mat-chip-list-stacked\" fxLayout=\"row\" fxLayoutAlign=\"start center\" style=\"margin-bottom: .5em\"\n      id=\"chiplist-{{extraContent.vocab}}\">\n      <mat-chip *ngFor=\"let item of chipsList; let i=index\" (removed)=\"removeChip(i)\" [removable]=\"true\" style=\"width: 100%;height: 100%;\">\n        {{ getTermNameInATree(item) }}\n        <mat-icon matChipRemove>cancel</mat-icon>\n      </mat-chip>\n    </mat-chip-list>\n  </mat-card-content>\n\n</mat-card>\n",
                        host: {
                            "[style.minWidth]": "content.minWidth",
                            "[style.width]": "content.width"
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        VocabularyComponent.ctorParameters = function () { return [
            { type: TaxonomyService }
        ]; };
        return VocabularyComponent;
    }(InputControl));
    if (false) {
        /** @type {?} */
        VocabularyComponent.prototype.chipsFormControl;
        /** @type {?} */
        VocabularyComponent.prototype.inputId;
        /** @type {?} */
        VocabularyComponent.prototype.filteredOptions;
        /** @type {?} */
        VocabularyComponent.prototype.chipsList;
        /** @type {?} */
        VocabularyComponent.prototype.selectOptions;
        /** @type {?} */
        VocabularyComponent.prototype.terms;
        /** @type {?} */
        VocabularyComponent.prototype.loading;
        /** @type {?} */
        VocabularyComponent.prototype.extraContent;
        /** @type {?} */
        VocabularyComponent.prototype.searchText;
        /**
         * @type {?}
         * @private
         */
        VocabularyComponent.prototype.termsTreeObserver;
        /**
         * @type {?}
         * @private
         */
        VocabularyComponent.prototype.service;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/vocabulary-tree/vocabulary-tree.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function VocabularyComponentExtraContent$1() { }
    if (false) {
        /** @type {?} */
        VocabularyComponentExtraContent$1.prototype.multiple;
        /** @type {?} */
        VocabularyComponentExtraContent$1.prototype.selectedTermsIds;
        /** @type {?} */
        VocabularyComponentExtraContent$1.prototype.excludeTermsIds;
        /** @type {?} */
        VocabularyComponentExtraContent$1.prototype.level;
        /** @type {?} */
        VocabularyComponentExtraContent$1.prototype.vocab;
    }
    /**
     * A control to select a term or terms in a vocabulary.
     */
    var VocabularyTreeComponent = /** @class */ (function (_super) {
        __extends(VocabularyTreeComponent, _super);
        function VocabularyTreeComponent(service) {
            var _this = _super.call(this) || this;
            _this.service = service;
            // internalControl = new FormControl();
            //this control is used by the chips,not necessary to expose it
            _this.chipsFormControl = new forms.FormControl();
            _this.levelsOptions = null;
            _this.levelsSelection = new Array();
            _this.lastLevelTerm = null;
            _this.chipsList = [];
            _this.leafsOptions = null;
            _this.terms = [];
            _this.loading = true;
            // selectedTermsIds = [];
            _this.searchText = "Seleccione las opciones";
            return _this;
        }
        /**
         * @return {?}
         */
        VocabularyTreeComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.init('', '', false, true);
            // (this.content.parentFormSection as FormGroup).addControl(
            //   this.content.name,
            //   this.content.formControl
            // );
            if (this.content.required) {
                this.content.formControl.setValidators((/**
                 * @param {?} control
                 * @return {?}
                 */
                function (control) {
                    return !_this.content.value || _this.content.value.length == 0
                        ? { requiredTerms: "No Terms Selected" }
                        : null;
                }));
            }
            this.inputId = this.content.label.trim().toLowerCase();
            if (this.content.extraContent) {
                this.extraContent = this.content.extraContent;
                // already selected terms
                if (!this.extraContent.selectedTermsIds) {
                    this.extraContent.selectedTermsIds = [];
                }
                // terms ids to exclude of the possible options.
                if (!this.extraContent.excludeTermsIds) {
                    this.extraContent.excludeTermsIds = [];
                }
                this.content.value = [];
                this.content.formControl.setValue(this.content.value);
                if (this.extraContent.level == undefined) {
                    this.extraContent.level = 10;
                }
                if (this.extraContent.vocab) {
                    this.loading = true;
                    this.service.getTermsTreeByVocab(this.extraContent.vocab, 0).subscribe((/**
                     * @param {?} response
                     * @return {?}
                     */
                    function (response) {
                        _this.loading = false;
                        /** @type {?} */
                        var nextLevel = response.data.tree.term_node;
                        if (_this.extraContent.level > 0) {
                            _this.levelsOptions = new Array();
                            // this.levelsSelection = new Array<TermNode>();
                            _this._setLevelsOptions(nextLevel, 0);
                        }
                        else {
                            _this.leafsOptions = _this._get_terms(nextLevel);
                            _this._updateFilteredOptions();
                        }
                    }), (/**
                     * @param {?} err
                     * @return {?}
                     */
                    function (err) {
                        console.log("The observable got an error notification: " + err + ".");
                    }), (/**
                     * @return {?}
                     */
                    function () {
                        console.log("The observable got a complete notification.");
                        _this.loading = !_this.loading;
                    }));
                }
                //   else if(this.extraContent.termID){
                //     this.service.getTermByUUID(this.extraContent.termID, this.extraContent.level)
                //     .subscribe(this.termsTreeObserver);
                // }
            }
        };
        /**
         * @private
         * @param {?} nextLevel
         * @param {?} level
         * @return {?}
         */
        VocabularyTreeComponent.prototype._setLevelsOptions = /**
         * @private
         * @param {?} nextLevel
         * @param {?} level
         * @return {?}
         */
        function (nextLevel, level) {
            var _this = this;
            console.log('VOCABULARY TREE *****');
            console.log(this.extraContent.selectedTermsIds, nextLevel);
            /** @type {?} */
            var result = [];
            nextLevel.forEach((/**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                if (!((/** @type {?} */ (_this.extraContent.excludeTermsIds))).some((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return id === node.term.uuid; }))) {
                    result.push(node);
                }
                if (((/** @type {?} */ (_this.extraContent.selectedTermsIds))).some((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return id === node.term.uuid; }))) {
                    _this.onSelectionChange(level, node.term);
                    // this.addTermToValue(node.term);
                    // this.levelsSelection[level] = node.term;
                }
            }));
            this.levelsOptions.push(result);
        };
        /**
         * @param {?} level
         * @param {?} item
         * @return {?}
         */
        VocabularyTreeComponent.prototype.onSelectionChange = /**
         * @param {?} level
         * @param {?} item
         * @return {?}
         */
        function (level, item) {
            var _this = this;
            console.log(level, item);
            this.leafsOptions = null;
            this.chipsList = [];
            this.loading = true;
            this.lastLevelTerm = item;
            this.levelsOptions = this.levelsOptions.slice(0, level + 1);
            // this.removeTermFromValue(this.levelsSelection[level]);
            // this.levelsSelection[level] = item;
            // this.addTermToValue(this.levelsSelection[level]);
            this.content.value = [];
            this.levelsSelection = this.levelsSelection.slice(0, level);
            this.levelsSelection.push(item);
            this.levelsSelection.forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                _this.addTermToValue(element, false);
            }));
            this.service.getTermByUUID(item.uuid, 1).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                console.log(response);
                _this.loading = false;
                /** @type {?} */
                var nextLevel = response.data.term_node.children;
                if (_this.extraContent.level > level + 1) {
                    _this._setLevelsOptions(nextLevel, level);
                }
                else {
                    _this.leafsOptions = _this._get_terms(nextLevel);
                    _this._updateFilteredOptions();
                }
            }), (/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                console.log("The observable got an error notification: " + err + ".");
            }), (/**
             * @return {?}
             */
            function () {
                console.log("The observable got a complete notification.");
                _this.loading = !_this.loading;
            }));
        };
        /**
         * @private
         * @return {?}
         */
        VocabularyTreeComponent.prototype.setValidation = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.content.formControl.valid) {
                this.chipsFormControl.setErrors(null);
            }
            else {
                this.chipsFormControl.setErrors({ requiered: true });
            }
        };
        /**
         * @private
         * @param {?} term
         * @param {?=} isLeaf
         * @return {?}
         */
        VocabularyTreeComponent.prototype.addTermToValue = /**
         * @private
         * @param {?} term
         * @param {?=} isLeaf
         * @return {?}
         */
        function (term, isLeaf) {
            var _this = this;
            if (isLeaf === void 0) { isLeaf = true; }
            if (this.extraContent.multiple) {
                this.content.value.unshift(term);
            }
            else {
                this.content.value = [];
                this.levelsSelection.forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                function (element) {
                    _this.content.value.unshift(element);
                }));
                this.content.value.unshift(term);
            }
            console.log(this.content.value);
            this.content.formControl.setValue(this.content.value);
            this.setValidation();
            console.log(this.content.formControl);
        };
        /**
         * @private
         * @param {?} term
         * @return {?}
         */
        VocabularyTreeComponent.prototype.removeTermFromValue = /**
         * @private
         * @param {?} term
         * @return {?}
         */
        function (term) {
            this.content.value = ((/** @type {?} */ (this.content.value))).filter((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return e.id !== term.id; }));
            this.content.formControl.setValue(this.content.value);
            this.setValidation();
            console.log(this.content.formControl);
        };
        /**
         * @private
         * @return {?}
         */
        VocabularyTreeComponent.prototype._updateFilteredOptions = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.filteredOptions = this.chipsFormControl.valueChanges.pipe(operators.startWith(""), operators.map((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var filterValue = value ? value.toLowerCase() : "";
                return _this.leafsOptions.filter((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) {
                    return option.term.description.toLowerCase().includes(filterValue);
                }));
            })));
        };
        /**
         * @private
         * @param {?} nodes
         * @return {?}
         */
        VocabularyTreeComponent.prototype._get_terms = /**
         * @private
         * @param {?} nodes
         * @return {?}
         */
        function (nodes) {
            var _this = this;
            this.chipsList = [];
            /** @type {?} */
            var result = [];
            nodes.forEach((/**
             * @param {?} node
             * @return {?}
             */
            function (node) {
                if (((/** @type {?} */ (_this.extraContent.selectedTermsIds))).some((/**
                 * @param {?} id
                 * @return {?}
                 */
                function (id) { return id === node.term.uuid; }))) {
                    _this.addTermToValue(node.term);
                    _this.chipsList.push(node);
                }
                else {
                    // if is not in any of the exclude term ids, then push
                    if (!((/** @type {?} */ (_this.extraContent.excludeTermsIds))).some((/**
                     * @param {?} id
                     * @return {?}
                     */
                    function (id) { return id === node.term.uuid; }))) {
                        result.push(node);
                    }
                }
            }));
            return result;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        VocabularyTreeComponent.prototype.addChips = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.extraContent.multiple) {
                this.chipsList.unshift(value);
            }
            else {
                // if not is multiple, then the element in the chipsList goes back to the options
                if (this.chipsList.length > 0) {
                    this.leafsOptions.push(this.chipsList[0]);
                }
                this.chipsList = [value];
            }
            console.log(value, this.chipsList);
            this.addTermToValue(value.term);
            this.leafsOptions = this.leafsOptions.filter((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.term.id !== value.term.id; }));
            this.chipsFormControl.setValue("");
            // document.getElementById(this.inputId).blur();
            this._updateFilteredOptions();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        VocabularyTreeComponent.prototype.removeChip = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.leafsOptions.push(this.chipsList[index]);
            this.removeTermFromValue(this.chipsList[index].term);
            this.chipsList.splice(index, 1);
            this._updateFilteredOptions();
        };
        /**
         * @param {?} node
         * @return {?}
         */
        VocabularyTreeComponent.prototype.getTermNameInATree = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            if (node.parent != null) {
                return (this.getTermNameInATree(node.parent) + " / " + node.term.description);
            }
            else {
                return node.term.description;
            }
        };
        VocabularyTreeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-vocabulary-tree",
                        template: "<mat-card>\n  <mat-card-header>\n\n    <mat-progress-bar *ngIf=\"!levelsOptions\" mode=\"indeterminate\"></mat-progress-bar>\n\n    <ng-template *ngIf=\"levelsOptions\" >\n\n      <mat-form-field\n      *ngFor=\"let level of levelsOptions; let i = index\"\n      class=\"select-mat-form-field\"\n      [appearance]=\"content.appearance\"\n      style=\"width: 100%;\"\n    >\n      <mat-label>{{ content.label }}</mat-label>\n      <mat-select\n        name=\"item\"\n        [required]=\"content.required\"\n        [multiple]=\"false\"\n        [(value)]=\"levelsSelection[i]\"\n        (selectionChange)=\"onSelectionChange(i, levelsSelection[i])\"\n      >\n        <mat-option *ngFor=\"let item of level\" [value]=\"item.term\">\n          {{ item.term.description }}\n        </mat-option>\n      </mat-select>\n    </mat-form-field>\n    </ng-template>\n  </mat-card-header>\n\n  <mat-card-content *ngIf=\"lastLevelTerm\">\n    <mat-progress-bar *ngIf=\"!leafsOptions\" mode=\"indeterminate\">\n    </mat-progress-bar>\n\n    <mat-form-field *ngIf=\"leafsOptions\" style=\"width: 100%;\">\n      <mat-label>\n        {{ lastLevelTerm.description }}\n        <span *ngIf=\"content.required\">*</span></mat-label\n      >\n      <input\n        matInput\n        id=\"'inputId-'{{ content.name }}\"\n        type=\"text\"\n        [formControl]=\"chipsFormControl\"\n        [matAutocomplete]=\"auto\"\n        aria-label=\"Number\"\n      />\n\n      <mat-hint *ngIf=\"content.startHint\" [align]=\"'start'\">{{\n        content.startHint.label\n      }}</mat-hint>\n      <mat-hint *ngIf=\"!content.startHint\" [align]=\"'start'\">{{\n        searchText\n      }}</mat-hint>\n\n      <mat-autocomplete #auto=\"matAutocomplete\">\n        <mat-option\n          *ngFor=\"let option of filteredOptions | async\"\n          [value]=\"option.term.description\"\n          (click)=\"addChips(option)\"\n          [title]=\"option.term.description\"\n        >\n          {{ option.term.description }}\n        </mat-option>\n      </mat-autocomplete>\n\n      <!-- <button mat-icon-button color=\"accent\" class=\"delete-filter\" (click)=\"remove_component()\">\n      <mat-icon>close</mat-icon>\n    </button> -->\n    </mat-form-field>\n\n    <mat-chip-list\n      class=\"mat-chip-list-stacked\"\n      fxLayout=\"row\"\n      fxLayoutAlign=\"start center\"\n      style=\"margin-bottom: 0.5em;\"\n      id=\"chiplist-{{ extraContent.vocab }}\"\n    >\n      <mat-chip\n        *ngFor=\"let item of chipsList; let i = index\"\n        (removed)=\"removeChip(i)\"\n        [removable]=\"true\"\n      >\n        {{ getTermNameInATree(item) }}\n        <mat-icon matChipRemove>cancel</mat-icon>\n      </mat-chip>\n    </mat-chip-list>\n  </mat-card-content>\n</mat-card>\n",
                        host: {
                            "[style.minWidth]": "content.minWidth",
                            "[style.width]": "content.width",
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        VocabularyTreeComponent.ctorParameters = function () { return [
            { type: TaxonomyService }
        ]; };
        return VocabularyTreeComponent;
    }(InputControl));
    if (false) {
        /** @type {?} */
        VocabularyTreeComponent.prototype.chipsFormControl;
        /** @type {?} */
        VocabularyTreeComponent.prototype.levelsOptions;
        /** @type {?} */
        VocabularyTreeComponent.prototype.levelsSelection;
        /** @type {?} */
        VocabularyTreeComponent.prototype.lastLevelTerm;
        /** @type {?} */
        VocabularyTreeComponent.prototype.inputId;
        /** @type {?} */
        VocabularyTreeComponent.prototype.filteredOptions;
        /** @type {?} */
        VocabularyTreeComponent.prototype.chipsList;
        /** @type {?} */
        VocabularyTreeComponent.prototype.leafsOptions;
        /** @type {?} */
        VocabularyTreeComponent.prototype.terms;
        /** @type {?} */
        VocabularyTreeComponent.prototype.loading;
        /** @type {?} */
        VocabularyTreeComponent.prototype.extraContent;
        /** @type {?} */
        VocabularyTreeComponent.prototype.searchText;
        /**
         * @type {?}
         * @private
         */
        VocabularyTreeComponent.prototype.service;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/term-parent/term-parent.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TermParentComponent = /** @class */ (function (_super) {
        __extends(TermParentComponent, _super);
        function TermParentComponent() {
            var _this = _super.call(this) || this;
            // internalControl = new FormControl();
            _this.formControl = new forms.FormControl();
            _this.selectOptions = [];
            _this.currentTerm = null;
            _this.parentTerm = null;
            return _this;
        }
        /**
         * @return {?}
         */
        TermParentComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.init('', '', false, true);
            // (this.content.parentFormSection as FormGroup).addControl(
            //     this.content.name,
            //     this.internalControl
            //   );
            console.log(this.content.value);
            console.log(this.content.required);
            console.log(this.content.required && (this.content.value == 0 || this.content.value == null || this.content.value == undefined));
            if (this.content.required) {
                this.content.formControl.setValidators((/**
                 * @param {?} control
                 * @return {?}
                 */
                function (control) {
                    return (control.value == 0 || control.value == null || control.value == undefined)
                        ? { 'requiredTerms': 'No Terms Selected' }
                        : null;
                }));
            }
            this.setValueToInternalControl();
            this.inputId = this.content.label.trim().toLowerCase();
            if (this.content.extraContent && this.content.extraContent.terms) {
                if (this.content.extraContent.currentTerm) {
                    this.currentTerm = this.content.extraContent.currentTerm;
                }
                ((/** @type {?} */ (this.content.extraContent.terms))).forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                function (element) {
                    _this.selectOptions = _this.selectOptions.concat(_this._get_terms(element));
                }));
                this._updateFilteredOptions();
            }
        };
        /**
         * @private
         * @return {?}
         */
        TermParentComponent.prototype._updateFilteredOptions = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.filteredOptions = this.formControl.valueChanges.pipe(operators.startWith(''), operators.map((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var filterValue = value.toLowerCase();
                return _this.selectOptions.filter((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) { return option.identifier.toLowerCase().includes(filterValue); }));
            })));
        };
        /**
         * @private
         * @param {?} node
         * @return {?}
         */
        TermParentComponent.prototype._get_terms = /**
         * @private
         * @param {?} node
         * @return {?}
         */
        function (node) {
            var _this = this;
            /** @type {?} */
            var result = [];
            if (!this.currentTerm) {
                result.push(node.term);
            }
            else {
                if (this.currentTerm.id !== node.term.id) {
                    if (this.currentTerm.parent_id && this.currentTerm.parent_id === node.term.id) {
                        this.parentTerm = node.term;
                    }
                    else {
                        result.push(node.term);
                    }
                }
            }
            node.children.forEach((/**
             * @param {?} child
             * @return {?}
             */
            function (child) {
                result = result.concat(_this._get_terms(child));
            }));
            return result;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        TermParentComponent.prototype.addParent = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.parentTerm = value;
            this.selectOptions = this.selectOptions.filter((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.id !== value.id; }));
            this.formControl.setValue('');
            this._updateFilteredOptions();
            // document.getElementById(this.inputId).blur();
            (this.currentTerm) ? this.currentTerm.parent_id = this.parentTerm.id : this.parentTerm.id;
            this.setValueToInternalControl();
        };
        /**
         * @return {?}
         */
        TermParentComponent.prototype.removeParent = /**
         * @return {?}
         */
        function () {
            this.selectOptions.push(this.parentTerm);
            this._updateFilteredOptions();
            this.parentTerm = null;
            this.setValueToInternalControl();
        };
        /**
         * @private
         * @return {?}
         */
        TermParentComponent.prototype.setValueToInternalControl = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.parentTerm == null) {
                this.content.value = null;
                this.content.formControl.setValue(null);
            }
            else {
                this.content.value = this.parentTerm.id;
                this.content.formControl.setValue(this.content.value);
            }
            if (this.content.formControl.valid) {
                this.formControl.setErrors(null);
            }
            else {
                this.formControl.setErrors({ requiered: true });
            }
        };
        TermParentComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-term-parent',
                        template: "<div class=\"card-filter\" *ngIf=\"content.extraContent\">\n\n  <mat-form-field style=\"width: 100%;\">\n\n      <mat-label> {{content.label}} <span *ngIf=\"content.required\">*</span></mat-label>\n    <input \n        matInput \n        id=\"'inputId-'{{content.name}}\" \n        type=\"text\" \n        [formControl]=\"formControl\"\n        [placeholder]=\"content.label\"\n        [matAutocomplete]=\"auto\" \n        aria-label=\"Number\" \n      />\n    <mat-autocomplete #auto=\"matAutocomplete\">\n      <mat-option *ngFor=\"let option of filteredOptions | async\" [value]=\"option.identifier\" (click)=\"addParent(option)\"\n        [title]=\"option.description\">\n        {{ option.description }}\n      </mat-option>\n    </mat-autocomplete>\n\n  </mat-form-field>\n\n  <mat-chip-list fxLayout=\"row\" fxLayoutAlign=\"start center\" style=\"margin-bottom: .5em\" id=\"chiplist\">\n    <mat-chip (click)=\"removeParent()\" *ngIf=\"parentTerm\">{{ parentTerm.description }}</mat-chip>\n  </mat-chip-list>\n\n</div>",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        TermParentComponent.ctorParameters = function () { return []; };
        return TermParentComponent;
    }(InputControl));
    if (false) {
        /** @type {?} */
        TermParentComponent.prototype.formControl;
        /** @type {?} */
        TermParentComponent.prototype.inputId;
        /** @type {?} */
        TermParentComponent.prototype.filteredOptions;
        /** @type {?} */
        TermParentComponent.prototype.selectOptions;
        /** @type {?} */
        TermParentComponent.prototype.currentTerm;
        /** @type {?} */
        TermParentComponent.prototype.parentTerm;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/select/select.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This interface is deprecated.
     * An interface that represents a selectable option.
     * @record
     */
    function SelectOption$1() { }
    if (false) {
        /**
         * Returns the label that is showed.
         * @type {?}
         */
        SelectOption$1.prototype.label;
        /**
         * Returns the value that is stored internally.
         * @type {?}
         */
        SelectOption$1.prototype.value;
    }
    /**
     * This component is deprecated.
     * The `extraContent` recibe una funcion llamada getOptions() que se encarga de contruir un SelectOption[].
     * Si es multiple, entonces el `value` es un array de valores.
     */
    var SelectComponent = /** @class */ (function (_super) {
        __extends(SelectComponent, _super); /*FormFieldControl_Experimental*/
        function SelectComponent() {
            var _this = _super.call(this) || this;
            _this.selectOptions = [];
            _this.multiple = false;
            return _this;
        }
        /**
         * @return {?}
         */
        SelectComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            console.log('SelectComponent OnInit');
            /* Sets the default values. */
            this.init('', '', false, false);
            this.onSelectionChange();
        };
        /**
         * Initializes the `content` input property.
         * @param label The default label to use. It is used if the `content.label` is not specified.
         * @param placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param alwaysHint If it is true then there is always at leat one hint start-aligned.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
         * @return {?}
         */
        SelectComponent.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @param {?=} placeholder The default placeholder to use. It is used if the `content.placeholder` is not specified.
         * @param {?=} isAbbreviation If it is true then the `label` argument represents an abbreviation; otherwise, false.
         * @param {?=} alwaysHint If it is true then there is always at leat one hint start-aligned.
         * @return {?}
         */
        function (label, placeholder, isAbbreviation, alwaysHint) {
            /* Sets the default values. */
            var _this = this;
            if (placeholder === void 0) { placeholder = ''; }
            _super.prototype.init.call(this, label, placeholder, isAbbreviation, alwaysHint);
            //		if (this.content.appearance == undefined) this.content.appearance = false;
            this.multiple = this.content.extraContent['multiple'] ? this.content.extraContent['multiple'] : false;
            if (this.content.extraContent.observable) {
                this.content.extraContent.observable.subscribe((
                // next
                // next
                /**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    _this.selectOptions = _this.content.extraContent.getOptions(response);
                }), (
                // error
                // error
                /**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) { console.log(error); }), (
                // complete
                // complete
                /**
                 * @return {?}
                 */
                function () { }));
            }
            else {
                this.selectOptions = this.content.extraContent.getOptions();
            }
        };
        /**
         * @return {?}
         */
        SelectComponent.prototype.onSelectionChange = /**
         * @return {?}
         */
        function () {
            if ((this.content.extraContent) && (this.content.extraContent.selectionChange)) {
                this.content.extraContent.selectionChange(this.content.value);
            }
            console.log('Select value: ', this.content.formControl.value);
        };
        SelectComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-select',
                        template: "\n<mat-form-field\n  class=\"select-mat-form-field\"\n  [appearance]=\"content.appearance\"\n>\n\n  <mat-label>\n    {{ content.label }}\n  </mat-label>\n\n  <mat-select \n    [formControl]=\"content.formControl\"\n    [required]=\"content.required\"\n    [style.textAlign]=\"content.textAlign\"\n    [attr.aria-label]=\"content.ariaLabel\"\n    [(value)]=\"content.value\"\n    [multiple]=\"multiple\"\n    (selectionChange)=\"onSelectionChange()\"\n  >\n    <mat-option \n      *ngFor=\"let option of selectOptions\" \n      [value]=\"option.value\"\n    >\n      {{ option.label }}\n    </mat-option>\n  </mat-select>\n\n</mat-form-field>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [".select-mat-form-field{width:100%}"]
                    }] }
        ];
        /** @nocollapse */
        SelectComponent.ctorParameters = function () { return []; };
        return SelectComponent;
    }(InputControl /*FormFieldControl_Experimental*/));
    if (false) {
        /**
         * Returns the options list that can be selected.
         * By default, its value is `[]`.
         * @type {?}
         */
        SelectComponent.prototype.selectOptions;
        /**
         * Returns true if the selection can be multiple; otherwise, false.
         * By default, its value is `false`.
         * @type {?}
         */
        SelectComponent.prototype.multiple;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/textarea/textarea.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TextareaComponent = /** @class */ (function (_super) {
        __extends(TextareaComponent, _super);
        // internalControl = new FormControl();
        function TextareaComponent() {
            return _super.call(this) || this;
        }
        /**
         * @return {?}
         */
        TextareaComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.init('', '', false, true);
            // (this.content.parentFormSection as FormGroup).addControl(
            //   this.content.name,
            //   this.internalControl
            // );
            // console.log(this.content);
            // this.content.formControl.setValue(this.content.value);
        };
        TextareaComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-textarea",
                        template: "<mat-form-field\n[style.width]=\"content.width\"\n[style.minWidth]=\"content.minWidth\"\n>\n<textarea\n    [formControl]=\"content.formControl\"\n    matInput [value]=\"content.value\"\n    (input)=\"$event.target.value\"\n    name=\"{{ content.name }}\"\n    placeholder=\"{{ content.label }}\"\n    required=\"{{ content.required }}\"\n    [formControl]=\"content.formControl\"\n    matTextareaAutosize=\"true\"\n></textarea>\n</mat-form-field>\n",
                        host: {
                            "[style.minWidth]": "content.minWidth",
                            "[style.width]": "content.width",
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        TextareaComponent.ctorParameters = function () { return []; };
        return TextareaComponent;
    }(InputControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/select-filter/select-filter.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function SelectFilterComponentExtraContent() { }
    if (false) {
        /** @type {?} */
        SelectFilterComponentExtraContent.prototype.multiple;
        /** @type {?} */
        SelectFilterComponentExtraContent.prototype.selectedTermsIds;
        /** @type {?} */
        SelectFilterComponentExtraContent.prototype.excludeTermsIds;
    }
    var SelectFilterComponent = /** @class */ (function (_super) {
        __extends(SelectFilterComponent, _super);
        function SelectFilterComponent() {
            var _this = _super.call(this) || this;
            //   internalControl = new FormControl();
            // internalControl = new FormControl();
            //this control is used by the chips,not necessary to expose it
            _this.chipsFormControl = new forms.FormControl();
            _this.chipsList = [];
            _this.selectOptions = [];
            _this.terms = [];
            _this.loading = true;
            // selectedTermsIds = [];
            _this.searchText = "Seleccione las opciones";
            return _this;
        }
        /**
         * @return {?}
         */
        SelectFilterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.init('', '', false, true);
            // (this.content.parentFormSection as FormGroup).addControl(
            //   this.content.name,
            //   this.internalControl
            // );
            if (this.content.required) {
                this.content.formControl.setValidators((/**
                 * @param {?} control
                 * @return {?}
                 */
                function (control) {
                    return !_this.content.value || _this.content.value.length == 0
                        ? { requiredTerms: "No Terms Selected" }
                        : null;
                }));
            }
            this.inputId = this.content.label.trim().toLowerCase();
            if (this.content.extraContent) {
                this.extraContent = this.content.extraContent;
                // if (this.extraContent.multiple !== null) {
                //   this.multiple = this.extraContent.multiple;
                // }
                // if (this.extraContent.selectedTermsIds) {
                //   this.content.value = this.extraContent.selectedTermsIds;
                // } else {
                //   this.content.value = [];
                // }
                // already selected terms
                if (!this.extraContent.selectedTermsIds) {
                    this.extraContent.selectedTermsIds = [];
                }
                // terms ids to exclude of the possible options.
                if (!this.extraContent.excludeTermsIds) {
                    this.extraContent.excludeTermsIds = [];
                }
                this.content.value = [];
                if (this.content.extraContent.observable) {
                    this.content.extraContent.observable.subscribe((
                    // next
                    // next
                    /**
                     * @param {?} response
                     * @return {?}
                     */
                    function (response) {
                        _this.selectOptions = _this.content.extraContent.getOptions(response);
                        _this.selectOptionsLoaded();
                    }), (
                    // error
                    // error
                    /**
                     * @param {?} error
                     * @return {?}
                     */
                    function (error) {
                        console.log(error);
                    }), (
                    // complete
                    // complete
                    /**
                     * @return {?}
                     */
                    function () { }));
                }
                else {
                    this.selectOptions = this.content.extraContent.getOptions();
                    this.selectOptionsLoaded();
                }
                //   else if(this.extraContent.termID){
                //     this.service.getTermByUUID(this.extraContent.termID, this.extraContent.level)
                //     .subscribe(this.termsTreeObserver);
                // }
                // this._updateFilteredOptions();
            }
        };
        /**
         * @private
         * @return {?}
         */
        SelectFilterComponent.prototype.selectOptionsLoaded = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.selectOptions.forEach((/**
             * @param {?} option
             * @return {?}
             */
            function (option) {
                if (((/** @type {?} */ (_this.extraContent.selectedTermsIds))).some((/**
                 * @param {?} val
                 * @return {?}
                 */
                function (val) { return val === option.value; }))) {
                    _this.addChips(option);
                }
                // if (this.extraContent.multiple) {
                //   try {
                //     const index = this.content.value.indexOf(option.value);
                //     if (index >= 0) {
                //       this.addChips(option);
                //     }
                //   } catch (error) {}
                // } else {
                //   if (option.value == this.content.value) {
                //     this.addChips(option);
                //   }
                // }
            }));
            if (this.extraContent.multiple &&
                (this.content.value == null ||
                    this.content.value == undefined ||
                    !util.isArray(this.content.value))) {
                this.content.value = [];
            }
            this._updateFilteredOptions();
            this.loading = false;
        };
        /**
         * @private
         * @return {?}
         */
        SelectFilterComponent.prototype.setValidation = /**
         * @private
         * @return {?}
         */
        function () {
            if (this.content.formControl.valid) {
                this.chipsFormControl.setErrors(null);
            }
            else {
                this.chipsFormControl.setErrors({ requiered: true });
            }
        };
        /**
         * @private
         * @param {?} term
         * @return {?}
         */
        SelectFilterComponent.prototype.addTermToValue = /**
         * @private
         * @param {?} term
         * @return {?}
         */
        function (term) {
            if (this.extraContent.multiple) {
                this.content.value.unshift(term);
            }
            else {
                this.content.value = [term];
            }
            this.content.formControl.setValue(this.content.value);
            this.setValidation();
        };
        /**
         * @private
         * @param {?} term
         * @return {?}
         */
        SelectFilterComponent.prototype.removeTermFromValue = /**
         * @private
         * @param {?} term
         * @return {?}
         */
        function (term) {
            this.content.value = ((/** @type {?} */ (this.content.value))).filter((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return e.value !== term.value; }));
            this.content.formControl.setValue(this.content.value);
            this.setValidation();
        };
        /**
         * @private
         * @return {?}
         */
        SelectFilterComponent.prototype._updateFilteredOptions = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            this.filteredOptions = this.chipsFormControl.valueChanges.pipe(operators.startWith(""), operators.map((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                /** @type {?} */
                var filterValue = value ? value.toLowerCase() : "";
                console.log('************************************');
                console.log(_this.selectOptions);
                console.log('************************************');
                return _this.selectOptions.filter((/**
                 * @param {?} option
                 * @return {?}
                 */
                function (option) {
                    return option.label.toLowerCase().includes(filterValue);
                }));
            })));
        };
        /**
         * @param {?} value
         * @return {?}
         */
        SelectFilterComponent.prototype.addChips = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.extraContent.multiple) {
                this.chipsList.unshift(value);
            }
            else {
                // if not is multiple, then the element in the chipsList goes back to the options
                if (this.chipsList.length > 0) {
                    this.selectOptions.push(this.chipsList[0]);
                }
                this.chipsList = [value];
            }
            this.addTermToValue(value);
            // console.log(this.selectOptions);
            this.selectOptions = this.selectOptions.filter((/**
             * @param {?} option
             * @return {?}
             */
            function (option) { return option.value !== value.value; }));
            // console.log(this.selectOptions);
            this.chipsFormControl.setValue("");
            // document.getElementById(this.inputId).blur();
            this._updateFilteredOptions();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        SelectFilterComponent.prototype.removeChip = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            // console.log(this.selectOptions);
            this.selectOptions.push(this.chipsList[index]);
            // console.log(this.selectOptions);
            this.removeTermFromValue(this.chipsList[index]);
            this.chipsList.splice(index, 1);
            this._updateFilteredOptions();
        };
        SelectFilterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-select-filter",
                        template: "\n<mat-card>\n\n  <mat-progress-bar\n    mode=\"indeterminate\"\n    *ngIf=\"!selectOptions\">\n  </mat-progress-bar>\n\n  <mat-card-subtitle *ngIf=\"selectOptions\">\n    <mat-form-field style=\"width: 100%;\">\n\n      <mat-label> {{content.label}} <span *ngIf=\"content.required\">*</span></mat-label>\n      <input\n        matInput\n        id=\"'inputId-'{{content.name}}\"\n        type=\"text\"\n        [formControl]=\"chipsFormControl\"\n        [matAutocomplete]=\"auto\"\n          aria-label=\"Number\"\n      />\n\n      <mat-hint *ngIf=\"content.startHint\" [align]=\"'start'\">{{ content.startHint.label }}</mat-hint>\n      <mat-hint *ngIf=\"!content.startHint\" [align]=\"'start'\">{{ searchText }}</mat-hint>\n\n      <mat-autocomplete #auto=\"matAutocomplete\">\n        <mat-option *ngFor=\"let option of filteredOptions | async\" [value]=\"option.label\" (click)=\"addChips(option)\"\n          [title]=\"option.label\">\n          {{ option.label }}\n        </mat-option>\n      </mat-autocomplete>\n\n      <!-- <button mat-icon-button color=\"accent\" class=\"delete-filter\" (click)=\"remove_component()\">\n        <mat-icon>close</mat-icon>\n      </button> -->\n    </mat-form-field>\n  </mat-card-subtitle>\n\n  <mat-card-content *ngIf=\"!loading\">\n    <mat-chip-list class=\"mat-chip-list-stacked\" fxLayout=\"row\" fxLayoutAlign=\"start center\" style=\"margin-bottom: .5em\"\n      id=\"chiplist-{{content.name}}\">\n      <mat-chip *ngFor=\"let item of chipsList; let i=index\" (removed)=\"removeChip(i)\" [removable]=\"true\" style=\"width: 100%;height: 100%;\">\n        {{ item.label }}\n        <mat-icon matChipRemove>cancel</mat-icon>\n      </mat-chip>\n    </mat-chip-list>\n  </mat-card-content>\n\n</mat-card>\n",
                        host: {
                            "[style.minWidth]": "content.minWidth",
                            "[style.width]": "content.width",
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        SelectFilterComponent.ctorParameters = function () { return []; };
        return SelectFilterComponent;
    }(InputControl));
    if (false) {
        /** @type {?} */
        SelectFilterComponent.prototype.chipsFormControl;
        /** @type {?} */
        SelectFilterComponent.prototype.inputId;
        /** @type {?} */
        SelectFilterComponent.prototype.filteredOptions;
        /** @type {?} */
        SelectFilterComponent.prototype.chipsList;
        /** @type {?} */
        SelectFilterComponent.prototype.selectOptions;
        /** @type {?} */
        SelectFilterComponent.prototype.terms;
        /** @type {?} */
        SelectFilterComponent.prototype.loading;
        /** @type {?} */
        SelectFilterComponent.prototype.extraContent;
        /** @type {?} */
        SelectFilterComponent.prototype.searchText;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/select-tree/select-tree.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function SelectOptionNode() { }
    if (false) {
        /** @type {?} */
        SelectOptionNode.prototype.element;
        /** @type {?|undefined} */
        SelectOptionNode.prototype.parent;
        /** @type {?|undefined} */
        SelectOptionNode.prototype.children;
    }
    /**
     * @record
     */
    function FlatTreeNode() { }
    if (false) {
        /** @type {?} */
        FlatTreeNode.prototype.name;
        /** @type {?} */
        FlatTreeNode.prototype.level;
        /** @type {?} */
        FlatTreeNode.prototype.expandable;
        /** @type {?} */
        FlatTreeNode.prototype.element;
    }
    /**
     * @record
     */
    function TreeFilterData$1() { }
    if (false) {
        /** @type {?} */
        TreeFilterData$1.prototype.selectOptions;
        /** @type {?} */
        TreeFilterData$1.prototype.type;
        /** @type {?} */
        TreeFilterData$1.prototype.placeholder;
        /** @type {?} */
        TreeFilterData$1.prototype.text;
        /** @type {?} */
        TreeFilterData$1.prototype.field;
        /** @type {?} */
        TreeFilterData$1.prototype.index;
        /** @type {?} */
        TreeFilterData$1.prototype.value;
        /** @type {?} */
        TreeFilterData$1.prototype.idVocab;
    }
    var SelectTreeComponent = /** @class */ (function (_super) {
        __extends(SelectTreeComponent, _super);
        function SelectTreeComponent() {
            var _this = _super.call(this) || this;
            _this.checklistSelection = new collections.SelectionModel(true /* multiple */);
            _this.treeFlattener = new material.MatTreeFlattener(_this.transformer, _this.getLevel, _this.isExpandable, _this.getChildren);
            _this.treeControl = new tree$1.FlatTreeControl(_this.getLevel, _this.isExpandable);
            _this.dataSource = new material.MatTreeFlatDataSource(_this.treeControl, _this.treeFlattener);
            return _this;
        }
        /**
         * @return {?}
         */
        SelectTreeComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            // (this.content.parentFormSection as FormGroup).addControl(
            //   this.content.name,
            //   this.internalControl
            // );
            var _this = this;
            this.init('', '', false, true);
            if (this.content.extraContent) {
                if (this.content.extraContent.observable) {
                    this.content.extraContent.observable.subscribe((
                    // next
                    // next
                    /**
                     * @param {?} response
                     * @return {?}
                     */
                    function (response) {
                        console.log(response);
                        _this.data = _this.content.extraContent.getOptions(response);
                        console.log(_this.data);
                        _this.dataSource.data = _this.data;
                        console.log(_this.dataSource);
                        _this.content.extraContent.selectedTermsIds.forEach((/**
                         * @param {?} uuid
                         * @return {?}
                         */
                        function (uuid) {
                            console.log(uuid);
                            _this.treeControl.dataNodes.forEach((/**
                             * @param {?} node
                             * @return {?}
                             */
                            function (node) {
                                if (node.element.value == uuid) {
                                    console.log(node);
                                    if (node.expandable) {
                                        _this.itemSelectionToggle(node);
                                    }
                                    else {
                                        _this.leafItemSelectionToggle(node);
                                    }
                                }
                            }));
                        }));
                    }), (
                    // error
                    // error
                    /**
                     * @param {?} error
                     * @return {?}
                     */
                    function (error) {
                        console.log(error);
                    }), (
                    // complete
                    // complete
                    /**
                     * @return {?}
                     */
                    function () { }));
                }
                else {
                    this.data = this.content.extraContent.getOptions();
                    this.dataSource.data = this.data;
                }
                if (!this.content.extraContent.selectedTermsIds) {
                    this.content.extraContent.selectedTermsIds = [];
                }
            }
            this.content.value = "";
        };
        /**
         * @return {?}
         */
        SelectTreeComponent.prototype.remove_component = /**
         * @return {?}
         */
        function () { };
        /**
         * @return {?}
         */
        SelectTreeComponent.prototype.onChange = /**
         * @return {?}
         */
        function () {
            console.log("ttree change");
        };
        /**
         * @return {?}
         */
        SelectTreeComponent.prototype.emitSelection = /**
         * @return {?}
         */
        function () {
            this.content.formControl.setValue(this.checklistSelection.selected);
            // this.content.extraContent.selectionChange(this.checklistSelection.selected)
            // var valueEmiter = "OR";
            // this.checklistSelection.selected.forEach(node => {
            //   valueEmiter = valueEmiter + "," + node.element.value;
            // });
            // if (this.content.extraContent.selectionChange) {
            //   this.content.extraContent.selectionChange(this.content.value);
            // }
        };
        /** Transform the data to something the tree can read. */
        /**
         * Transform the data to something the tree can read.
         * @param {?} node
         * @param {?} level
         * @return {?}
         */
        SelectTreeComponent.prototype.transformer = /**
         * Transform the data to something the tree can read.
         * @param {?} node
         * @param {?} level
         * @return {?}
         */
        function (node, level) {
            /** @type {?} */
            var result = {
                name: node.element.label,
                level: level,
                expandable: node.children.length > 0,
                element: node.element
            };
            return result;
        };
        /** Get the level of the node */
        /**
         * Get the level of the node
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.getLevel = /**
         * Get the level of the node
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return node.level;
        };
        /** Get whether the node is expanded or not. */
        /**
         * Get whether the node is expanded or not.
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.isExpandable = /**
         * Get whether the node is expanded or not.
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return node.expandable;
        };
        /** Get whether the node has children or not. */
        /**
         * Get whether the node has children or not.
         * @param {?} index
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.hasChild = /**
         * Get whether the node has children or not.
         * @param {?} index
         * @param {?} node
         * @return {?}
         */
        function (index, node) {
            return node.expandable;
        };
        /** Get the children for the node. */
        /**
         * Get the children for the node.
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.getChildren = /**
         * Get the children for the node.
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return rxjs.of(node.children);
        };
        /** Whether all the descendants of the node are selected. */
        /**
         * Whether all the descendants of the node are selected.
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.descendantsAllSelected = /**
         * Whether all the descendants of the node are selected.
         * @param {?} node
         * @return {?}
         */
        function (node) {
            var _this = this;
            if (this.treeControl.dataNodes != undefined) {
                /** @type {?} */
                var descendants = this.treeControl.getDescendants(node);
                /** @type {?} */
                var descAllSelected = descendants.every((/**
                 * @param {?} child
                 * @return {?}
                 */
                function (child) {
                    return _this.checklistSelection.isSelected(child);
                }));
                return descAllSelected;
            }
            return false;
        };
        /** Whether part of the descendants are selected */
        /**
         * Whether part of the descendants are selected
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.descendantsPartiallySelected = /**
         * Whether part of the descendants are selected
         * @param {?} node
         * @return {?}
         */
        function (node) {
            var _this = this;
            if (this.treeControl.dataNodes != undefined) {
                /** @type {?} */
                var descendants = this.treeControl.getDescendants(node);
                /** @type {?} */
                var result = descendants.some((/**
                 * @param {?} child
                 * @return {?}
                 */
                function (child) {
                    return _this.checklistSelection.isSelected(child);
                }));
                return result && !this.descendantsAllSelected(node);
            }
            return false;
        };
        /** Select/deselect all the descendants node */
        /**
         * Select/deselect all the descendants node
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.itemSelectionToggle = /**
         * Select/deselect all the descendants node
         * @param {?} node
         * @return {?}
         */
        function (node) {
            var _a, _b;
            var _this = this;
            this.checklistSelection.toggle(node);
            /** @type {?} */
            var descendants = this.treeControl.getDescendants(node);
            this.checklistSelection.isSelected(node)
                ? (_a = this.checklistSelection).select.apply(_a, __spread(descendants)) : (_b = this.checklistSelection).deselect.apply(_b, __spread(descendants));
            // Force update for the parent
            descendants.every((/**
             * @param {?} child
             * @return {?}
             */
            function (child) { return _this.checklistSelection.isSelected(child); }));
            this.checkAllParentsSelection(node);
            this.emitSelection();
        };
        /** Check all the parents to see if they changed */
        /**
         * Check all the parents to see if they changed
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.leafItemSelectionToggle = /**
         * Check all the parents to see if they changed
         * @param {?} node
         * @return {?}
         */
        function (node) {
            this.checklistSelection.toggle(node);
            this.checkAllParentsSelection(node);
            this.emitSelection();
        };
        /* Checks all the parents when a leaf node is selected/unselected */
        /* Checks all the parents when a leaf node is selected/unselected */
        /**
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.checkAllParentsSelection = /* Checks all the parents when a leaf node is selected/unselected */
        /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var parent = this.getParentNode(node);
            while (parent) {
                this.checkRootNodeSelection(parent);
                parent = this.getParentNode(parent);
            }
        };
        /** Check root node checked state and change it accordingly */
        /**
         * Check root node checked state and change it accordingly
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.checkRootNodeSelection = /**
         * Check root node checked state and change it accordingly
         * @param {?} node
         * @return {?}
         */
        function (node) {
            var _this = this;
            /** @type {?} */
            var nodeSelected = this.checklistSelection.isSelected(node);
            /** @type {?} */
            var descendants = this.treeControl.getDescendants(node);
            /** @type {?} */
            var descAllSelected = descendants.every((/**
             * @param {?} child
             * @return {?}
             */
            function (child) {
                return _this.checklistSelection.isSelected(child);
            }));
            if (nodeSelected && !descAllSelected) {
                this.checklistSelection.deselect(node);
            }
            else if (!nodeSelected && descAllSelected) {
                this.checklistSelection.select(node);
            }
        };
        /* Get the parent node of a node */
        /* Get the parent node of a node */
        /**
         * @param {?} node
         * @return {?}
         */
        SelectTreeComponent.prototype.getParentNode = /* Get the parent node of a node */
        /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            /** @type {?} */
            var currentLevel = this.getLevel(node);
            if (currentLevel < 1) {
                return null;
            }
            /** @type {?} */
            var startIndex = this.treeControl.dataNodes.indexOf(node) - 1;
            for (var i = startIndex; i >= 0; i--) {
                /** @type {?} */
                var currentNode = this.treeControl.dataNodes[i];
                if (this.getLevel(currentNode) < currentLevel) {
                    return currentNode;
                }
            }
            return null;
        };
        SelectTreeComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-select-tree",
                        template: "<mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" class=\"scrolleable\">\n  <mat-tree-node\n    class=\"hover\"\n    *matTreeNodeDef=\"let node\"\n    matTreeNodeToggle\n    matTreeNodePadding\n    fxLayout=\"row\"\n    fxLayoutAlign=\"space-between center\"\n    [ngStyle]=\"{ 'white-space': 'normal !important' }\"\n  >\n    <div fxLayout=\"row\" fxLayoutAlign=\"start center\">\n      <button mat-icon-button disabled></button>\n      <mat-checkbox\n        class=\"checklist-leaf-node\"\n        [checked]=\"checklistSelection.isSelected(node)\"\n        (change)=\"leafItemSelectionToggle(node)\"\n        matTooltip=\"{{ node.name }}\"\n        [ngStyle]=\"{ 'white-space': 'normal !important' }\"\n      >\n          {{ node.name }}\n      </mat-checkbox>\n    </div>\n  </mat-tree-node>\n\n  <mat-tree-node\n    class=\"hover\"\n    *matTreeNodeDef=\"let node; when: hasChild\"\n    matTreeNodePadding\n    [ngStyle]=\"{ 'white-space': 'normal !important' }\"\n  >\n    <button\n      mat-icon-button\n      matTreeNodeToggle\n      [attr.aria-label]=\"'toggle ' + node.name\"\n    >\n      <mat-icon class=\"mat-icon-rtl-mirror\">\n        {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n      </mat-icon>\n    </button>\n    <div class=\"item-width\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n      <mat-checkbox\n        [checked]=\"descendantsAllSelected(node)\"\n        [indeterminate]=\"descendantsPartiallySelected(node)\"\n        (change)=\"itemSelectionToggle(node)\"\n        matTooltip=\"{{ node.name }}\"\n        [ngStyle]=\"{ 'white-space': 'normal !important' }\"\n        >{{ node.name }}</mat-checkbox\n      >\n    </div>\n  </mat-tree-node>\n</mat-tree>\n",
                        styles: [".scrolleable{max-height:20em;min-width:15em;overflow:auto}"]
                    }] }
        ];
        /** @nocollapse */
        SelectTreeComponent.ctorParameters = function () { return []; };
        return SelectTreeComponent;
    }(InputControl));
    if (false) {
        /** @type {?} */
        SelectTreeComponent.prototype.data;
        /** @type {?} */
        SelectTreeComponent.prototype.treeControl;
        /** @type {?} */
        SelectTreeComponent.prototype.treeFlattener;
        /** @type {?} */
        SelectTreeComponent.prototype.dataSource;
        /** @type {?} */
        SelectTreeComponent.prototype.checklistSelection;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/datepicker/datepicker.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var DatepickerComponent = /** @class */ (function (_super) {
        __extends(DatepickerComponent, _super);
        // TODO: for datepicker, !!!! use https://stackblitz.com/edit/angular-material2-year-picker-7z9k4t?file=app%2Fcustom-datepicker%2Fyear-picker-component%2Fyear-picker.component.html
        function DatepickerComponent() {
            return _super.call(this) || this;
        }
        /**
         * @return {?}
         */
        DatepickerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.init('', '', false, true);
            // (this.content.parentFormSection as FormGroup).addControl(
            //   this.content.name,
            //   this.internalControl
            // );
        };
        DatepickerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-datepicker",
                        template: "<mat-form-field\nstyle=\"width: 100%;\"\n>\n<input\n    matInput\n    [value]=\"content.value\"\n    (input)=\"$event.target.value\"\n    [matDatepicker]=\"picker\"\n    name=\"{{ content.name }}\"\n    placeholder=\"{{ content.label }}\"\n    required=\"{{ content.required }}\"\n    [formControl]=\"content.formControl\"\n>\n<mat-datepicker-toggle\n    matSuffix [for]=\"picker\"\n></mat-datepicker-toggle>\n<mat-datepicker\n    #picker\n    startView=\"multi-year\"\n></mat-datepicker>\n</mat-form-field>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        DatepickerComponent.ctorParameters = function () { return []; };
        return DatepickerComponent;
    }(InputControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/checkbox/checkbox.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CheckboxComponent = /** @class */ (function (_super) {
        __extends(CheckboxComponent, _super);
        function CheckboxComponent() {
            return _super.call(this) || this;
        }
        /**
         * @return {?}
         */
        CheckboxComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.init('', '', false, true);
            // (this.content.parentFormSection as FormGroup).addControl(
            //   this.content.name,
            //   this.internalControl
            // );
        };
        CheckboxComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-checkbox',
                        template: "<ng-container\n>\n<mat-checkbox\n    [style.width]=\"content.width\"\n    [style.minWidth]=\"content.minWidth\"\n    [value]=\"content.value\"\n    (input)=\"$event.target.value\"\n    name=\"{{ content.name }}\"\n    required=\"{{ content.required }}\"\n    [formControlName]=\"content.name\"\n    [formControl]=\"content.formControl\"\n>\n    {{ content.label }}\n</mat-checkbox>\n</ng-container>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        CheckboxComponent.ctorParameters = function () { return []; };
        return CheckboxComponent;
    }(InputControl));

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/container/panel-action/panel-action-container.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function PanelAction() { }
    if (false) {
        /**
         * @param {?} data
         * @return {?}
         */
        PanelAction.prototype.doit = function (data) { };
    }
    /**
     * An interface that represents the content of a panel control.
     * @record
     */
    function PanelActionContent() { }
    if (false) {
        /**
         * Returns the panel's description.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        PanelActionContent.prototype.description;
        /**
         * Returns the panel's icon name.
         * By default, its value is `undefined`.
         * @type {?|undefined}
         */
        PanelActionContent.prototype.iconName;
        /**
         * Returns the action and action labels for each panel.
         * @type {?|undefined}
         */
        PanelActionContent.prototype.action;
        /** @type {?|undefined} */
        PanelActionContent.prototype.actionLabel;
    }
    /**
     * Represents a container control that is showed as a panel.
     * Usage notes:
     *  - It can be used as:
     * <container-panel [content]="panelContent"></container-panel>
     * Where `content.formSection` is created, for example, as this:
     * this.content.formSection = new FormGroup({ }, [ ]);
     */
    var ContainerPanelActionComponent = /** @class */ (function (_super) {
        __extends(ContainerPanelActionComponent, _super);
        function ContainerPanelActionComponent() {
            return _super.call(this) || this;
        }
        /**
         * @return {?}
         */
        ContainerPanelActionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets the default values. */
            this.init('');
        };
        /**
         * Initializes the `content` input property.
         * @param label The default label to use. It is used if the `content.label` is not specified.
         */
        /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @return {?}
         */
        ContainerPanelActionComponent.prototype.init = /**
         * Initializes the `content` input property.
         * @protected
         * @param {?} label The default label to use. It is used if the `content.label` is not specified.
         * @return {?}
         */
        function (label) {
            /* Sets the default values. */
            _super.prototype.init.call(this, label);
            /* The `content.description`, and `content.iconName` fields
            have the `undefined` value by default. */
        };
        /**
         * @return {?}
         */
        ContainerPanelActionComponent.prototype.doAction = /**
         * @return {?}
         */
        function () {
            // const data = {};
            // this.content..formSectionContent.forEach(element => {
            //   element
            // });
            // this.panelsContent.forEach((panel) => {
            //   panel.formSectionContent.forEach((controlContent) => {
            //     data[controlContent.name] = controlContent.value;
            //   });
            // });
            if (this.content.action) {
                this.content.action.doit(this.content.value);
            }
        };
        ContainerPanelActionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'container-panel-action',
                        template: "<mat-card\n  class=\"container-panel-mat-card\"\n  [formGroup]=\"content.formSection\"\n  [attr.aria-label]=\"content.ariaLabel\"\n>\n  <mat-card-header>\n    <mat-card-title *ngIf=\"content.label\">\n      {{ content.label }}\n    </mat-card-title>\n    <mat-card-subtitle *ngIf=\"content.description\">\n      {{ content.description }}\n      <mat-icon>{{ content.iconName }}</mat-icon>\n    </mat-card-subtitle>\n  </mat-card-header>\n\n  <mat-card-content\n    fxLayout=\"row wrap\"\n    fxLayout.xs=\"column\"\n    fxLayoutAlign=\"space-between end\"\n    fxLayoutAlign.xs=\"space-between center\"\n    fxLayoutGap=\"1em\"\n    class=\"form-field-component\"\n  >\n    <ng-template get-view-container></ng-template>\n  </mat-card-content>\n\n  <mat-card-actions *ngIf=\"content.actionLabel\">\n    <button\n      *ngIf=\"content.actionLabel\"\n      mat-button\n      color=\"accent\"\n      (click)=\"doAction()\"\n    >\n      {{ content.actionLabel }}\n    </button>\n  </mat-card-actions>\n\n  <mat-card-actions *ngIf=\"content.isDynamic\">\n    <button mat-raised-button color=\"primary\" (click)=\"addToFormArray()\">\n      <!-- <mat-icon>add box</mat-icon> -->\n      <mat-icon>add_circle</mat-icon>\n      Add new item\n    </button>\n    <button\n      mat-raised-button\n      color=\"primary\"\n      [disabled]=\"!canRemoveFromFormArray\"\n      (click)=\"clearFormArray()\"\n    >\n      <!-- <mat-icon>remove box</mat-icon> -->\n      <mat-icon>remove_circle</mat-icon>\n      Clear all\n    </button>\n  </mat-card-actions>\n</mat-card>\n",
                        host: {
                            '[style.minWidth]': 'content.minWidth',
                            '[style.width]': 'content.width'
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        ContainerPanelActionComponent.ctorParameters = function () { return []; };
        ContainerPanelActionComponent.propDecorators = {
            content: [{ type: core.Input }]
        };
        return ContainerPanelActionComponent;
    }(ContainerControl));
    if (false) {
        /**
         * Input field that contains the content of this class.
         * @type {?}
         */
        ContainerPanelActionComponent.prototype.content;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/datepicker-year/datepicker-year.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // const moment = _rollupMoment || _moment;
    /** @type {?} */
    var YEAR_MODE_FORMATS = {
        parse: {
            dateInput: 'YYYY',
        },
        display: {
            dateInput: 'YYYY',
            monthYearLabel: 'MMM YYYY',
            dateA11yLabel: 'LL',
            monthYearA11yLabel: 'MMMM YYYY',
        },
    };
    var DatepickerYearComponent = /** @class */ (function (_super) {
        __extends(DatepickerYearComponent, _super);
        function DatepickerYearComponent() {
            var _this = _super.call(this) || this;
            /**
             * Component label
             */
            _this.label = '';
            _this.touchUi = false;
            // _inputCtrl: FormControl = new FormControl();
            // Function to call when the date changes.
            _this.onChange = (/**
             * @param {?} year
             * @return {?}
             */
            function (year) { });
            // Function to call when the input is touched (when a star is clicked).
            _this.onTouched = (/**
             * @return {?}
             */
            function () { });
            return _this;
        }
        Object.defineProperty(DatepickerYearComponent.prototype, "max", {
            get: /**
             * @return {?}
             */
            function () {
                return this._max ? this._max.year() : undefined;
            },
            set: /**
             * @param {?} max
             * @return {?}
             */
            function (max) {
                if (max) {
                    /** @type {?} */
                    var momentDate = typeof max === 'number' ? moment([max, 0, 1]) : moment(max);
                    this._max = momentDate.isValid() ? momentDate : undefined;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DatepickerYearComponent.prototype, "min", {
            get: /**
             * @return {?}
             */
            function () {
                return this._min ? this._min.year() : undefined;
            },
            set: /**
             * @param {?} min
             * @return {?}
             */
            function (min) {
                if (min) {
                    /** @type {?} */
                    var momentDate = typeof min === 'number' ? moment([min, 0, 1]) : moment(min);
                    this._min = momentDate.isValid() ? momentDate : undefined;
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @return {?}
         */
        DatepickerYearComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.init('', '', false, true);
            // this.value = moment(this.value.toString()).format("YYYY")
            if (this.label == '') {
                this.label = this.content.label;
            }
            this.min = this.content.extraContent.minYear;
            this.max = this.content.extraContent.maxYear;
            console.log(this.content.extraContent, 'DATEPICKER YEAR EXTRA CONTENT....', this._min, this._max);
            this.writeValue(new Date(this.content.value));
        };
        /**
         * @param {?} date
         * @return {?}
         */
        DatepickerYearComponent.prototype.writeValue = /**
         * @param {?} date
         * @return {?}
         */
        function (date) {
            if (date && this._isYearEnabled(date.getFullYear())) {
                /** @type {?} */
                var momentDate = moment(date);
                if (momentDate.isValid()) {
                    this.content.formControl.setValue(moment(date), { emitEvent: false });
                    this.content.value = moment(date).year;
                    // this.content.formControl.setValue(this.content.value);
                }
            }
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DatepickerYearComponent.prototype.registerOnChange = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onChange = fn;
        };
        /**
         * @param {?} fn
         * @return {?}
         */
        DatepickerYearComponent.prototype.registerOnTouched = /**
         * @param {?} fn
         * @return {?}
         */
        function (fn) {
            this.onTouched = fn;
        };
        // Allows Angular to disable the input.
        // Allows Angular to disable the input.
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        DatepickerYearComponent.prototype.setDisabledState = 
        // Allows Angular to disable the input.
        /**
         * @param {?} isDisabled
         * @return {?}
         */
        function (isDisabled) {
            isDisabled ? this._picker.disabled = true : this._picker.disabled = false;
            isDisabled ? this.content.formControl.disable() : this.content.formControl.enable();
        };
        /**
         * @param {?} chosenDate
         * @param {?} datepicker
         * @return {?}
         */
        DatepickerYearComponent.prototype._yearSelectedHandler = /**
         * @param {?} chosenDate
         * @param {?} datepicker
         * @return {?}
         */
        function (chosenDate, datepicker) {
            if (!this._isYearEnabled(chosenDate.year())) {
                datepicker.close();
                return;
            }
            this.content.formControl.setValue(chosenDate, { emitEvent: false });
            this.content.value = chosenDate.year;
            // this.content.formControl.setValue(this.content.value);
            this.onChange(chosenDate.toDate());
            this.onTouched();
            datepicker.close();
        };
        /**
         * @param {?} datepicker
         * @return {?}
         */
        DatepickerYearComponent.prototype._openDatepickerOnClick = /**
         * @param {?} datepicker
         * @return {?}
         */
        function (datepicker) {
            if (!datepicker.opened) {
                datepicker.open();
            }
        };
        /**
         * @param {?} datepicker
         * @return {?}
         */
        DatepickerYearComponent.prototype._openDatepickerOnFocus = /**
         * @param {?} datepicker
         * @return {?}
         */
        function (datepicker) {
            setTimeout((/**
             * @return {?}
             */
            function () {
                if (!datepicker.opened) {
                    datepicker.open();
                }
            }));
        };
        /** Whether the given year is enabled. */
        /**
         * Whether the given year is enabled.
         * @private
         * @param {?} year
         * @return {?}
         */
        DatepickerYearComponent.prototype._isYearEnabled = /**
         * Whether the given year is enabled.
         * @private
         * @param {?} year
         * @return {?}
         */
        function (year) {
            // disable if the year is greater than maxDate lower than minDate
            if (year === undefined || year === null ||
                (this._max && year > this._max.year()) ||
                (this._min && year < this._min.year())) {
                return false;
            }
            return true;
        };
        DatepickerYearComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-datepicker-year',
                        template: "<mat-form-field style=\"width: 100%\">\n  <!-- <mat-label>{{ label }}</mat-label> -->\n  <input\n    matInput\n    [matDatepicker]=\"datepicker\"\n    [max]=\"_max\"\n    [min]=\"_min\"\n    [formControl]=\"content.formControl\"\n    (click)=\"_openDatepickerOnClick(datepicker)\"\n    (focus)=\"_openDatepickerOnFocus(datepicker)\"\n    readonly\n    placeholder=\"{{ content.label }}\"\n    required=\"{{ content.required }}\"\n  />\n\n  <mat-datepicker\n    #datepicker\n    [touchUi]=\"touchUi\"\n    startView=\"multi-year\"\n    (yearSelected)=\"_yearSelectedHandler($event, datepicker)\"\n    panelClass=\"year-picker\"\n  >\n  </mat-datepicker>\n</mat-form-field>\n",
                        providers: [
                            { provide: material.DateAdapter, useClass: materialMomentAdapter.MomentDateAdapter, deps: [material.MAT_DATE_LOCALE] },
                            { provide: material.MAT_DATE_FORMATS, useValue: YEAR_MODE_FORMATS },
                            {
                                provide: forms.NG_VALUE_ACCESSOR,
                                useExisting: core.forwardRef((/**
                                 * @return {?}
                                 */
                                function () { return DatepickerYearComponent; })),
                                multi: true,
                            },
                        ],
                        host: {
                            "[style.minWidth]": "content.minWidth",
                            "[style.width]": "content.width",
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        DatepickerYearComponent.ctorParameters = function () { return []; };
        DatepickerYearComponent.propDecorators = {
            label: [{ type: core.Input }],
            max: [{ type: core.Input }],
            min: [{ type: core.Input }],
            touchUi: [{ type: core.Input }],
            _picker: [{ type: core.ViewChild, args: [material.MatDatepicker, { static: true },] }]
        };
        return DatepickerYearComponent;
    }(InputControl));
    if (false) {
        /**
         * Component label
         * @type {?}
         */
        DatepickerYearComponent.prototype.label;
        /** @type {?} */
        DatepickerYearComponent.prototype._max;
        /** @type {?} */
        DatepickerYearComponent.prototype._min;
        /** @type {?} */
        DatepickerYearComponent.prototype.touchUi;
        /** @type {?} */
        DatepickerYearComponent.prototype._picker;
        /** @type {?} */
        DatepickerYearComponent.prototype.onChange;
        /** @type {?} */
        DatepickerYearComponent.prototype.onTouched;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/experimental/select-orgs/select-orgs.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function SelectOrgsComponentExtraContent() { }
    if (false) {
        /** @type {?} */
        SelectOrgsComponentExtraContent.prototype.multiple;
        /** @type {?} */
        SelectOrgsComponentExtraContent.prototype.selectedOrgsIds;
        /**
         * Input `orgFilter` is a dict with `type` and `value` to filter the organizations,
         * \@Example { type: 'country' , value: 'Cuba" }
         * @type {?}
         */
        SelectOrgsComponentExtraContent.prototype.orgFilter;
    }
    var SelectOrgsComponent = /** @class */ (function (_super) {
        __extends(SelectOrgsComponent, _super);
        function SelectOrgsComponent(_orgService) {
            var _this = _super.call(this) || this;
            _this._orgService = _orgService;
            /**
             * Input `orgCtrl` is a FormControl
             */
            _this.orgCtrl = new forms.FormControl();
            _this.filteredOrg = new HitList();
            _this.params = new http.HttpParams();
            _this.placeholder = "Escriba al menos 3 letras";
            _this.label = "Busque una organización";
            _this.appearance = "outline";
            /**
             * Input `cleaning` is a boolen, if true then clean the search
             */
            _this.cleaning = false;
            _this.selectedOrg = new core.EventEmitter();
            _this.chipsList = [];
            _this.loading = false;
            _this.toSearch = 0;
            return _this;
        }
        /**
         * @return {?}
         */
        SelectOrgsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.init('', '', false, false);
            this.extraContent = this.content.extraContent;
            this.content.value = [];
            this.extraContent.selectedOrgsIds.forEach((/**
             * @param {?} uuid
             * @return {?}
             */
            function (uuid) {
                _this._orgService.getOrganizationByUUID(uuid).subscribe({
                    next: (/**
                     * @param {?} response
                     * @return {?}
                     */
                    function (response) {
                        _this.addChips(response);
                    })
                });
            }));
            this.params = this.params.set('size', '10');
            this.params = this.params.set('page', '1');
            if (this.extraContent.orgFilter != undefined) {
                this.params = this.params.set(this.extraContent.orgFilter.type, this.extraContent.orgFilter.value);
            }
            this.orgCtrl.valueChanges
                .subscribe({
                next: (/**
                 * @param {?} orgValueChanges
                 * @return {?}
                 */
                function (orgValueChanges) {
                    _this.toSearch++;
                    // this condition check if the param is a `string` an if at least write 3 letters
                    if (_this.toSearch > 3 && typeof orgValueChanges === 'string') {
                        _this.toSearch = 0;
                        _this.params = _this.params.set('q', orgValueChanges);
                        _this.loading = true;
                        _this._orgService.getOrganizations(_this.params).subscribe({
                            next: (/**
                             * @param {?} response
                             * @return {?}
                             */
                            function (response) {
                                _this.filteredOrg = response.hits;
                                _this.loading = false;
                            })
                        });
                    }
                    else if (typeof orgValueChanges === 'object') {
                        _this.toSearch = 0;
                        _this.selectedOrg.emit(orgValueChanges);
                        if (_this.cleaning) {
                            _this.orgCtrl.setValue('');
                        }
                    }
                })
            });
        };
        /* This function return the organization name
         * @param org the Organization object
         */
        /* This function return the organization name
            * @param org the Organization object
            */
        /**
         * @param {?=} org
         * @return {?}
         */
        SelectOrgsComponent.prototype.displayFn = /* This function return the organization name
            * @param org the Organization object
            */
        /**
         * @param {?=} org
         * @return {?}
         */
        function (org) {
            return org ? org.name : undefined;
        };
        /**
         * @param {?} value
         * @return {?}
         */
        SelectOrgsComponent.prototype.addChips = /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.extraContent.multiple) {
                if (!this.chipsList.find((/**
                 * @param {?} x
                 * @return {?}
                 */
                function (x) { return x.id == value.id; }))) {
                    this.chipsList.unshift(value);
                    this.content.value.unshift(value);
                }
            }
            else {
                this.chipsList = [value];
                this.content.value = [value];
            }
            this.content.formControl.setValue(this.content.value);
            this.orgCtrl.setValue("");
            this.filteredOrg = new HitList();
        };
        /**
         * @param {?} index
         * @return {?}
         */
        SelectOrgsComponent.prototype.removeChip = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            /** @type {?} */
            var todelete = this.chipsList[index];
            this.content.value = ((/** @type {?} */ (this.content.value))).filter((/**
             * @param {?} e
             * @return {?}
             */
            function (e) { return e.id !== todelete.id; }));
            this.content.formControl.setValue(this.content.value);
            this.chipsList.splice(index, 1);
        };
        SelectOrgsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-select-org',
                        template: "<mat-card>\n\n\n  <mat-card-subtitle>\n    <mat-form-field style=\"width: 100%;height: 100%;\">\n\n      <mat-label> {{content.label}} <span *ngIf=\"content.required\">*</span></mat-label>\n      <input matInput placeholder=\"{{placeholder}}\" aria-label=\"Buscar\" [matAutocomplete]=\"auto\" [formControl]=\"orgCtrl\">\n      <input\n        matInput\n        id=\"'inputId-'{{content.name}}\"\n        type=\"text\"\n        [formControl]=\"orgCtrl\"\n        [matAutocomplete]=\"auto\"\n          aria-label=\"Number\"\n      />\n\n      <mat-hint *ngIf=\"content.startHint\" [align]=\"'start'\">{{ content.startHint.label }}</mat-hint>\n\n      <mat-autocomplete #auto=\"matAutocomplete\" [displayWith]=\"displayFn\">\n\n        <mat-option *ngFor=\"let org of filteredOrg.hits\" [value]=\"org.metadata\" (click)=\"addChips(org)\">\n            <span title=\"{{org.metadata.name}}\">{{org.metadata.name}}</span>\n        </mat-option>\n\n      </mat-autocomplete>\n\n      <!-- <button mat-icon-button color=\"accent\" class=\"delete-filter\" (click)=\"remove_component()\">\n        <mat-icon>close</mat-icon>\n      </button> -->\n    </mat-form-field>\n  </mat-card-subtitle>\n\n  <mat-progress-bar\n    mode=\"indeterminate\"\n    *ngIf=\"loading\">\n  </mat-progress-bar>\n\n  <mat-card-content *ngIf=\"!loading\">\n    <mat-chip-list class=\"mat-chip-list-stacked\" fxLayout=\"row\" fxLayoutAlign=\"start center\" style=\"margin-bottom: .5em\"\n      id=\"chiplist-{{content.name}}\">\n      <mat-chip *ngFor=\"let item of chipsList; let i=index\" (removed)=\"removeChip(i)\" [removable]=\"true\" style=\"width: 100%;height: 100%;\">\n        {{ item.metadata.name }}\n        <mat-icon matChipRemove>cancel</mat-icon>\n      </mat-chip>\n    </mat-chip-list>\n  </mat-card-content>\n\n</mat-card>\n",
                        host: {
                            "[style.minWidth]": "content.minWidth",
                            "[style.width]": "content.width"
                        },
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        SelectOrgsComponent.ctorParameters = function () { return [
            { type: OrganizationServiceNoAuth }
        ]; };
        SelectOrgsComponent.propDecorators = {
            orgCtrl: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            label: [{ type: core.Input }],
            appearance: [{ type: core.Input }],
            cleaning: [{ type: core.Input }],
            selectedOrg: [{ type: core.Output }]
        };
        return SelectOrgsComponent;
    }(InputControl));
    if (false) {
        /**
         * Input `orgCtrl` is a FormControl
         * @type {?}
         */
        SelectOrgsComponent.prototype.orgCtrl;
        /** @type {?} */
        SelectOrgsComponent.prototype.filteredOrg;
        /** @type {?} */
        SelectOrgsComponent.prototype.params;
        /** @type {?} */
        SelectOrgsComponent.prototype.placeholder;
        /** @type {?} */
        SelectOrgsComponent.prototype.label;
        /** @type {?} */
        SelectOrgsComponent.prototype.appearance;
        /**
         * Input `cleaning` is a boolen, if true then clean the search
         * @type {?}
         */
        SelectOrgsComponent.prototype.cleaning;
        /** @type {?} */
        SelectOrgsComponent.prototype.selectedOrg;
        /** @type {?} */
        SelectOrgsComponent.prototype.chipsList;
        /** @type {?} */
        SelectOrgsComponent.prototype.extraContent;
        /** @type {?} */
        SelectOrgsComponent.prototype.loading;
        /** @type {?} */
        SelectOrgsComponent.prototype.toSearch;
        /**
         * @type {?}
         * @private
         */
        SelectOrgsComponent.prototype._orgService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/forms.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TocoFormsModule = /** @class */ (function () {
        function TocoFormsModule(_iconService) {
            //console.log('Icon Service: registers icons.');
            this._iconService = _iconService;
            this._iconService.registerIcons([
                IconService.defaultIconName,
                'outlined-bar_code-24px',
                'outlined-mail-24px'
            ], '../assets/svg/icons');
        }
        TocoFormsModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ActionButtonComponent,
                            ComponentFactory_Depr,
                            FormContainerComponent,
                            ContainerPanelComponent,
                            ContainerPanelActionComponent,
                            ContainerSimpleComponent,
                            TableComponent,
                            ContainerLabelDiffLangComponent,
                            InputBoolComponent,
                            InputEmailComponent,
                            InputIdentifierComponent,
                            InputIssnComponent,
                            InputNumberComponent,
                            InputRnpsComponent,
                            InputSelectComponent,
                            InputTextComponent,
                            InputUrlComponent,
                            VocabularyComponent,
                            VocabularyTreeComponent,
                            TermParentComponent,
                            SelectComponent,
                            SelectFilterComponent,
                            TextareaComponent,
                            SelectTreeComponent,
                            DatepickerComponent,
                            CheckboxComponent,
                            DatepickerYearComponent,
                            SelectOrgsComponent
                        ],
                        imports: [
                            SharedModule,
                            forms.ReactiveFormsModule,
                            core$2.TranslateModule,
                            CoreModule
                        ],
                        /* In order to ensure that the compiler still generates a factory for all dynamically loaded components. */
                        entryComponents: [
                            ActionButtonComponent,
                            ContainerPanelComponent,
                            ContainerPanelActionComponent,
                            ContainerSimpleComponent,
                            InputBoolComponent,
                            InputEmailComponent,
                            InputIdentifierComponent,
                            InputIssnComponent,
                            InputNumberComponent,
                            InputRnpsComponent,
                            InputSelectComponent,
                            InputTextComponent,
                            InputUrlComponent,
                            VocabularyComponent,
                            VocabularyTreeComponent,
                            TermParentComponent,
                            SelectComponent,
                            SelectFilterComponent,
                            TextareaComponent,
                            SelectTreeComponent,
                            DatepickerComponent,
                            DatepickerYearComponent,
                            CheckboxComponent,
                            SelectOrgsComponent
                        ],
                        exports: [
                            ActionButtonComponent,
                            ComponentFactory_Depr,
                            FormContainerComponent,
                            ContainerPanelComponent,
                            ContainerPanelActionComponent,
                            ContainerSimpleComponent,
                            TableComponent,
                            ContainerLabelDiffLangComponent,
                            InputBoolComponent,
                            InputEmailComponent,
                            InputIdentifierComponent,
                            InputIssnComponent,
                            InputNumberComponent,
                            InputRnpsComponent,
                            InputSelectComponent,
                            InputTextComponent,
                            InputUrlComponent,
                            VocabularyComponent,
                            VocabularyTreeComponent,
                            TermParentComponent,
                            SelectComponent,
                            SelectFilterComponent,
                            TextareaComponent,
                            DatepickerComponent,
                            DatepickerYearComponent,
                            CheckboxComponent,
                            SelectOrgsComponent
                        ],
                        providers: []
                    },] }
        ];
        /** @nocollapse */
        TocoFormsModule.ctorParameters = function () { return [
            { type: IconService }
        ]; };
        return TocoFormsModule;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        TocoFormsModule.prototype._iconService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/container/form-container/form-container.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This service is deprecated.
     */
    var FormContainerService = /** @class */ (function () {
        function FormContainerService(httpClient, env) {
            this.httpClient = httpClient;
            this.env = env;
            this.httpOptions = {
                headers: new http.HttpHeaders({
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer '
                })
            };
        }
        /**
         * Sends data to the server.
         * @param endPoint The data end point. For example, `/add_new`.
         * @param token The autorization token.
         * @param data The data to send, must be parsed.
         */
        /**
         * Sends data to the server.
         * @param {?} endPoint The data end point. For example, `/add_new`.
         * @param {?} token The autorization token.
         * @param {?} data The data to send, must be parsed.
         * @return {?}
         */
        FormContainerService.prototype.sendPostData = /**
         * Sends data to the server.
         * @param {?} endPoint The data end point. For example, `/add_new`.
         * @param {?} token The autorization token.
         * @param {?} data The data to send, must be parsed.
         * @return {?}
         */
        function (endPoint, token, data) {
            this.httpOptions.headers = this.httpOptions.headers.set('Authorization', 'Bearer ' + token);
            return this.httpClient.post(this.env.sceibaApi + endPoint, data, this.httpOptions);
        };
        FormContainerService.decorators = [
            { type: core.Injectable, args: [{
                        providedIn: 'root'
                    },] }
        ];
        /** @nocollapse */
        FormContainerService.ctorParameters = function () { return [
            { type: http.HttpClient },
            { type: Environment }
        ]; };
        /** @nocollapse */ FormContainerService.ngInjectableDef = core.ɵɵdefineInjectable({ factory: function FormContainerService_Factory() { return new FormContainerService(core.ɵɵinject(http.HttpClient), core.ɵɵinject(Environment)); }, token: FormContainerService, providedIn: "root" });
        return FormContainerService;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        FormContainerService.prototype.httpOptions;
        /**
         * @type {?}
         * @private
         */
        FormContainerService.prototype.httpClient;
        /**
         * @type {?}
         * @private
         */
        FormContainerService.prototype.env;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/forms/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/harvester/harvester/harvester.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HarvesterComponent = /** @class */ (function () {
        function HarvesterComponent() {
        }
        /**
         * @return {?}
         */
        HarvesterComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () { };
        HarvesterComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-harvester',
                        template: "<router-outlet></router-outlet>",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        HarvesterComponent.ctorParameters = function () { return []; };
        return HarvesterComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/harvester/harvester-filters/harvester-filters.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HarvesterFiltersComponent = /** @class */ (function (_super) {
        __extends(HarvesterFiltersComponent, _super);
        function HarvesterFiltersComponent(componentFactoryResolver, childrenService, service) {
            var _this = _super.call(this, componentFactoryResolver, childrenService) || this;
            _this.componentFactoryResolver = componentFactoryResolver;
            _this.childrenService = childrenService;
            _this.service = service;
            return _this;
        }
        /**
         * @return {?}
         */
        HarvesterFiltersComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            default_filters.forEach((/**
             * @param {?} filter
             * @return {?}
             */
            function (filter) {
                _this.filters_data.push(filter);
            }));
            this.service.getJournalsVocab().subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                response.data.vocabularies.forEach((/**
                 * @param {?} vocab
                 * @return {?}
                 */
                function (vocab) {
                    _this.service.getTerminosByVocab(vocab.name + '/any').subscribe((/**
                     * @param {?} termsResponse
                     * @return {?}
                     */
                    function (termsResponse) {
                        _this.filters_data.push({
                            index: _this.filters_data.length,
                            field: 'terms',
                            type: 'select-autocomplete',
                            placeholder: vocab.name,
                            name: vocab.name,
                            idVocab: vocab.id,
                            selectOptions: termsResponse.data.terms,
                            is_enabled: true
                        });
                    }));
                }));
            }));
        };
        HarvesterFiltersComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-harvester-filters-container',
                        template: "<!-- <div fxLayout=\"row wrap\" fxLayoutAlign=\"start center\" fxLayoutAlign.xs=\"center center\" fxLayoutGap=\"1em\" fxLayoutGap.xs=\"0\"> -->\n\n  <ng-template toco-Filter></ng-template>\n\n<!-- </div> -->\n\n<button mat-icon-button [matMenuTriggerFor]=\"menu\">\n    <mat-icon>add</mat-icon>\n</button>\n  <mat-menu #menu=\"matMenu\" >\n    <ng-container *ngFor=\"let item of filters_data,let i=index\">\n        <ng-container *ngIf=\"item.is_enabled\">\n          <button mat-menu-item (click)=\"addFilter(i)\">\n            {{item.name}}\n          </button>\n        </ng-container>\n    </ng-container>\n    \n\n    \n  </mat-menu>",
                        styles: [".width-100{width:100%}.mat-menu-item{height:37px}"]
                    }] }
        ];
        /** @nocollapse */
        HarvesterFiltersComponent.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver },
            { type: FilterContainerService },
            { type: CatalogService }
        ]; };
        return HarvesterFiltersComponent;
    }(FilterContainerComponent));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        HarvesterFiltersComponent.prototype.componentFactoryResolver;
        /**
         * @type {?}
         * @protected
         */
        HarvesterFiltersComponent.prototype.childrenService;
        /**
         * @type {?}
         * @protected
         */
        HarvesterFiltersComponent.prototype.service;
    }
    /** @type {?} */
    var default_filters = [
        {
            index: 0,
            field: 'title',
            type: 'search',
            placeholder: 'Título',
            name: 'Título',
            is_enabled: true
        }
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/harvester/repositories/repositories.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RepositoriesComponent = /** @class */ (function () {
        function RepositoriesComponent(service, metadata, filterService, env) {
            this.service = service;
            this.metadata = metadata;
            this.filterService = filterService;
            this.env = env;
            this.journalList = [];
            this.loading = true;
            this.dataSource = new table.MatTableDataSource();
            this.columnsToDisplay = ['title'];
            this.length = 0;
            this.pageSize = 5;
            this.pageSizeOptions = [5, 10, 20, 40, 60, 80, 100];
            this.sceibaHost = '';
            this.currentlayout = {
                name: 'Izquierda',
                layout: 'row',
                aling: 'center baseline',
                width: '22'
            };
            this.sceibaHost = env.sceibaHost + "/catalog";
        }
        /**
         * @return {?}
         */
        RepositoriesComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.metadata.setStandardMeta("Catálogo de Revistas Científicas", "", "");
            this.paginator.firstPage();
            this.paginator.pageSize = this.pageSize;
            this.service.getJournalsCount().subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                _this.length = response.data.count;
            }));
            this.fetchJournalData();
            this.filterService.paramsChanged.subscribe((/**
             * @param {?} params
             * @return {?}
             */
            function (params) {
                _this.params = params;
                _this.fetchJournalData();
            }));
        };
        // onPaginatorChanged(){
        //   this.filterService.changeFilter('count',this.paginator.pageSize, false);
        //   this.filterService.changeFilter('page',this.paginator.pageIndex);
        // }
        // onPaginatorChanged(){
        //   this.filterService.changeFilter('count',this.paginator.pageSize, false);
        //   this.filterService.changeFilter('page',this.paginator.pageIndex);
        // }
        /**
         * @return {?}
         */
        RepositoriesComponent.prototype.fetchJournalData = 
        // onPaginatorChanged(){
        //   this.filterService.changeFilter('count',this.paginator.pageSize, false);
        //   this.filterService.changeFilter('page',this.paginator.pageIndex);
        // }
        /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.loading = true;
            //this.dataSource.data = this.service.getJournalsPage(this.count, this.page);
            /** @type {?} */
            var arr = new Array();
            rxjs.merge().pipe(operators.startWith({}), operators.switchMap((/**
             * @return {?}
             */
            function () {
                _this.loading = true;
                return (/** @type {?} */ (_this.service)).getJournalsPage(_this.paginator.pageSize, _this.paginator.pageIndex, _this.params);
            })), operators.map((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                // Flip flag to show that loading has finished.
                _this.loading = false;
                // this.isRateLimitReached = false;
                // this.resultsLength = response.total_count;
                _this.length = response.data.sources.count;
                response.data.sources.data.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    /** @type {?} */
                    var j = new Journal();
                    j.id = item.id;
                    j.uuid = item.uuid;
                    j.source_type = item.source_type;
                    // j.harvest_type = item.harvest_type;
                    j.data.oaiurl = item.harvest_endpoint;
                    /** @type {?} */
                    var info = new JournalData();
                    info.url = item.data != null ? item.data.url : "";
                    info.title = item.name;
                    info.subtitle = item.subtitle;
                    info.shortname = item.shortname;
                    /** @type {?} */
                    var issn = new ISSN();
                    issn.e = item.data != null ? item.data.issn.e : "";
                    issn.l = item.data != null ? item.data.issn.l : "";
                    issn.p = item.data != null ? item.data.issn.p : "";
                    info.issn = issn;
                    info.rnps = item.data != null ? item.data.rnps : "";
                    info.logo = item.data != null ? item.data.logo : "";
                    info.purpose = item.purpose;
                    info.description = item.data != null ? item.data.description : "";
                    j.data = info;
                    arr.push(j);
                }));
                return arr;
            })), operators.catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                _this.loading = false;
                console.log("ERRORRR  " + error);
                // Catch if the GitHub API has reached its rate limit. Return empty data.
                // this.isRateLimitReached = true;
                return rxjs.of([]);
            }))).subscribe((/**
             * @param {?} data
             * @return {?}
             */
            function (data) { return _this.dataSource.data = data; }));
        };
        /**
         * @return {?}
         */
        RepositoriesComponent.prototype.onScrollUp = /**
         * @return {?}
         */
        function () {
            // console.log("scrolled up!!");
        };
        /**
         * @return {?}
         */
        RepositoriesComponent.prototype.isEmpty = /**
         * @return {?}
         */
        function () {
            if (this.journalList.length == 0) {
                this.loading = false;
                return true;
            }
            return false;
        };
        /**
         * @return {?}
         */
        RepositoriesComponent.prototype.isLoading = /**
         * @return {?}
         */
        function () {
            return this.loading;
        };
        /**
         * @return {?}
         */
        RepositoriesComponent.prototype.currentJournals = /**
         * @return {?}
         */
        function () {
            console.log(this.dataSource.data);
        };
        RepositoriesComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-repositories',
                        template: "<div fxLayout=\"{{currentlayout.layout}}\" fxLayout.xs=\"column nowrap\" fxLayoutAlign=\"{{currentlayout.aling}}\">\n  <button mat-raised-button (click)=\"currentJournals()\">Print Current Fournals</button>\n  <button mat-raised-button (click)=\"currentJournals()\">Print Current Fournals</button>\n  <button mat-raised-button (click)=\"currentJournals()\">Print Current Fournals</button>\n</div>\n\n\n<div fxLayout=\"{{currentlayout.layout}}\" fxLayout.xs=\"column nowrap\" fxLayoutAlign=\"{{currentlayout.aling}}\">\n\n  <toco-harvester-filters-container fxLayout=\"row wrap\" fxLayout.xs=\"column wrap\" fxFlex=\"{{currentlayout.width}}\" fxLayoutAlign=\"start center\" fxLayoutAlign.xs=\"center center\"\n    fxLayoutGap=\"1em\" class=\"width-90 back-grey mat-elevation-z8\">\n  </toco-harvester-filters-container>\n\n  <div class=\"mat-elevation-z8 width-90 margin1em\">\n    <table mat-table [dataSource]=\"dataSource\" multiTemplateDataRows>\n      <ng-container matColumnDef=\"title\">\n        <th mat-header-cell *matHeaderCellDef>Titulo</th>\n        <td mat-cell *matCellDef=\"let element\"> {{element.data.title}} </td>\n      </ng-container>\n      <!-- Expanded Content Column - The detail row is made up of this one column that spans across all columns -->\n      <ng-container matColumnDef=\"expandedDetail\">\n        <td mat-cell *matCellDef=\"let element\" [attr.colspan]=\"columnsToDisplay.length\">\n          <div class=\"example-element-detail\" [@detailExpand]=\"element == expandedElement ? 'expanded' : 'collapsed'\">\n              <toco-harvester-repository\n              [repostitory]=\"element\"></toco-harvester-repository>\n          </div>\n        </td>\n      </ng-container>\n\n      <tr mat-header-row *matHeaderRowDef=\"columnsToDisplay\"></tr>\n      <tr mat-row *matRowDef=\"let element; columns: columnsToDisplay;\" class=\"example-element-row\" [class.example-expanded-row]=\"expandedElement === element\"\n        (click)=\"expandedElement = element\">\n      </tr>\n      <tr mat-row *matRowDef=\"let row; columns: ['expandedDetail']\" class=\"example-detail-row\"></tr>\n    </table>\n    <mat-paginator [length]=\"length\"\n          [pageSize]=\"pageSize\"\n          [pageSizeOptions]=\"pageSizeOptions\"\n          (page)=\"fetchJournalData()\">\n    </mat-paginator>\n  </div>\n\n  <mat-card *ngIf=\"!isEmpty()\" class=\"center-spinner\" fxLayout=\"row\" fxLayoutAlign=\"center center\" fxLayoutGap=\"gappx\">\n    <mat-spinner></mat-spinner>\n    <!--<mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>-->\n  </mat-card>\n\n  <!-- <mat-card *ngIf=\"isEmpty()\" class=\"center-spinner\" fxLayout=\"row\" fxLayoutAlign=\"center center\" fxLayoutGap=\"gappx\">\n    <h1>No hay Informaci\u00F3n para Mostrar</h1>\n  </mat-card> -->\n</div>\n\n",
                        animations: [
                            animations.trigger('detailExpand', [
                                animations.state('collapsed', animations.style({ height: '0px', minHeight: '0', display: 'none' })),
                                animations.state('expanded', animations.style({ height: '*' })),
                                animations.transition('expanded <=> collapsed', animations.animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
                            ]),
                        ],
                        styles: [".width-card{width:30%;min-width:240px;margin-left:24px;margin-top:24px}.card-float-left{float:left}.center-spinner{width:90.5%;min-width:240px;margin-left:24px;margin-right:24px;margin-top:24px}.back-grey{background:rgba(0,0,0,.01);margin:1.5em 1em;padding:1em;min-width:18em}.width-90{width:90%}.width-93{width:93.5%}table{width:90%}.margin1em{margin:1em}.menu-pull-right{flex:1 1 auto}table.mat-table{width:100%}tr.example-detail-row{height:0}tr.example-element-row:not(.example-expanded-row):hover{background:#f5f5f5}tr.example-element-row:not(.example-expanded-row):active{background:#efefef}.example-element-row td{border-bottom-width:0}.example-element-detail{overflow:hidden;display:flex}.example-element-diagram{min-width:80px;border:2px solid #000;padding:8px;font-weight:lighter;margin:8px 0;height:104px}.example-element-symbol{font-weight:700;font-size:40px;line-height:normal}.example-element-description{padding:16px}.example-element-description-attribution{opacity:.5}"]
                    }] }
        ];
        /** @nocollapse */
        RepositoriesComponent.ctorParameters = function () { return [
            { type: CatalogService },
            { type: MetadataService },
            { type: FiltersService },
            { type: Environment }
        ]; };
        RepositoriesComponent.propDecorators = {
            paginator: [{ type: core.ViewChild, args: [paginator.MatPaginator, { static: true },] }],
            filter_component: [{ type: core.ViewChild, args: [HarvesterFiltersComponent, { static: true },] }]
        };
        return RepositoriesComponent;
    }());
    if (false) {
        /** @type {?} */
        RepositoriesComponent.prototype.journalList;
        /**
         * @type {?}
         * @private
         */
        RepositoriesComponent.prototype.loading;
        /** @type {?} */
        RepositoriesComponent.prototype.dataSource;
        /** @type {?} */
        RepositoriesComponent.prototype.columnsToDisplay;
        /** @type {?} */
        RepositoriesComponent.prototype.expandedElement;
        /** @type {?} */
        RepositoriesComponent.prototype.length;
        /** @type {?} */
        RepositoriesComponent.prototype.pageSize;
        /** @type {?} */
        RepositoriesComponent.prototype.pageSizeOptions;
        /** @type {?} */
        RepositoriesComponent.prototype.pageEvent;
        /** @type {?} */
        RepositoriesComponent.prototype.params;
        /** @type {?} */
        RepositoriesComponent.prototype.sceibaHost;
        /** @type {?} */
        RepositoriesComponent.prototype.currentlayout;
        /** @type {?} */
        RepositoriesComponent.prototype.paginator;
        /** @type {?} */
        RepositoriesComponent.prototype.filter_component;
        /**
         * @type {?}
         * @private
         */
        RepositoriesComponent.prototype.service;
        /**
         * @type {?}
         * @private
         */
        RepositoriesComponent.prototype.metadata;
        /**
         * @type {?}
         * @private
         */
        RepositoriesComponent.prototype.filterService;
        /**
         * @type {?}
         * @private
         */
        RepositoriesComponent.prototype.env;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/harvester/harvester-routing.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ɵ0$1 = {
        title: 'Revistas'
    };
    /** @type {?} */
    var routes$1 = [{
            path: '',
            component: HarvesterComponent,
            children: [
                {
                    path: '',
                    component: RepositoriesComponent,
                    data: ɵ0$1
                }
            ]
        }];
    var HarvesterRoutingModule = /** @class */ (function () {
        function HarvesterRoutingModule() {
        }
        HarvesterRoutingModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [router.RouterModule.forChild(routes$1)],
                        exports: [router.RouterModule]
                    },] }
        ];
        return HarvesterRoutingModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/harvester/repository/repository.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RepositoryComponent = /** @class */ (function () {
        function RepositoryComponent() {
        }
        /**
         * @return {?}
         */
        RepositoryComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
        };
        /**
         * @return {?}
         */
        RepositoryComponent.prototype.onIdentify = /**
         * @return {?}
         */
        function () {
            console.log('onIdentify' + this.repostitory.id);
        };
        /**
         * @return {?}
         */
        RepositoryComponent.prototype.onHarvest = /**
         * @return {?}
         */
        function () {
            console.log('onHarvest' + this.repostitory.id);
        };
        /**
         * @return {?}
         */
        RepositoryComponent.prototype.onRecord = /**
         * @return {?}
         */
        function () {
            console.log('onRecord' + this.repostitory.id);
        };
        RepositoryComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-harvester-repository',
                        template: "<mat-card>\n    <mat-card-header>\n        <mat-card-title>\n            <strong>\n            {{repostitory.source_type}} \n            <!-- {{repostitory.harvest_type}} -->\n            </strong>\n        </mat-card-title>\n        <mat-card-subtitle>\n        <!-- {{repostitory.harvest_endpoint}} -->\n        </mat-card-subtitle>\n    </mat-card-header>\n    <mat-card-content>\n            Informacion sobre el estado, la cantidad de elementos etc...\n    </mat-card-content>\n    <mat-card-actions>\n        \n        <button mat-fab-button (click)=\"onIdentify()\">Identify</button>\n        <button mat-fab-button (click)=\"onHarvest()\">Harvest</button>\n        <button mat-fab-button (click)=\"onRecord()\">Record</button>\n    </mat-card-actions>\n      \n</mat-card>",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        RepositoryComponent.ctorParameters = function () { return []; };
        RepositoryComponent.propDecorators = {
            repostitory: [{ type: core.Input }]
        };
        return RepositoryComponent;
    }());
    if (false) {
        /** @type {?} */
        RepositoryComponent.prototype.repostitory;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/harvester/harvester.service.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HarvesterService = /** @class */ (function () {
        function HarvesterService(http) {
            this.http = http;
        }
        HarvesterService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        HarvesterService.ctorParameters = function () { return [
            { type: http.HttpClient }
        ]; };
        return HarvesterService;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        HarvesterService.prototype.http;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/harvester/harvester.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var HarvesterModule = /** @class */ (function () {
        function HarvesterModule() {
        }
        HarvesterModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RepositoriesComponent,
                            RepositoryComponent,
                            HarvesterComponent,
                            HarvesterFiltersComponent
                        ],
                        imports: [
                            SharedModule,
                            forms.ReactiveFormsModule,
                            HarvesterRoutingModule,
                            FiltersModule
                        ],
                        exports: [
                            RepositoriesComponent,
                            RepositoryComponent,
                            HarvesterComponent,
                            HarvesterFiltersComponent
                        ],
                        providers: [
                            CatalogService,
                            HarvesterService
                            // FiltersService,
                            // FilterContainerService
                        ]
                    },] }
        ];
        return HarvesterModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/harvester/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/notification/notification-button/notification-button.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NotificationButtonComponent = /** @class */ (function () {
        function NotificationButtonComponent(service, _snackBar, oauthStorage) {
            var _this = this;
            this.service = service;
            this._snackBar = _snackBar;
            this.oauthStorage = oauthStorage;
            this.count = 0;
            this.moment = moment;
            this.timerSuscription = null;
            this.timerObserver = {
                next: (/**
                 * @param {?} _
                 * @return {?}
                 */
                function (_) {
                    // if (this.oauthStorage.getItem('access_token')){
                    _this.service.getNotificationsList(5, 0).pipe(operators.catchError((/**
                     * @param {?} error
                     * @return {?}
                     */
                    function (error) {
                        /** @type {?} */
                        var m = new MessageHandler(_this._snackBar);
                        m.showMessage(StatusCode.serverError, error.message);
                        return rxjs.of(null);
                    })))
                        .subscribe((/**
                     * @param {?} response
                     * @return {?}
                     */
                    function (response) {
                        if (response && response.status === "success") {
                            _this.count = response.data.total_not_view;
                            /** @type {?} */
                            var arr = response.data.notifications
                                .map((/**
                             * @param {?} n
                             * @return {?}
                             */
                            function (n) { return (__assign({}, n, { classification: {
                                    label: n.classification,
                                    color: n.classification === 'INFO' ? '#2196F3' : n.classification === 'ALERT' ? '#FF5722' : '#d32f2f'
                                } })); }))
                                .filter((/**
                             * @param {?} n
                             * @return {?}
                             */
                            function (n) { return !n.viewed; }));
                            _this.notifications = arr;
                        }
                        else if (response) {
                            /** @type {?} */
                            var m = new MessageHandler(_this._snackBar);
                            m.showMessage(StatusCode.serverError, response.message);
                        }
                        else {
                            /** @type {?} */
                            var m = new MessageHandler(_this._snackBar);
                            m.showMessage(StatusCode.serverError, 'Notificaciones no encontradas');
                        }
                    }));
                    // }
                }),
                error: (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    console.log('The observable got an error notification: ' + err + '.');
                }),
                complete: (/**
                 * @return {?}
                 */
                function () {
                    console.log('The observable got a complete notification.');
                })
            };
        }
        /**
         * @return {?}
         */
        NotificationButtonComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            // Emits, one every second (90000ms), starting after 0 seconds
            this.timerSuscription = rxjs.timer(0, 900000).subscribe(this.timerObserver);
            if (this.color == undefined)
                this.color = "primary";
            if (this.buttonType == undefined)
                this.buttonType = "mat-mini-fab";
        };
        /**
         * @return {?}
         */
        NotificationButtonComponent.prototype.notificationsCount = /**
         * @return {?}
         */
        function () {
            if (this.count == 0)
                return '';
            if (this.count > 10)
                return '+10';
            return this.count;
        };
        NotificationButtonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-notification-button',
                        template: "<ng-container [ngSwitch]=\"buttonType\">\n\n    <button *ngSwitchCase=\"'mat-icon-button'\" mat-icon-button [matBadge]=\"notificationsCount()\" matBadgeColor=\"accent\" [matMenuTriggerFor]=\"notificationsMenu\" matTooltip=\"Notificaciones\">\n        <mat-icon>notifications</mat-icon>\n    </button>\n\n    <button *ngSwitchCase=\"'mat-button'\" mat-button color=\"{{color}}\" [matBadge]=\"notificationsCount()\" matBadgeColor=\"accent\" [matMenuTriggerFor]=\"notificationsMenu\" matTooltip=\"Notificaciones\">\n        <mat-icon>notifications</mat-icon>\n    </button>\n\n    <button *ngSwitchDefault mat-mini-fab color=\"{{color}}\" [matBadge]=\"notificationsCount()\" matBadgeColor=\"accent\" [matMenuTriggerFor]=\"notificationsMenu\" matTooltip=\"Notificaciones\">\n        <mat-icon>notifications</mat-icon>\n    </button>\n</ng-container>\n\n<mat-menu #notificationsMenu=\"matMenu\" style=\"max-width: 400px !important;\">\n  <button class=\"notification-item\" mat-menu-item *ngFor=\"let notification of notifications\">\n    <div class=\"notification-container\" [ngStyle]=\"{'border-left-color': notification.classification.color}\">\n      <div class=\"notification-header\">\n        <span>{{notification.emiter.name}} {{notification.emiter.lastname}}</span>\n        <span>{{moment(notification.createdAt).startOf('day').fromNow()}}</span>\n      </div>\n      <span class=\"notification-description\">\n        {{(notification.description.length>135) ?\n          (notification.description | slice:0:135)+' ...'\n          :(notification.description)\n        }}\n      </span>\n    </div>\n  </button>\n  <div *ngIf=\"count === 0\" class=\"empty-notifications-container\">\n    <mat-icon class=\"empty-notifications-icon\">notifications</mat-icon>\n    <h1 style=\"color: gray; font-size: 25px\">SIN NOTIFICACIONES</h1>\n  </div>\n    <mat-divider></mat-divider>\n    <a [routerLink]=\"['/notifications']\" style=\"text-decoration: none;\">\n        <button mat-menu-item style=\"text-align: center;\" color=\"accent\">\n            Ver todas\n        </button>\n    </a>\n</mat-menu>\n",
                        styles: [".notification-item{height:100%;border-bottom:1px solid #f5f5f5;padding-left:0}.notification-container{display:flex;flex-direction:column;justify-content:flex-start;padding-left:10px;padding-bottom:10px;border-left:10px solid}.notification-header{display:flex;justify-content:space-between;margin-bottom:-5px;font-size:12px;color:gray}.notification-description{line-height:20px;white-space:pre-wrap;font-size:15px}.empty-notifications-container{display:flex;flex-direction:column;justify-content:center;align-items:center;padding:30px}.empty-notifications-icon{color:grey;font-size:4.5em;height:70px;width:70px}::ng-deep.mat-menu-panel{max-width:400px!important}"]
                    }] }
        ];
        /** @nocollapse */
        NotificationButtonComponent.ctorParameters = function () { return [
            { type: NotificationService },
            { type: material.MatSnackBar },
            { type: angularOauth2Oidc.OAuthStorage }
        ]; };
        NotificationButtonComponent.propDecorators = {
            color: [{ type: core.Input }],
            buttonType: [{ type: core.Input }]
        };
        return NotificationButtonComponent;
    }());
    if (false) {
        /** @type {?} */
        NotificationButtonComponent.prototype.color;
        /** @type {?} */
        NotificationButtonComponent.prototype.buttonType;
        /** @type {?} */
        NotificationButtonComponent.prototype.count;
        /** @type {?} */
        NotificationButtonComponent.prototype.notifications;
        /** @type {?} */
        NotificationButtonComponent.prototype.moment;
        /**
         * @type {?}
         * @private
         */
        NotificationButtonComponent.prototype.timerSuscription;
        /**
         * @type {?}
         * @private
         */
        NotificationButtonComponent.prototype.timerObserver;
        /**
         * @type {?}
         * @private
         */
        NotificationButtonComponent.prototype.service;
        /**
         * @type {?}
         * @private
         */
        NotificationButtonComponent.prototype._snackBar;
        /**
         * @type {?}
         * @private
         */
        NotificationButtonComponent.prototype.oauthStorage;
    }
    var UserNotification = /** @class */ (function () {
        function UserNotification() {
        }
        return UserNotification;
    }());
    if (false) {
        /** @type {?} */
        UserNotification.prototype.id;
        /** @type {?} */
        UserNotification.prototype.name;
        /** @type {?} */
        UserNotification.prototype.lastname;
        /** @type {?} */
        UserNotification.prototype.email;
    }
    var NotificationInfo = /** @class */ (function () {
        function NotificationInfo() {
        }
        return NotificationInfo;
    }());
    if (false) {
        /** @type {?} */
        NotificationInfo.prototype.classification;
        /** @type {?} */
        NotificationInfo.prototype.receiver_id;
        /** @type {?} */
        NotificationInfo.prototype.viewed;
        /** @type {?} */
        NotificationInfo.prototype.viewed_date;
        /** @type {?} */
        NotificationInfo.prototype.description;
        /** @type {?} */
        NotificationInfo.prototype.createdAt;
        /** @type {?} */
        NotificationInfo.prototype.emiter;
        /** @type {?} */
        NotificationInfo.prototype.app;
        /** @type {?} */
        NotificationInfo.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/notification/notification-list/notification-list.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NotificationListComponent = /** @class */ (function () {
        function NotificationListComponent(service, _snackBar) {
            this.service = service;
            this._snackBar = _snackBar;
            this.dataSource = new material.MatTableDataSource();
            this.columnsToDisplay = ['action', 'description', 'classification', 'emiter', 'emiterEmail', 'createdAt'];
            this.columnsLabels = ['', 'Descripción', 'Clasificación', 'Emisor', 'Correo del emisor', 'Creada'];
            this.moment = moment;
            this.pageSizeOptions = [5, 10, 15, 20];
        }
        /**
         * @return {?}
         */
        NotificationListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.paginator.firstPage();
            this.paginator.pageSize = 5;
            this.getNotificationsListData();
        };
        /**
         * @return {?}
         */
        NotificationListComponent.prototype.getNotificationsListData = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.service.getNotificationsList(this.paginator.pageSize, this.paginator.pageIndex)
                .pipe(operators.catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                /** @type {?} */
                var m = new MessageHandler(_this._snackBar);
                m.showMessage(StatusCode.serverError, error.message);
                return rxjs.of(null);
            })))
                .subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                if (response) {
                    _this.paginator.length = response.data.total_not_view;
                    /** @type {?} */
                    var arr = response.data.notifications
                        .map((/**
                     * @param {?} n
                     * @return {?}
                     */
                    function (n) { return (__assign({}, n, { classification: {
                            label: n.classification,
                            color: n.classification === 'INFO' ? '#2196F3' : n.classification === 'ALERT' ? '#FF5722' : '#d32f2f'
                        } })); }));
                    _this.dataSource.data = arr;
                }
                else {
                    _this.paginator.length = 0;
                    _this.dataSource.data = null;
                }
            }));
        };
        /**
         * @param {?} id
         * @return {?}
         */
        NotificationListComponent.prototype.setnotificationViewed = /**
         * @param {?} id
         * @return {?}
         */
        function (id) {
            var _this = this;
            console.log(id);
            if (id) {
                this.service.setNotificationViewed(id)
                    .pipe(operators.catchError((/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) {
                    /** @type {?} */
                    var m = new MessageHandler(_this._snackBar);
                    m.showMessage(StatusCode.serverError, error.message);
                    return rxjs.of(null);
                })))
                    .subscribe((/**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    if (response.status === 'success') {
                        _this.getNotificationsListData();
                        /** @type {?} */
                        var m = new MessageHandler(_this._snackBar);
                        m.showMessage(StatusCode.OK, 'La notificación fue marcada como leída');
                    }
                    else {
                        /** @type {?} */
                        var m = new MessageHandler(_this._snackBar);
                        m.showMessage(StatusCode.serverError, response.message);
                    }
                }));
            }
        };
        NotificationListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'lib-notification-list',
                        template: "<div [ngStyle]=\"{padding: '2em 1em 0 1em', overflow: 'auto'}\">\n    <table mat-table [dataSource]=\"dataSource\" multiTemplateDataRows>\n        <ng-container matColumnDef=\"{{column}}\" *ngFor=\"let column of columnsToDisplay; let i = index\">\n            <th [id]=\"column+'-th'\" mat-header-cell *matHeaderCellDef> {{columnsLabels[i]}} </th>\n            <td class=\"element-row-header\"\n                mat-cell *matCellDef=\"let element\"\n                [id]=\"column+'-td'\"\n                [class.expanded-row]=\"column === 'description' && expandedElement === element\" (click)=\"expandedElement = element\"\n                [ngStyle]=\"{'font-weight': !element.viewed ? 'bold' : '0', width: column === 'action' ? '50px' : 'inherit'}\"\n            >\n              <ng-container *ngIf=\"column === 'action'\">\n                <button mat-icon-button *ngIf=\"!element.viewed\" color=\"primary\" (click)=\"setnotificationViewed(element.id)\" matTooltip=\"Marcar como visto\">\n                  <mat-icon class=\"mat-16\">visibility</mat-icon>\n                </button>\n                <button mat-icon-button *ngIf=\"element.viewed\" disabled color=\"primary\" (click)=\"setnotificationViewed(element.id)\" matTooltip=\"Visto\">\n                  <mat-icon class=\"mat-16\">viewed</mat-icon>\n                </button>\n              </ng-container>\n\n              <span *ngIf=\"column === 'createdAt' \" > {{moment(element[column]).format('ll')}} </span>\n              <div class=\"element-tag\" [ngStyle]=\"{'background-color': element['classification'].color}\" *ngIf=\"column === 'classification'\" > {{element[column].label}} </div>\n              <span *ngIf=\"column === 'emiter'\" > {{element[column].name}} {{element[column].lastname}} </span>\n              <span *ngIf=\"column === 'emiterEmail'\" > {{element['emiter'].email}} </span>\n              <div  *ngIf=\"column === 'description'\" class=\"element-description-header\" >\n                <mat-icon class=\"mat-16\" color=\"primary\" >{{expandedElement === element ? 'expand_more' : 'chevron_right'}}</mat-icon>\n                {{(element[column].length && element[column].length>70) ?\n                   (element[column] | slice:0:70)+' ...'\n                   :(element[column])\n                }}\n              </div>\n            </td>\n            <td mat-cell *matCellDef=\"let element\">\n            </td>\n        </ng-container>\n\n        <!-- Expanded Content Column - The detail row is made up of this one column that spans across all columns -->\n        <ng-container matColumnDef=\"expandedDetail\">\n            <td mat-cell *matCellDef=\"let element\" [attr.colspan]=\"columnsToDisplay.length\">\n                <div class=\"element-detail\" fxLayout=\"row wrap\" fxLayoutAlign=\"space-between center\"  fxLayoutGap=\"15px\" [@detailExpand]=\"element == expandedElement ? 'expanded' : 'collapsed'\">\n\n                    <div class=\"element-description\">\n                        {{element.description}}\n                    </div>\n\n                </div>\n            </td>\n        </ng-container>\n\n        <tr mat-header-row *matHeaderRowDef=\"columnsToDisplay\"></tr>\n        <tr mat-row *matRowDef=\"let element; columns: columnsToDisplay;\" class=\"element-row\"\n            >\n        </tr>\n        <tr mat-row *matRowDef=\"let row; columns: ['expandedDetail']\" class=\"detail-row\"></tr>\n    </table>\n    <div *ngIf=\"paginator.length === 0\" class=\"empty-notifications-container\">\n      <mat-icon class=\"empty-notifications-icon\">notifications</mat-icon>\n      <h1 style=\"color: grey;\">SIN NOTIFICACIONES</h1>\n    </div>\n    <mat-paginator [length]=\"paginator.length\" [pageSize]=\"paginator.pageSize\" [pageSizeOptions]=\"pageSizeOptions\" (page)=\"getNotificationsListData()\">\n    </mat-paginator>\n</div>\n",
                        animations: [
                            animations.trigger('detailExpand', [
                                animations.state('collapsed', animations.style({ height: '0px', minHeight: '0' })),
                                animations.state('expanded', animations.style({ height: '*' })),
                                animations.transition('expanded <=> collapsed', animations.animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
                            ]),
                        ],
                        styles: ["table{width:100%}tr.detail-row{height:0}tr.element-row:not(.expanded-row):hover{background:#f4f4f4}tr.element-row:not(.expanded-row):active{background:#efefef}.element-row td{border-bottom-width:0}.element-detail{overflow:hidden;display:flex;background-color:#f4f4f4;border-radius:10px 10px 0 0}.element-tag{display:flex;justify-content:center;padding:6px;border-radius:15px;width:60%}.element-description-header{display:flex;align-items:center;cursor:pointer;padding:10px 25px 10px 10px}.element-description{padding:16px}.element-description-attribution{opacity:.5}.empty-notifications-container{display:flex;flex-direction:column;justify-content:center;align-items:center;padding:30px}.empty-notifications-icon{color:grey;font-size:6em;height:100px;width:100px}@media only screen and (max-width:768px){#description-th{padding-left:34px!important}#emiter-td,#emiter-th{display:none!important}#createdAt-th,#emiterEmail-td,#emiterEmail-th{padding-left:20px!important}#createdAt-td{min-width:120px!important;padding-left:20px!important}}"]
                    }] }
        ];
        /** @nocollapse */
        NotificationListComponent.ctorParameters = function () { return [
            { type: NotificationService },
            { type: material.MatSnackBar }
        ]; };
        NotificationListComponent.propDecorators = {
            paginator: [{ type: core.ViewChild, args: [material.MatPaginator, { static: true },] }]
        };
        return NotificationListComponent;
    }());
    if (false) {
        /** @type {?} */
        NotificationListComponent.prototype.dataSource;
        /** @type {?} */
        NotificationListComponent.prototype.columnsToDisplay;
        /** @type {?} */
        NotificationListComponent.prototype.columnsLabels;
        /** @type {?} */
        NotificationListComponent.prototype.expandedElement;
        /** @type {?} */
        NotificationListComponent.prototype.moment;
        /** @type {?} */
        NotificationListComponent.prototype.pageSizeOptions;
        /** @type {?} */
        NotificationListComponent.prototype.paginator;
        /**
         * @type {?}
         * @private
         */
        NotificationListComponent.prototype.service;
        /**
         * @type {?}
         * @private
         */
        NotificationListComponent.prototype._snackBar;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/notification/notification.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var NotificationModule = /** @class */ (function () {
        function NotificationModule() {
        }
        NotificationModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            NotificationButtonComponent,
                            NotificationListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            router.RouterModule,
                            material.MatButtonModule,
                            material.MatMenuModule,
                            material.MatIconModule,
                            material.MatBadgeModule,
                            material.MatTableModule,
                            material.MatPaginatorModule,
                            material.MatDividerModule,
                            material.MatTooltipModule
                        ],
                        exports: [
                            NotificationButtonComponent,
                            NotificationListComponent
                        ],
                        providers: [
                            NotificationService
                        ]
                    },] }
        ];
        return NotificationModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/notification/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/statics/chips/chips-static.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a static control that shows an array of texts using chips.
     */
    var StaticChipsComponent = /** @class */ (function () {
        function StaticChipsComponent() {
            this.appearance = 'outline';
            this.desc = undefined;
            this.value = [];
        }
        StaticChipsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'static-chips',
                        template: "\n<mat-form-field class=\"chips-mat-form-field control-without-interactivity\" [appearance]=\"appearance\">\n\t<mat-label>{{ desc }}</mat-label>\n\t<mat-chip-list *ngIf=\"value.length\" [selectable]=\"'false'\" [attr.aria-label]=\"desc\">\n    <mat-chip *ngFor=\"let item of value\" [selectable]=\"'false'\" [disableRipple]=\"'true'\">{{ item }}</mat-chip>\n  </mat-chip-list>\n  <input *ngIf=\"!value.length\" matInput [value]=\"'There is not any item to show!'\" [attr.aria-label]=\"desc\" />\n</mat-form-field>\n",
                        styles: [".chips-mat-form-field{width:100%}.control-without-interactivity{pointer-events:none}"]
                    }] }
        ];
        /** @nocollapse */
        StaticChipsComponent.ctorParameters = function () { return []; };
        StaticChipsComponent.propDecorators = {
            appearance: [{ type: core.Input }],
            desc: [{ type: core.Input }],
            value: [{ type: core.Input }]
        };
        return StaticChipsComponent;
    }());
    if (false) {
        /**
         * The control's appearance.
         * By default, its value is `'outline'`.
         * @type {?}
         */
        StaticChipsComponent.prototype.appearance;
        /**
         * The control's description.
         * By default, its value is `undefined` and it is not showed.
         * @type {?}
         */
        StaticChipsComponent.prototype.desc;
        /**
         * The array of items for displaying.
         * By default, its value is `[]`.
         * @type {?}
         */
        StaticChipsComponent.prototype.value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/statics/table/table-static.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function PeriodicElement() { }
    if (false) {
        /** @type {?} */
        PeriodicElement.prototype.name;
        /** @type {?} */
        PeriodicElement.prototype.position;
        /** @type {?} */
        PeriodicElement.prototype.weight;
        /** @type {?} */
        PeriodicElement.prototype.symbol;
    }
    /* For testing. */
    /** @type {?} */
    var ELEMENT_DATA = [
        { position: 1, name: 'Hydrogen', weight: 1.0079, symbol: 'H' },
        { position: 2, name: 'Helium', weight: 4.0026, symbol: 'He' },
        { position: 3, name: 'Lithium', weight: 6.941, symbol: 'Li' },
        { position: 4, name: 'Beryllium', weight: 9.0122, symbol: 'Be' },
        { position: 5, name: 'Boron', weight: 10.811, symbol: 'B' },
        { position: 6, name: 'Carbon', weight: 12.0107, symbol: 'C' },
        { position: 7, name: 'Nitrogen', weight: 14.0067, symbol: 'N' },
        { position: 8, name: 'Oxygen', weight: 15.9994, symbol: 'O' },
        { position: 9, name: 'Fluorine', weight: 18.9984, symbol: 'F' },
        { position: 10, name: 'Neon', weight: 20.1797, symbol: 'Ne' },
    ];
    /**
     * Represents a static control that shows an array of objects using a table.
     */
    var StaticTableComponent = /** @class */ (function () {
        function StaticTableComponent() {
            this.appearance = 'outline';
            this.desc = undefined;
            this.value = [];
            this.columnsObjectProperty = [];
            this.columnsHeaderText = [];
        }
        StaticTableComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'static-table',
                        template: "\n<!-- TODO: En dependencia del valor de `appearance`, se aplican las clases CSS para lograr la apariencia deseada. \n     Actualmente, `appearance = 'outline'` es el \u00FAnico que est\u00E1 hecho. -->\n<fieldset class=\"static-table-fieldset\">\n    <legend class=\"static-table-fieldset-legend\">{{ desc }}</legend>\n\n    <table mat-table [dataSource]=\"value\" class=\"mat-elevation-z8\" [attr.aria-label]=\"desc\">\n        <!-- The content that is showed when the `dataSource` is not empty. -->\n        <ng-container *ngFor=\"let column of columnsObjectProperty; let pos = index\" [matColumnDef]=\"column\">\n            <th mat-header-cell *matHeaderCellDef>\n                {{ columnsHeaderText[pos] }}\n            </th>\n\n            <td mat-cell *matCellDef=\"let element\">\n                {{ element[column] }}\n            </td>\n        </ng-container>\n\n        <tr mat-header-row *matHeaderRowDef=\"columnsObjectProperty; sticky: true\"></tr>\n        <tr mat-row *matRowDef=\"let row; columns: columnsObjectProperty;\"></tr>\n    </table>\n\n</fieldset>\n",
                        styles: [".static-table-fieldset{width:auto;margin:-4px 0 24px;padding:0 10px 14px;cursor:default;background-color:#fff;border:1px solid rgba(0,0,0,.12);border-radius:4px}.static-table-fieldset-legend{padding:0 4px;background-color:#fff;color:rgba(0,0,0,.6);font-size:10px}table{width:100%;box-shadow:none}"]
                    }] }
        ];
        /** @nocollapse */
        StaticTableComponent.ctorParameters = function () { return []; };
        StaticTableComponent.propDecorators = {
            appearance: [{ type: core.Input }],
            desc: [{ type: core.Input }],
            value: [{ type: core.Input }],
            columnsObjectProperty: [{ type: core.Input }],
            columnsHeaderText: [{ type: core.Input }]
        };
        return StaticTableComponent;
    }());
    if (false) {
        /**
         * The control's appearance.
         * By default, its value is `'outline'`.
         * @type {?}
         */
        StaticTableComponent.prototype.appearance;
        /**
         * The control's description.
         * By default, its value is `undefined` and it is not showed.
         * @type {?}
         */
        StaticTableComponent.prototype.desc;
        /**
         * The array of data that should be rendered by the table, where each object represents one row.
         * By default, its value is `[]`.
         * @type {?}
         */
        StaticTableComponent.prototype.value;
        /**
         * The array of strings that indicates the object property name of the columns.
         * By default, its value is `[]`.
         * @type {?}
         */
        StaticTableComponent.prototype.columnsObjectProperty;
        /**
         * The array of strings that indicates the header text of the columns.
         * By default, its value is `[]`.
         * @type {?}
         */
        StaticTableComponent.prototype.columnsHeaderText;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/statics/text/text-static.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a static control that shows a text.
     */
    var StaticTextComponent = /** @class */ (function () {
        function StaticTextComponent() {
            this.width = '100%';
            this.appearance = 'outline';
            this.desc = undefined;
            this.value = undefined;
            this.valueByDefault = 'There is not any text to show!';
            this.textAlign = 'left';
            this.input_static = undefined;
        }
        /**
         * @return {?}
         */
        StaticTextComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.value === undefined)
                this.value = this.valueByDefault;
            this.input_static = new forms.FormControl(this.value);
        };
        /**
         * Handler method that is called when the control's value changes in the UI.
         * It is always used to set the `value` input field as the component value.
         * For internal use only.
         */
        /**
         * Handler method that is called when the control's value changes in the UI.
         * It is always used to set the `value` input field as the component value.
         * For internal use only.
         * @return {?}
         */
        StaticTextComponent.prototype.handleInput = /**
         * Handler method that is called when the control's value changes in the UI.
         * It is always used to set the `value` input field as the component value.
         * For internal use only.
         * @return {?}
         */
        function () {
            /* It always sets the `value` input field as the component value. */
            this.input_static.setValue(this.value);
        };
        StaticTextComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'static-text',
                        template: "\n<mat-form-field class=\"text-mat-form-field control-without-interactivity\" [appearance]=\"appearance\">\n    <mat-label>{{ desc }}</mat-label>\n    <input matInput [formControl]=\"input_static\" [style.textAlign]=\"textAlign\" [attr.aria-label]=\"desc\" (input)=\"handleInput()\" />\n</mat-form-field>\n",
                        host: {
                            '[style.width]': 'width'
                        },
                        styles: [".text-mat-form-field{width:100%}.control-without-interactivity{pointer-events:none}"]
                    }] }
        ];
        /** @nocollapse */
        StaticTextComponent.ctorParameters = function () { return []; };
        StaticTextComponent.propDecorators = {
            width: [{ type: core.Input }],
            appearance: [{ type: core.Input }],
            desc: [{ type: core.Input }],
            value: [{ type: core.Input }],
            valueByDefault: [{ type: core.Input }],
            textAlign: [{ type: core.Input }]
        };
        return StaticTextComponent;
    }());
    if (false) {
        /**
         * The control's width.
         * The width of the content area, padding area or border area (depending on `box-sizing`) of certain boxes.
         * By default, its value is `'100%'`.
         * @type {?}
         */
        StaticTextComponent.prototype.width;
        /**
         * The control's appearance.
         * By default, its value is `'outline'`.
         * @type {?}
         */
        StaticTextComponent.prototype.appearance;
        /**
         * The control's description.
         * By default, its value is `undefined` and it is not showed.
         * @type {?}
         */
        StaticTextComponent.prototype.desc;
        /**
         * The control's value.
         * By default, its value is `undefined`.
         * @type {?}
         */
        StaticTextComponent.prototype.value;
        /**
         * The control's default value.
         * By default, its value is `'There is not any text to show!'`.
         * @type {?}
         */
        StaticTextComponent.prototype.valueByDefault;
        /**
         * Returns the control's text align.
         * By default, its value is `'left'`.
         * @type {?}
         */
        StaticTextComponent.prototype.textAlign;
        /**
         * Returns a reference to the `FormControl` that tracks the value and validity state
         * of the internal control that contains the text input.
         * For internal use only.
         * @type {?}
         */
        StaticTextComponent.prototype.input_static;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/statics/statics.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var StaticsModule = /** @class */ (function () {
        function StaticsModule() {
        }
        StaticsModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            StaticChipsComponent,
                            StaticTableComponent,
                            StaticTextComponent
                        ],
                        imports: [
                            SharedModule,
                            forms.ReactiveFormsModule
                        ],
                        exports: [
                            StaticChipsComponent,
                            StaticTableComponent,
                            StaticTextComponent
                        ]
                    },] }
        ];
        return StaticsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/statics/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/org-view/org-view-accordion/org-view-accordion.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var OrgViewAccordionType = {
        /**
         * The `OrgViewAccordionComponent` is used to show relationships.
         */
        Relationships: "Relaci\u00F3n" /*'Relationship'*/,
        /**
         * The `OrgViewAccordionComponent` is used to show addresses.
         */
        Addresses: "Direcci\u00F3n" /*'Address'*/,
    };
    ;
    var OrgViewAccordionComponent = /** @class */ (function () {
        function OrgViewAccordionComponent() {
            this.orgViewAccordion_Type = OrgViewAccordionType;
            this.appearance = 'outline';
            this.desc = undefined;
            this.value = [];
            this.orgViewAccordionType = OrgViewAccordionType.Relationships;
            this.panelsTitle = []; /* This array has the same length than the `value` field. */
        }
        /**
         * @return {?}
         */
        OrgViewAccordionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
        };
        Object.defineProperty(OrgViewAccordionComponent.prototype, "getAccordion", {
            /**
             * Returns the `MatAccordion` control.
             */
            get: /**
             * Returns the `MatAccordion` control.
             * @return {?}
             */
            function () {
                return this._accordion;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns true if the panel has element; otherwise, false.
         * The panel always has element by default.
         * @param pos The panel position.
         */
        /**
         * Returns true if the panel has element; otherwise, false.
         * The panel always has element by default.
         * @param {?} pos The panel position.
         * @return {?}
         */
        OrgViewAccordionComponent.prototype.panelHasElement = /**
         * Returns true if the panel has element; otherwise, false.
         * The panel always has element by default.
         * @param {?} pos The panel position.
         * @return {?}
         */
        function (pos) {
            switch (this.orgViewAccordionType) {
                case this.orgViewAccordion_Type.Relationships:
                    {
                        return this.value[pos].links.length;
                    }
                default:
                    {
                        /* The panel always has element by default. */
                        return true;
                    }
            }
        };
        OrgViewAccordionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-org-view-accordion',
                        template: "\n<!-- TODO: En dependencia del valor de `appearance`, se aplican las clases CSS para lograr la apariencia deseada. \n     Actualmente, `appearance = 'outline'` es el \u00FAnico que est\u00E1 hecho. -->\n<fieldset class=\"static-accordion-fieldset\">\n\t<legend class=\"static-accordion-fieldset-legend\">{{ desc }}</legend>\n\n\t<div class=\"static-accordion-buttons\">\n\t\t<button mat-raised-button color=\"primary\" (click)=\"getAccordion.openAll()\">Expandir Todo</button>\n\t\t<button mat-raised-button color=\"primary\" (click)=\"getAccordion.closeAll()\">Colapsar Todo</button>\n\t</div>\n\n\t<mat-accordion class=\"static-mat-accordion\" multi [attr.aria-label]=\"desc\">\n\t\t<ng-container *ngFor=\"let panelTitle of panelsTitle; let pos = index\">\n\t\t\t<mat-expansion-panel *ngIf=\"panelHasElement(pos)\">\n\t\t\t\t<mat-expansion-panel-header>\n\t\t\t\t\t<mat-panel-title>\n\t\t\t\t\t\t{{ panelTitle }}\n\t\t\t\t\t</mat-panel-title>\n\t\t\t\t</mat-expansion-panel-header>\n\n\t\t\t\t<ng-container [ngSwitch]=\"orgViewAccordionType\">\n\t\t\t\t\t<toco-org-view-relationship *ngSwitchCase=\"orgViewAccordion_Type.Relationships\" [value]=\"value[pos]\"></toco-org-view-relationship>\n\t\t\t\t\t<toco-org-view-address *ngSwitchCase=\"orgViewAccordion_Type.Addresses\" [value]=\"value[pos]\"></toco-org-view-address>\n\t\t\t\t</ng-container>\n\t\t\t</mat-expansion-panel>\n\t\t</ng-container>\n\t</mat-accordion>\n</fieldset>\n",
                        styles: [".static-accordion-fieldset{width:auto;margin:-4px 0 24px;padding:0 10px 14px;cursor:default;background-color:#fff;border:1px solid rgba(0,0,0,.12);border-radius:4px}.static-accordion-fieldset-legend{padding:0 4px;background-color:#fff;color:rgba(0,0,0,.6);font-size:10px}.static-accordion-buttons{margin:20px 0}button{margin-right:10px}.mat-expansion-panel{box-shadow:none;border:1px solid #eaeaea}.mat-expansion-panel:not(.mat-expansion-panel-spacing):not(:first-of-type){margin:-1px 0 0}::ng-deep div.mat-expansion-panel-body{padding:0}"]
                    }] }
        ];
        /** @nocollapse */
        OrgViewAccordionComponent.ctorParameters = function () { return []; };
        OrgViewAccordionComponent.propDecorators = {
            appearance: [{ type: core.Input }],
            desc: [{ type: core.Input }],
            value: [{ type: core.Input }],
            orgViewAccordionType: [{ type: core.Input }],
            panelsTitle: [{ type: core.Input }],
            _accordion: [{ type: core.ViewChild, args: [material.MatAccordion, { static: true },] }]
        };
        return OrgViewAccordionComponent;
    }());
    if (false) {
        /**
         * Represents the `OrgViewAccordionType` enum for internal use.
         * @type {?}
         */
        OrgViewAccordionComponent.prototype.orgViewAccordion_Type;
        /**
         * The control's appearance.
         * By default, its value is `'outline'`.
         * @type {?}
         */
        OrgViewAccordionComponent.prototype.appearance;
        /**
         * The control's description.
         * By default, its value is `undefined` and it is not showed.
         * @type {?}
         */
        OrgViewAccordionComponent.prototype.desc;
        /**
         * The array of data that should be rendered by the accordion, where each object represents one row.
         * This array has the same length than the `panelsTitle` field.
         * By default, its value is `[]`.
         * @type {?}
         */
        OrgViewAccordionComponent.prototype.value;
        /**
         * The `OrgViewAccordionComponent` type.
         * By default, its value is `OrgViewAccordionType.Relationships`.
         * @type {?}
         */
        OrgViewAccordionComponent.prototype.orgViewAccordionType;
        /**
         * The panels title.
         * This array has the same length than the `value` field.
         * By default, its value is `[]`.
         * @type {?}
         */
        OrgViewAccordionComponent.prototype.panelsTitle;
        /**
         * @type {?}
         * @private
         */
        OrgViewAccordionComponent.prototype._accordion;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/org-view/org-view.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function RelationshipLink() { }
    if (false) {
        /** @type {?} */
        RelationshipLink.prototype.url;
        /** @type {?} */
        RelationshipLink.prototype.name;
    }
    /**
     * @record
     */
    function RelationshipsValue() { }
    if (false) {
        /** @type {?} */
        RelationshipsValue.prototype.links;
    }
    var OrgViewComponent = /** @class */ (function () {
        function OrgViewComponent() {
            this.showContent = true;
            this.orgViewAccordionType = OrgViewAccordionType;
            this.org = undefined;
        }
        /**
         * @return {?}
         */
        OrgViewComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            // si se recibe un objeto que no tiene todos los campos.
            /** @type {?} */
            var org_full = new Organization();
            org_full.deepcopy(this.org);
            this.org = org_full;
            this._panelsTitle_Relationships = ['Organizaciones Padres', 'Organizaciones Hijas', 'Organizaciones Relacionadas'];
            this._relationshipsValue = this._createRelationshipsValue();
            this._addressesValue = this._createAddressesValue(); /* This initialization is first than the `_panelsTitle_Addresses` initialization. */
            // this._panelsTitle_Addresses = (this.org.addresses) ? this._createPanelsTitle_Generic(this.orgViewAccordionType.Addresses, this.org.addresses.length) : [ ];
            this._panelsTitle_Addresses = this._createPanelsTitle_Addresses();
        };
        /**
         * @return {?}
         */
        OrgViewComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            this.ngOnInit();
        };
        /**
         * Creates a generic array of panels title.
         * Usage example:
         * this._panelsTitle_Addresses = (this.org.addresses) ? this._createPanelsTitle_Generic(this.orgViewAccordionType.Addresses, this.org.addresses.length) : [ ];
         * @param orgViewAccordionType The `OrgViewAccordionComponent` type.
         * @param panelsTitleCount Amount of panels title.
         */
        /**
         * Creates a generic array of panels title.
         * Usage example:
         * this._panelsTitle_Addresses = (this.org.addresses) ? this._createPanelsTitle_Generic(this.orgViewAccordionType.Addresses, this.org.addresses.length) : [ ];
         * @private
         * @param {?} orgViewAccordionType The `OrgViewAccordionComponent` type.
         * @param {?} panelsTitleCount Amount of panels title.
         * @return {?}
         */
        OrgViewComponent.prototype._createPanelsTitle_Generic = /**
         * Creates a generic array of panels title.
         * Usage example:
         * this._panelsTitle_Addresses = (this.org.addresses) ? this._createPanelsTitle_Generic(this.orgViewAccordionType.Addresses, this.org.addresses.length) : [ ];
         * @private
         * @param {?} orgViewAccordionType The `OrgViewAccordionComponent` type.
         * @param {?} panelsTitleCount Amount of panels title.
         * @return {?}
         */
        function (orgViewAccordionType, panelsTitleCount) {
            /** @type {?} */
            var panelsTitle = [];
            /* Initializae the `panelsTitle` array. */
            for (var i = 0; i < panelsTitleCount;) {
                panelsTitle.push(orgViewAccordionType + " (" + ++i + ") of (" + panelsTitleCount + ")");
            }
            return panelsTitle;
        };
        /**
         * @private
         * @return {?}
         */
        OrgViewComponent.prototype._createPanelsTitle_Addresses = /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var panelsTitle = [];
            /** @type {?} */
            var panelsTitleCount = this._addressesValue.length;
            /* Initializae the `panelsTitle` array. */
            for (var i = 0; i < panelsTitleCount; i++) {
                panelsTitle.push(this._addressesValue[i].city + " | " + this._addressesValue[i].country + " " + ((this._addressesValue[i].primary) ? '(Principal)' : ''));
            }
            return panelsTitle;
        };
        /**
         * @private
         * @return {?}
         */
        OrgViewComponent.prototype._createRelationshipsValue = /**
         * @private
         * @return {?}
         */
        function () {
            var e_1, _a, e_2, _b;
            /* The positions represent:
                 * pos = 0 --> Organizaciones Padres
                 * pos = 1 --> Organizaciones Hijas
                 * pos = 2 --> Organizaciones Relacionadas */
            /** @type {?} */
            var result = [];
            /** @type {?} */
            var pos = -1;
            /** @type {?} */
            var item;
            try {
                for (var _c = __values(this._panelsTitle_Relationships), _d = _c.next(); !_d.done; _d = _c.next()) {
                    item = _d.value;
                    result.push({
                        'links': []
                    });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            if (this.org.relationships) {
                try {
                    for (var _e = __values(this.org.relationships), _f = _e.next(); !_f.done; _f = _e.next()) {
                        item = _f.value;
                        switch (item.type) {
                            case 'parent':
                                {
                                    pos = 0;
                                    break;
                                }
                            case 'child':
                                {
                                    pos = 1;
                                    break;
                                }
                            default: /* 'related' */
                                {
                                    pos = 2;
                                    break;
                                }
                        }
                        result[pos].links.push({
                            // 'url': `${ item.id }/view`,
                            'url': '/' + item.id + '/view',
                            'name': item.label
                        });
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            return result;
        };
        /**
         * Returns an array of addresses ordered by the `primary` field of its addresses,
         * the true values are first than the false values.
         */
        /**
         * Returns an array of addresses ordered by the `primary` field of its addresses,
         * the true values are first than the false values.
         * @private
         * @return {?}
         */
        OrgViewComponent.prototype._createAddressesValue = /**
         * Returns an array of addresses ordered by the `primary` field of its addresses,
         * the true values are first than the false values.
         * @private
         * @return {?}
         */
        function () {
            var e_3, _a;
            /** @type {?} */
            var result = [];
            /** @type {?} */
            var noPrimary = [];
            try {
                for (var _b = __values(this.org.addresses), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var item = _c.value;
                    if (item.primary) {
                        result.push(item);
                    }
                    else {
                        noPrimary.push(item);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_3) throw e_3.error; }
            }
            return result.concat(noPrimary);
        };
        Object.defineProperty(OrgViewComponent.prototype, "getPanelsTitle_Relationships", {
            get: /**
             * @return {?}
             */
            function () {
                return this._panelsTitle_Relationships;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrgViewComponent.prototype, "getValue_Relationships", {
            get: /**
             * @return {?}
             */
            function () {
                return this._relationshipsValue;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrgViewComponent.prototype, "getPanelsTitle_Addresses", {
            get: /**
             * @return {?}
             */
            function () {
                return this._panelsTitle_Addresses;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrgViewComponent.prototype, "getValue_Addresses", {
            get: /**
             * @return {?}
             */
            function () {
                return this._addressesValue;
            },
            enumerable: true,
            configurable: true
        });
        OrgViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-org-view',
                        template: "\n<mat-card *ngIf=\"org\" class=\"container-panel-mat-card\" [attr.aria-label]=\"'Muestra la organizaci\u00F3n seleccionada'\">\n  <mat-card-header>\n\n    <!-- <div mat-card-avatar class=\"example-header-image\"></div> -->\n    <mat-card-title class=\"title-padding\">{{ org.name }}</mat-card-title>\n    <mat-card-subtitle class=\"title-padding\">SceibaOrgID: {{ org.id }}</mat-card-subtitle>\n    <mat-card-subtitle *ngIf=\"org.status\" class=\"cursor-default title-padding\">\n      Estatus de la organizaci\u00F3n: {{ org.status }}\n    </mat-card-subtitle>\n\n  </mat-card-header>\n\n  <mat-card-content *ngIf=\"showContent\">\n\n    <static-table *ngIf=\"org.identifiers && org.identifiers.length\" [desc]=\"'Lista de los identificadores de la organizaci\u00F3n'\" [value]=\"org.identifiers\"\n      [columnsObjectProperty]=\"['idtype', 'value']\"\n      [columnsHeaderText]=\"['Identifier type', 'Identifier value']\"\n    >\n    </static-table>\n    <static-chips *ngIf=\"org.aliases && org.aliases.length\" [desc]=\"'Lista de otros nombres con los que se conoce la organizaci\u00F3n'\" [value]=\"org.aliases\"></static-chips>\n    <static-chips *ngIf=\"org.acronyms && org.acronyms.length\" [desc]=\"'Lista de los acr\u00F3nimos con que se conoce la organizaci\u00F3n'\" [value]=\"org.acronyms\"></static-chips>\n    <static-chips *ngIf=\"org.types && org.types.length\" [desc]=\"'Lista de los tipos que describen la organizaci\u00F3n'\" [value]=\"org.types\"></static-chips>\n    <static-text *ngIf=\"org.wikipedia_url\" [desc]=\"'URL de la p\u00E1gina de Wikipedia de la organizaci\u00F3n'\" [value]=\"org.wikipedia_url\"></static-text>\n    <static-text *ngIf=\"org.redirect\" [desc]=\"'URL de la p\u00E1gina originaria de la organizaci\u00F3n'\" [value]=\"org.redirect.properties.value\"></static-text>\n    <static-text *ngIf=\"org.email_address\" [desc]=\"'Correo electr\u00F3nico de contacto de la organizaci\u00F3n'\" [value]=\"org.email_address\"></static-text>\n    <!-- <static-chips *ngIf=\"org.ip_addresses && org.ip_addresses.length\" [desc]=\"'Lista de direcciones IP conocidas que pertenecen a la organizaci\u00F3n'\" [value]=\"org.ip_addresses\"></static-chips> -->\n    <static-text *ngIf=\"org.established\" [desc]=\"'A\u00F1o de fundada la organizaci\u00F3n'\" [value]=\"org.established\"></static-text>\n    <static-text *ngIf=\"org.onei_registry\" [desc]=\"'N\u00FAmero de registro en la ONEI'\" [value]=\"org.onei_registry\"></static-text>\n    <static-chips *ngIf=\"org.links && org.links.length\" [desc]=\"'Lista de los enlaces conocidos de la organizaci\u00F3n'\" [value]=\"org.links\"></static-chips>\n    <static-table *ngIf=\"org.labels && org.labels.length\" [desc]=\"'Nombre de la organizaci\u00F3n en diferentes lenguajes'\" [value]=\"org.labels\"\n      [columnsObjectProperty]=\"['label', 'iso639']\"\n      [columnsHeaderText]=\"['Institute name in a language variant', 'ISO-639-1 language code']\"\n    >\n    </static-table>\n    <toco-org-view-accordion *ngIf=\"org.relationships && org.relationships.length\" [desc]=\"'Relaciones con otras organizaciones'\" [value]=\"getValue_Relationships\"\n      [orgViewAccordionType]=\"orgViewAccordionType.Relationships\"\n      [panelsTitle] = \"getPanelsTitle_Relationships\"\n    >\n    </toco-org-view-accordion>\n    <toco-org-view-accordion *ngIf=\"org.addresses && org.addresses.length\" [desc]=\"'Direcciones conocidas de la organizaci\u00F3n'\" [value]=\"getValue_Addresses\"\n      [orgViewAccordionType]=\"orgViewAccordionType.Addresses\"\n      [panelsTitle] = \"getPanelsTitle_Addresses\"\n    >\n    </toco-org-view-accordion>\n\n  </mat-card-content>\n</mat-card>\n",
                        styles: [".cursor-default{cursor:default}.title-padding{padding:0 0 0 .1em}.example-header-image{background-image:url(https://material.angular.io/assets/img/examples/shiba1.jpg);background-size:cover}.form-container{display:flex;flex-direction:column;justify-content:start;width:40%}"]
                    }] }
        ];
        /** @nocollapse */
        OrgViewComponent.ctorParameters = function () { return []; };
        OrgViewComponent.propDecorators = {
            org: [{ type: core.Input }],
            showContent: [{ type: core.Input }]
        };
        return OrgViewComponent;
    }());
    if (false) {
        /**
         * Represents the `OrgViewAccordionType` enum for internal use.
         * @type {?}
         */
        OrgViewComponent.prototype.orgViewAccordionType;
        /**
         * Represents the current organization.
         * @type {?}
         */
        OrgViewComponent.prototype.org;
        /** @type {?} */
        OrgViewComponent.prototype.showContent;
        /**
         * @type {?}
         * @private
         */
        OrgViewComponent.prototype._panelsTitle_Relationships;
        /**
         * @type {?}
         * @private
         */
        OrgViewComponent.prototype._relationshipsValue;
        /**
         * @type {?}
         * @private
         */
        OrgViewComponent.prototype._panelsTitle_Addresses;
        /**
         * @type {?}
         * @private
         */
        OrgViewComponent.prototype._addressesValue;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/org-view/org-view-address/org-view-address.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OrgViewAddressComponent = /** @class */ (function () {
        function OrgViewAddressComponent() {
            this.value = undefined;
        }
        OrgViewAddressComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-org-view-address',
                        template: "\n<static-text *ngIf=\"value.city\" [desc]=\"'Nombre de la ciudad'\" [value]=\"value.city\"></static-text>\n<static-text *ngIf=\"value.municipality\" [desc]=\"'Nombre del municipio'\" [value]=\"value.municipality\"></static-text>\n<static-text *ngIf=\"value.country\" [desc]=\"'Nombre del pa\u00EDs'\" [value]=\"value.country\"></static-text>\n<static-text *ngIf=\"value.country_code\" [desc]=\"'C\u00F3digo ISO 3166-1 alpha-2 del pa\u00EDs'\" [value]=\"value.country_code\"></static-text>\n<static-text *ngIf=\"value.lat\" [desc]=\"'Latitud (coordenadas geogr\u00E1ficas)'\" [value]=\"value.lat\"></static-text>\n<static-text *ngIf=\"value.lng\" [desc]=\"'Longitud (coordenadas geogr\u00E1ficas)'\" [value]=\"value.lng\"></static-text>\n<static-text *ngIf=\"value.line_1\" [desc]=\"'Primera l\u00EDnea de la direcci\u00F3n'\" [value]=\"value.line_1\"></static-text>\n<static-text *ngIf=\"value.line_2\" [desc]=\"'Segunda l\u00EDnea de la direcci\u00F3n'\" [value]=\"value.line_2\"></static-text>\n<static-text *ngIf=\"value.line_3\" [desc]=\"'Tercera l\u00EDnea de la direcci\u00F3n'\" [value]=\"value.line_3\"></static-text>\n<static-text *ngIf=\"value.postcode\" [desc]=\"'C\u00F3digo postal'\" [value]=\"value.postcode\"></static-text>\n<static-text *ngIf=\"value.primary != undefined\" [desc]=\"'Especifica si esta direcci\u00F3n identifica la direcci\u00F3n principal'\" [value]=\"value.primary.toString()\"></static-text>\n<static-text *ngIf=\"value.state\" [desc]=\"'Nombre del estado/regi\u00F3n'\" [value]=\"value.state\"></static-text>\n<static-text *ngIf=\"value.state_code\" [desc]=\"'C\u00F3digo ISO 3166-2 del estado/regi\u00F3n'\" [value]=\"value.state_code\"></static-text>\n<toco-org-view-geo-names-city *ngIf=\"value.geonames_city\" [desc]=\"'Datos GeoNames enlazados'\" [value]=\"value.geonames_city\"></toco-org-view-geo-names-city>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        OrgViewAddressComponent.ctorParameters = function () { return []; };
        OrgViewAddressComponent.propDecorators = {
            value: [{ type: core.Input }]
        };
        return OrgViewAddressComponent;
    }());
    if (false) {
        /**
         * An address associated with the organization.
         * By default, its value is `undefined`.
         * @type {?}
         */
        OrgViewAddressComponent.prototype.value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/org-view/org-view-geo-names-city/org-view-geo-names-city.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OrgViewGeoNamesCityComponent = /** @class */ (function () {
        function OrgViewGeoNamesCityComponent() {
            this.appearance = 'outline';
            this.desc = undefined;
            this.value = undefined;
            this._geonames_admin1 = [];
            this._geonames_admin2 = [];
            this._nuts_level1 = [];
            this._nuts_level2 = [];
            this._nuts_level3 = [];
        }
        /**
         * @return {?}
         */
        OrgViewGeoNamesCityComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.value) {
                if (this.value.geonames_admin1)
                    this._createValueAsArray(this.value.geonames_admin1, this._geonames_admin1);
                if (this.value.geonames_admin2)
                    this._createValueAsArray(this.value.geonames_admin2, this._geonames_admin2);
                if (this.value.nuts_level1)
                    this._createValueAsArray(this.value.nuts_level1, this._nuts_level1);
                if (this.value.nuts_level2)
                    this._createValueAsArray(this.value.nuts_level2, this._nuts_level2);
                if (this.value.nuts_level3)
                    this._createValueAsArray(this.value.nuts_level3, this._nuts_level3);
            }
        };
        /**
         * @private
         * @param {?} objFromCopy
         * @param {?} arrayToFill
         * @return {?}
         */
        OrgViewGeoNamesCityComponent.prototype._createValueAsArray = /**
         * @private
         * @param {?} objFromCopy
         * @param {?} arrayToFill
         * @return {?}
         */
        function (objFromCopy, arrayToFill) {
            Object.keys(objFromCopy).forEach((/**
             * @param {?} key
             * @return {?}
             */
            function (key) {
                arrayToFill.push({
                    'property': key,
                    'value': objFromCopy[key]
                });
            }));
        };
        Object.defineProperty(OrgViewGeoNamesCityComponent.prototype, "getGeoNamesAdmin1", {
            /**
             * Returns the `geonames_admin1` value as an array for using by `StaticTableComponent`.
             */
            get: /**
             * Returns the `geonames_admin1` value as an array for using by `StaticTableComponent`.
             * @return {?}
             */
            function () {
                return this._geonames_admin1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrgViewGeoNamesCityComponent.prototype, "getGeoNamesAdmin2", {
            /**
             * Returns the `geonames_admin2` value as an array for using by `StaticTableComponent`.
             */
            get: /**
             * Returns the `geonames_admin2` value as an array for using by `StaticTableComponent`.
             * @return {?}
             */
            function () {
                return this._geonames_admin2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrgViewGeoNamesCityComponent.prototype, "getNutsLevel1", {
            /**
             * Returns the `nuts_level1` value as an array for using by `StaticTableComponent`.
             */
            get: /**
             * Returns the `nuts_level1` value as an array for using by `StaticTableComponent`.
             * @return {?}
             */
            function () {
                return this._nuts_level1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrgViewGeoNamesCityComponent.prototype, "getNutsLevel2", {
            /**
             * Returns the `nuts_level2` value as an array for using by `StaticTableComponent`.
             */
            get: /**
             * Returns the `nuts_level2` value as an array for using by `StaticTableComponent`.
             * @return {?}
             */
            function () {
                return this._nuts_level2;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrgViewGeoNamesCityComponent.prototype, "getNutsLevel3", {
            /**
             * Returns the `nuts_level3` value as an array for using by `StaticTableComponent`.
             */
            get: /**
             * Returns the `nuts_level3` value as an array for using by `StaticTableComponent`.
             * @return {?}
             */
            function () {
                return this._nuts_level3;
            },
            enumerable: true,
            configurable: true
        });
        OrgViewGeoNamesCityComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-org-view-geo-names-city',
                        template: "\n<!-- TODO: En dependencia del valor de `appearance`, se aplican las clases CSS para lograr la apariencia deseada. \n     Actualmente, `appearance = 'outline'` es el \u00FAnico que est\u00E1 hecho. -->\n<fieldset class=\"static-geo-names-city-fieldset\">\n    <legend class=\"static-geo-names-city-fieldset-legend\">{{ desc }}</legend>\n\n    <static-text *ngIf=\"value.id\" [desc]=\"'Identificador GeoNames'\" [value]=\"value.id\"></static-text>\n    <static-text *ngIf=\"value.city\" [desc]=\"'Nombre de la ciudad'\" [value]=\"value.city\"></static-text>\n    <static-table *ngIf=\"value.geonames_admin1\" [desc]=\"'geonames_admin1'\" [value]=\"getGeoNamesAdmin1\"\n        [columnsObjectProperty]=\"['property', 'value']\"\n        [columnsHeaderText]=\"['Property', 'Value']\"\n    >\n    </static-table>\n    <static-table *ngIf=\"value.geonames_admin2\" [desc]=\"'geonames_admin2'\" [value]=\"getGeoNamesAdmin2\"\n        [columnsObjectProperty]=\"['property', 'value']\"\n        [columnsHeaderText]=\"['Property', 'Value']\"\n    >\n    </static-table>\n    <static-table *ngIf=\"value.nuts_level1\" [desc]=\"'nuts_level1'\" [value]=\"getNutsLevel1\"\n        [columnsObjectProperty]=\"['property', 'value']\"\n        [columnsHeaderText]=\"['Property', 'Value']\"\n    >\n    </static-table>\n    <static-table *ngIf=\"value.nuts_level2\" [desc]=\"'nuts_level2'\" [value]=\"getNutsLevel2\"\n        [columnsObjectProperty]=\"['property', 'value']\"\n        [columnsHeaderText]=\"['Property', 'Value']\"\n    >\n    </static-table>\n    <static-table *ngIf=\"value.nuts_level3\" [desc]=\"'nuts_level3'\" [value]=\"getNutsLevel3\"\n        [columnsObjectProperty]=\"['property', 'value']\"\n        [columnsHeaderText]=\"['Property', 'Value']\"\n    >\n    </static-table>\n</fieldset>\n",
                        styles: [".static-geo-names-city-fieldset{width:auto;margin:-4px 0 24px;padding:14px 10px;cursor:default;background-color:#fff;border:1px solid rgba(0,0,0,.12);border-radius:4px}.static-geo-names-city-fieldset-legend{padding:0 4px;background-color:#fff;color:rgba(0,0,0,.6);font-size:10px}"]
                    }] }
        ];
        /** @nocollapse */
        OrgViewGeoNamesCityComponent.ctorParameters = function () { return []; };
        OrgViewGeoNamesCityComponent.propDecorators = {
            appearance: [{ type: core.Input }],
            desc: [{ type: core.Input }],
            value: [{ type: core.Input }]
        };
        return OrgViewGeoNamesCityComponent;
    }());
    if (false) {
        /**
         * The control's appearance.
         * By default, its value is `'outline'`.
         * @type {?}
         */
        OrgViewGeoNamesCityComponent.prototype.appearance;
        /**
         * The control's description.
         * By default, its value is `undefined` and it is not showed.
         * @type {?}
         */
        OrgViewGeoNamesCityComponent.prototype.desc;
        /**
         * A linked GeoNames data associated with the organization.
         * By default, its value is `undefined`.
         * @type {?}
         */
        OrgViewGeoNamesCityComponent.prototype.value;
        /**
         * @type {?}
         * @private
         */
        OrgViewGeoNamesCityComponent.prototype._geonames_admin1;
        /**
         * @type {?}
         * @private
         */
        OrgViewGeoNamesCityComponent.prototype._geonames_admin2;
        /**
         * @type {?}
         * @private
         */
        OrgViewGeoNamesCityComponent.prototype._nuts_level1;
        /**
         * @type {?}
         * @private
         */
        OrgViewGeoNamesCityComponent.prototype._nuts_level2;
        /**
         * @type {?}
         * @private
         */
        OrgViewGeoNamesCityComponent.prototype._nuts_level3;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/org-view/org-view-relationship/org-view-relationship.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OrgViewRelationshipComponent = /** @class */ (function () {
        function OrgViewRelationshipComponent() {
            this.value = undefined;
        }
        OrgViewRelationshipComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-org-view-relationship',
                        template: "\n<a mat-button *ngFor=\"let link of value.links\"\n    class=\"aling-left\"\n    color=\"warn\"\n    [routerLink]=\"link.url\"\n    [ngStyle]=\"{'line-height': 'initial', 'padding': '10px 16px'}\"\n>\n    {{ link.name }}\n</a>\n\n<!--\n  href=\"{{ link.url }}\"\n\n  <static-table *ngIf=\"value.identifiers && value.identifiers.length\" [desc]=\"'Identificadores de la organizaci\u00F3n'\" [value]=\"value.identifiers\"\n    [columnsObjectProperty]=\"['idtype', 'value']\"\n    [columnsHeaderText]=\"['Identifier type', 'Identifier value']\"\n>\n</static-table>\n<static-text *ngIf=\"value.type\" [desc]=\"'Tipo de la relaci\u00F3n'\" [value]=\"value.type\"></static-text>\n<static-text *ngIf=\"value.label\" [desc]=\"'Nombre de la organizaci\u00F3n relacionada'\" [value]=\"value.label\"></static-text> -->\n",
                        styles: [".aling-left{text-align:left;white-space:normal!important}"]
                    }] }
        ];
        /** @nocollapse */
        OrgViewRelationshipComponent.ctorParameters = function () { return []; };
        OrgViewRelationshipComponent.propDecorators = {
            value: [{ type: core.Input }]
        };
        return OrgViewRelationshipComponent;
    }());
    if (false) {
        /**
         * A relationship the organization has to other.
         * By default, its value is `undefined`.
         * @type {?}
         */
        OrgViewRelationshipComponent.prototype.value;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/org-edit/org-edit.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OrgEditComponent = /** @class */ (function () {
        function OrgEditComponent(_router, _activatedRoute) {
            this._router = _router;
            this._activatedRoute = _activatedRoute;
            this.operationAction = OperationAction;
            this.panelFormSection = new forms.FormGroup({}, []);
        }
        /**
         * @return {?}
         */
        OrgEditComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            // /* Gets the `Organization` data. */
            // this._activatedRoute.data.subscribe(
            // 	(data: { 'org': Organization }) => {
            // 		this.org = data.org;
            // 		console.log('Data got for editing: ', this.org);
            // 	}
            // )
            /* Creates the panel's content. */
            this.panelContent = this._initPanelContent();
        };
        /**
         * Returns the panel's content.
         */
        /**
         * Returns the panel's content.
         * @private
         * @return {?}
         */
        OrgEditComponent.prototype._initPanelContent = /**
         * Returns the panel's content.
         * @private
         * @return {?}
         */
        function () {
            return {
                'formSection': this.panelFormSection,
                'name': 'panel',
                'label': 'Edita la organización seleccionada',
                'controlType': ContainerPanelComponent,
                'description': '',
                'iconName': undefined /*''*/,
                'formSectionContent': [
                    {
                        'formControl': InputTextComponent.getFormControlByDefault(),
                        'name': 'name',
                        'label': 'Name typically used to refer to the institute',
                        'controlType': InputTextComponent,
                        'required': true,
                        'value': this.org.name,
                        'width': '100%',
                        'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'Name typically used to refer to the institute'
                    },
                    {
                        'formControl': InputSelectComponent.getFormControlByDefault(),
                        'name': 'status',
                        'label': 'Institute status',
                        'controlType': InputSelectComponent,
                        'required': true,
                        'value': this.org.status,
                        'width': '45%',
                        'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'Institute status',
                        'selectOptions': [
                            {
                                'label': 'Active',
                                'value': 'active'
                            },
                            {
                                'label': 'Closed',
                                'value': 'closed'
                            },
                            {
                                'label': 'Unknown',
                                'value': 'unknown'
                            }
                        ],
                        'multiple': false
                    },
                    this._initIdentifiersContent('Organization Identifiers, different from GRID mapping', this.org.identifiers, false),
                    {
                        'formControl': InputSelectComponent.getFormControlByDefault(),
                        'name': 'aliases',
                        'label': 'The list of other names the institute is known as',
                        'controlType': InputSelectComponent,
                        'required': false,
                        'value': this.org.aliases,
                        'width': '100%',
                        'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'The list of other names the institute is known as',
                        /* The 'selectOptions' field is gotten from the 'value' field. */
                        'multiple': true
                    },
                    {
                        'formControl': InputSelectComponent.getFormControlByDefault(),
                        'name': 'acronyms',
                        'label': 'The of short acronyms the institute is known as (e.g. MRC for the Medical Research Council)',
                        'controlType': InputSelectComponent,
                        'required': false,
                        'value': this.org.acronyms,
                        'width': '100%',
                        'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'The list of short acronyms the institute is known as (e.g. MRC for the Medical Research Council)',
                        /* The 'selectOptions' field is gotten from the 'value' field. */
                        'multiple': true
                    },
                    {
                        'formControl': InputSelectComponent.getFormControlByDefault(),
                        'name': 'types',
                        'label': 'The list of types describing the institute',
                        'controlType': InputSelectComponent,
                        'required': true,
                        'value': this.org.types,
                        'width': '100%',
                        'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'The list of types describing the institute',
                        'selectOptions': [
                            {
                                'label': 'Education',
                                'value': 'Education'
                            },
                            {
                                'label': 'Healthcare',
                                'value': 'Healthcare'
                            },
                            {
                                'label': 'Company',
                                'value': 'Company'
                            },
                            {
                                'label': 'Archive',
                                'value': 'Archive'
                            },
                            {
                                'label': 'Nonprofit',
                                'value': 'Nonprofit'
                            },
                            {
                                'label': 'Government',
                                'value': 'Government'
                            },
                            {
                                'label': 'Facility',
                                'value': 'Facility'
                            },
                            {
                                'label': 'Other',
                                'value': 'Other'
                            }
                        ],
                        'multiple': true
                    },
                    {
                        'formControl': InputUrlComponent.getFormControlByDefault(),
                        'name': 'wikipedia_url',
                        'label': 'URL of the wikipedia page for the institute',
                        'controlType': InputUrlComponent,
                        'required': false,
                        'value': this.org.wikipedia_url,
                        'width': '45%',
                        'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'URL of the wikipedia page for the institute'
                    },
                    {
                        'formControl': InputEmailComponent.getFormControlByDefault(),
                        'name': 'email_address',
                        'label': 'Contact email address for the institute',
                        'controlType': InputEmailComponent,
                        'required': true,
                        'value': this.org.email_address,
                        'width': '45%',
                        'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'Contact email address for the institute'
                    },
                    {
                        'formControl': InputSelectComponent.getFormControlByDefault(),
                        'name': 'ip_addresses',
                        'label': 'The list of IP addresses known to belong to the institute',
                        'controlType': InputSelectComponent,
                        'required': false,
                        'value': this.org.ip_addresses,
                        'width': '100%',
                        'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'The list of IP addresses known to belong to the institute',
                        /* The 'selectOptions' field is gotten from the 'value' field. */
                        'multiple': true
                    },
                    {
                        'formControl': InputTextComponent.getFormControlByDefault(),
                        'name': 'established',
                        'label': 'Year the institute opened, CE',
                        'controlType': InputTextComponent,
                        'required': true,
                        'value': this.org.established,
                        'width': '45%',
                        'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'Year the institute opened, CE'
                    },
                    {
                        'formControl': InputSelectComponent.getFormControlByDefault(),
                        'name': 'links',
                        'label': 'The list of URLs linking to things like the homepage for the institute',
                        'controlType': InputSelectComponent,
                        'required': false,
                        'value': this.org.links,
                        'width': '100%',
                        'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'The list of URLs linking to things like the homepage for the institute',
                        /* The 'selectOptions' field is gotten from the 'value' field. */
                        'multiple': true
                    },
                    this._initLabelsSimpleContent(),
                    this._initRelationshipsSimpleContent(),
                    this._initAddressesSimpleContent()
                ]
            };
        };
        /**
         * Returns the identifiers' content.
         */
        /**
         * Returns the identifiers' content.
         * @private
         * @param {?} description
         * @param {?} value
         * @param {?} isDynamic
         * @return {?}
         */
        OrgEditComponent.prototype._initIdentifiersContent = /**
         * Returns the identifiers' content.
         * @private
         * @param {?} description
         * @param {?} value
         * @param {?} isDynamic
         * @return {?}
         */
        function (description, value, isDynamic) {
            /** @type {?} */
            var result = {
                'formSection': ContainerSimpleComponent.getFormArrayByDefault(),
                'name': 'identifiers',
                'label': description,
                'controlType': ContainerSimpleComponent,
                'value': value,
                'width': '100%',
                //            'appearance': TextInputAppearance.outline,
                'required': true,
                'ariaLabel': description,
                'isDynamic': isDynamic,
                'formSectionContent': [
                    {
                        'formSection': ContainerSimpleComponent.getFormGroupByDefault(),
                        'name': '0',
                        'label': 'Organization Identifier',
                        'controlType': ContainerSimpleComponent,
                        'width': '100%',
                        //            'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'Organization Identifier',
                        'formSectionContent': [
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'idtype',
                                'label': 'Identifier type',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '50%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Identifier type',
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'value',
                                'label': 'Identifier value',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '50%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Identifier value',
                                'startHint': new HintValue(HintPosition.start, 'Un identificador es una secuencia de letras')
                            }
                        ]
                    }
                ]
            };
            if (isDynamic) {
                result.formSectionContent[0].formSectionContent.push(this._initRemoveButtonContent('Remove identifier'));
            }
            return result;
        };
        /**
         * Returns the labels' content.
         */
        /**
         * Returns the labels' content.
         * @private
         * @return {?}
         */
        OrgEditComponent.prototype._initLabelsSimpleContent = /**
         * Returns the labels' content.
         * @private
         * @return {?}
         */
        function () {
            return {
                'formSection': ContainerSimpleComponent.getFormArrayByDefault(),
                'name': 'labels',
                'label': 'Name of the institute in different languages',
                'controlType': ContainerSimpleComponent,
                'value': this.org.labels,
                'width': '100%',
                //            'appearance': TextInputAppearance.outline,
                'ariaLabel': 'Name of the institute in different languages',
                'formSectionContent': [
                    {
                        'formSection': ContainerSimpleComponent.getFormGroupByDefault(),
                        'name': '0',
                        'label': 'Label diff lang',
                        'controlType': ContainerSimpleComponent,
                        'width': '100%',
                        //            'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'Label diff lang',
                        'formSectionContent': [
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'label',
                                'label': 'Institute name in a language variant',
                                'controlType': InputTextComponent,
                                'required': true,
                                /* 'value': undefined, this is the default behavior. */
                                'width': '70%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Institute name in a language variant'
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'iso639',
                                'label': 'ISO-639-1 language code',
                                'controlType': InputTextComponent,
                                'required': true,
                                /* 'value': undefined, this is the default behavior. */
                                'width': '30%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'ISO-639-1 language code',
                            },
                            this._initRemoveButtonContent('Remove label')
                        ]
                    }
                ]
            };
        };
        /**
         * Returns the relationships' content.
         */
        /**
         * Returns the relationships' content.
         * @private
         * @return {?}
         */
        OrgEditComponent.prototype._initRelationshipsSimpleContent = /**
         * Returns the relationships' content.
         * @private
         * @return {?}
         */
        function () {
            return {
                'formSection': ContainerSimpleComponent.getFormArrayByDefault(),
                'name': 'relationships',
                'label': 'Any relationships the institute has to others',
                'controlType': ContainerSimpleComponent,
                'value': this.org.relationships,
                'required': false,
                /* The `relationships` can be empty by definition. */
                'width': '100%',
                //            'appearance': TextInputAppearance.outline,
                'ariaLabel': 'Any relationships the institute has to others',
                'formSectionContent': [
                    {
                        'formSection': ContainerSimpleComponent.getFormGroupByDefault(),
                        'name': '0',
                        'label': 'Relationship',
                        'controlType': ContainerSimpleComponent,
                        'width': '100%',
                        //            'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'Relationship',
                        'formSectionContent': [
                            /* This `identifiers` value is `undefined` because it is inside a `FormArray`. */
                            this._initIdentifiersContent('Related Organization Identifiers', undefined, true),
                            {
                                'formControl': InputSelectComponent.getFormControlByDefault(),
                                'name': 'type',
                                'label': 'Relationship type',
                                'controlType': InputSelectComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Relationship type',
                                'selectOptions': [
                                    {
                                        'label': 'Parent',
                                        'value': 'parent'
                                    },
                                    {
                                        'label': 'Related',
                                        'value': 'related'
                                    },
                                    {
                                        'label': 'Child',
                                        'value': 'child'
                                    }
                                ],
                                'multiple': false
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'label',
                                'label': 'Name of the related institute',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Name of the related institute'
                            },
                            this._initRemoveButtonContent('Remove relationship')
                        ]
                    }
                ]
            };
        };
        /**
         * Returns the addresses' content.
         */
        /**
         * Returns the addresses' content.
         * @private
         * @return {?}
         */
        OrgEditComponent.prototype._initAddressesSimpleContent = /**
         * Returns the addresses' content.
         * @private
         * @return {?}
         */
        function () {
            return {
                'formSection': ContainerSimpleComponent.getFormArrayByDefault(),
                'name': 'addresses',
                'label': 'An array of addresses associated with the institute',
                'controlType': ContainerSimpleComponent,
                'value': this.org.addresses,
                'required': true,
                /* The `addresses` can not be empty by definition. */
                'width': '100%',
                //            'appearance': TextInputAppearance.outline,
                'ariaLabel': 'An array of addresses associated with the institute',
                'formSectionContent': [
                    {
                        'formSection': ContainerSimpleComponent.getFormGroupByDefault(),
                        'name': '0',
                        'label': 'Address',
                        'controlType': ContainerSimpleComponent,
                        'width': '100%',
                        //            'appearance': TextInputAppearance.outline,
                        'ariaLabel': 'Address',
                        'formSectionContent': [
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'city',
                                'label': 'Name of the city',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Name of the city'
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'country',
                                'label': 'Name of the country',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Name of the country'
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'country_code',
                                'label': 'ISO 3166-1 alpha-2 code of the country',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'ISO 3166-1 alpha-2 code of the country'
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'lat',
                                'label': 'Latitute of the institute',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Latitute of the institute'
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'lng',
                                'label': 'Longitude of the institute',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Longitude of the institute'
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'line_1',
                                'label': 'First line of the address',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'First line of the address'
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'line_2',
                                'label': 'Second line of the address',
                                'controlType': InputTextComponent,
                                'required': false,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Second line of the address'
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'line_3',
                                'label': 'Third line of the address',
                                'controlType': InputTextComponent,
                                'required': false,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Third line of the address'
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'postcode',
                                'label': 'Postcode/zipcode',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Postcode/zipcode'
                            },
                            //TODO: Poner aquí el campo 'primary' de tipo 'boolean' (checkbox).
                            //This address identifies the main location
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'state',
                                'label': 'Name of the state/region',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'Name of the state/region'
                            },
                            {
                                'formControl': InputTextComponent.getFormControlByDefault(),
                                'name': 'state_code',
                                'label': 'ISO 3166-2 region code',
                                'controlType': InputTextComponent,
                                'required': true,
                                'width': '45%',
                                'appearance': TextInputAppearance.outline,
                                'ariaLabel': 'ISO 3166-2 region code'
                            },
                            //TODO: Poner el resto de los campos.
                            this._initRemoveButtonContent('Remove address')
                        ]
                    }
                ]
            };
        };
        /**
         * Returns the remove button's content.
         * @param tooltip The tooltip to show.
         */
        /**
         * Returns the remove button's content.
         * @private
         * @param {?} tooltip The tooltip to show.
         * @return {?}
         */
        OrgEditComponent.prototype._initRemoveButtonContent = /**
         * Returns the remove button's content.
         * @private
         * @param {?} tooltip The tooltip to show.
         * @return {?}
         */
        function (tooltip) {
            return {
                'name': 'remove',
                'label': 'Remove',
                'controlType': ActionButtonComponent,
                'width': '30%',
                // 'appearance': TextInputAppearance.outline,
                'ariaLabel': 'Remove',
                'icon': new IconValue(IconSource.external, ContentPosition.prefix, 'remove_circle'),
                'tooltip': new HintValue(HintPosition.start, tooltip),
                'click': (/**
                 * @param {?} sender
                 * @return {?}
                 */
                function (sender) {
                    sender.parentContainerControl.parentContainerControl.removeFromFormArray(+(sender.parentContainerControl.content.name));
                }),
                'isDisabled': (/**
                 * @param {?} sender
                 * @return {?}
                 */
                function (sender) {
                    return !(sender.parentContainerControl.parentContainerControl.canRemoveFromFormArray);
                })
            };
        };
        /**
         * Does the tasks for the operation action.
         * @param op The operation action.
         */
        /**
         * Does the tasks for the operation action.
         * @param {?} op The operation action.
         * @return {?}
         */
        OrgEditComponent.prototype.doOperationAction = /**
         * Does the tasks for the operation action.
         * @param {?} op The operation action.
         * @return {?}
         */
        function (op) {
            console.log('panelContent: ', this.panelContent);
            console.log('panelContent.parentFormSection: ', this.panelContent.parentFormSection);
            console.log('panelContent.formSection', this.panelContent.formSection);
            // console.log('addressesPanelFormSection', this.addressesPanelFormSection);
            // console.log('labelsSimpleFormSection', this.labelsSimpleFormSection);
            return;
            if (op == OperationAction.submit) {
                //TODO: Do the tasks for the submit action.
            }
            /* Currently, it does not do any task for the cancel action. */
            if (op != OperationAction.reset) {
                this._router.navigate(['../', { 'operation': op }]);
            }
        };
        Object.defineProperty(OrgEditComponent.prototype, "isResetActionDisabled", {
            /**
             * Returns true if the reset action is disabled; otherwise, false.
             */
            get: /**
             * Returns true if the reset action is disabled; otherwise, false.
             * @return {?}
             */
            function () {
                //TODO: Implement this.
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OrgEditComponent.prototype, "isSubmitActionDisabled", {
            /**
             * Returns true if the submit action is disabled; otherwise, false.
             */
            get: /**
             * Returns true if the submit action is disabled; otherwise, false.
             * @return {?}
             */
            function () {
                return this.panelFormSection.invalid;
            },
            enumerable: true,
            configurable: true
        });
        OrgEditComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-org-edit',
                        template: "\n<container-panel [content]=\"panelContent\"></container-panel>\n<!-- <test-container-control></test-container-control> -->\n\n<!-- <container-panel [content]=\"addressesPanelContent\"></container-panel> -->\n<!-- <br /> -->\n<!-- <container-simple [content]=\"labelsSimpleContent\"></container-simple> -->\n\n<div [ngStyle]=\"{'margin': '1em 0 1em 0'}\">\n    <button mat-raised-button color=\"primary\" (click)=\"doOperationAction(operationAction.cancel)\">Cancel</button>\n    <button mat-raised-button color=\"primary\" [disabled]=\"isResetActionDisabled\" (click)=\"doOperationAction(operationAction.reset)\">Reset</button>\n    <button mat-raised-button color=\"primary\" (click)=\"doOperationAction(operationAction.delete)\">Delete</button>\n    <button mat-raised-button color=\"primary\" [disabled]=\"isSubmitActionDisabled\" (click)=\"doOperationAction(operationAction.submit)\">Submit</button>\n</div>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        OrgEditComponent.ctorParameters = function () { return [
            { type: router.Router },
            { type: router.ActivatedRoute }
        ]; };
        OrgEditComponent.propDecorators = {
            org: [{ type: core.Input }]
        };
        return OrgEditComponent;
    }());
    if (false) {
        /**
         * Represents the `OperationAction` enum for internal use.
         * @type {?}
         */
        OrgEditComponent.prototype.operationAction;
        /**
         * Represents the current organization.
         * @type {?}
         */
        OrgEditComponent.prototype.org;
        /**
         * Tracks the value and validity state of the internal child controls that contains this component.
         * @type {?}
         * @private
         */
        OrgEditComponent.prototype.panelFormSection;
        /**
         * Contains the panel's content.
         * @type {?}
         */
        OrgEditComponent.prototype.panelContent;
        /**
         * @type {?}
         * @private
         */
        OrgEditComponent.prototype._router;
        /**
         * @type {?}
         * @private
         */
        OrgEditComponent.prototype._activatedRoute;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/org-add/org-add.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OrgAddComponent = /** @class */ (function () {
        function OrgAddComponent(_router, _activatedRoute) {
            this._router = _router;
            this._activatedRoute = _activatedRoute;
            this.operationAction = OperationAction;
            this.panelFormSection = new forms.FormGroup({}, []);
        }
        /**
         * @return {?}
         */
        OrgAddComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Creates the panel's content. */
            this.panelContent = this._initPanelContent();
        };
        /**
         * Returns the panel's content.
         */
        /**
         * Returns the panel's content.
         * @private
         * @return {?}
         */
        OrgAddComponent.prototype._initPanelContent = /**
         * Returns the panel's content.
         * @private
         * @return {?}
         */
        function () {
            return {
                /* The 'label' and 'title' fields have the same values, but they are different fields with different functionalities. */
                'formSection': this.panelFormSection,
                'name': 'panel',
                'label': 'Adiciona una nueva organización',
                'controlType': ContainerPanelComponent,
                'title': 'Adiciona una nueva organización',
                'description': '',
                'iconName': undefined /*''*/,
                'formSectionContent': [
                //TODO: Poner los campos.'
                ]
            };
        };
        /**
         * Does the tasks for the operation action.
         * @param op The operation action.
         */
        /**
         * Does the tasks for the operation action.
         * @param {?} op The operation action.
         * @return {?}
         */
        OrgAddComponent.prototype.doOperationAction = /**
         * Does the tasks for the operation action.
         * @param {?} op The operation action.
         * @return {?}
         */
        function (op) {
            if (op == OperationAction.submit) {
                //TODO: Do the tasks for the submit action. 
            }
            /* Currently, it does not do any task for the cancel action. */
            this._router.navigate(['../', { 'operation': op }]);
        };
        Object.defineProperty(OrgAddComponent.prototype, "isSubmitActionDisabled", {
            /**
             * Returns true if the submit action is disabled; otherwise, false.
             */
            get: /**
             * Returns true if the submit action is disabled; otherwise, false.
             * @return {?}
             */
            function () {
                return this.panelFormSection.invalid;
            },
            enumerable: true,
            configurable: true
        });
        OrgAddComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-org-add',
                        template: "\n<container-panel [content]=\"panelContent\"></container-panel>\n\n<h3>Add the rest of <span [ngStyle]=\"{ 'color': 'red' }\">readonly</span> content to `panelContent.formSectionContent` field!</h3>\n\n<div [ngStyle]=\"{'margin': '1em 0 1em 0'}\">\n    <button mat-raised-button color=\"primary\" (click)=\"doOperationAction(operationAction.cancel)\">Cancel</button>\n    <button mat-raised-button color=\"primary\" [disabled]=\"isSubmitActionDisabled\" (click)=\"doOperationAction(operationAction.submit)\">Submit</button>\n</div>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        OrgAddComponent.ctorParameters = function () { return [
            { type: router.Router },
            { type: router.ActivatedRoute }
        ]; };
        return OrgAddComponent;
    }());
    if (false) {
        /**
         * Represents the `OperationAction` enum for internal use.
         * @type {?}
         */
        OrgAddComponent.prototype.operationAction;
        /**
         * Represents the organization for adding.
         * @type {?}
         */
        OrgAddComponent.prototype.org;
        /**
         * Tracks the value and validity state of the internal child controls that contains this component.
         * @type {?}
         * @private
         */
        OrgAddComponent.prototype.panelFormSection;
        /**
         * Contains the panel's content.
         * @type {?}
         */
        OrgAddComponent.prototype.panelContent;
        /**
         * @type {?}
         * @private
         */
        OrgAddComponent.prototype._router;
        /**
         * @type {?}
         * @private
         */
        OrgAddComponent.prototype._activatedRoute;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/org-search/org-search.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OrgSearchComponent = /** @class */ (function () {
        function OrgSearchComponent(_orgService) {
            this._orgService = _orgService;
            /**
             * Input `orgCtrl` is a FormControl
             */
            this.orgCtrl = new forms.FormControl();
            this.filteredOrg = new HitList();
            this.params = new http.HttpParams();
            this.placeholder = "Escriba al menos 3 letras";
            this.label = "Busque una organización";
            this.appearance = "outline";
            /**
             * Input `cleaning` is a boolen, if true then clean the search
             */
            this.cleaning = false;
            this.selectedOrg = new core.EventEmitter();
            this.toSearch = 0;
        }
        /**
         * @return {?}
         */
        OrgSearchComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var e_1, _a;
            var _this = this;
            this.params = this.params.set('size', '10');
            this.params = this.params.set('page', '1');
            if (this.orgFilter != undefined) {
                if (util.isArray(this.orgFilter)) {
                    /** @type {?} */
                    var filter_array = ((/** @type {?} */ (this.orgFilter)));
                    try {
                        for (var filter_array_1 = __values(filter_array), filter_array_1_1 = filter_array_1.next(); !filter_array_1_1.done; filter_array_1_1 = filter_array_1.next()) {
                            var filter = filter_array_1_1.value;
                            this.params = this.params.set(filter.type, filter.value);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (filter_array_1_1 && !filter_array_1_1.done && (_a = filter_array_1.return)) _a.call(filter_array_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                }
                else {
                    /** @type {?} */
                    var type = ((/** @type {?} */ (this.orgFilter))).type;
                    /** @type {?} */
                    var value = ((/** @type {?} */ (this.orgFilter))).value;
                    this.params = this.params.set(type, value);
                }
            }
            this.orgCtrl.valueChanges
                .subscribe({
                next: (/**
                 * @param {?} orgValueChanges
                 * @return {?}
                 */
                function (orgValueChanges) {
                    _this.toSearch++;
                    // this condition check if the param is a `string` an if at least write 3 letters
                    if (_this.toSearch > 3 && typeof orgValueChanges === 'string') {
                        _this.toSearch = 0;
                        _this.params = _this.params.set('q', orgValueChanges);
                        _this._orgService.getOrganizations(_this.params).subscribe({
                            next: (/**
                             * @param {?} response
                             * @return {?}
                             */
                            function (response) {
                                _this.filteredOrg = response.hits;
                            })
                        });
                    }
                    else if (typeof orgValueChanges === 'object') {
                        _this.toSearch = 0;
                        _this.selectedOrg.emit(orgValueChanges);
                        if (_this.cleaning) {
                            _this.orgCtrl.setValue('');
                        }
                    }
                })
            });
        };
        /* This function return the organization name
         * @param org the Organization object
         */
        /* This function return the organization name
           * @param org the Organization object
           */
        /**
         * @param {?=} org
         * @return {?}
         */
        OrgSearchComponent.prototype.displayFn = /* This function return the organization name
           * @param org the Organization object
           */
        /**
         * @param {?=} org
         * @return {?}
         */
        function (org) {
            return org ? org.name : undefined;
        };
        OrgSearchComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-org-search',
                        template: "\n<mat-form-field [ngStyle]=\"{'width': '100%'}\" appearance=\"{{appearance}}\">\n    <mat-label>{{label}}</mat-label>\n    <input matInput placeholder=\"{{placeholder}}\" aria-label=\"Buscar\" [matAutocomplete]=\"auto\" [formControl]=\"orgCtrl\">\n\n    <mat-autocomplete #auto=\"matAutocomplete\" [displayWith]=\"displayFn\">\n\n        <mat-option *ngFor=\"let org of filteredOrg.hits\" [value]=\"org.metadata\">\n            <span title=\"{{org.metadata.name}}\">{{org.metadata.name}}</span>\n        </mat-option>\n\n    </mat-autocomplete>\n  </mat-form-field>",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        OrgSearchComponent.ctorParameters = function () { return [
            { type: OrganizationServiceNoAuth }
        ]; };
        OrgSearchComponent.propDecorators = {
            orgCtrl: [{ type: core.Input }],
            orgFilter: [{ type: core.Input }],
            placeholder: [{ type: core.Input }],
            label: [{ type: core.Input }],
            appearance: [{ type: core.Input }],
            cleaning: [{ type: core.Input }],
            selectedOrg: [{ type: core.Output }]
        };
        return OrgSearchComponent;
    }());
    if (false) {
        /**
         * Input `orgCtrl` is a FormControl
         * @type {?}
         */
        OrgSearchComponent.prototype.orgCtrl;
        /** @type {?} */
        OrgSearchComponent.prototype.filteredOrg;
        /** @type {?} */
        OrgSearchComponent.prototype.params;
        /**
         * Input `orgFilter` is a dict with `type` and `value` to filter the organizations,
         * \@Example { type: 'country' , value: 'Cuba" }
         * @type {?}
         */
        OrgSearchComponent.prototype.orgFilter;
        /** @type {?} */
        OrgSearchComponent.prototype.placeholder;
        /** @type {?} */
        OrgSearchComponent.prototype.label;
        /** @type {?} */
        OrgSearchComponent.prototype.appearance;
        /**
         * Input `cleaning` is a boolen, if true then clean the search
         * @type {?}
         */
        OrgSearchComponent.prototype.cleaning;
        /** @type {?} */
        OrgSearchComponent.prototype.selectedOrg;
        /** @type {?} */
        OrgSearchComponent.prototype.toSearch;
        /**
         * @type {?}
         * @private
         */
        OrgSearchComponent.prototype._orgService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/org-table-edit/org-table-edit.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OrgTableEditComponent = /** @class */ (function () {
        function OrgTableEditComponent(_router, _activatedRoute, _organizationService) {
            this._router = _router;
            this._activatedRoute = _activatedRoute;
            this._organizationService = _organizationService;
        }
        /**
         * @return {?}
         */
        OrgTableEditComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            /* Sets an initial search value. */
            //this._inputSearch.formControl.setValue('cl');
            /***************************/
            // this.searchContent = this._initSearchContent();
            this.tableContent = this._initTableContent();
            /***************************/
            // this._tableControl.page.subscribe((value) => console.log('page', value));
        };
        /**
         * @private
         * @return {?}
         */
        OrgTableEditComponent.prototype._initSearchContent = /**
         * @private
         * @return {?}
         */
        function () {
            return {
                'formControl': InputTextComponent.getFormControlByDefault(),
                'width': '65%',
                'label': 'Write a text to search',
                'controlType': InputTextComponent,
                'textAlign': TextAlign.left,
                'ariaLabel': 'Search',
                'appearance': TextInputAppearance.outline,
                'prefixIcon': new IconValue(IconSource.external, ContentPosition.prefix, 'search'),
                'startHint': new HintValue(HintPosition.start, 'Searches when typing stops.')
            };
        };
        /**
         * @private
         * @return {?}
         */
        OrgTableEditComponent.prototype._initTableContent = /**
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                'columnsObjectProperty': ['name', 'status', 'email_address'],
                //'columnsObjectProperty': ['id', 'name', 'registrationDate'],
                'columnsHeaderText': ['Nombre', 'Estatus', 'Dirección de Correo'],
                //'columnsHeaderText': ['id', 'name', 'registrationDate'],
                'columnsWidth': ['60%', '22%', '18%'],
                'columnContentWrap': [CellContentWrap.ellipsis, CellContentWrap.ellipsis, CellContentWrap.responsible],
                'createCssClassesForRow': (/**
                 * @param {?} rowData
                 * @return {?}
                 */
                function (rowData) {
                    return {
                        //'new-release': rowData['email_address'],
                        'selected-row': (rowData[_this.tableContent.propertyNameToIdentify]) == _this._tableControl.selectedRow
                    };
                }),
                'propertyNameToIdentify': 'id',
                //'propertyNameToIdentify': 'id',
                // 'filter': {
                //     'search': this._inputSearch,
                //     //'registration': undefined
                // },
                'sort': {
                    'active': 'id',
                    'direction': SortDirection.desc
                },
                'pageIndex': 0,
                'pageSize': 5,
                'pageSizeOptions': [5, 10, 20, 50],
                //'hidePageSize': true,
                'showFirstLastButtons': true,
                'endpoint': this._getMySources.bind(this),
                //'endpoint': this._userService.page.bind(this._userService),
                actions: [
                    { icon: 'visibility', route: 'ver', tooltip: 'Ver' },
                    { icon: 'edit', route: 'editar', tooltip: 'Editar' },
                ]
            };
        };
        /**
         * @private
         * @param {?} pageRequest
         * @return {?}
         */
        OrgTableEditComponent.prototype._getMySources = /**
         * @private
         * @param {?} pageRequest
         * @return {?}
         */
        function (pageRequest) {
            return this._organizationService.get(ENDPOINT_APIS.organizations, []).pipe(operators.map((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                console.log('Organizations Response: ', response);
                // if (response && response.status != ResponseStatus.ERROR){
                return {
                    'data': response,
                    'totalData': response.length,
                    'pageIndex': pageRequest.paginator.pageIndex,
                    'pageSize': pageRequest.paginator.pageSize
                };
                // }
            })));
        };
        /**
         * @return {?}
         */
        OrgTableEditComponent.prototype.doOperation = /**
         * @return {?}
         */
        function () {
            this._router.navigate(['organizaciones/adicionar']);
        };
        OrgTableEditComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-org-table-edit',
                        template: "\n<!-- <container-simple [content]=\"identifiersContent\"></container-simple> -->\n<!-- <container-simple [content]=\"identifiersContent_Complex\"></container-simple> -->\n\n<div [ngStyle]=\"{'margin': '1em 0 1em 0'}\">\n    <button mat-raised-button color=\"primary\" (click)=\"doOperation()\">Add Organization</button>\n    <!-- <input-text #input_search [content]=\"searchContent\"></input-text> -->\n  </div>\n  \n  <!-- <toco-table></toco-table> -->\n  <toco-table [content]=\"tableContent\"></toco-table>\n  ",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        OrgTableEditComponent.ctorParameters = function () { return [
            { type: router.Router },
            { type: router.ActivatedRoute },
            { type: OrganizationService }
        ]; };
        OrgTableEditComponent.propDecorators = {
            _tableControl: [{ type: core.ViewChild, args: [TableComponent, { static: true },] }]
        };
        return OrgTableEditComponent;
    }());
    if (false) {
        /**
         * Contains the content of the identifiers section.
         * @type {?}
         */
        OrgTableEditComponent.prototype.identifiersContent;
        /**
         * The sources list.
         * Use this field to initialize only; to change value use the `_tableControl` field.
         * @type {?}
         */
        OrgTableEditComponent.prototype.tableContent;
        /**
         * @type {?}
         * @private
         */
        OrgTableEditComponent.prototype._tableControl;
        /**
         * @type {?}
         * @private
         */
        OrgTableEditComponent.prototype._router;
        /**
         * @type {?}
         * @private
         */
        OrgTableEditComponent.prototype._activatedRoute;
        /**
         * @type {?}
         * @private
         */
        OrgTableEditComponent.prototype._organizationService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/org-tree-viewer/org-tree-viewer.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Flat node with expandable and level information
     */
    var   /**
     * Flat node with expandable and level information
     */
    OrganizationFlatNode = /** @class */ (function () {
        function OrganizationFlatNode(item, parent, level, expandable, isLoading) {
            if (level === void 0) { level = 1; }
            if (expandable === void 0) { expandable = false; }
            if (isLoading === void 0) { isLoading = false; }
            this.item = item;
            this.parent = parent;
            this.level = level;
            this.expandable = expandable;
            this.isLoading = isLoading;
        }
        return OrganizationFlatNode;
    }());
    if (false) {
        /** @type {?} */
        OrganizationFlatNode.prototype.item;
        /** @type {?} */
        OrganizationFlatNode.prototype.parent;
        /** @type {?} */
        OrganizationFlatNode.prototype.level;
        /** @type {?} */
        OrganizationFlatNode.prototype.expandable;
        /** @type {?} */
        OrganizationFlatNode.prototype.isLoading;
    }
    var OrganizationDataSource = /** @class */ (function () {
        function OrganizationDataSource(_treeControl, orgService) {
            this._treeControl = _treeControl;
            this.orgService = orgService;
            this.dataChange = new rxjs.BehaviorSubject([]);
            this.orgRelationshipType = null;
        }
        Object.defineProperty(OrganizationDataSource.prototype, "data", {
            get: /**
             * @return {?}
             */
            function () { return this.dataChange.value; },
            set: /**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                this._treeControl.dataNodes = value;
                this.dataChange.next(value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {?} collectionViewer
         * @return {?}
         */
        OrganizationDataSource.prototype.connect = /**
         * @param {?} collectionViewer
         * @return {?}
         */
        function (collectionViewer) {
            var _this = this;
            this._treeControl.expansionModel.onChange.subscribe((/**
             * @param {?} change
             * @return {?}
             */
            function (change) {
                if (((/** @type {?} */ (change))).added ||
                    ((/** @type {?} */ (change))).removed) {
                    _this.handleTreeControl((/** @type {?} */ (change)));
                }
            }));
            return rxjs.merge(collectionViewer.viewChange, this.dataChange).pipe(operators.map((/**
             * @return {?}
             */
            function () { return _this.data; })));
        };
        /** Handle expand/collapse behaviors */
        /**
         * Handle expand/collapse behaviors
         * @param {?} change
         * @return {?}
         */
        OrganizationDataSource.prototype.handleTreeControl = /**
         * Handle expand/collapse behaviors
         * @param {?} change
         * @return {?}
         */
        function (change) {
            var _this = this;
            if (change.added) {
                change.added.forEach((/**
                 * @param {?} node
                 * @return {?}
                 */
                function (node) { return _this.toggleNode(node, true); }));
            }
            if (change.removed) {
                change.removed.slice().reverse().forEach((/**
                 * @param {?} node
                 * @return {?}
                 */
                function (node) { return _this.toggleNode(node, false); }));
            }
        };
        /**
         * Toggle the node, remove from display list
         */
        /**
         * Toggle the node, remove from display list
         * @param {?} node
         * @param {?} expand
         * @return {?}
         */
        OrganizationDataSource.prototype.toggleNode = /**
         * Toggle the node, remove from display list
         * @param {?} node
         * @param {?} expand
         * @return {?}
         */
        function (node, expand) {
            var _this = this;
            node.isLoading = true;
            /** @type {?} */
            var index = this.data.indexOf(node);
            if (node.item.metadata.relationships.length <= 0 || index < 0) { // If no children, or cannot find the node, no op
                return;
            }
            if (expand) {
                this.orgService.getOrganizationRelationships(node.item.metadata.id, this.orgRelationshipType).subscribe((/**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    var _a;
                    /** @type {?} */
                    var nodes = response.map((/**
                     * @param {?} org
                     * @return {?}
                     */
                    function (org) {
                        return new OrganizationFlatNode(org, node, node.level + 1, org.metadata.relationships.length > 0);
                    }));
                    (_a = _this.data).splice.apply(_a, __spread([index + 1, 0], nodes));
                    _this.dataChange.next(_this.data);
                    node.isLoading = false;
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) { }), (/**
                 * @return {?}
                 */
                function () { }));
            }
            else {
                /** @type {?} */
                var count = 0;
                for (var i = index + 1; i < this.data.length
                    && this.data[i].level > node.level; i++) {
                    count++;
                }
                this.data.splice(index + 1, count);
                this.dataChange.next(this.data);
                node.isLoading = false;
            }
        };
        OrganizationDataSource.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        OrganizationDataSource.ctorParameters = function () { return [
            { type: tree$1.FlatTreeControl },
            { type: OrganizationServiceNoAuth }
        ]; };
        return OrganizationDataSource;
    }());
    if (false) {
        /** @type {?} */
        OrganizationDataSource.prototype.dataChange;
        /** @type {?} */
        OrganizationDataSource.prototype.orgRelationshipType;
        /**
         * @type {?}
         * @private
         */
        OrganizationDataSource.prototype._treeControl;
        /**
         * @type {?}
         * @private
         */
        OrganizationDataSource.prototype.orgService;
    }
    var OrgTreeViewerComponent = /** @class */ (function () {
        function OrgTreeViewerComponent(orgService) {
            this.orgService = orgService;
            this.organizations = new Array();
            this.orgRelationshipType = null;
            this.iconAction = 'visibility';
            this.labelAction = '';
            this.ngStyle = null;
            this.action = new core.EventEmitter();
            this.error = false;
            this.getLevel = (/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return node.level; });
            this.isExpandable = (/**
             * @param {?} node
             * @return {?}
             */
            function (node) { return node.expandable; });
            this.hasChild = (/**
             * @param {?} _
             * @param {?} _nodeData
             * @return {?}
             */
            function (_, _nodeData) { return _nodeData.expandable; });
            this.treeControl = new tree$1.FlatTreeControl(this.getLevel, this.isExpandable);
            this.dataSource = new OrganizationDataSource(this.treeControl, orgService);
        }
        /**
         * @return {?}
         */
        OrgTreeViewerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.dataSource.orgRelationshipType = this.orgRelationshipType;
            this.dataSource.data = this.organizations.map((/**
             * @param {?} org
             * @return {?}
             */
            function (org) {
                return new OrganizationFlatNode(org, null, 1, org.metadata.relationships.length > 0);
            }));
        };
        /**
         * @param {?} org
         * @return {?}
         */
        OrgTreeViewerComponent.prototype.emitAction = /**
         * @param {?} org
         * @return {?}
         */
        function (org) {
            this.action.emit(org);
        };
        OrgTreeViewerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-org-tree-viewer',
                        template: "<mat-tree\n  [dataSource]=\"dataSource\"\n  [treeControl]=\"treeControl\"\n  [ngStyle]=\"ngStyle\"\n>\n  <mat-tree-node\n    *matTreeNodeDef=\"let node\"\n    matTreeNodePadding\n  >\n    <button mat-icon-button disabled></button>\n    {{ node.item.metadata.name }}\n    <button\n        mat-icon-button\n        matTooltip=\"labelAction\"\n        (click)=\"emitAction(node)\"\n      >\n        <mat-icon>{{iconAction}}</mat-icon>\n      </button>\n  </mat-tree-node>\n  <mat-tree-node\n    *matTreeNodeDef=\"let node; when: hasChild\"\n    matTreeNodePadding\n  >\n    <button\n      mat-icon-button\n      [attr.aria-label]=\"'toggle ' + node.filename\"\n      matTreeNodeToggle\n    >\n      <mat-icon class=\"mat-icon-rtl-mirror\">\n        {{ treeControl.isExpanded(node) ? \"expand_more\" : \"chevron_right\" }}\n      </mat-icon>\n    </button>\n    {{ node.item.metadata.name }}\n    <button\n        mat-icon-button\n        matTooltip=\"labelAction\"\n        (click)=\"emitAction(node)\"\n      >\n        <mat-icon>{{iconAction}}</mat-icon>\n      </button>\n    <mat-progress-bar\n      *ngIf=\"node.isLoading\"\n      mode=\"indeterminate\"\n      class=\"example-tree-progress-bar\"\n    ></mat-progress-bar>\n  </mat-tree-node>\n</mat-tree>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        OrgTreeViewerComponent.ctorParameters = function () { return [
            { type: OrganizationServiceNoAuth }
        ]; };
        OrgTreeViewerComponent.propDecorators = {
            organizations: [{ type: core.Input }],
            orgRelationshipType: [{ type: core.Input }],
            iconAction: [{ type: core.Input }],
            labelAction: [{ type: core.Input }],
            ngStyle: [{ type: core.Input }],
            action: [{ type: core.Output }]
        };
        return OrgTreeViewerComponent;
    }());
    if (false) {
        /** @type {?} */
        OrgTreeViewerComponent.prototype.organizations;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.orgRelationshipType;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.iconAction;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.labelAction;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.ngStyle;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.action;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.error;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.treeControl;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.dataSource;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.getLevel;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.isExpandable;
        /** @type {?} */
        OrgTreeViewerComponent.prototype.hasChild;
        /**
         * @type {?}
         * @private
         */
        OrgTreeViewerComponent.prototype.orgService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/organizations.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var OrganizationsModule = /** @class */ (function () {
        function OrganizationsModule() {
        }
        OrganizationsModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            OrgViewComponent,
                            OrgViewAccordionComponent,
                            OrgViewAddressComponent,
                            OrgViewGeoNamesCityComponent,
                            OrgViewRelationshipComponent,
                            OrgEditComponent,
                            OrgAddComponent,
                            OrgSearchComponent,
                            OrgTableEditComponent,
                            // OrgFooterComponent,
                            OrgTreeViewerComponent
                        ],
                        imports: [
                            // SharedModule,
                            flexLayout.FlexLayoutModule,
                            common.CommonModule,
                            forms.FormsModule,
                            http.HttpClientModule,
                            AngularMaterialModule,
                            forms.ReactiveFormsModule,
                            router.RouterModule,
                            TocoFormsModule,
                            material.MatAutocompleteModule,
                            material.MatChipsModule,
                            StaticsModule
                        ],
                        exports: [
                            OrgViewComponent,
                            OrgEditComponent,
                            OrgAddComponent,
                            OrgSearchComponent,
                            // OrgFooterComponent,
                            OrgTreeViewerComponent
                        ],
                        schemas: [
                            core.CUSTOM_ELEMENTS_SCHEMA
                        ]
                    },] }
        ];
        return OrganizationsModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/organizations/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/person/person/person.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PersonComponent = /** @class */ (function () {
        function PersonComponent() {
        }
        /**
         * @return {?}
         */
        PersonComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () { };
        PersonComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-person',
                        template: "<p>\n  person works!\n</p>\n<!-- <router-outlet></router-outlet> -->",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        PersonComponent.ctorParameters = function () { return []; };
        return PersonComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/person/person-view/person-view.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PersonViewComponent = /** @class */ (function () {
        function PersonViewComponent() {
        }
        /**
         * @return {?}
         */
        PersonViewComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () { };
        PersonViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-person-view',
                        template: "<p>\n  person-view works!\n</p>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        PersonViewComponent.ctorParameters = function () { return []; };
        return PersonViewComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/person/person.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var PersonModule = /** @class */ (function () {
        function PersonModule() {
        }
        PersonModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            PersonComponent,
                            PersonViewComponent
                        ],
                        imports: [
                            SharedModule
                        ],
                        exports: [
                            PersonComponent,
                            PersonViewComponent
                        ]
                    },] }
        ];
        return PersonModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/person/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/search/record/record.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RecordComponent = /** @class */ (function () {
        function RecordComponent() {
        }
        /**
         * @return {?}
         */
        RecordComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
        };
        RecordComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-record',
                        template: "<mat-card *ngIf=\"record\">\n    <mat-card-header>\n        <mat-card-title>{{record.title}}</mat-card-title>\n        <mat-card-subtitle>{{record.source_repo}}</mat-card-subtitle>\n    </mat-card-header>\n\n    <mat-card-content>\n        {{record.description}}\n    </mat-card-content>\n    <mat-card-actions>\n        <mat-chip-list>\n            <mat-chip *ngFor=\"let keyword of record.keywords\">{{keyword}}</mat-chip>\n        </mat-chip-list>\n    </mat-card-actions>\n</mat-card>\n<mat-divider>\n</mat-divider>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        RecordComponent.ctorParameters = function () { return []; };
        RecordComponent.propDecorators = {
            record: [{ type: core.Input }]
        };
        return RecordComponent;
    }());
    if (false) {
        /** @type {?} */
        RecordComponent.prototype.record;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/search/aggregations/aggregations.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * @record
     */
    function AggregationsSelection() { }
    var AggregationsComponent = /** @class */ (function () {
        function AggregationsComponent() {
            this.aggregations = {};
            /**
             *
             * {
             *  'country': ['Cuba','Peru'],
             *  'state': ['New York']
             *  ...
             * }
             *
             * in the aggregation country, buckets 'Cuba' and 'Peru' are selected
             * in the aggregation state, bucket 'New York' is selected
             *
             */
            this.selectedAggr = {};
            this.keySelect = new core.EventEmitter();
            this.keys = [];
        }
        /**
         * @return {?}
         */
        AggregationsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            for (var key in this.aggregations) {
                if (this.aggregations.hasOwnProperty(key)) {
                    /** @type {?} */
                    var element = this.aggregations[key];
                    //this.keys.push(key);
                    this.keys.push({ "key": key, "sp": this._translate(key) });
                }
            }
            console.log("cola");
            console.log(this.keys);
        };
        //aqui se agregan los casos que puedan haber en las agregaciones para q salgan siempre en español
        //aqui se agregan los casos que puedan haber en las agregaciones para q salgan siempre en español
        /**
         * @private
         * @param {?} key
         * @return {?}
         */
        AggregationsComponent.prototype._translate = 
        //aqui se agregan los casos que puedan haber en las agregaciones para q salgan siempre en español
        /**
         * @private
         * @param {?} key
         * @return {?}
         */
        function (key) {
            switch (key) {
                case "status": {
                    return "Estado";
                }
                case "country": {
                    return "País";
                }
                case "state": {
                    return "Provincia (Estado)";
                }
                case "types": {
                    return "Tipos";
                }
                default: {
                    return this.aggregations[key]['label'];
                }
            }
            return key;
        };
        /**
         * @param {?} aggrKey
         * @param {?} bucket
         * @return {?}
         */
        AggregationsComponent.prototype.isSelected = /**
         * @param {?} aggrKey
         * @param {?} bucket
         * @return {?}
         */
        function (aggrKey, bucket) {
            if (this.selectedAggr.hasOwnProperty(aggrKey)) {
                for (var index = 0; index < this.selectedAggr[aggrKey].length; index++) {
                    /** @type {?} */
                    var element = this.selectedAggr[aggrKey][index];
                    if (element == bucket.key) {
                        // console.log(this.selectedAggr, aggrKey, bucket);
                        // console.log("--------------------");
                        return true;
                    }
                }
                // this.selectedAggr[aggrKey].forEach((key) => {
                //   if (key == bucket.key) {
                //     console.log(this.selectedAggr, aggrKey, bucket);
                //     console.log("--------------------");
                //     return true;
                //   }
                // });
            }
            // console.log("FALSE");
            return false;
        };
        /**
         * @param {?} aggrKey
         * @param {?} bucket
         * @return {?}
         */
        AggregationsComponent.prototype.selectionChange = /**
         * @param {?} aggrKey
         * @param {?} bucket
         * @return {?}
         */
        function (aggrKey, bucket) {
            if (!this.selectedAggr.hasOwnProperty(aggrKey)) {
                this.selectedAggr[aggrKey] = [];
            }
            if (this.selectedAggr[aggrKey].find((/**
             * @param {?} k
             * @return {?}
             */
            function (k) { return k == bucket.key; }))) {
                this.selectedAggr[aggrKey] = this.selectedAggr[aggrKey].filter((/**
                 * @param {?} k
                 * @return {?}
                 */
                function (k) { return k != bucket.key; }));
            }
            else {
                this.selectedAggr[aggrKey].push(bucket.key);
            }
            this.keySelect.emit(this.selectedAggr);
        };
        AggregationsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-search-aggregations",
                        template: "<ng-container *ngFor=\"let key of keys\">\n  <mat-card *ngIf=\"aggregations[key.key].buckets.length != 0\" class=\"m-1\">\n    <mat-card-header>\n      <mat-card-title class=\"text-capitalize\">{{ key.sp }} </mat-card-title>\n    </mat-card-header>\n    <mat-card-content fxLayout=\"column\">\n      <mat-checkbox\n        *ngFor=\"let bucket of aggregations[key.key].buckets\"\n        [checked]=\"isSelected(key.key, bucket)\"\n        (change)=\"selectionChange(key.key, bucket)\"\n        class=\"text-capitalize\"\n      >\n        {{ bucket.key }} ({{ bucket.doc_count }})\n      </mat-checkbox>\n    </mat-card-content>\n  </mat-card>\n</ng-container>\n",
                        styles: [".m-1{margin:1em}.text-capitalize{text-transform:capitalize!important}"]
                    }] }
        ];
        /** @nocollapse */
        AggregationsComponent.ctorParameters = function () { return []; };
        AggregationsComponent.propDecorators = {
            aggregations: [{ type: core.Input }],
            selectedAggr: [{ type: core.Input }],
            keySelect: [{ type: core.Output }]
        };
        return AggregationsComponent;
    }());
    if (false) {
        /** @type {?} */
        AggregationsComponent.prototype.aggregations;
        /**
         *
         * {
         *  'country': ['Cuba','Peru'],
         *  'state': ['New York']
         *  ...
         * }
         *
         * in the aggregation country, buckets 'Cuba' and 'Peru' are selected
         * in the aggregation state, bucket 'New York' is selected
         *
         * @type {?}
         */
        AggregationsComponent.prototype.selectedAggr;
        /** @type {?} */
        AggregationsComponent.prototype.keySelect;
        /** @type {?} */
        AggregationsComponent.prototype.keys;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/search/query-input/query-input.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Represents a component used to search a query.
     *
     * In order to use this component with the correct i18n, you must include
     * (in your i18n translate files that are in the folder `assets\i18n`)
     * a translation key of name "TOCO_SEARCH_QUERY_INPUT" that contains
     * an object as value with the translation needed by this component.
     *
     * In the case of `es.json` file, you must include the following translation key:
     * "TOCO_SEARCH_QUERY_INPUT": {
     * "INPUT_SEARCH_LABEL": "Buscar",
     * "INPUT_SEARCH_PLACEHOLDER": "Escriba un criterio y presione Enter",
     * "BUTTON_SEARCH": "Buscar"
     * }
     *
     * In the case of `en.json` file, you must include the following translation key:
     * "TOCO_SEARCH_QUERY_INPUT": {
     * "INPUT_SEARCH_LABEL": "Search",
     * "INPUT_SEARCH_PLACEHOLDER": "Write a phrase and press Enter",
     * "BUTTON_SEARCH": "Search"
     * }
     *
     * If you have another language, then you have another `*.json` file,
     * and you must include the "TOCO_SEARCH_QUERY_INPUT" translation key with the correct translation values.
     */
    var QueryInputComponent = /** @class */ (function () {
        function QueryInputComponent() {
            this.query = "";
            this.minWordCount = 3;
            this.appearance = 'outline';
            this.inputColor = '';
            this.buttonColor = 'primary';
            this.showButton = true;
            this.width = 100;
            this.queryChange = new core.EventEmitter();
            this.queryCtrl = new forms.FormControl();
        }
        /**
         * @return {?}
         */
        QueryInputComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            // this.queryCtrl.valueChanges
            // .subscribe({
            //   next: (queryValueChanges) => {
            //     // this condition check if the param is a `string` an if at least write 3 letters
            //     if (typeof queryValueChanges === 'string' && (queryValueChanges.length >= this.minWordCount)) {
            //       this.queryChange.emit(queryValueChanges);
            //     }
            //   }
            // })
        };
        /**
         * @return {?}
         */
        QueryInputComponent.prototype.riseQuery = /**
         * @return {?}
         */
        function () {
            this.queryChange.emit(this.queryCtrl.value ? this.queryCtrl.value : '');
        };
        QueryInputComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-search-query-input',
                        template: "<div fxLayout=\"row\" [ngStyle]=\"{'align-items': 'center', 'width.%': width }\">\n    \n    <mat-form-field *ngIf=\"appearance == 'outline';else templateMatFormField\" appearance=\"{{appearance}}\" [color]=\"inputColor\" class=\"query-input\" [ngStyle]=\"{'width.%': 100 }\">\n        <mat-label>{{ 'TOCO_SEARCH_QUERY_INPUT.INPUT_SEARCH_LABEL' | translate }}</mat-label>\n        <input matInput placeholder=\"{{ 'TOCO_SEARCH_QUERY_INPUT.INPUT_SEARCH_PLACEHOLDER' | translate }}\" type=\"search\" [value]=\"query\" [formControl]=\"queryCtrl\" (keyup.enter)= \"riseQuery()\">\n    </mat-form-field>\n    \n    <ng-template #templateMatFormField>\n        <mat-form-field [ngStyle]=\"{'width.%': width }\">\n            <mat-label>{{ 'TOCO_SEARCH_QUERY_INPUT.INPUT_SEARCH_LABEL' | translate }}</mat-label>\n            <input matInput placeholder=\"{{ 'TOCO_SEARCH_QUERY_INPUT.INPUT_SEARCH_PLACEHOLDER' | translate }}\" type=\"search\" [value]=\"query\" [formControl]=\"queryCtrl\" (keyup.enter)= \"riseQuery()\">\n        </mat-form-field>\n    </ng-template>\n    \n    <button mat-raised-button *ngIf=\"showButton && appearance == 'outline'\" (click)=\"riseQuery()\" color=\"{{buttonColor}}\" [ngStyle]=\"{'height': '59.5px', 'margin-left': '1em'}\">{{ 'TOCO_SEARCH_QUERY_INPUT.BUTTON_SEARCH' | translate }}</button>\n    <button mat-raised-button *ngIf=\"showButton && appearance != 'outline'\" (click)=\"riseQuery()\" color=\"{{buttonColor}}\" [ngStyle]=\"{'margin-left': '1em'}\">{{ 'TOCO_SEARCH_QUERY_INPUT.BUTTON_SEARCH' | translate }}</button>\n\n</div>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        QueryInputComponent.ctorParameters = function () { return []; };
        QueryInputComponent.propDecorators = {
            query: [{ type: core.Input }],
            minWordCount: [{ type: core.Input }],
            appearance: [{ type: core.Input }],
            inputColor: [{ type: core.Input }],
            buttonColor: [{ type: core.Input }],
            showButton: [{ type: core.Input }],
            width: [{ type: core.Input }],
            queryChange: [{ type: core.Output }]
        };
        return QueryInputComponent;
    }());
    if (false) {
        /** @type {?} */
        QueryInputComponent.prototype.query;
        /** @type {?} */
        QueryInputComponent.prototype.minWordCount;
        /** @type {?} */
        QueryInputComponent.prototype.appearance;
        /** @type {?} */
        QueryInputComponent.prototype.inputColor;
        /** @type {?} */
        QueryInputComponent.prototype.buttonColor;
        /** @type {?} */
        QueryInputComponent.prototype.showButton;
        /** @type {?} */
        QueryInputComponent.prototype.width;
        /** @type {?} */
        QueryInputComponent.prototype.queryChange;
        /** @type {?} */
        QueryInputComponent.prototype.queryCtrl;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/search/record-list/record-list.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var RecordListComponent = /** @class */ (function () {
        function RecordListComponent() {
        }
        /**
         * @return {?}
         */
        RecordListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            console.log(this.hitList);
        };
        RecordListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-record-list',
                        template: "\n<div *ngIf=\"hitList\">\n    <div *ngFor=\"let hit of hitList.hits\">\n        <toco-record [record]=\"hit.metadata\"></toco-record>\n    </div>\n\n</div>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        RecordListComponent.ctorParameters = function () { return []; };
        RecordListComponent.propDecorators = {
            hitList: [{ type: core.Input }]
        };
        return RecordListComponent;
    }());
    if (false) {
        /** @type {?} */
        RecordListComponent.prototype.hitList;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/search/search.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SearchModule = /** @class */ (function () {
        function SearchModule() {
        }
        SearchModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            RecordComponent,
                            AggregationsComponent,
                            QueryInputComponent,
                            RecordListComponent
                        ],
                        imports: [
                            common.CommonModule,
                            SharedModule,
                            forms.ReactiveFormsModule,
                            core$2.TranslateModule,
                            SharedModule
                        ],
                        exports: [
                            RecordComponent,
                            AggregationsComponent,
                            QueryInputComponent,
                            RecordListComponent
                        ]
                    },] }
        ];
        return SearchModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/search/search-utils.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {string} */
    var QueryParamKey = {
        /**
         * The query param for the current language.
         */
        lang: "lang",
        /**
         * The query param for the page size.
         */
        size: "size",
        /**
         * The query param for the page index.
         */
        page: "page",
        /**
         * The query param for the query.
         */
        q: "q",
        /**
         * The query param for the aggregations selection.
         */
        aggrsSel: "aggrsSel",
    };

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/search/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/journal-view/journal-view.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /** @enum {number} */
    var JournalDataType = {
        /** is used by default, `Journal` have not that type of data. */
        default: 0,
        title: 1,
        subtitle: 2,
        shortname: 3,
        issnP: 4,
        issnE: 5,
        issnL: 6,
        rnpsP: 7,
        rnpsE: 21,
        url: 8,
        email: 9,
        logo: 10,
        purpose: 11,
        start_year: 12,
        end_year: 13,
        frequency: 14,
        seriadas_cubanas: 15,
        facebook: 16,
        twitter: 17,
        linkedin: 18,
        description: 19,
        term: 20,
        oaiurl: 22,
    };
    JournalDataType[JournalDataType.default] = 'default';
    JournalDataType[JournalDataType.title] = 'title';
    JournalDataType[JournalDataType.subtitle] = 'subtitle';
    JournalDataType[JournalDataType.shortname] = 'shortname';
    JournalDataType[JournalDataType.issnP] = 'issnP';
    JournalDataType[JournalDataType.issnE] = 'issnE';
    JournalDataType[JournalDataType.issnL] = 'issnL';
    JournalDataType[JournalDataType.rnpsP] = 'rnpsP';
    JournalDataType[JournalDataType.rnpsE] = 'rnpsE';
    JournalDataType[JournalDataType.url] = 'url';
    JournalDataType[JournalDataType.email] = 'email';
    JournalDataType[JournalDataType.logo] = 'logo';
    JournalDataType[JournalDataType.purpose] = 'purpose';
    JournalDataType[JournalDataType.start_year] = 'start_year';
    JournalDataType[JournalDataType.end_year] = 'end_year';
    JournalDataType[JournalDataType.frequency] = 'frequency';
    JournalDataType[JournalDataType.seriadas_cubanas] = 'seriadas_cubanas';
    JournalDataType[JournalDataType.facebook] = 'facebook';
    JournalDataType[JournalDataType.twitter] = 'twitter';
    JournalDataType[JournalDataType.linkedin] = 'linkedin';
    JournalDataType[JournalDataType.description] = 'description';
    JournalDataType[JournalDataType.term] = 'term';
    JournalDataType[JournalDataType.oaiurl] = 'oaiurl';
    var JournalViewComponent = /** @class */ (function () {
        function JournalViewComponent(metadata, env, _snackBar, dialog) {
            this.metadata = metadata;
            this.env = env;
            this._snackBar = _snackBar;
            this.dialog = dialog;
            this.topMainOrganization = null;
            /**
             * ************* auxiliary variables ******************
             */
            this.panelOpenState = false;
            this.defaultLogo = this.env.sceibaHost + 'static/favicon.ico';
            /**
             * Inmutables data types of Journal
             */
            this.journalDataType = JournalDataType;
            /**
             * version.is_current = true
             */
            // public currentJournal: JournalVersion;
            this.showVersions = false;
            this.editVersion = false;
        }
        /**
         * @return {?}
         */
        JournalViewComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.isDisabledNavigatePrevious = true;
            this.isDisabledNavigateNext = false;
            this.vocabularies = VocabulariesInmutableNames;
            // guardar la cantidad total de versiones
            this.lengthVersion = this.versions.length;
            // guardar la posicion de la version donde este la actual
            this.selectedVersion = this.getSelectedJournalPosition();
            this.SelectJournalVersion();
            this.metadata.setStandardMeta("Revista Científica " + this.editingJournal.data.title, this.editingJournal.data.description, "");
            // if (this.versions){
            //   this.versions.forEach((journalVersion: JournalVersion, index: number) => {
            //     // check if has versions to view and return that position
            //     if (journalVersion.is_current) {
            //         this.currentJournal = new JournalVersion();
            //         this.currentJournal.deepcopy(journalVersion);
            //     }
            //   });
            // }
        };
        /**
         * Changes the selected position to the next one if possible
         */
        /**
         * Changes the selected position to the next one if possible
         * @return {?}
         */
        JournalViewComponent.prototype.nextVersion = /**
         * Changes the selected position to the next one if possible
         * @return {?}
         */
        function () {
            if (this.selectedVersion < this.lengthVersion - 1) {
                this.isDisabledNavigateNext = false;
                this.isDisabledNavigatePrevious = false;
                this.selectedVersion++;
                this.SelectJournalVersion();
            }
            else {
                this.isDisabledNavigateNext = true;
                /** @type {?} */
                var m = new MessageHandler(this._snackBar);
                m.showMessage(StatusCode.OK, 'No hay más versiones para mostrar');
            }
            if (this.selectedVersion == this.lengthVersion - 1) {
                this.isDisabledNavigateNext = true;
            }
        };
        /**
         * Changes the selected position to the before one if possible
         */
        /**
         * Changes the selected position to the before one if possible
         * @return {?}
         */
        JournalViewComponent.prototype.previousVersion = /**
         * Changes the selected position to the before one if possible
         * @return {?}
         */
        function () {
            if (this.selectedVersion > 0) {
                this.isDisabledNavigatePrevious = false;
                this.isDisabledNavigateNext = false;
                this.selectedVersion--;
                this.SelectJournalVersion();
            }
            else {
                this.isDisabledNavigatePrevious = true;
                /** @type {?} */
                var m = new MessageHandler(this._snackBar);
                m.showMessage(StatusCode.OK, 'No hay más versiones para mostrar');
            }
            if (this.selectedVersion == 0) {
                this.isDisabledNavigatePrevious = true;
            }
        };
        /**
         * Selects the selected journal as a JournalVersion
         */
        /**
         * Selects the selected journal as a JournalVersion
         * @return {?}
         */
        JournalViewComponent.prototype.SelectJournalVersion = /**
         * Selects the selected journal as a JournalVersion
         * @return {?}
         */
        function () {
            if (this.versions.length >= 0 &&
                this.selectedVersion >= 0 &&
                this.selectedVersion < this.versions.length) {
                // load the selected journal
                /** @type {?} */
                var version = new JournalVersion();
                version.deepcopy(this.versions[this.selectedVersion]);
                this.selectedJournal = version;
                // load if was viewed
                // this.selectedJournalChecked = this.selectedJournal.reviewed;
            }
        };
        /**
         * Returns the position of the unseen version of the journal as JournalVersion
         */
        /**
         * Returns the position of the unseen version of the journal as JournalVersion
         * @private
         * @return {?}
         */
        JournalViewComponent.prototype.getSelectedJournalPosition = /**
         * Returns the position of the unseen version of the journal as JournalVersion
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var count = 0;
            this.versions.forEach((/**
             * @param {?} journalVersion
             * @param {?} index
             * @return {?}
             */
            function (journalVersion, index) {
                // check if has versions to view and return that position
                if (journalVersion.reviewed != null && journalVersion.reviewed) {
                    count = index;
                    return count;
                }
            }));
            return count;
        };
        /**
         * @param {?} version
         * @return {?}
         */
        JournalViewComponent.prototype.sourceEditDone = /**
         * @param {?} version
         * @return {?}
         */
        function (version) {
            this.editVersion = false;
            console.log('AAaAAAAAAAAAAAAAAAAAA');
        };
        /**
         * @return {?}
         */
        JournalViewComponent.prototype.toogleShowVersions = /**
         * @return {?}
         */
        function () {
            this.showVersions = !this.showVersions;
            this.editVersion = false;
        };
        JournalViewComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-journal-view',
                        template: "<div *ngIf=\"editingJournal != undefined\" fxLayout=\"row wrap\" style=\"margin: 1em\">\n  <!-- navigate buttons -->\n  <mat-toolbar>\n    <mat-toolbar-row fxLayoutGap=\"1em\" fxLayoutAlign=\"end center\">\n      <!-- <mat-slide-toggle\n        (change)=\"editVersion = !editVersion\"\n        color=\"primary\"\n        matTooltip=\"Vista Edicion\"\n    >\n    </mat-slide-toggle>\n\n      <mat-slide-toggle\n        *ngIf=\"!editVersion\"\n        (change)=\"showVersions = !showVersions\"\n        color=\"accent\"\n        matTooltip=\"Ver Revisiones\"\n      >\n      </mat-slide-toggle> -->\n\n      <button\n        *ngIf=\"!editVersion\"\n        mat-icon-button\n        aria-label=\"Editar la Revisi\u00F3n actual\"\n        matTooltip=\"Editar la Revisi\u00F3n actual\"\n        (click)=\"editVersion = !editVersion\"\n      >\n        <mat-icon>edit</mat-icon>\n      </button>\n\n      <button\n        *ngIf=\"editVersion\"\n        mat-icon-button\n        aria-label=\"Vista Revisiones\"\n        matTooltip=\"Vista Revisiones\"\n        (click)=\"editVersion = !editVersion\"\n      >\n        <mat-icon>visibility</mat-icon>\n      </button>\n\n      <button\n        *ngIf=\"!editVersion && !showVersions\"\n        mat-icon-button\n        aria-label=\"Ver Revisiones\"\n        matTooltip=\"Ver Revisiones\"\n        (click)=\"showVersions = !showVersions\"\n      >\n        <mat-icon>history</mat-icon>\n      </button>\n\n      <button\n        *ngIf=\"!editVersion && showVersions\"\n        mat-icon-button\n        aria-label=\"Ocultar Revisiones\"\n        matTooltip=\"Ocultar Revisiones\"\n        (click)=\"showVersions = !showVersions\"\n      >\n        <mat-icon>history</mat-icon>\n      </button>\n\n      <div *ngIf=\"!editVersion && showVersions\">\n        <button\n          mat-icon-button\n          aria-label=\"Previous version\"\n          [disabled]=\"isDisabledNavigatePrevious\"\n          matTooltip=\"Revisi\u00F3n Anterior\"\n          (click)=\"previousVersion()\"\n        >\n          <mat-icon>navigate_before</mat-icon>\n        </button>\n        <button\n          mat-icon-button\n          aria-label=\"Next version\"\n          [disabled]=\"isDisabledNavigateNext\"\n          matTooltip=\"Revisi\u00F3n Siguiente\"\n          (click)=\"nextVersion()\"\n        >\n          <mat-icon>navigate_next</mat-icon>\n        </button>\n      </div>\n    </mat-toolbar-row>\n  </mat-toolbar>\n\n  <ng-container *ngIf=\"versions != undefined\">\n    <toco-journal-edit\n      *ngIf=\"editVersion\"\n      [journalVersion]=\"editingJournal\"\n      (journalEditDone)=\"sourceEditDone($event)\"\n      [showEditHeader]=\"false\"\n      [showFinalStep]=\"false\"\n      [topMainOrganization]=\"topMainOrganization\"\n    >\n    </toco-journal-edit>\n    <toco-journal-view-info\n      *ngIf=\"!editVersion && !showVersions\"\n      [journalVersion]=\"editingJournal\"\n      fxFlex=\"1 2 calc(15em + 20px)\"\n      style=\"margin: 0.5em\"\n    >\n    </toco-journal-view-info>\n    <ng-container *ngIf=\"!editVersion && showVersions\">\n      <toco-journal-view-info\n        #journalViewInfo\n        [journalVersion]=\"editingJournal\"\n        fxFlex=\"1 2 calc(15em + 20px)\"\n        style=\"margin: 0.5em\"\n      >\n      </toco-journal-view-info>\n\n      <toco-journal-view-version\n        #versionsPanel\n        [editingJournal]=\"editingJournal\"\n        [currentJournal]=\"selectedJournal\"\n        (editingJournalChange)=\"\n          journalViewInfo.editingJournalChange(editingJournal)\n        \"\n        fxFlex=\"1 2 calc(15em + 20px)\"\n        style=\"margin: 0.5em\"\n      ></toco-journal-view-version>\n    </ng-container>\n  </ng-container>\n\n  <mat-card *ngIf=\"versions == undefined\" style=\"margin: 1em\">\n    <mat-card-content>\n      <h1>Este componente necesita las revisiones de la revista.</h1>\n    </mat-card-content>\n  </mat-card>\n</div>\n\n<mat-card *ngIf=\"editingJournal == undefined\" style=\"margin: 1em\">\n  <mat-card-content>\n    <h1>No se encontr\u00F3 la informaci\u00F3n solicitada</h1>\n  </mat-card-content>\n</mat-card>\n",
                        styles: [".text-muted{color:rgba(0,0,0,.54);padding-left:.2em}.text-through{text-decoration:line-through}.notification-position{position:absolute;top:0;right:0}p{padding-top:.8em}.overlay{opacity:.4;background:#000;width:100%;height:100%;z-index:10;top:0;left:0;position:fixed}"]
                    }] }
        ];
        /** @nocollapse */
        JournalViewComponent.ctorParameters = function () { return [
            { type: MetadataService },
            { type: Environment },
            { type: material.MatSnackBar },
            { type: material.MatDialog }
        ]; };
        JournalViewComponent.propDecorators = {
            topMainOrganization: [{ type: core.Input }],
            editingJournal: [{ type: core.Input }],
            versions: [{ type: core.Input }]
        };
        return JournalViewComponent;
    }());
    if (false) {
        /** @type {?} */
        JournalViewComponent.prototype.topMainOrganization;
        /**
         * ************* auxiliary variables ******************
         * @type {?}
         */
        JournalViewComponent.prototype.panelOpenState;
        /** @type {?} */
        JournalViewComponent.prototype.defaultLogo;
        /**
         * Button roperty, is to enable or disable if there are not more versions
         * @type {?}
         */
        JournalViewComponent.prototype.isDisabledNavigatePrevious;
        /** @type {?} */
        JournalViewComponent.prototype.isDisabledNavigateNext;
        /** @type {?} */
        JournalViewComponent.prototype.vocabularies;
        /**
         * Represents a Journal Object, it is a type of Source.
         * Need the source.version array filled
         * @type {?}
         */
        JournalViewComponent.prototype.editingJournal;
        /** @type {?} */
        JournalViewComponent.prototype.versions;
        /**
         * the current version of a Journal, (a type of Source)
         * it is to compare and show changes between Journal and last version of journal
         * iteration over journal.versions
         * @type {?}
         */
        JournalViewComponent.prototype.selectedJournal;
        /**
         * Properties to move between versions
         * @type {?}
         * @private
         */
        JournalViewComponent.prototype.selectedVersion;
        /**
         * @type {?}
         * @private
         */
        JournalViewComponent.prototype.lengthVersion;
        /**
         * Inmutables data types of Journal
         * @type {?}
         */
        JournalViewComponent.prototype.journalDataType;
        /**
         * version.is_current = true
         * @type {?}
         */
        JournalViewComponent.prototype.showVersions;
        /** @type {?} */
        JournalViewComponent.prototype.editVersion;
        /**
         * @type {?}
         * @private
         */
        JournalViewComponent.prototype.metadata;
        /**
         * @type {?}
         * @private
         */
        JournalViewComponent.prototype.env;
        /**
         * @type {?}
         * @private
         */
        JournalViewComponent.prototype._snackBar;
        /** @type {?} */
        JournalViewComponent.prototype.dialog;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/source-edit/journal-edit/journal-edit.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var JournalEditComponent = /** @class */ (function () {
        function JournalEditComponent(metadata, sourceService, catalogService, taxonomyService, snackBar, formBuilder) {
            this.metadata = metadata;
            this.sourceService = sourceService;
            this.catalogService = catalogService;
            this.taxonomyService = taxonomyService;
            this.snackBar = snackBar;
            this.formBuilder = formBuilder;
            // TODO: Idea del componente:
            // trabajan internamente con un journal, si recibe null entonces es uno nuevo, si recibe un journal entonces es editar.
            // en ambos casos devuelve el journal editado, o sea el contenido, listo para hacer post en el backend.
            this.pageTitle = "";
            this.journalData = null;
            this.journalVersion = null;
            this.showEditHeader = false;
            this.description = "";
            this.topMainOrganization = null;
            this.showFinalStep = true;
            // journal identifiers variables for step 0
            this.identifiersPanel = null;
            // journal information variables for step 1
            this.informationPanel = null;
            // institutions: SourceClasification[] = [];
            // entityFormGroup: FormGroup;
            // indexes (databases), variables for step 3
            this.finalPanel = null;
            // TODO: Esto se puede hacer mejor, con un emiter alcanza
            this.journalEditDone = new core.EventEmitter();
            this.editCanceled = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        JournalEditComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.journalData = new JournalData();
            this.journalData.deepcopy(this.journalVersion.data);
            this.pageTitle = this.journalData.isNew
                ? "Nueva Revista"
                : "Editando: " + this.journalData.title;
            this.metadata.setStandardMeta(this.pageTitle, "", "");
            console.log("journal edit INIT");
            this.resetStepper();
            this.initStep2();
            this.initStep0Identifiers();
            this.initStep1();
            this.initStep3();
            this.initStepFinal();
        };
        /**
         * @return {?}
         */
        JournalEditComponent.prototype.resetStepper = /**
         * @return {?}
         */
        function () {
            this.identifiersPanel = null;
            this.identifiersFormGroup = null;
            this.informationPanel = null;
            this.informationFormGroup = null;
            this.informationSocialFormGroup = null;
            // this.organization = null;
            // this.organizationPanel = null;
            // this.institution = null;
            // this.institutionPanel = null;
            // this.entity = null;
            // this.entityPanel = null;
            this.organizationFormGroup = null;
            this.indexesFormGroup = null;
        };
        /**
         * @return {?}
         */
        JournalEditComponent.prototype.initStep0Identifiers = /**
         * @return {?}
         */
        function () {
            this.identifiersFormGroup = this.formBuilder.group({});
            this.identifiersPanel =
                {
                    name: 'identifiersPanel',
                    label: 'Identificadores',
                    controlType: ContainerPanelComponent,
                    description: "",
                    iconName: "",
                    formSection: this.identifiersFormGroup,
                    formSectionContent: [
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "issn_l",
                            label: "ISSN de Enlace",
                            type: FormFieldType.text,
                            controlType: InputTextComponent,
                            required: false,
                            startHint: new HintValue(HintPosition.start, "XXXX-XXXX"),
                            width: "23%",
                            value: this.journalData
                                ? this.journalData.getIdentifierValue(IdentifierSchemas.issn_l)
                                : "",
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "issn_p",
                            label: "ISSN Impreso",
                            type: FormFieldType.text,
                            controlType: InputTextComponent,
                            required: false,
                            startHint: new HintValue(HintPosition.start, "XXXX-XXXX"),
                            width: "23%",
                            value: this.journalData
                                ? this.journalData.getIdentifierValue(IdentifierSchemas.issn_p)
                                : "",
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "issn_e",
                            label: "ISSN Electrónico",
                            type: FormFieldType.text,
                            controlType: InputTextComponent,
                            required: false,
                            startHint: new HintValue(HintPosition.start, "XXXX-XXXX"),
                            width: "23%",
                            value: this.journalData
                                ? this.journalData.getIdentifierValue(IdentifierSchemas.issn_e)
                                : "",
                        },
                        {
                            formControl: InputRnpsComponent.getFormControlByDefault(),
                            name: "rnps_p",
                            label: "RNPS Impreso",
                            type: FormFieldType.rnps,
                            controlType: InputRnpsComponent,
                            required: true,
                            startHint: new HintValue(HintPosition.start, "XXXX."),
                            width: "23%",
                            value: this.journalData
                                ? this.journalData.getIdentifierValue(IdentifierSchemas.prnps)
                                : "",
                        },
                        {
                            formControl: InputRnpsComponent.getFormControlByDefault(),
                            name: "rnps_e",
                            label: "RNPS Electrónico",
                            type: FormFieldType.rnps,
                            controlType: InputRnpsComponent,
                            required: true,
                            startHint: new HintValue(HintPosition.start, "XXXX."),
                            width: "23%",
                            value: this.journalData
                                ? this.journalData.getIdentifierValue(IdentifierSchemas.ernps)
                                : "",
                        },
                    ],
                };
        };
        /**
         * @return {?}
         */
        JournalEditComponent.prototype.initStep1 = /**
         * @return {?}
         */
        function () {
            this.informationFormGroup = this.formBuilder.group({
                // 'description': descriptionControl,
                start_year: new forms.FormControl(""),
                end_year: new forms.FormControl(""),
            });
            this.informationSocialFormGroup = this.formBuilder.group({});
            this.informationPanel =
                {
                    name: 'informationPanel',
                    label: 'Datos de la Revista',
                    description: "",
                    iconName: "",
                    controlType: ContainerPanelComponent,
                    formSection: this.informationFormGroup,
                    formSectionContent: [
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "title",
                            label: "Título",
                            type: FormFieldType.text,
                            controlType: InputTextComponent,
                            required: true,
                            width: "100%",
                            value: this.journalData ? this.journalData.title : "",
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "subtitle",
                            label: "Subtítulo",
                            type: FormFieldType.text,
                            controlType: InputTextComponent,
                            required: false,
                            width: "30%",
                            startHint: new HintValue(HintPosition.start, ""),
                            value: this.journalData ? this.journalData.subtitle : "",
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "shortname",
                            label: "Título abreviado",
                            type: FormFieldType.text,
                            controlType: InputTextComponent,
                            required: false,
                            width: "30%",
                            startHint: new HintValue(HintPosition.start, ""),
                            value: this.journalData ? this.journalData.shortname : "",
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "source_type",
                            label: "Tipo de Revista",
                            type: FormFieldType.select_expr,
                            controlType: SelectComponent,
                            required: true,
                            width: "30%",
                            value: this.journalData ? this.journalData.source_type : "",
                            extraContent: {
                                multiple: false,
                                getOptions: (/**
                                 * @return {?}
                                 */
                                function () {
                                    return [
                                        {
                                            label: SourceTypes.JOURNAL.label,
                                            value: SourceTypes.JOURNAL.value,
                                        },
                                        {
                                            label: SourceTypes.STUDENT.label,
                                            value: SourceTypes.STUDENT.value,
                                        },
                                        {
                                            label: SourceTypes.POPULARIZATION.label,
                                            value: SourceTypes.POPULARIZATION.value,
                                        },
                                    ];
                                }),
                            },
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "description",
                            label: "Descripción",
                            type: FormFieldType.textarea,
                            controlType: TextareaComponent,
                            required: true,
                            width: "100%",
                            value: this.journalData ? this.journalData.description : "",
                        },
                        // {
                        //   name: 'purpose',
                        //   label: 'Propósito',
                        //   type: FormFieldType.textarea,
                        //   required: true,
                        //   width: '100%',
                        //   value: this.journalVersion ? this.journalVersion.purpose : ''
                        // },
                        {
                            formControl: InputUrlComponent.getFormControlByDefault(),
                            name: "url",
                            label: "URL",
                            type: FormFieldType.url,
                            controlType: InputUrlComponent,
                            required: true,
                            startHint: new HintValue(HintPosition.start, "Escriba una URL válida."),
                            width: "100%",
                            value: this.journalData
                                ? this.journalData.getIdentifierValue(IdentifierSchemas.url)
                                : "",
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "source_system",
                            label: "Tipo de Sistema que soporta la revista",
                            type: FormFieldType.select_expr,
                            controlType: SelectComponent,
                            required: false,
                            width: "35%",
                            value: this.journalData ? this.journalData.source_system : "",
                            extraContent: {
                                multiple: false,
                                getOptions: (/**
                                 * @return {?}
                                 */
                                function () {
                                    return [
                                        {
                                            label: SourceSystems.OJS.label,
                                            value: SourceSystems.OJS.value,
                                        },
                                        {
                                            label: SourceSystems.CMS.label,
                                            value: SourceSystems.CMS.value,
                                        },
                                        {
                                            label: SourceSystems.OTHER.label,
                                            value: SourceSystems.OTHER.value,
                                        },
                                    ];
                                }),
                            },
                        },
                        {
                            formControl: InputUrlComponent.getFormControlByDefault(),
                            name: "oaiurl",
                            label: "OAI-PMH",
                            type: FormFieldType.url,
                            controlType: InputUrlComponent,
                            required: false,
                            startHint: new HintValue(HintPosition.start, "Escriba una URL válida."),
                            width: "60%",
                            value: this.journalData
                                ? this.journalData.getIdentifierValue(IdentifierSchemas.oaiurl)
                                : "",
                        },
                        // {
                        //   name: 'seriadas_cubanas',
                        //   label: 'URL en Seriadas Cubanas',
                        //   type: FormFieldType.url,
                        //   required: false,
                        //   startHint: new HintValue(HintPosition.start, ''),
                        //   width: '100%',
                        //   value: this.journalVersion ? this.journalVersion.seriadas_cubanas : ''
                        // },
                        {
                            formControl: InputEmailComponent.getFormControlByDefault(),
                            name: "email",
                            label: "Correo Electrónico",
                            type: FormFieldType.email,
                            controlType: InputEmailComponent,
                            required: true,
                            startHint: new HintValue(HintPosition.start, "Escriba un email válido."),
                            width: "45%",
                            value: this.journalData ? this.journalData.email : "",
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "licence",
                            label: "Licencia",
                            type: FormFieldType.vocabulary,
                            controlType: VocabularyComponent,
                            required: false,
                            width: "45%",
                            extraContent: {
                                multiple: false,
                                selectedTermsIds: this.journalData
                                    ? this.journalData.classifications.map((/**
                                     * @param {?} termSource
                                     * @return {?}
                                     */
                                    function (termSource) { return termSource.id; }))
                                    : null,
                                vocab: VocabulariesInmutableNames.LICENCES,
                                level: 0,
                            },
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "start_year",
                            label: "Año de inicio",
                            type: FormFieldType.datepicker,
                            controlType: DatepickerComponent,
                            required: false,
                            width: "30%",
                            value: this.journalData ? this.journalData.start_year : "",
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "end_year",
                            label: "Año final",
                            type: FormFieldType.datepicker,
                            controlType: DatepickerComponent,
                            required: false,
                            width: "30%",
                            value: this.journalData ? this.journalData.end_year : "",
                        },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "frequency",
                            label: "Frecuencia",
                            type: FormFieldType.text,
                            controlType: InputTextComponent,
                            required: false,
                            startHint: new HintValue(HintPosition.start, ""),
                            width: "30%",
                            value: this.journalData ? this.journalData.frequency : "",
                        },
                        // {
                        //   // TODO: el top level de unesco de materias....
                        //   name: "cover",
                        //   label: "Cobertura Temática",
                        //   type: FormFieldType.select_expr,
                        //   required: true,
                        //   width: "45%",
                        //   extraContent: {
                        //     multiple: false,
                        //     observable: this.taxonomyService.getTermsTreeByVocab(
                        //       VocabulariesInmutableNames.SUBJECTS,
                        //       0
                        //     ),
                        //     getOptions: (response: any) => {
                        //       const opts: SelectOption[] = [];
                        //       response.data.tree.term_node.forEach((node: TermNode) => {
                        //         opts.push({
                        //           value: node.term,
                        //           label: node.term.description,
                        //         });
                        //       });
                        //       return opts;
                        //     },
                        //     selectionChange: (term) => {
                        //       this.journalCover = new SourceClasification();
                        //       this.journalCover.description = term.description;
                        //       this.journalCover.id = term.uuid;
                        //       this.journalCover.vocabulary = term.vocabulary_id;
                        //     },
                        //   },
                        // },
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "subjects",
                            label: "Materias",
                            type: FormFieldType.vocabulary_tree,
                            controlType: VocabularyTreeComponent,
                            required: false,
                            width: "80%",
                            extraContent: {
                                multiple: true,
                                selectedTermsIds: this.journalData
                                    ? this.journalData.classifications.map((/**
                                     * @param {?} termSource
                                     * @return {?}
                                     */
                                    function (termSource) { return termSource.id; }))
                                    : null,
                                vocab: VocabulariesInmutableNames.SUBJECTS,
                                level: 1,
                            },
                        },
                        {
                            formControl: InputUrlComponent.getFormControlByDefault(),
                            name: "facebook",
                            label: "Facebook",
                            type: FormFieldType.url,
                            controlType: InputUrlComponent,
                            required: false,
                            width: "33%",
                            value: this.journalData
                                ? this.journalData.socialNetworks.facebook
                                : "",
                        },
                        {
                            formControl: InputUrlComponent.getFormControlByDefault(),
                            name: "twitter",
                            label: "Twitter",
                            type: FormFieldType.url,
                            controlType: InputUrlComponent,
                            required: false,
                            width: "33%",
                            value: this.journalData
                                ? this.journalData.socialNetworks.twitter
                                : "",
                        },
                        {
                            formControl: InputUrlComponent.getFormControlByDefault(),
                            name: "linkedin",
                            label: "LinkedIN",
                            type: FormFieldType.url,
                            controlType: InputUrlComponent,
                            required: false,
                            width: "33%",
                            value: this.journalData
                                ? this.journalData.socialNetworks.linkedin
                                : "",
                        }
                    ],
                };
            // {
            //   title: "Redes Sociales",
            //   description: "",
            //   iconName: "",
            //   formSection: this.informationFormGroup,
            //   formSectionContent: [
            //     {
            //       name: "facebook",
            //       label: "Facebook",
            //       type: FormFieldType.url,
            //       required: false,
            //       width: "33%",
            //       value: this.journalData
            //         ? this.journalData.socialNetworks.facebook
            //         : "",
            //     },
            //     {
            //       name: "twitter",
            //       label: "Twitter",
            //       type: FormFieldType.url,
            //       required: false,
            //       width: "33%",
            //       value: this.journalData
            //         ? this.journalData.socialNetworks.twitter
            //         : "",
            //     },
            //     {
            //       name: "linkedin",
            //       label: "LinkedIN",
            //       type: FormFieldType.url,
            //       required: false,
            //       width: "33%",
            //       value: this.journalData
            //         ? this.journalData.socialNetworks.linkedin
            //         : "",
            //     },
            //   ],
            // },
        };
        /**
         * @return {?}
         */
        JournalEditComponent.prototype.initStep2 = /**
         * @return {?}
         */
        function () {
            this.organizationFormGroup = this.formBuilder.group({
                institutions: new forms.FormControl(""),
            });
        };
        /**
         * @return {?}
         */
        JournalEditComponent.prototype.initStep3 = /**
         * @return {?}
         */
        function () {
            this.indexesFormGroup = this.formBuilder.group({});
        };
        /**
         * @return {?}
         */
        JournalEditComponent.prototype.indexerStepper = /**
         * @return {?}
         */
        function () {
            // console.log(this.journalData);
            // this.indexes = this.journalData.classifications.filter(
            //   (value) => value.vocabulary == VocabulariesInmutableNames.INDEXES
            // );
            // console.log(this.indexes);
        };
        /**
         * @return {?}
         */
        JournalEditComponent.prototype.initStepFinal = /**
         * @return {?}
         */
        function () {
            this.finalFormGroup = this.formBuilder.group({});
            this.finalPanel =
                {
                    name: 'finalPanel',
                    label: '',
                    description: "",
                    iconName: "",
                    formSection: this.finalFormGroup,
                    controlType: ContainerPanelComponent,
                    formSectionContent: [
                        {
                            formControl: InputTextComponent.getFormControlByDefault(),
                            name: "comment",
                            label: "Puede agregar aquí un comentario.",
                            type: FormFieldType.textarea,
                            controlType: TextareaComponent,
                            required: false,
                            startHint: new HintValue(HintPosition.start, ""),
                            width: "100%",
                            minWidth: "100%",
                            value: this.journalData ? this.journalData._save_info.comment : "",
                        },
                    ],
                };
        };
        /**
         * @private
         * @return {?}
         */
        JournalEditComponent.prototype.fillJournalFields = /**
         * @private
         * @return {?}
         */
        function () {
            // this.journalVersion.source_type = this.informationFormGroup.value['source_type'];
            var _this = this;
            this.journalData.setIdentifierValue(IdentifierSchemas.issn_p, this.identifiersFormGroup.value.issn_p);
            this.journalData.setIdentifierValue(IdentifierSchemas.issn_e, this.identifiersFormGroup.value.issn_e);
            this.journalData.setIdentifierValue(IdentifierSchemas.issn_l, this.identifiersFormGroup.value.issn_l);
            this.journalData.setIdentifierValue(IdentifierSchemas.prnps, this.identifiersFormGroup.value.rnps_p);
            this.journalData.setIdentifierValue(IdentifierSchemas.ernps, this.identifiersFormGroup.value.rnps_e);
            // this.journalVersion.issn.deepcopy(
            //   this.identifiersFormGroup.value
            // );
            // this.journalVersion.rnps.deepcopy(
            //   this.identifiersFormGroup.value
            // );
            console.log(this.informationFormGroup);
            this.journalData.deepcopy(this.informationFormGroup.value);
            this.journalData.socialNetworks.deepcopy(this.informationFormGroup.value);
            this.journalData.setIdentifierValue(IdentifierSchemas.url, this.informationFormGroup.value.url);
            this.journalData.setIdentifierValue(IdentifierSchemas.oaiurl, this.informationFormGroup.value.oaiurl);
            this.journalData.source_type = this.informationFormGroup.value["source_type"];
            /** @type {?} */
            var indexes = this.journalData.classifications.filter((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return value.vocabulary == VocabulariesInmutableNames.INDEXES; }));
            this.journalData.classifications = [];
            if (this.informationFormGroup.value["licence"]) {
                this.informationFormGroup.value["licence"].forEach((/**
                 * @param {?} term
                 * @return {?}
                 */
                function (term) {
                    /** @type {?} */
                    var ts = new SourceClasification();
                    ts.description = term.description;
                    ts.id = term.uuid;
                    ts.vocabulary = term.vocabulary_id;
                    _this.journalData.classifications.push(ts);
                }));
            }
            // this.informationFormGroup.value["cover"].forEach((term) => {
            //   const ts = new SourceClasification();
            //   ts.description = term.description;
            //   ts.id = term.uuid;
            //   ts.vocabulary = term.vocabulary_id;
            //   this.journalData.classifications.push(ts);
            // });
            if (this.informationFormGroup.value["subjects"]) {
                this.informationFormGroup.value["subjects"].forEach((/**
                 * @param {?} term
                 * @return {?}
                 */
                function (term) {
                    /** @type {?} */
                    var ts = new SourceClasification();
                    ts.description = term.description;
                    ts.id = term.uuid;
                    ts.vocabulary = term.vocabulary_id;
                    _this.journalData.classifications.push(ts);
                }));
            }
            console.log(indexes);
            this.journalData.classifications = this.journalData.classifications.concat(indexes);
            // this.journalData.organizations = this.source.data.organizations;
            // this.organizationFormGroup.value[
            //   "institutions"
            // ].forEach((panel: JournalInstitutionsPanel) => {
            //   const ts = new SourceClasification();
            //   ts.deepcopy(panel.inst);
            //   ts.term_id = panel.inst.term.id;
            //   ts.source_id = this.journalVersion.source_id;
            //   this.journalVersion.classifications.push(ts);
            // }
            // );
            // this.institutions.forEach(inst => {
            //   this.journalVersion.classifications.push(inst);
            // });
            // console.log(this.indexesPanel);
            // this.indexesPanel.forEach(panel => {
            //   const ts = new SourceClasification();
            //   const term: Term = panel.value;
            //   ts.description = term.description;
            //   ts.id = term.uuid;
            //   ts.vocabulary = term.vocabulary_id;
            //   ts.data['url'] = this.indexesFormGroup.value['url_' + ts.id];
            //   ts.data['initial_cover'] = this.indexesFormGroup.value[
            //     'initial_cover_' + ts.id
            //   ];
            //   ts.data['end_cover'] = this.indexesFormGroup.value[
            //     'end_cover_' + ts.id
            //   ];
            //   this.journalData.classifications.push(ts);
            // });
            this.journalData._save_info.comment = this.finalFormGroup.value["comment"];
            this.journalVersion.comment = this.finalFormGroup.value["comment"];
            this.journalVersion.data.deepcopy(this.journalData);
            console.log(this.identifiersFormGroup);
            console.log(this.informationFormGroup);
            console.log(this.organizationFormGroup);
            console.log(this.indexesFormGroup);
            console.log(this.journalData);
        };
        /**
         * @return {?}
         */
        JournalEditComponent.prototype.finishStepper = /**
         * @return {?}
         */
        function () {
            console.log(this.journalData);
            // console.log(this.journalVersion, this)
            this.fillJournalFields();
            console.log(this.journalData);
            this.journalEditDone.emit(this.journalVersion);
        };
        /**
         * @return {?}
         */
        JournalEditComponent.prototype.cancelStepper = /**
         * @return {?}
         */
        function () {
            this.editCanceled.emit(true);
        };
        JournalEditComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-journal-edit",
                        template: "<mat-card [ngStyle]=\"{ margin: '1em' }\">\n  <mat-card-header\n    *ngIf=\"showEditHeader\"\n    fxLayout=\"column wrap\"\n    fxLayoutAlign=\"start center\"\n  >\n    <div\n      fxLayout=\"row wrap\"\n      fxLayoutAlign=\"space-between center\"\n      [ngStyle]=\"{ width: '100%' }\"\n    >\n      <h2>\n        {{ pageTitle }}\n      </h2>\n      <button mat-stroked-button color=\"warn\" (click)=\"cancelStepper()\">\n        Cancelar\n      </button>\n    </div>\n    <mat-card-subtitle>{{ description }}</mat-card-subtitle>\n  </mat-card-header>\n\n  <mat-card-content>\n    <mat-horizontal-stepper labelPosition=\"end\" [linear]=\"true\" #stepper>\n      <mat-step *ngIf=\"identifiersPanel\" [stepControl]=\"identifiersFormGroup\">\n        <ng-template matStepLabel>Identificadores</ng-template>\n        <form [formGroup]=\"identifiersFormGroup\">\n          <container-panel\n            [content]=\"identifiersPanel\"\n          >\n          </container-panel>\n          <!-- <toco-form-container\n            #informationPanelContainer\n            [panelsContent]=\"identifiersPanel\"\n            [useAccordion]=\"false\"\n            fxLayout=\"row\"\n            [formGroup]=\"identifiersFormGroup\"\n            [deleteValuesAfterAction]=\"false\"\n          >\n          </toco-form-container> -->\n        </form>\n        <div fxLayout=\"row wrap\" fxLayoutAlign=\"end center\">\n          <button mat-stroked-button color=\"primary\" matStepperNext>\n            Siguiente\n          </button>\n        </div>\n      </mat-step>\n\n      <mat-step\n        *ngIf=\"organizationFormGroup\"\n        [stepControl]=\"organizationFormGroup\"\n      >\n        <ng-template matStepLabel>Organizaciones</ng-template>\n        <h2>Organizaciones</h2>\n        <form [formGroup]=\"organizationFormGroup\">\n          <toco-source-organizations\n            [topMainOrganization]=\"topMainOrganization\"\n            [sourceData]=\"journalData\"\n          >\n          </toco-source-organizations>\n        </form>\n        <div fxLayout=\"row wrap\" fxLayoutAlign=\"space-between center\">\n          <button mat-stroked-button color=\"accent\" matStepperPrevious>\n            Atr\u00E1s\n          </button>\n          <button mat-stroked-button color=\"primary\" matStepperNext>\n            Siguiente\n          </button>\n        </div>\n      </mat-step>\n\n      <mat-step *ngIf=\"informationPanel\" [stepControl]=\"informationFormGroup\">\n        <ng-template matStepLabel>Datos</ng-template>\n        <form [formGroup]=\"informationFormGroup\">\n          <container-panel\n            [content]=\"informationPanel\"\n          >\n          </container-panel>\n          <!-- <toco-form-container\n            #informationPanelContainer\n            [panelsContent]=\"informationPanel\"\n            [useAccordion]=\"false\"\n            fxLayout=\"row\"\n            [formGroup]=\"informationFormGroup\"\n            [deleteValuesAfterAction]=\"false\"\n          >\n          </toco-form-container> -->\n        </form>\n        <div fxLayout=\"row wrap\" fxLayoutAlign=\"space-between center\">\n          <button mat-stroked-button color=\"accent\" matStepperPrevious>\n            Atr\u00E1s\n          </button>\n          <button mat-stroked-button color=\"primary\" matStepperNext>\n            Siguiente\n          </button>\n        </div>\n      </mat-step>\n\n      <mat-step *ngIf=\"indexesFormGroup\" [stepControl]=\"indexesFormGroup\">\n        <ng-template matStepLabel>Indizaciones</ng-template>\n        <h2>Indizaciones</h2>\n        <toco-source-indexes [sourceData]=\"journalData\"> </toco-source-indexes>\n\n        <div\n          *ngIf=\"showFinalStep\"\n          fxLayout=\"row wrap\"\n          fxLayoutAlign=\"space-between center\"\n        >\n          <button mat-stroked-button color=\"accent\" matStepperPrevious>\n            Atr\u00E1s\n          </button>\n          <button\n            mat-stroked-button\n            color=\"primary\"\n            matStepperNext\n            (click)=\"indexerStepper()\"\n          >\n            Siguiente\n          </button>\n        </div>\n        <div\n          *ngIf=\"!showFinalStep\"\n          fxLayout=\"row wrap\"\n          fxLayoutAlign=\"space-between center\"\n        >\n          <button mat-stroked-button color=\"accent\" matStepperPrevious>\n            Atr\u00E1s\n          </button>\n\n          <button mat-stroked-button color=\"primary\" (click)=\"finishStepper()\">\n            Aceptar\n          </button>\n        </div>\n      </mat-step>\n\n      <mat-step *ngIf=\"showFinalStep\">\n        <ng-template matStepLabel>Fin</ng-template>\n        <h3>Ha completado el formulario</h3>\n        <h4>\n          Antes de aceptar puede revisar nuevamente los valores que ha\n          introducido.\n        </h4>\n        <!-- <toco-journal-view-info [journal]=\"journal\"></toco-journal-view-info> -->\n\n        <form [formGroup]=\"finalFormGroup\">\n          <container-panel\n            [content]=\"finalPanel\"\n          >\n          </container-panel>\n          <!-- <toco-form-container\n            #indexPanelContainer\n            [panelsContent]=\"finalPanel\"\n            [useAccordion]=\"false\"\n            fxLayout=\"row\"\n            [formGroup]=\"finalFormGroup\"\n            [deleteValuesAfterAction]=\"false\"\n            [ngStyle]=\"{ width: '100%' }\"\n          >\n          </toco-form-container> -->\n        </form>\n\n        <div fxLayout=\"row wrap\" fxLayoutAlign=\"space-between center\">\n          <button mat-stroked-button color=\"accent\" matStepperPrevious>\n            Atr\u00E1s\n          </button>\n\n          <button mat-stroked-button color=\"primary\" (click)=\"finishStepper()\">\n            Aceptar\n          </button>\n        </div>\n      </mat-step>\n    </mat-horizontal-stepper>\n  </mat-card-content>\n</mat-card>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        JournalEditComponent.ctorParameters = function () { return [
            { type: MetadataService },
            { type: SourceService },
            { type: CatalogService },
            { type: TaxonomyService },
            { type: material.MatSnackBar },
            { type: forms.FormBuilder }
        ]; };
        JournalEditComponent.propDecorators = {
            journalVersion: [{ type: core.Input }],
            showEditHeader: [{ type: core.Input }],
            description: [{ type: core.Input }],
            topMainOrganization: [{ type: core.Input }],
            showFinalStep: [{ type: core.Input }],
            journalEditDone: [{ type: core.Output }],
            editCanceled: [{ type: core.Output }]
        };
        return JournalEditComponent;
    }());
    if (false) {
        /** @type {?} */
        JournalEditComponent.prototype.pageTitle;
        /** @type {?} */
        JournalEditComponent.prototype.journalData;
        /** @type {?} */
        JournalEditComponent.prototype.journalVersion;
        /** @type {?} */
        JournalEditComponent.prototype.showEditHeader;
        /** @type {?} */
        JournalEditComponent.prototype.description;
        /** @type {?} */
        JournalEditComponent.prototype.topMainOrganization;
        /** @type {?} */
        JournalEditComponent.prototype.showFinalStep;
        /** @type {?} */
        JournalEditComponent.prototype.identifiersPanel;
        /** @type {?} */
        JournalEditComponent.prototype.identifiersFormGroup;
        /** @type {?} */
        JournalEditComponent.prototype.informationPanel;
        /** @type {?} */
        JournalEditComponent.prototype.informationFormGroup;
        /** @type {?} */
        JournalEditComponent.prototype.informationSocialFormGroup;
        /** @type {?} */
        JournalEditComponent.prototype.journalCover;
        /** @type {?} */
        JournalEditComponent.prototype.organizationFormGroup;
        /** @type {?} */
        JournalEditComponent.prototype.indexesFormGroup;
        /** @type {?} */
        JournalEditComponent.prototype.finalPanel;
        /** @type {?} */
        JournalEditComponent.prototype.finalFormGroup;
        /** @type {?} */
        JournalEditComponent.prototype.stepAction1;
        /** @type {?} */
        JournalEditComponent.prototype.stepAction2;
        /** @type {?} */
        JournalEditComponent.prototype.stepAction3;
        /** @type {?} */
        JournalEditComponent.prototype.stepAction4;
        /** @type {?} */
        JournalEditComponent.prototype.journalEditDone;
        /** @type {?} */
        JournalEditComponent.prototype.editCanceled;
        /**
         * @type {?}
         * @private
         */
        JournalEditComponent.prototype.metadata;
        /**
         * @type {?}
         * @private
         */
        JournalEditComponent.prototype.sourceService;
        /**
         * @type {?}
         * @private
         */
        JournalEditComponent.prototype.catalogService;
        /**
         * @type {?}
         * @private
         */
        JournalEditComponent.prototype.taxonomyService;
        /** @type {?} */
        JournalEditComponent.prototype.snackBar;
        /**
         * @type {?}
         * @private
         */
        JournalEditComponent.prototype.formBuilder;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/journal-view/journal-view-version-term.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This component share the same scss that `JournalViewComponent`.
     * His goal is show a list of `terms`
     */
    var JournalViewTermComponent = /** @class */ (function () {
        function JournalViewTermComponent() {
        }
        /**
         * @return {?}
         */
        JournalViewTermComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.terms == undefined)
                this.terms = new Array(0);
            if (this.vocab_id == undefined)
                this.vocab_id = 0;
            if (this.title == undefined)
                this.title = '';
        };
        JournalViewTermComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-journal-view-term',
                        template: "\n<mat-card style=\"margin: 1em; background-color: whitesmoke;\">\n\n    <mat-card-header>\n        <mat-card-title>\n            {{ title }}\n        </mat-card-title>\n        <mat-label *ngIf=\"terms.length == 0\" class=\"text-muted text-through\">Vac\u00EDo</mat-label>\n    </mat-card-header>\n\n    <mat-card-content>\n\n        <mat-chip-list class=\"mat-chip-list-stacked\" fxLayout=\"row\" fxLayoutAlign=\"start center\">\n\n            <ng-container *ngFor=\"let termSource of terms\">\n\n                <mat-chip>\n                    {{ termSource.description }}\n                </mat-chip>\n\n            </ng-container>\n\n        </mat-chip-list>\n    </mat-card-content>\n\n</mat-card>\n",
                        styles: [".text-muted{color:rgba(0,0,0,.54);padding-left:.2em}.text-through{text-decoration:line-through}.notification-position{position:absolute;top:0;right:0}p{padding-top:.8em}.overlay{opacity:.4;background:#000;width:100%;height:100%;z-index:10;top:0;left:0;position:fixed}"]
                    }] }
        ];
        /** @nocollapse */
        JournalViewTermComponent.ctorParameters = function () { return []; };
        JournalViewTermComponent.propDecorators = {
            title: [{ type: core.Input }],
            vocab_id: [{ type: core.Input }],
            terms: [{ type: core.Input }]
        };
        return JournalViewTermComponent;
    }());
    if (false) {
        /** @type {?} */
        JournalViewTermComponent.prototype.title;
        /** @type {?} */
        JournalViewTermComponent.prototype.vocab_id;
        /** @type {?} */
        JournalViewTermComponent.prototype.terms;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/source-edit/source-indexes/source-indexes.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SourceIndexesComponent = /** @class */ (function () {
        function SourceIndexesComponent(dialog, service) {
            this.dialog = dialog;
            this.service = service;
            this.editable = true;
            /*
                el arbol entero de los indexes
                el primer nivel se considera que es una clasificacion del index, por ejemplo
                    {
                      "children": {...}
                      "term": {
                        "clasified_ids": [],
                        "class_ids": [],
                        "data": null,
                        "description": "WoS / Scopus",
                        "id": 4355,
                        "name": "http://miar.ub.edu/databases/GRUPO/G",
                        "parent_id": null,
                        "uuid": "a4aae8a2-b65d-4313-b666-5ef4170fc549",
                        "vocabulary_id": "INDEXES"
                      }
                    }
                en el segundo nivel (children) estan los indices(bases de datos) que realmente clasifican a las fuentes
              */
            this.databases = null;
            /*
                cada elemento de este array tiene:
                dbclass, que es un termino del primer nivel de databases,
                dblist, son las clasificaciones de las fuentes con los correspondientes datos,
                  los terminos correspondientes de los elementos de dblist son hijos de dbclass en databses
              */
            this.selectedDatabases = null;
        }
        /**
         * @return {?}
         */
        SourceIndexesComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.service.getTermsTreeByVocab(VocabulariesInmutableNames.INDEXES, 1).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                if (response.data.tree.term_node) {
                    _this.databases = response.data.tree.term_node;
                    _this.initIndexes();
                }
            }), (/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                console.log('ERROR: ' + err + '.');
            }), (/**
             * @return {?}
             */
            function () {
            }));
        };
        /**
         * @return {?}
         */
        SourceIndexesComponent.prototype.initIndexes = /**
         * @return {?}
         */
        function () {
            this.selectedDatabases = new Array(this.databases.length);
            this._setSelectedDatabses();
            this._setIndexesToSource();
            console.log('******* complete process');
        };
        /**
         * divide los source.classifications que son de INDEXES
         * en el arreglo selectedDatabases, cuyos elementos tienen
         * dbclass, que es el primer nivel
         * dblist, que son los SourceClassification seleccionados e hijos de dbclass
         */
        /**
         * divide los source.classifications que son de INDEXES
         * en el arreglo selectedDatabases, cuyos elementos tienen
         * dbclass, que es el primer nivel
         * dblist, que son los SourceClassification seleccionados e hijos de dbclass
         * @private
         * @return {?}
         */
        SourceIndexesComponent.prototype._setSelectedDatabses = /**
         * divide los source.classifications que son de INDEXES
         * en el arreglo selectedDatabases, cuyos elementos tienen
         * dbclass, que es el primer nivel
         * dblist, que son los SourceClassification seleccionados e hijos de dbclass
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            var _loop_1 = function (i) {
                this_1.selectedDatabases[i] = {
                    dbclass: this_1.databases[i].term,
                    dblist: this_1.sourceData.classifications.filter((/**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) {
                        return value.vocabulary == VocabulariesInmutableNames.INDEXES &&
                            _this.databases[i].children.find((/**
                             * @param {?} db
                             * @return {?}
                             */
                            function (db) { return db.term.uuid == value.id; })) != undefined;
                    }))
                };
            };
            var this_1 = this;
            for (var i = 0; i < this.databases.length; i++) {
                _loop_1(i);
            }
            for (var i = 0; i < this.databases.length; i++) {
                for (var k = 0; k < this.selectedDatabases[i].dblist.length; k++) {
                    /** @type {?} */
                    var element = this.selectedDatabases[i].dblist[k];
                    if (!this.selectedDatabases[i].dblist[k].data) {
                        this.selectedDatabases[i].dblist[k].data = {};
                    }
                    if (!this.selectedDatabases[i].dblist[k].data['url']) {
                        this.selectedDatabases[i].dblist[k].data['url'] = '';
                    }
                    if (!this.selectedDatabases[i].dblist[k].data['initial_cover']) {
                        this.selectedDatabases[i].dblist[k].data['initial_cover'] = '';
                    }
                    if (!this.selectedDatabases[i].dblist[k].data['end_cover']) {
                        this.selectedDatabases[i].dblist[k].data['end_cover'] = '';
                    }
                }
            }
        };
        /**
         * mantiene la lista sourceData.classification bien formada en relacion con lo que hay en selectedDatabases
         */
        /**
         * mantiene la lista sourceData.classification bien formada en relacion con lo que hay en selectedDatabases
         * @private
         * @return {?}
         */
        SourceIndexesComponent.prototype._setIndexesToSource = /**
         * mantiene la lista sourceData.classification bien formada en relacion con lo que hay en selectedDatabases
         * @private
         * @return {?}
         */
        function () {
            var _this = this;
            // filtra las clasificaciones que no sean indexes
            this.sourceData.classifications = this.sourceData.classifications.filter((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return value.vocabulary != VocabulariesInmutableNames.INDEXES; }));
            this.selectedDatabases.forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                // por cada elemento en selectedDatabases, si tiene algun elemento en dblist
                // entonces dbclass y dblist tambien son parte de sourceData.classifications
                if (element.dblist.length > 0) {
                    /** @type {?} */
                    var parent_1 = new SourceClasification();
                    parent_1.id = element.dbclass.uuid;
                    parent_1.description = element.dbclass.description;
                    parent_1.vocabulary = element.dbclass.vocabulary_id;
                    _this.sourceData.classifications.push(parent_1);
                    _this.sourceData.classifications = _this.sourceData.classifications.concat(element.dblist);
                }
            }));
            console.log(this.sourceData);
        };
        /**
         * @param {?} dbclassIndex
         * @return {?}
         */
        SourceIndexesComponent.prototype.addIndexAction = /**
         * @param {?} dbclassIndex
         * @return {?}
         */
        function (dbclassIndex) {
            var _this = this;
            /** @type {?} */
            var dbclass = this.selectedDatabases[dbclassIndex].dbclass;
            /** @type {?} */
            var options = this.databases[dbclassIndex].children.filter((/**
             * @param {?} value
             * @return {?}
             */
            function (value) {
                return _this.selectedDatabases[dbclassIndex].dblist.find((/**
                 * @param {?} db
                 * @return {?}
                 */
                function (db) { return db.id == value.term.uuid; })) == undefined;
            }));
            if (options.length > 0) {
                this.dialog.open(SourceEditAddIndexComponent, {
                    data: {
                        dbclass: this.selectedDatabases[dbclassIndex].dbclass,
                        options: options,
                        editing: null,
                        addIndex: (/**
                         * @param {?} result
                         * @return {?}
                         */
                        function (result) {
                            _this.dialog.closeAll();
                            _this.selectedDatabases[dbclassIndex].dblist = _this.selectedDatabases[dbclassIndex].dblist.filter((/**
                             * @param {?} value
                             * @return {?}
                             */
                            function (value) { return value.id != result.id; }));
                            _this.selectedDatabases[dbclassIndex].dblist.push(result);
                            _this._setIndexesToSource();
                        }),
                    },
                });
            }
        };
        /**
         * @param {?} dbclassIndex
         * @param {?} editing
         * @return {?}
         */
        SourceIndexesComponent.prototype.editIndexAction = /**
         * @param {?} dbclassIndex
         * @param {?} editing
         * @return {?}
         */
        function (dbclassIndex, editing) {
            var _this = this;
            /** @type {?} */
            var dbclass = this.selectedDatabases[dbclassIndex].dbclass;
            if (editing) {
                // this.selectedDatabases[dbclassIndex].dblist = this.selectedDatabases[dbclassIndex].dblist.filter(
                //   value => value.id != editing.id
                // );
                /** @type {?} */
                var options = this.databases[dbclassIndex].children.filter((/**
                 * @param {?} value
                 * @return {?}
                 */
                function (value) {
                    return _this.selectedDatabases[dbclassIndex].dblist.find((/**
                     * @param {?} db
                     * @return {?}
                     */
                    function (db) { return db.id == value.term.uuid; })) == undefined ||
                        value.term.uuid == editing.id;
                }));
                if (options.length > 0 || editing) {
                    this.dialog.open(SourceEditAddIndexComponent, {
                        data: {
                            dbclass: this.selectedDatabases[dbclassIndex].dbclass,
                            options: options,
                            editing: editing,
                            addIndex: (/**
                             * @param {?} result
                             * @return {?}
                             */
                            function (result) {
                                _this.dialog.closeAll();
                                // console.log('----------------------------',this.selectedDatabases[dbclassIndex].dblist);
                                /** @type {?} */
                                var newSelected = [];
                                _this.selectedDatabases[dbclassIndex].dblist.forEach((/**
                                 * @param {?} element
                                 * @return {?}
                                 */
                                function (element) {
                                    if (element.id != result.id && element.id != editing.id) {
                                        newSelected.push(element);
                                    }
                                }));
                                _this.selectedDatabases[dbclassIndex].dblist = newSelected;
                                // this.selectedDatabases[dbclassIndex].dblist = this.selectedDatabases[dbclassIndex].dblist.filter(
                                //   value => (value.id == result.id && value.id == editing.id));
                                // console.log('++++++++++++++++++++++',this.selectedDatabases[dbclassIndex].dblist);
                                _this.selectedDatabases[dbclassIndex].dblist.push(result);
                                // console.log('*********************',this.selectedDatabases[dbclassIndex].dblist);
                                _this._setIndexesToSource();
                            }),
                        },
                    });
                }
            }
        };
        /**
         * @param {?} dbclassIndex
         * @param {?} toDelete
         * @return {?}
         */
        SourceIndexesComponent.prototype.deleteIndexAction = /**
         * @param {?} dbclassIndex
         * @param {?} toDelete
         * @return {?}
         */
        function (dbclassIndex, toDelete) {
            // console.log('DELETE', toDelete);
            this.selectedDatabases[dbclassIndex].dblist = this.selectedDatabases[dbclassIndex].dblist.filter((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return value.id != toDelete.id; }));
            this._setIndexesToSource();
        };
        SourceIndexesComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-source-indexes",
                        template: "<mat-progress-bar\n  *ngIf=\"!selectedDatabases\"\n  mode=\"indeterminate\"\n></mat-progress-bar>\n\n<mat-accordion *ngIf=\"selectedDatabases\">\n  <mat-expansion-panel\n    *ngFor=\"let clasification of selectedDatabases; let classIndex = index\"\n  >\n    <mat-expansion-panel-header>\n      {{ clasification.dbclass.description }} ({{clasification.dblist.length}})\n    </mat-expansion-panel-header>\n    <mat-action-row *ngIf=\"editable\">\n      <button\n          mat-icon-button\n          aria-label=\"Adicionar\"\n          matTooltip=\"Adicionar\"\n          (click)=\"addIndexAction(classIndex)\"\n        >\n          <mat-icon>add</mat-icon>\n        </button>\n    </mat-action-row>\n    <mat-card *ngFor=\"let db of clasification.dblist; let dbIndex = index\">\n      <mat-card-header>\n        <mat-card-title><mat-label>{{ db.description }}</mat-label></mat-card-title>\n        <mat-card-subtitle>\n          <mat-label style=\"font-weight: bold;\">URL: </mat-label>\n          {{ db.data[\"url\"] }}\n        </mat-card-subtitle>\n      </mat-card-header>\n      <mat-card-content>\n          <mat-label style=\"font-weight: bold;\">Cobertura: </mat-label>\n          <mat-label>\n            {{ db.data[\"initial_cover\"] }} - {{ db.data[\"end_cover\"] }}\n          </mat-label>\n      </mat-card-content>\n      <mat-card-actions *ngIf=\"editable\">\n        <button\n          mat-icon-button\n          aria-label=\"Editar\"\n          matTooltip=\"Editar\"\n          (click)=\"editIndexAction(classIndex, db)\"\n        >\n          <mat-icon>edit</mat-icon>\n        </button>\n        <button\n          mat-icon-button\n          aria-label=\"Eliminar\"\n          matTooltip=\"Eliminar\"\n          (click)=\"deleteIndexAction(classIndex, db)\"\n        >\n          <mat-icon>delete</mat-icon>\n        </button>\n      </mat-card-actions>\n    </mat-card>\n  </mat-expansion-panel>\n</mat-accordion>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        SourceIndexesComponent.ctorParameters = function () { return [
            { type: material.MatDialog },
            { type: TaxonomyService }
        ]; };
        SourceIndexesComponent.propDecorators = {
            sourceData: [{ type: core.Input }],
            editable: [{ type: core.Input }]
        };
        return SourceIndexesComponent;
    }());
    if (false) {
        /** @type {?} */
        SourceIndexesComponent.prototype.sourceData;
        /** @type {?} */
        SourceIndexesComponent.prototype.editable;
        /** @type {?} */
        SourceIndexesComponent.prototype.databases;
        /** @type {?} */
        SourceIndexesComponent.prototype.selectedDatabases;
        /** @type {?} */
        SourceIndexesComponent.prototype.dialog;
        /**
         * @type {?}
         * @private
         */
        SourceIndexesComponent.prototype.service;
    }
    var SourceEditAddIndexComponent = /** @class */ (function () {
        function SourceEditAddIndexComponent(service, _formBuilder, data) {
            // console.log(data);
            this.service = service;
            this._formBuilder = _formBuilder;
            this.data = data;
            this.indexPanel = null;
            this.editing = null;
            this.dbclass = data.dbclass;
            this.options = data.options;
            if (data.editing) {
                this.editing = data.editing;
            }
            this.addIndex = data.addIndex;
        }
        /**
         * @return {?}
         */
        SourceEditAddIndexComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.indexFormGroup = this._formBuilder.group({});
            if (this.dbclass) {
                this.indexPanel = [
                    {
                        title: (this.editing) ? 'Editar' : 'Adicionar',
                        description: '',
                        iconName: '',
                        formSection: this.indexFormGroup,
                        formSectionContent: [
                            {
                                formControl: InputTextComponent.getFormControlByDefault(),
                                name: 'indexes',
                                label: this.dbclass.description,
                                type: FormFieldType.select_expr,
                                controlType: SelectComponent,
                                required: true,
                                width: '100%',
                                value: (this.editing) ? this.editing.id : null,
                                extraContent: {
                                    multiple: false,
                                    getOptions: (/**
                                     * @param {?} response
                                     * @return {?}
                                     */
                                    function (response) {
                                        /** @type {?} */
                                        var opts = [];
                                        _this.options.forEach((/**
                                         * @param {?} node
                                         * @return {?}
                                         */
                                        function (node) {
                                            opts.push({
                                                value: node.term.uuid,
                                                label: node.term.description,
                                            });
                                        }));
                                        return opts;
                                    }),
                                    selectionChange: (/**
                                     * @param {?} value
                                     * @return {?}
                                     */
                                    function (value) {
                                        console.log(value);
                                    })
                                }
                            },
                            {
                                formControl: InputUrlComponent.getFormControlByDefault(),
                                name: 'url',
                                label: 'URL',
                                type: FormFieldType.url,
                                controlType: InputUrlComponent,
                                required: false,
                                startHint: new HintValue(HintPosition.start, 'URL de la revista en el índice.'),
                                width: '100%',
                                value: (this.editing) ? [this.editing.data['url']] : '',
                            },
                            {
                                formControl: InputTextComponent.getFormControlByDefault(),
                                name: 'initial_cover',
                                label: 'Cobertura inicio',
                                type: FormFieldType.text,
                                controlType: InputTextComponent,
                                required: false,
                                startHint: new HintValue(HintPosition.start, ''),
                                width: '45%',
                                value: (this.editing) ? [this.editing.data['initial_cover']] : '',
                            },
                            {
                                formControl: InputTextComponent.getFormControlByDefault(),
                                name: 'end_cover',
                                label: 'Cobertura',
                                type: FormFieldType.text,
                                controlType: InputTextComponent,
                                required: false,
                                startHint: new HintValue(HintPosition.start, ''),
                                width: '45%',
                                value: (this.editing) ? [this.editing.data['end_cover']] : '',
                            },
                        ],
                    },
                ];
            }
            this.addIndexAction = {
                doit: (/**
                 * @param {?} data
                 * @return {?}
                 */
                function (data) {
                    if (_this.indexFormGroup.valid) {
                        /** @type {?} */
                        var result = new SourceClasification();
                        // console.log(this.indexFormGroup);
                        if (_this.indexFormGroup.controls['indexes'].value) {
                            /** @type {?} */
                            var node = _this.options.find((/**
                             * @param {?} value
                             * @return {?}
                             */
                            function (value) { return value.term.uuid == _this.indexFormGroup.controls['indexes'].value; }));
                            if (node) {
                                result.vocabulary = node.term.vocabulary_id;
                                result.description = node.term.description;
                                result.id = node.term.uuid;
                                result.data = {
                                    url: _this.indexFormGroup.controls['url'].value,
                                    initial_cover: _this.indexFormGroup.controls['initial_cover'].value,
                                    end_cover: _this.indexFormGroup.controls['end_cover'].value,
                                };
                                _this.addIndex(result);
                            }
                        }
                    }
                }),
            };
        };
        SourceEditAddIndexComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-source-addindex",
                        template: "\n    <toco-form-container\n      #indexPanelContainer\n      [panelsContent]=\"indexPanel\"\n      [useAccordion]=\"false\"\n      fxLayout=\"row\"\n      [formGroup]=\"indexFormGroup\"\n      [action]=\"addIndexAction\"\n      [actionLabel]=\"'OK'\"\n      [deleteValuesAfterAction]=\"false\"\n    ></toco-form-container>\n  ",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        SourceEditAddIndexComponent.ctorParameters = function () { return [
            { type: TaxonomyService },
            { type: forms.FormBuilder },
            { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] }
        ]; };
        return SourceEditAddIndexComponent;
    }());
    if (false) {
        /** @type {?} */
        SourceEditAddIndexComponent.prototype.indexPanel;
        /** @type {?} */
        SourceEditAddIndexComponent.prototype.indexFormGroup;
        /** @type {?} */
        SourceEditAddIndexComponent.prototype.addIndexAction;
        /** @type {?} */
        SourceEditAddIndexComponent.prototype.dbclass;
        /** @type {?} */
        SourceEditAddIndexComponent.prototype.options;
        /** @type {?} */
        SourceEditAddIndexComponent.prototype.editing;
        /** @type {?} */
        SourceEditAddIndexComponent.prototype.addIndex;
        /**
         * @type {?}
         * @private
         */
        SourceEditAddIndexComponent.prototype.service;
        /**
         * @type {?}
         * @private
         */
        SourceEditAddIndexComponent.prototype._formBuilder;
        /** @type {?} */
        SourceEditAddIndexComponent.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/source-edit/source-organizations/source-organizations.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SourceOrganizationsComponent = /** @class */ (function () {
        function SourceOrganizationsComponent(dialog, orgService) {
            this.dialog = dialog;
            this.orgService = orgService;
            this.editable = true;
            this.topMainOrganization = null;
            this.roles = SourceOrganizationRole;
        }
        /**
         * @return {?}
         */
        SourceOrganizationsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            console.log(this.sourceData.organizations);
            this.sourceData.organizations = this.sourceData.organizations.filter((/**
             * @param {?} element
             * @return {?}
             */
            function (element) { return element && element.role; }));
            console.log(this.sourceData.organizations);
        };
        /**
         * @param {?=} cuban
         * @param {?=} topMain
         * @return {?}
         */
        SourceOrganizationsComponent.prototype.addOrg = /**
         * @param {?=} cuban
         * @param {?=} topMain
         * @return {?}
         */
        function (cuban, topMain) {
            var _this = this;
            if (cuban === void 0) { cuban = true; }
            if (topMain === void 0) { topMain = false; }
            if (topMain && this.topMainOrganization) {
                this.dialog.open(SourceOrganizationSelectTopDialog, {
                    width: "500px",
                    data: {
                        topMainOrganization: this.topMainOrganization,
                        selectOrg: (/**
                         * @param {?} org
                         * @param {?} parents
                         * @return {?}
                         */
                        function (org, parents) {
                            _this.addOrgToSource(org, SourceOrganizationRole.MAIN.value);
                            parents.forEach((/**
                             * @param {?} element
                             * @return {?}
                             */
                            function (element) {
                                _this.addOrgToSource(element, SourceOrganizationRole.COLABORATOR.value);
                            }));
                        }),
                    },
                });
            }
            else {
                this.dialog.open(SourceOrganizationSelectDialog, {
                    width: "500px",
                    data: {
                        filter: cuban ? { type: "country", value: "Cuba" } : null,
                        canSelectRole: this.topMainOrganization == null,
                        selectOrg: (/**
                         * @param {?} org
                         * @param {?} role
                         * @param {?} parents
                         * @return {?}
                         */
                        function (org, role, parents) {
                            _this.addOrgToSource(org, role);
                            parents.forEach((/**
                             * @param {?} element
                             * @return {?}
                             */
                            function (element) {
                                _this.addOrgToSource(element, SourceOrganizationRole.COLABORATOR.value);
                            }));
                        }),
                    },
                });
            }
        };
        /**
         * @private
         * @param {?} org
         * @param {?} role
         * @return {?}
         */
        SourceOrganizationsComponent.prototype.addOrgToSource = /**
         * @private
         * @param {?} org
         * @param {?} role
         * @return {?}
         */
        function (org, role) {
            if (!this.sourceData.organizations.find((/**
             * @param {?} o
             * @return {?}
             */
            function (o) { return o.id == org.id; }))) {
                /** @type {?} */
                var selected = new SourceOrganization();
                selected.deepcopy(org);
                selected.role = role;
                this.sourceData.organizations.push(selected);
                if (SourceOrganizationRole.MAIN.value == role) {
                    this.setAsMain(org);
                }
            }
        };
        /**
         * @param {?} organization
         * @return {?}
         */
        SourceOrganizationsComponent.prototype.setAsMain = /**
         * @param {?} organization
         * @return {?}
         */
        function (organization) {
            this.sourceData.organizations.forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                if (organization.id == element.id) {
                    element.role = SourceOrganizationRole.MAIN.value;
                }
                else {
                    element.role = SourceOrganizationRole.COLABORATOR.value;
                }
            }));
        };
        /**
         * @param {?} index
         * @return {?}
         */
        SourceOrganizationsComponent.prototype.removeInst = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            var _this = this;
            /** @type {?} */
            var organization = this.sourceData.organizations[index];
            /** @type {?} */
            var m = new MessageHandler(null, this.dialog);
            /** @type {?} */
            var child = this.childToRemove(organization);
            if (child == null) {
                /** @type {?} */
                var parents = this.getOrgToDelete(organization);
                /** @type {?} */
                var toDelete = [];
                /** @type {?} */
                var msg = "";
                for (var i = 0; i < parents.length; i++) {
                    /** @type {?} */
                    var element = parents[i];
                    toDelete.push(this.sourceData.organizations[element]);
                    msg += this.sourceData.organizations[element].name + ", ";
                }
                toDelete.push(organization);
                console.log(toDelete);
                if (toDelete.length > 0) {
                    m.showMessage(StatusCode.OK, msg, HandlerComponent.dialog, "Se eliminó también: ");
                }
                /** @type {?} */
                var orgs = [];
                var _loop_1 = function (i) {
                    if (!toDelete.find((/**
                     * @param {?} o
                     * @return {?}
                     */
                    function (o) { return o.id == _this.sourceData.organizations[i].id; }))) {
                        orgs.push(this_1.sourceData.organizations[i]);
                    }
                };
                var this_1 = this;
                for (var i = 0; i < this.sourceData.organizations.length; i++) {
                    _loop_1(i);
                }
                console.log(orgs);
                this.sourceData.organizations = orgs;
                // this.sourceData.organizations = this.sourceData.organizations.filter(
                //   (o) => o.id != organization.id
                // );
            }
            else {
                m.showMessage(StatusCode.OK, child.name, HandlerComponent.dialog, "Para eliminar este elemento debe eliminar:");
            }
        };
        /**
         * @private
         * @param {?} org
         * @return {?}
         */
        SourceOrganizationsComponent.prototype.childToRemove = /**
         * @private
         * @param {?} org
         * @return {?}
         */
        function (org) {
            // se puede eliminar si no tiene hijos en el sourceData.organizations
            /** @type {?} */
            var result = true;
            if (org.relationships) {
                for (var index = 0; index < org.relationships.length; index++) {
                    /** @type {?} */
                    var element = org.relationships[index];
                    if (element.type == OrganizationRelationships.CHILD.value) {
                        /** @type {?} */
                        var childIndex = this.getIndexByPid(element.identifiers[0].value);
                        if (childIndex != null) {
                            return this.sourceData.organizations[childIndex];
                        }
                    }
                }
                return null;
            }
        };
        // removeInst(index) {
        //   let toDelete = []
        //   toDelete.push(index);
        //   toDelete.concat(this.getOrgToDelete(this.sourceData.organizations[index]));
        //   let orgs = [];
        //   for (let i = 0; i < this.sourceData.organizations.length; i++) {
        //     if(!toDelete.find((o) => o == i)){
        //       orgs.push(this.sourceData.organizations[i]);
        //     }
        //   }
        //   this.sourceData.organizations = orgs;
        // }
        // removeInst(index) {
        //   let toDelete = []
        //   toDelete.push(index);
        //   toDelete.concat(this.getOrgToDelete(this.sourceData.organizations[index]));
        //   let orgs = [];
        //   for (let i = 0; i < this.sourceData.organizations.length; i++) {
        //     if(!toDelete.find((o) => o == i)){
        //       orgs.push(this.sourceData.organizations[i]);
        //     }
        //   }
        //   this.sourceData.organizations = orgs;
        // }
        /**
         * @private
         * @param {?} org
         * @return {?}
         */
        SourceOrganizationsComponent.prototype.getOrgToDelete = 
        // removeInst(index) {
        //   let toDelete = []
        //   toDelete.push(index);
        //   toDelete.concat(this.getOrgToDelete(this.sourceData.organizations[index]));
        //   let orgs = [];
        //   for (let i = 0; i < this.sourceData.organizations.length; i++) {
        //     if(!toDelete.find((o) => o == i)){
        //       orgs.push(this.sourceData.organizations[i]);
        //     }
        //   }
        //   this.sourceData.organizations = orgs;
        // }
        /**
         * @private
         * @param {?} org
         * @return {?}
         */
        function (org) {
            var _this = this;
            /** @type {?} */
            var toDelete = [];
            if (org.relationships) {
                org.relationships.forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                function (element) {
                    if (element.type == OrganizationRelationships.PARENT.value) {
                        /** @type {?} */
                        var parentIndex = _this.getIndexByPid(element.identifiers[0].value);
                        if (parentIndex) {
                            toDelete.push(parentIndex);
                            toDelete.concat(_this.getOrgToDelete(_this.sourceData.organizations[parentIndex]));
                        }
                    }
                }));
            }
            return toDelete;
        };
        /**
         * @private
         * @param {?} pid
         * @return {?}
         */
        SourceOrganizationsComponent.prototype.getIndexByPid = /**
         * @private
         * @param {?} pid
         * @return {?}
         */
        function (pid) {
            for (var index = 0; index < this.sourceData.organizations.length; index++) {
                /** @type {?} */
                var element = this.sourceData.organizations[index];
                for (var pidindex = 0; pidindex < element.identifiers.length; pidindex++) {
                    /** @type {?} */
                    var identifier = element.identifiers[pidindex];
                    console.log(identifier.value + "==" + pid);
                    if (identifier.value == pid) {
                        console.log(identifier.value + "==" + pid + "  iguales!!!");
                        return index;
                    }
                }
            }
            return null;
        };
        SourceOrganizationsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-source-organizations",
                        template: "<ng-container>\n  <mat-toolbar\n    *ngIf=\"editable\"\n    fxLayout=\"row wrap\"\n    fxLayoutAlign=\"space-between center\"\n    fxLayoutGap=\"20px\"\n  >\n    <span>Adicionar</span>\n    <div\n      fxLayout=\"row wrap\"\n      fxLayoutAlign=\"space-between center\"\n      fxLayoutGap=\"20px\"\n    >\n    <button *ngIf=\"topMainOrganization\" mat-raised-button (click)=\"addOrg(true, true)\">\n      Organizaci\u00F3n Principal\n    </button>\n      <button mat-raised-button (click)=\"addOrg(true)\">\n        Organizaciones Cubanas\n      </button>\n      <button mat-raised-button (click)=\"addOrg(false)\">\n        Otras\n      </button>\n    </div>\n  </mat-toolbar>\n\n  \n  <mat-accordion>\n    <mat-expansion-panel\n      *ngFor=\"let org of sourceData.organizations; let index = index\"\n      [expanded]=\"false\"\n    >\n      <mat-expansion-panel-header>\n        <mat-panel-title>\n          {{ roles[org.role].label }}\n        </mat-panel-title>\n        <mat-panel-description>\n          {{ org.name }}\n        </mat-panel-description>\n      </mat-expansion-panel-header>\n      <mat-action-row *ngIf=\"editable\">\n        <button\n          mat-stroked-button\n          [disabled]=\"org.length === 1\"\n          (click)=\"setAsMain(org)\"\n          *ngIf=\"!topMainOrganization\"\n        >\n          Establecer como Principal\n        </button>\n        <button\n          mat-stroked-button\n          [disabled]=\"org.length === 1\"\n          (click)=\"removeInst(index)\"\n        >\n          Eliminar\n        </button>\n      </mat-action-row>\n      <toco-org-view [org]=\"org\" [showContent]=\"false\"></toco-org-view>\n    </mat-expansion-panel>\n  </mat-accordion>\n</ng-container>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        SourceOrganizationsComponent.ctorParameters = function () { return [
            { type: material.MatDialog },
            { type: OrganizationServiceNoAuth }
        ]; };
        SourceOrganizationsComponent.propDecorators = {
            sourceData: [{ type: core.Input }],
            editable: [{ type: core.Input }],
            topMainOrganization: [{ type: core.Input }]
        };
        return SourceOrganizationsComponent;
    }());
    if (false) {
        /** @type {?} */
        SourceOrganizationsComponent.prototype.sourceData;
        /** @type {?} */
        SourceOrganizationsComponent.prototype.editable;
        /** @type {?} */
        SourceOrganizationsComponent.prototype.topMainOrganization;
        /** @type {?} */
        SourceOrganizationsComponent.prototype.roles;
        /** @type {?} */
        SourceOrganizationsComponent.prototype.dialog;
        /**
         * @type {?}
         * @private
         */
        SourceOrganizationsComponent.prototype.orgService;
    }
    var SourceOrganizationSelectTopDialog = /** @class */ (function () {
        function SourceOrganizationSelectTopDialog(dialogRef, data, orgService) {
            this.dialogRef = dialogRef;
            this.data = data;
            this.orgService = orgService;
            this.topMainOrganization = null;
            this.toSelect = null;
            this.selected = -1;
        }
        /**
         * @return {?}
         */
        SourceOrganizationSelectTopDialog.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.topMainOrganization = this.data.topMainOrganization;
            this.toSelect = new Array();
            this.topMainOrganization.relationships.forEach((/**
             * @param {?} element
             * @return {?}
             */
            function (element) {
                if (element.type == OrganizationRelationships.CHILD.value) {
                    _this.toSelect.push(element);
                }
            }));
            console.log(this.toSelect);
        };
        /**
         * @return {?}
         */
        SourceOrganizationSelectTopDialog.prototype.onNoClick = /**
         * @return {?}
         */
        function () {
            this.dialogRef.close();
        };
        /**
         * @return {?}
         */
        SourceOrganizationSelectTopDialog.prototype.ok = /**
         * @return {?}
         */
        function () {
            var _this = this;
            // let selected = new SourceOrganization()
            // selected.organization = org;
            // selected.role = SourceOrganizationRole.MAIN.value;
            if (this.selected >= 0) {
                console.log(this.toSelect[this.selected]);
                this.orgService
                    .getOrganizationByPID(this.toSelect[this.selected].identifiers[0].value)
                    .subscribe({
                    next: (/**
                     * @param {?} response
                     * @return {?}
                     */
                    function (response) {
                        _this.data.selectOrg(response.metadata, [_this.topMainOrganization]);
                        _this.dialogRef.close();
                    }),
                });
            }
        };
        SourceOrganizationSelectTopDialog.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-source-organizations-select-top-main",
                        template: "<mat-dialog-content class=\"height-auto\">\n    <ng-container *ngIf=\"toSelect\"\n      >{{ topMainOrganization.name }}\n      <br />\n      <mat-form-field>\n        <mat-label>Seleccione la Organizaci\u00F3n Principal: </mat-label>\n        <mat-select [(value)]=\"selected\" required>\n          <mat-option\n            *ngFor=\"let item of toSelect; let index = index\"\n            value=\"{{ index }}\"\n            >{{ item.label }}</mat-option\n          >\n        </mat-select>\n      </mat-form-field>\n\n      <br />\n      <mat-label *ngIf=\"selected >= 0\">{{\n        toSelect[selected].label\n      }}</mat-label>\n      <br />\n    </ng-container>\n    <br />\n    <button mat-raised-button (click)=\"ok()\">OK</button>\n  </mat-dialog-content>"
                    }] }
        ];
        /** @nocollapse */
        SourceOrganizationSelectTopDialog.ctorParameters = function () { return [
            { type: material.MatDialogRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] },
            { type: OrganizationServiceNoAuth }
        ]; };
        return SourceOrganizationSelectTopDialog;
    }());
    if (false) {
        /** @type {?} */
        SourceOrganizationSelectTopDialog.prototype.topMainOrganization;
        /** @type {?} */
        SourceOrganizationSelectTopDialog.prototype.toSelect;
        /** @type {?} */
        SourceOrganizationSelectTopDialog.prototype.selected;
        /** @type {?} */
        SourceOrganizationSelectTopDialog.prototype.dialogRef;
        /** @type {?} */
        SourceOrganizationSelectTopDialog.prototype.data;
        /**
         * @type {?}
         * @private
         */
        SourceOrganizationSelectTopDialog.prototype.orgService;
    }
    var SourceOrganizationSelectDialog = /** @class */ (function () {
        function SourceOrganizationSelectDialog(dialogRef, data, orgService) {
            this.dialogRef = dialogRef;
            this.data = data;
            this.orgService = orgService;
            this.roles = [
                { label: "Principal", value: "MAIN" },
                { label: "Colaborador", value: "COLABORATOR" },
            ];
            this.role = null;
            this.parents = new Array();
            this.placeholder = "Buscar una organización";
            this.canSelectRole = true;
        }
        /**
         * @return {?}
         */
        SourceOrganizationSelectDialog.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            console.log(this.data);
            this.canSelectRole = this.data.canSelectRole;
            if (this.data.filter) {
                this.placeholder = "Buscar una organización cubana";
            }
        };
        /**
         * @return {?}
         */
        SourceOrganizationSelectDialog.prototype.onNoClick = /**
         * @return {?}
         */
        function () {
            this.dialogRef.close();
        };
        /**
         * @param {?=} org
         * @return {?}
         */
        SourceOrganizationSelectDialog.prototype.selectedOrg = /**
         * @param {?=} org
         * @return {?}
         */
        function (org) {
            console.log(org);
            this.org = org;
            this.addParent(this.org);
        };
        /**
         * @private
         * @param {?} child
         * @return {?}
         */
        SourceOrganizationSelectDialog.prototype.addParent = /**
         * @private
         * @param {?} child
         * @return {?}
         */
        function (child) {
            var _this = this;
            child.relationships.forEach((/**
             * @param {?} p
             * @return {?}
             */
            function (p) {
                if (p.type == OrganizationRelationships.PARENT.value) {
                    if (p.identifiers.length > 0 && p.identifiers[0].value) {
                        _this.orgService
                            .getOrganizationByPID(p.identifiers[0].value)
                            .subscribe({
                            next: (/**
                             * @param {?} response
                             * @return {?}
                             */
                            function (response) {
                                console.log(response);
                                _this.parents.push(response.metadata);
                                _this.addParent(response.metadata);
                            }),
                        });
                    }
                }
            }));
        };
        /**
         * @return {?}
         */
        SourceOrganizationSelectDialog.prototype.ok = /**
         * @return {?}
         */
        function () {
            // let selected = new SourceOrganization()
            // selected.organization = org;
            // selected.role = SourceOrganizationRole.MAIN.value;
            if (this.canSelectRole) {
                if (this.role) {
                    this.data.selectOrg(this.org, this.role, this.parents);
                    this.dialogRef.close();
                }
            }
            else {
                this.data.selectOrg(this.org, SourceOrganizationRole.COLABORATOR.value, this.parents);
                this.dialogRef.close();
            }
        };
        SourceOrganizationSelectDialog.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-source-organizations-select-dialog",
                        template: "<mat-dialog-content class=\"height-auto\">\n    <toco-org-search\n      [orgFilter]=\"data.filter\"\n      (selectedOrg)=\"selectedOrg($event)\"\n      [placeholder]=\"placeholder\"\n    >\n    </toco-org-search>\n    <br />\n    <mat-label *ngIf=\"org\">{{ org.name }}</mat-label>\n    <br />\n    <mat-form-field *ngIf=\"canSelectRole\">\n      <mat-label>Rol</mat-label>\n      <mat-select [(value)]=\"role\" required>\n        <mat-option *ngFor=\"let item of roles\" value=\"{{ item.value }}\">{{\n          item.label\n        }}</mat-option>\n      </mat-select>\n    </mat-form-field>\n\n    <br />\n\n    <ng-container *ngIf=\"parents.length > 0\">\n      <mat-label>Se a\u00F1adir\u00E1 tambi\u00E9n: </mat-label>\n      <ng-container *ngFor=\"let item of parents\">\n        <br />\n        <mat-label>{{ item.name }}</mat-label>\n        <br />\n      </ng-container>\n      <br />\n    </ng-container>\n\n    <button mat-raised-button (click)=\"ok()\">OK</button>\n  </mat-dialog-content>"
                    }] }
        ];
        /** @nocollapse */
        SourceOrganizationSelectDialog.ctorParameters = function () { return [
            { type: material.MatDialogRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] },
            { type: OrganizationServiceNoAuth }
        ]; };
        return SourceOrganizationSelectDialog;
    }());
    if (false) {
        /** @type {?} */
        SourceOrganizationSelectDialog.prototype.roles;
        /** @type {?} */
        SourceOrganizationSelectDialog.prototype.role;
        /** @type {?} */
        SourceOrganizationSelectDialog.prototype.org;
        /** @type {?} */
        SourceOrganizationSelectDialog.prototype.parents;
        /** @type {?} */
        SourceOrganizationSelectDialog.prototype.placeholder;
        /** @type {?} */
        SourceOrganizationSelectDialog.prototype.canSelectRole;
        /** @type {?} */
        SourceOrganizationSelectDialog.prototype.dialogRef;
        /** @type {?} */
        SourceOrganizationSelectDialog.prototype.data;
        /**
         * @type {?}
         * @private
         */
        SourceOrganizationSelectDialog.prototype.orgService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/journal-view/journal-view-info.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This component share the same scss that `JournalViewComponent`.
     * His goal, shows a Journal
     */
    var JournalViewInfoComponent = /** @class */ (function () {
        function JournalViewInfoComponent(_sourveService, _snackBar) {
            this._sourveService = _sourveService;
            this._snackBar = _snackBar;
            this.showVersionLabel = true;
            this.tipos = SourceTypes;
            this.sistemas = SourceSystems;
            this.panelOpenState = false;
            this.IdentifierSchemas = IdentifierSchemas;
        }
        /**
         * @return {?}
         */
        JournalViewInfoComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.loadJournalData();
        };
        /**
         * @return {?}
         */
        JournalViewInfoComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            console.log("changes....");
            this.loadJournalData();
        };
        /**
         * @return {?}
         */
        JournalViewInfoComponent.prototype.loadJournalData = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.journalData == undefined)
                this.journalData = new JournalData();
            this.journalData.deepcopy(this.journalVersion.data);
            this.dataBaseTerms = new Array();
            this.groupTerms = new Array();
            this.institutionTerms = new Array();
            this.licenceTerms = new Array();
            this.provinceTerms = new Array();
            this.subjectTerms = new Array();
            this.vocabularies = VocabulariesInmutableNames;
            if (this.journalData.classifications) {
                this.journalData.classifications.forEach((/**
                 * @param {?} term
                 * @return {?}
                 */
                function (term) {
                    switch (term.vocabulary.toString()) {
                        case VocabulariesInmutableNames.CUBAN_INTITUTIONS:
                        case VocabulariesInmutableNames.EXTRA_INSTITUTIONS:
                            _this.institutionTerms.push(term);
                            break;
                        case VocabulariesInmutableNames.INDEXES:
                            _this.dataBaseTerms.push(term);
                            break;
                        case VocabulariesInmutableNames.INDEXES_CLASIFICATION:
                            _this.groupTerms.push(term);
                            break;
                        case VocabulariesInmutableNames.LICENCES:
                            _this.licenceTerms.push(term);
                            break;
                        case VocabulariesInmutableNames.CUBAN_PROVINCES:
                            _this.provinceTerms.push(term);
                            break;
                        case VocabulariesInmutableNames.SUBJECTS:
                            _this.subjectTerms.push(term);
                            break;
                    }
                }));
            }
        };
        /**
         * @param {?} idtype
         * @return {?}
         */
        JournalViewInfoComponent.prototype.getIdentifier = /**
         * @param {?} idtype
         * @return {?}
         */
        function (idtype) {
            /** @type {?} */
            var r = this.journalData
                ? this.journalData.getIdentifierValue(idtype)
                : "";
            return r;
        };
        /**
         * @param {?} newVersion
         * @return {?}
         */
        JournalViewInfoComponent.prototype.editingJournalChange = /**
         * @param {?} newVersion
         * @return {?}
         */
        function (newVersion) {
            console.log("*****llego....", newVersion, this.journalData);
            this.loadJournalData();
            this.orgs.ngOnInit();
            this.indexes.initIndexes();
        };
        JournalViewInfoComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-journal-view-info",
                        template: "<!-- Journal Information -->\n<mat-card *ngIf=\"journalVersion && journalData\">\n  <mat-card-header *ngIf=\"showVersionLabel\">\n    <!-- <img mat-card-avatar *ngIf=\"journal.data.logo; else logotemplate\" [style.background-size]=\"'cover'\" src=\"journal.data.logo\">\n        <ng-template #logotemplate>\n            <img mat-card-avatar [src]=\"defaultLogo\" alt=\"\">\n        </ng-template> -->\n\n    <mat-card-title> </mat-card-title>\n\n    <mat-card-subtitle> Revisi\u00F3n actual </mat-card-subtitle>\n  </mat-card-header>\n\n  <mat-divider  *ngIf=\"showVersionLabel\" [inset]=\"true\" style=\"margin-bottom: 1em\"></mat-divider>\n\n  <mat-card-content>\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'T\u00EDtulo'\"\n        [value]=\"journalData.title\"\n      ></toco-journal-view-info-field>\n    </p>\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'Subt\u00EDtulo'\"\n        [value]=\"journalData.subtitle\"\n      ></toco-journal-view-info-field>\n    </p>\n\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'Nombre Abreviado'\"\n        [value]=\"journalData.shortname\"\n      ></toco-journal-view-info-field>\n    </p>\n    <p>\n      <toco-journal-view-info-field *ngIf=\"journalData.source_type\"\n        [label]=\"'Tipo'\"\n        [value]=\"tipos[journalData.source_type].label\"\n      ></toco-journal-view-info-field>\n    </p>\n\n    <mat-label style=\"font-weight: bold\">ISSN: </mat-label>\n    <div style=\"margin-left: 0.8em\">\n      <p>\n        <toco-journal-view-info-field\n          [label]=\"'Impreso'\"\n          [value]=\"getIdentifier(IdentifierSchemas.issn_p)\"\n        ></toco-journal-view-info-field>\n      </p>\n      <p>\n        <toco-journal-view-info-field\n          [label]=\"'Electr\u00F3nico'\"\n          [value]=\"getIdentifier(IdentifierSchemas.issn_e)\"\n        ></toco-journal-view-info-field>\n      </p>\n      <p>\n        <toco-journal-view-info-field\n          [label]=\"'De enlace'\"\n          [value]=\"getIdentifier(IdentifierSchemas.issn_l)\"\n        ></toco-journal-view-info-field>\n      </p>\n    </div>\n    <mat-label style=\"font-weight: bold\">RNPS: </mat-label>\n    <div style=\"margin-left: 0.8em\">\n      <p>\n        <toco-journal-view-info-field\n          [label]=\"'Impreso'\"\n          [value]=\"getIdentifier(IdentifierSchemas.prnps)\"\n        ></toco-journal-view-info-field>\n      </p>\n      <p>\n        <toco-journal-view-info-field\n          [label]=\"'Electr\u00F3nico'\"\n          [value]=\"getIdentifier(IdentifierSchemas.ernps)\"\n        ></toco-journal-view-info-field>\n      </p>\n    </div>\n\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'URL'\"\n        [value]=\"getIdentifier(IdentifierSchemas.url)\"\n      ></toco-journal-view-info-field>\n    </p>\n\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'OAIURL'\"\n        [value]=\"getIdentifier(IdentifierSchemas.oaiurl)\"\n      ></toco-journal-view-info-field>\n    </p>\n\n    <p>\n      <toco-journal-view-info-field *ngIf=\"journalData.source_system\"\n        [label]=\"'Sistema'\"\n        [value]=\"sistemas[journalData.source_system].label\"\n      ></toco-journal-view-info-field>\n    </p>\n\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'Email'\"\n        [value]=\"journalData.email\"\n      ></toco-journal-view-info-field>\n    </p>\n\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'Seriadas Cubanas'\"\n        [value]=\"journalData.seriadas_cubanas\"\n      ></toco-journal-view-info-field>\n    </p>\n\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'Prop\u00F3sito'\"\n        [value]=\"journalData.purpose\"\n      ></toco-journal-view-info-field>\n    </p>\n\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'A\u00F1o de Inicio'\"\n        [value]=\"journalData.start_year | date\"\n      ></toco-journal-view-info-field>\n      <!-- <mat-label style=\"font-weight: bold;\"> A\u00F1o de Inicio: </mat-label>\n      <mat-label *ngIf=\"journalData.start_year\">\n        {{ journalData.start_year | date }}\n      </mat-label>\n      <mat-label\n        *ngIf=\"!journalData.start_year\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      > -->\n    </p>\n\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'A\u00F1o de Fin'\"\n        [value]=\"journalData.end_year | date\"\n      ></toco-journal-view-info-field>\n    </p>\n\n    <p>\n      <toco-journal-view-info-field\n        [label]=\"'Frecuencia de Publicaci\u00F3n'\"\n        [value]=\"journalData.frequency\"\n      ></toco-journal-view-info-field>\n    </p>\n    <mat-label style=\"font-weight: bold\"> Descripci\u00F3n:</mat-label>\n    <mat-label *ngIf=\"!journalData.description\" class=\"text-muted text-through\"\n      >Vac\u00EDo</mat-label\n    >\n    <div\n      *ngIf=\"journalData.description\"\n      class=\"e2e-inner-html-bound text-align-justify\"\n      [innerHTML]=\"journalData.description\"\n    ></div>\n\n    <mat-label style=\"font-weight: bold\">Redes Sociales:</mat-label>\n    <div style=\"margin-left: 0.8em\">\n      <p>\n        <toco-journal-view-info-field\n          [label]=\"'Facebook'\"\n          [value]=\"journalData.socialNetworks.facebook\"\n        ></toco-journal-view-info-field>\n      </p>\n      <p>\n        <toco-journal-view-info-field\n          [label]=\"'Twitter'\"\n          [value]=\"journalData.socialNetworks.twitter\"\n        ></toco-journal-view-info-field>\n      </p>\n      <p>\n        <toco-journal-view-info-field\n          [label]=\"'Linkedin'\"\n          [value]=\"journalData.socialNetworks.linkedin\"\n        ></toco-journal-view-info-field>\n      </p>\n    </div>\n\n    <!-- show terms -->\n\n    <mat-divider\n      [inset]=\"true\"\n      style=\"margin-bottom: 1em; margin-top: 1em\"\n    ></mat-divider>\n\n    <!-- <toco-journal-view-term\n      title=\"Grupo:\"\n      [terms]=\"groupTerms\"\n      [vocab_id]=\"vocabularies.INDEXES_CLASIFICATION\"\n    ></toco-journal-view-term>\n\n    <toco-journal-view-term\n      title=\"Provincia:\"\n      [terms]=\"provinceTerms\"\n      [vocab_id]=\"vocabularies.CUBAN_PROVINCES\"\n    ></toco-journal-view-term> -->\n\n    <toco-journal-view-term\n      title=\"Licencia:\"\n      [terms]=\"licenceTerms\"\n      [vocab_id]=\"vocabularies.LICENCES\"\n    ></toco-journal-view-term>\n\n    <toco-journal-view-term\n      title=\"Materias:\"\n      [terms]=\"subjectTerms\"\n      [vocab_id]=\"vocabularies.SUBJECTS\"\n    ></toco-journal-view-term>\n\n    <mat-card style=\"margin: 1em; background-color: whitesmoke\">\n      <mat-card-header>\n        <mat-card-title>Organizaciones:</mat-card-title>\n      </mat-card-header>\n      <mat-card-content>\n        <toco-source-organizations\n          [sourceData]=\"journalData\"\n          [editable]=\"false\"\n          [ngStyle]=\"{ margin: '1em' }\"\n        >\n        </toco-source-organizations>\n      </mat-card-content>\n    </mat-card>\n\n    <mat-card style=\"margin: 1em; background-color: whitesmoke\">\n      <mat-card-header>\n        <mat-card-title> Indizaciones:</mat-card-title>\n      </mat-card-header>\n      <mat-card-content>\n        <toco-source-indexes\n          [sourceData]=\"journalData\"\n          [editable]=\"false\"\n          [ngStyle]=\"{ margin: '1em' }\"\n        >\n        </toco-source-indexes>\n        <!-- <mat-accordion>\n          <ng-container *ngFor=\"let termSource of dataBaseTerms\">\n            <mat-expansion-panel\n              *ngIf=\"termSource.term.vocabulary == vocabularies.INDEXES\"\n              (opened)=\"panelOpenState = true\"\n              (closed)=\"panelOpenState = false\"\n            >\n              <mat-expansion-panel-header>\n                <mat-panel-title>\n                  {{ termSource.term.description }}\n                </mat-panel-title>\n                <mat-panel-description> </mat-panel-description>\n              </mat-expansion-panel-header>\n              <p *ngIf=\"termSource.data\">\n                <strong>URL: </strong> {{ termSource.data.url }}\n              </p>\n              <p *ngIf=\"termSource.data && termSource.data['initial_cover']\">\n                <strong>Cobertura inicio: </strong>\n                {{ termSource.data[\"initial_cover\"] }}\n              </p>\n              <p *ngIf=\"termSource.data && termSource.data['end_cover']\">\n                <strong>Cobertura hasta: </strong>\n                {{ termSource.data[\"end_cover\"] }}\n              </p>\n            </mat-expansion-panel>\n          </ng-container>\n        </mat-accordion> -->\n      </mat-card-content>\n    </mat-card>\n  </mat-card-content>\n\n  <mat-divider [inset]=\"true\"></mat-divider>\n</mat-card>\n",
                        styles: [".text-muted{color:rgba(0,0,0,.54);padding-left:.2em}.text-through{text-decoration:line-through}.notification-position{position:absolute;top:0;right:0}p{padding-top:.8em}.overlay{opacity:.4;background:#000;width:100%;height:100%;z-index:10;top:0;left:0;position:fixed}"]
                    }] }
        ];
        /** @nocollapse */
        JournalViewInfoComponent.ctorParameters = function () { return [
            { type: SourceService },
            { type: material.MatSnackBar }
        ]; };
        JournalViewInfoComponent.propDecorators = {
            journalVersion: [{ type: core.Input }],
            showVersionLabel: [{ type: core.Input }],
            orgs: [{ type: core.ViewChild, args: [SourceOrganizationsComponent, { static: false },] }],
            indexes: [{ type: core.ViewChild, args: [SourceIndexesComponent, { static: false },] }]
        };
        return JournalViewInfoComponent;
    }());
    if (false) {
        /** @type {?} */
        JournalViewInfoComponent.prototype.journalVersion;
        /** @type {?} */
        JournalViewInfoComponent.prototype.showVersionLabel;
        /** @type {?} */
        JournalViewInfoComponent.prototype.journalData;
        /** @type {?} */
        JournalViewInfoComponent.prototype.tipos;
        /** @type {?} */
        JournalViewInfoComponent.prototype.sistemas;
        /**
         * TODO: In the future databaseTerms and subjectTerms will be changes by
         *  miarTerms and subjectsUnescoTerms
         *  public miarTerms: Array<SourceClasification>;
         *  public subjectsUnescoTerms: Array<SourceClasification>;
         * @type {?}
         */
        JournalViewInfoComponent.prototype.institutionTerms;
        /** @type {?} */
        JournalViewInfoComponent.prototype.dataBaseTerms;
        /** @type {?} */
        JournalViewInfoComponent.prototype.groupTerms;
        /** @type {?} */
        JournalViewInfoComponent.prototype.provinceTerms;
        /** @type {?} */
        JournalViewInfoComponent.prototype.subjectTerms;
        /** @type {?} */
        JournalViewInfoComponent.prototype.licenceTerms;
        /** @type {?} */
        JournalViewInfoComponent.prototype.vocabularies;
        /** @type {?} */
        JournalViewInfoComponent.prototype.panelOpenState;
        /** @type {?} */
        JournalViewInfoComponent.prototype.IdentifierSchemas;
        /** @type {?} */
        JournalViewInfoComponent.prototype.orgs;
        /** @type {?} */
        JournalViewInfoComponent.prototype.indexes;
        /**
         * @type {?}
         * @private
         */
        JournalViewInfoComponent.prototype._sourveService;
        /**
         * @type {?}
         * @private
         */
        JournalViewInfoComponent.prototype._snackBar;
    }
    var JournalViewInfoFieldComponent = /** @class */ (function () {
        function JournalViewInfoFieldComponent() {
            this.emptyLabel = 'Vacío';
        }
        JournalViewInfoFieldComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-journal-view-info-field",
                        template: "\n    <mat-label style=\"font-weight: bold;\">{{label}}: </mat-label>\n    <mat-label *ngIf=\"value\">\n      {{ value }}\n    </mat-label>\n    <mat-label\n      *ngIf=\"!value\"\n      class=\"text-muted text-through\"\n      >{{emptyLabel}}\n    </mat-label\n    >",
                        styles: [".text-muted{color:rgba(0,0,0,.54);padding-left:.2em}.text-through{text-decoration:line-through}.notification-position{position:absolute;top:0;right:0}p{padding-top:.8em}.overlay{opacity:.4;background:#000;width:100%;height:100%;z-index:10;top:0;left:0;position:fixed}"]
                    }] }
        ];
        JournalViewInfoFieldComponent.propDecorators = {
            label: [{ type: core.Input }],
            value: [{ type: core.Input }],
            emptyLabel: [{ type: core.Input }]
        };
        return JournalViewInfoFieldComponent;
    }());
    if (false) {
        /** @type {?} */
        JournalViewInfoFieldComponent.prototype.label;
        /** @type {?} */
        JournalViewInfoFieldComponent.prototype.value;
        /** @type {?} */
        JournalViewInfoFieldComponent.prototype.emptyLabel;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/journal-view/journal-view-version-field.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * This component share the same scss that `JournalViewComponent`.
     * His goal, handle the actions and how show a specific data of a `JournalData`
     */
    var JournalViewFieldComponent = /** @class */ (function () {
        function JournalViewFieldComponent() {
            this.editingJournalChange = new core.EventEmitter();
            this.journalDataType = JournalDataType;
            this.IdentifierSchemas = IdentifierSchemas;
        }
        /**
         * @return {?}
         */
        JournalViewFieldComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.editingJournal.data == undefined)
                this.editingJournal.data = new JournalData();
            if (this.currentJournal.data == undefined)
                this.currentJournal.data = new JournalData();
            if (this.type == undefined)
                this.type = JournalDataType.default;
        };
        /**
     * Replaces a `Journal` property by a equal property in `JournalData`.
     * @param type is a `JournalDataType` enum, that means, `type` has all properties of a `Journal` enumerated as identifyer.
     * @param concat is a `boolean`, by default in `false`. If his value is `true` means the fields will be concated and not replaced.
     * @NOTE The `terms` of a `Journal` can NOT replace because will be the same information and not have sense, only we can merge.
     */
        /**
         * Replaces a `Journal` property by a equal property in `JournalData`.
         * \@NOTE The `terms` of a `Journal` can NOT replace because will be the same information and not have sense, only we can merge.
         * @param {?} type is a `JournalDataType` enum, that means, `type` has all properties of a `Journal` enumerated as identifyer.
         * @param {?=} concat is a `boolean`, by default in `false`. If his value is `true` means the fields will be concated and not replaced.
         * @return {?}
         */
        JournalViewFieldComponent.prototype.replace = /**
         * Replaces a `Journal` property by a equal property in `JournalData`.
         * \@NOTE The `terms` of a `Journal` can NOT replace because will be the same information and not have sense, only we can merge.
         * @param {?} type is a `JournalDataType` enum, that means, `type` has all properties of a `Journal` enumerated as identifyer.
         * @param {?=} concat is a `boolean`, by default in `false`. If his value is `true` means the fields will be concated and not replaced.
         * @return {?}
         */
        function (type, concat) {
            if (concat === void 0) { concat = false; }
            switch (type) {
                case JournalDataType.description:
                    concat ?
                        this.editingJournal.data.description += ' ' + this.currentJournal.data.description :
                        this.editingJournal.data.description = this.currentJournal.data.description;
                    break;
                case JournalDataType.email:
                    concat ?
                        this.editingJournal.data.email += ' ' + this.currentJournal.data.email :
                        this.editingJournal.data.email = this.currentJournal.data.email;
                    break;
                case JournalDataType.end_year:
                    concat ?
                        this.editingJournal.data.end_year += ' ' + this.currentJournal.data.end_year :
                        this.editingJournal.data.end_year = this.currentJournal.data.end_year;
                    break;
                case JournalDataType.facebook:
                    concat ?
                        this.editingJournal.data.socialNetworks.facebook += ' ' + this.currentJournal.data.socialNetworks.facebook :
                        this.editingJournal.data.socialNetworks.facebook = this.currentJournal.data.socialNetworks.facebook;
                    break;
                case JournalDataType.frequency:
                    concat ?
                        this.editingJournal.data.frequency += ' ' + this.currentJournal.data.frequency :
                        this.editingJournal.data.frequency = this.currentJournal.data.frequency;
                    break;
                case JournalDataType.issnP:
                    concat ?
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.issn_p, this.editingJournal.data.getIdentifierValue(IdentifierSchemas.issn_p) +
                            ' ' +
                            this.currentJournal.data.getIdentifierValue(IdentifierSchemas.issn_p)) :
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.issn_p, this.currentJournal.data.getIdentifierValue(IdentifierSchemas.issn_p));
                    break;
                case JournalDataType.issnE:
                    concat ?
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.issn_e, this.editingJournal.data.getIdentifierValue(IdentifierSchemas.issn_e) +
                            ' ' +
                            this.currentJournal.data.getIdentifierValue(IdentifierSchemas.issn_e)) :
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.issn_e, this.currentJournal.data.getIdentifierValue(IdentifierSchemas.issn_e));
                    break;
                case JournalDataType.issnL:
                    concat ?
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.issn_l, this.editingJournal.data.getIdentifierValue(IdentifierSchemas.issn_l) +
                            ' ' +
                            this.currentJournal.data.getIdentifierValue(IdentifierSchemas.issn_l)) :
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.issn_l, this.currentJournal.data.getIdentifierValue(IdentifierSchemas.issn_l));
                    break;
                case JournalDataType.rnpsP:
                    concat ?
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.prnps, this.editingJournal.data.getIdentifierValue(IdentifierSchemas.prnps) +
                            ' ' +
                            this.currentJournal.data.getIdentifierValue(IdentifierSchemas.prnps)) :
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.prnps, this.currentJournal.data.getIdentifierValue(IdentifierSchemas.prnps));
                    break;
                case JournalDataType.rnpsE:
                    concat ?
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.ernps, this.editingJournal.data.getIdentifierValue(IdentifierSchemas.ernps) +
                            ' ' +
                            this.currentJournal.data.getIdentifierValue(IdentifierSchemas.ernps)) :
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.ernps, this.currentJournal.data.getIdentifierValue(IdentifierSchemas.ernps));
                    break;
                case JournalDataType.end_year:
                    concat ?
                        this.editingJournal.data.end_year += ' ' + this.currentJournal.data.end_year :
                        this.editingJournal.data.end_year = this.currentJournal.data.end_year;
                    break;
                case JournalDataType.linkedin:
                    concat ?
                        this.editingJournal.data.socialNetworks.linkedin += ' ' + this.currentJournal.data.socialNetworks.linkedin :
                        this.editingJournal.data.socialNetworks.linkedin = this.currentJournal.data.socialNetworks.linkedin;
                    break;
                case JournalDataType.logo:
                    concat ?
                        this.editingJournal.data.logo += ' ' + this.currentJournal.data.logo :
                        this.editingJournal.data.logo = this.currentJournal.data.logo;
                    break;
                case JournalDataType.purpose:
                    concat ?
                        this.editingJournal.data.purpose += ' ' + this.currentJournal.data.purpose :
                        this.editingJournal.data.purpose = this.currentJournal.data.purpose;
                    break;
                case JournalDataType.seriadas_cubanas:
                    concat ?
                        this.editingJournal.data.seriadas_cubanas += ' ' + this.currentJournal.data.seriadas_cubanas :
                        this.editingJournal.data.seriadas_cubanas = this.currentJournal.data.seriadas_cubanas;
                    break;
                case JournalDataType.shortname:
                    concat ?
                        this.editingJournal.data.shortname += ' ' + this.currentJournal.data.shortname :
                        this.editingJournal.data.shortname = this.currentJournal.data.shortname;
                    break;
                case JournalDataType.start_year:
                    concat ?
                        this.editingJournal.data.start_year += ' ' + this.currentJournal.data.start_year :
                        this.editingJournal.data.start_year = this.currentJournal.data.start_year;
                    break;
                case JournalDataType.subtitle:
                    concat ?
                        this.editingJournal.data.subtitle += ' ' + this.currentJournal.data.subtitle :
                        this.editingJournal.data.subtitle = this.currentJournal.data.subtitle;
                    break;
                case JournalDataType.title:
                    concat ?
                        this.editingJournal.data.title += ' ' + this.currentJournal.data.title :
                        this.editingJournal.data.title = this.currentJournal.data.title;
                    break;
                case JournalDataType.twitter:
                    concat ?
                        this.editingJournal.data.socialNetworks.twitter += ' ' + this.currentJournal.data.socialNetworks.twitter :
                        this.editingJournal.data.socialNetworks.twitter = this.currentJournal.data.socialNetworks.twitter;
                    break;
                case JournalDataType.url:
                    concat ?
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.url, this.editingJournal.data.getIdentifierValue(IdentifierSchemas.url) +
                            ' ' +
                            this.currentJournal.data.getIdentifierValue(IdentifierSchemas.url)) :
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.url, this.currentJournal.data.getIdentifierValue(IdentifierSchemas.url));
                    break;
                case JournalDataType.oaiurl:
                    concat ?
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.oaiurl, this.editingJournal.data.getIdentifierValue(IdentifierSchemas.oaiurl) +
                            ' ' +
                            this.currentJournal.data.getIdentifierValue(IdentifierSchemas.oaiurl)) :
                        this.editingJournal.data.setIdentifierValue(IdentifierSchemas.oaiurl, this.currentJournal.data.getIdentifierValue(IdentifierSchemas.oaiurl));
                    break;
            }
            this.editingJournalChange.emit(this.editingJournal);
        };
        JournalViewFieldComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-journal-view-version-field',
                        template: "<div>\n  <button\n    mat-icon-button\n    aria-label=\"Next version\"\n    matTooltip=\"Remplazar\"\n    (click)=\"replace(type)\"\n  >\n    <mat-icon color=\"warn\">layers</mat-icon>\n  </button>\n\n  <!-- <button mat-icon-button aria-label=\"Next version\" matTooltip=\"Mezclar\" (click)=\"concat(type)\">\n        <mat-icon color=\"warn\">merge_type</mat-icon>\n    </button> -->\n\n  <ng-container [ngSwitch]=\"type\">\n    <ng-container *ngSwitchCase=\"journalDataType.title\">\n      <mat-label style=\"font-weight: bold\">T\u00EDtulo:</mat-label>\n      <mat-label *ngIf=\"currentJournal.data.title\">\n        {{ currentJournal.data.title }}\n      </mat-label>\n      <mat-label\n        *ngIf=\"!currentJournal.data.title\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.subtitle\">\n      <mat-label style=\"font-weight: bold\">Subt\u00EDtulo:</mat-label>\n      <mat-label *ngIf=\"currentJournal.data.subtitle\">\n        {{ currentJournal.data.subtitle }}\n      </mat-label>\n      <mat-label\n        *ngIf=\"!currentJournal.data.subtitle\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.shortname\">\n      <mat-label style=\"font-weight: bold\">Nombre Abreviado:</mat-label>\n      <mat-label *ngIf=\"currentJournal.data.shortname\">\n        {{ currentJournal.data.shortname }}\n      </mat-label>\n      <mat-label\n        *ngIf=\"!currentJournal.data.shortname\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.issnP\">\n      <toco-journal-view-info-field\n        [label]=\"'Impreso'\"\n        [value]=\"\n          currentJournal.data.getIdentifierValue(IdentifierSchemas.issn_p)\n        \"\n      ></toco-journal-view-info-field>\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.issnE\">\n      <toco-journal-view-info-field\n        [label]=\"'Electr\u00F3nico'\"\n        [value]=\"\n          currentJournal.data.getIdentifierValue(IdentifierSchemas.issn_e)\n        \"\n      ></toco-journal-view-info-field>\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.issnL\">\n      <toco-journal-view-info-field\n        [label]=\"'De enlace'\"\n        [value]=\"\n          currentJournal.data.getIdentifierValue(IdentifierSchemas.issn_l)\n        \"\n      ></toco-journal-view-info-field>\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.rnpsP\">\n      <toco-journal-view-info-field\n        [label]=\"'Impreso'\"\n        [value]=\"\n          currentJournal.data.getIdentifierValue(IdentifierSchemas.prnps)\n        \"\n      ></toco-journal-view-info-field>\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.rnpsE\">\n      <toco-journal-view-info-field\n        [label]=\"'Electr\u00F3nico'\"\n        [value]=\"\n          currentJournal.data.getIdentifierValue(IdentifierSchemas.ernps)\n        \"\n      ></toco-journal-view-info-field>\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.url\">\n      <toco-journal-view-info-field\n        [label]=\"'URL'\"\n        [value]=\"currentJournal.data.getIdentifierValue(IdentifierSchemas.url)\"\n      ></toco-journal-view-info-field>\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.oaiurl\">\n      <toco-journal-view-info-field\n        [label]=\"'OAIURL'\"\n        [value]=\"\n          currentJournal.data.getIdentifierValue(IdentifierSchemas.oaiurl)\n        \"\n      ></toco-journal-view-info-field>\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.email\">\n      <mat-label style=\"font-weight: bold\">Email:</mat-label>\n      <mat-label *ngIf=\"currentJournal.data.email\">\n        {{ currentJournal.data.email }}\n      </mat-label>\n      <mat-label\n        *ngIf=\"!currentJournal.data.email\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.purpose\">\n      <mat-label style=\"font-weight: bold\">Prop\u00F3sito:</mat-label>\n      <mat-label *ngIf=\"currentJournal.data.purpose\">\n        {{ currentJournal.data.purpose }}\n      </mat-label>\n      <mat-label\n        *ngIf=\"!currentJournal.data.purpose\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.start_year\">\n      <mat-label style=\"font-weight: bold\">A\u00F1o de Inicio:</mat-label>\n      <mat-label *ngIf=\"currentJournal.data.start_year\">\n        {{ currentJournal.data.start_year | date }}\n      </mat-label>\n      <mat-label\n        *ngIf=\"!currentJournal.data.start_year\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.end_year\">\n      <mat-label style=\"font-weight: bold\">A\u00F1o de Fin:</mat-label>\n      <mat-label *ngIf=\"currentJournal.data.end_year\">\n        {{ currentJournal.data.end_year | date }}\n      </mat-label>\n      <mat-label\n        *ngIf=\"!currentJournal.data.end_year\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.frequency\">\n      <mat-label style=\"font-weight: bold\"\n        >Frecuencia de Publicaci\u00F3n:</mat-label\n      >\n      <mat-label *ngIf=\"currentJournal.data.frequency\">\n        {{ currentJournal.data.frequency }}\n      </mat-label>\n      <mat-label\n        *ngIf=\"!currentJournal.data.frequency\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.seriadas_cubanas\">\n      <mat-label style=\"font-weight: bold\">Seriadas Cubanas:</mat-label>\n      <a\n        href=\"{{ currentJournal.data.seriadas_cubanas }}\"\n        target=\"_blanck\"\n        *ngIf=\"currentJournal.data.seriadas_cubanas\"\n      >\n        {{ currentJournal.data.seriadas_cubanas }}\n      </a>\n      <mat-label\n        *ngIf=\"!currentJournal.data.seriadas_cubanas\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.facebook\">\n      <mat-label style=\"font-weight: bold\">Facebook:</mat-label>\n      <a\n        href=\"{{ currentJournal.data.socialNetworks.facebook }}\"\n        target=\"_blanck\"\n        *ngIf=\"currentJournal.data.socialNetworks.facebook\"\n      >\n        {{ currentJournal.data.socialNetworks.facebook }}\n      </a>\n      <mat-label\n        *ngIf=\"!currentJournal.data.socialNetworks.facebook\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.twitter\">\n      <mat-label style=\"font-weight: bold\">Twitter:</mat-label>\n      <a\n        href=\"{{ currentJournal.data.socialNetworks.twitter }}\"\n        target=\"_blanck\"\n        *ngIf=\"currentJournal.data.socialNetworks.twitter\"\n      >\n        {{ currentJournal.data.socialNetworks.twitter }}\n      </a>\n      <mat-label\n        *ngIf=\"!currentJournal.data.socialNetworks.twitter\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.linkedin\">\n      <mat-label style=\"font-weight: bold\">Linkedin:</mat-label>\n      <a\n        href=\"{{ currentJournal.data.socialNetworks.linkedin }}\"\n        target=\"_blanck\"\n        *ngIf=\"currentJournal.data.socialNetworks.linkedin\"\n      >\n        {{ currentJournal.data.socialNetworks.linkedin }}\n      </a>\n      <mat-label\n        *ngIf=\"!currentJournal.data.socialNetworks.linkedin\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n\n    <ng-container *ngSwitchCase=\"journalDataType.description\">\n      <mat-label style=\"font-weight: bold\">Descripci\u00F3n:</mat-label>\n      <mat-label\n        *ngIf=\"!currentJournal.data.description\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n    </ng-container>\n  </ng-container>\n\n  <!-- <mat-icon class=\"mat-18\" color=\"accent\" *ngIf=\"currentJournal.data.data && currentJournal.data.subtitle !== '' && currentJournal.data.subtitle !== currentcurrentJournal.data.subtitle\" matTooltip=\"Tiene cambios\">notifications</mat-icon> -->\n</div>\n",
                        styles: [".text-muted{color:rgba(0,0,0,.54);padding-left:.2em}.text-through{text-decoration:line-through}.notification-position{position:absolute;top:0;right:0}p{padding-top:.8em}.overlay{opacity:.4;background:#000;width:100%;height:100%;z-index:10;top:0;left:0;position:fixed}"]
                    }] }
        ];
        /** @nocollapse */
        JournalViewFieldComponent.ctorParameters = function () { return []; };
        JournalViewFieldComponent.propDecorators = {
            editingJournal: [{ type: core.Input }],
            currentJournal: [{ type: core.Input }],
            type: [{ type: core.Input }],
            editingJournalChange: [{ type: core.Output }]
        };
        return JournalViewFieldComponent;
    }());
    if (false) {
        /** @type {?} */
        JournalViewFieldComponent.prototype.editingJournal;
        /** @type {?} */
        JournalViewFieldComponent.prototype.currentJournal;
        /** @type {?} */
        JournalViewFieldComponent.prototype.type;
        /** @type {?} */
        JournalViewFieldComponent.prototype.editingJournalChange;
        /** @type {?} */
        JournalViewFieldComponent.prototype.journalDataType;
        /** @type {?} */
        JournalViewFieldComponent.prototype.IdentifierSchemas;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/journal-view/journal-view-version.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var JournalViewVersionComponent = /** @class */ (function () {
        function JournalViewVersionComponent(_snackBar) {
            this._snackBar = _snackBar;
            this.journalDataType = JournalDataType;
            this.panelOpenState = false;
            this.currentJournalChecked = false;
            this.editingJournalChange = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        JournalViewVersionComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (this.currentJournal == undefined)
                this.currentJournal = new JournalVersion();
            this.loadJournalData();
            if (this.type == undefined)
                this.type = JournalDataType.default;
        };
        /**
         * @return {?}
         */
        JournalViewVersionComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            console.log("***////****////***///");
            this.ngOnInit();
        };
        /**
         * @return {?}
         */
        JournalViewVersionComponent.prototype.loadJournalData = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.currentDataBaseTerms = new Array();
            this.currentGroupTerms = new Array();
            this.currentInstitutionTerms = new Array();
            this.currentLicenceTerms = new Array();
            this.currentProvinceTerms = new Array();
            this.currentSubjectTerms = new Array();
            this.vocabularies = VocabulariesInmutableNames;
            if (this.currentJournal.data.classifications) {
                this.currentJournal.data.classifications.forEach((/**
                 * @param {?} termSource
                 * @return {?}
                 */
                function (termSource) {
                    switch (termSource.vocabulary.toString()) {
                        case VocabulariesInmutableNames.CUBAN_INTITUTIONS:
                            _this.currentInstitutionTerms.push(termSource);
                            break;
                        case VocabulariesInmutableNames.INDEXES:
                            _this.currentDataBaseTerms.push(termSource);
                            break;
                        case VocabulariesInmutableNames.INDEXES_CLASIFICATION:
                            _this.currentGroupTerms.push(termSource);
                            break;
                        case VocabulariesInmutableNames.LICENCES:
                            _this.currentLicenceTerms.push(termSource);
                            break;
                        case VocabulariesInmutableNames.CUBAN_PROVINCES:
                            _this.currentProvinceTerms.push(termSource);
                            break;
                        case VocabulariesInmutableNames.SUBJECTS:
                            _this.currentSubjectTerms.push(termSource);
                            break;
                    }
                }));
            }
        };
        /**
         * Changes the field `reviewed` of a `Journal`, that means the user saw these version
         * and consider it not has more information.
         */
        /**
         * Changes the field `reviewed` of a `Journal`, that means the user saw these version
         * and consider it not has more information.
         * @return {?}
         */
        JournalViewVersionComponent.prototype.markAsViewed = /**
         * Changes the field `reviewed` of a `Journal`, that means the user saw these version
         * and consider it not has more information.
         * @return {?}
         */
        function () {
            if (this.currentJournalChecked) {
                this.currentJournal.data.reviewed = true;
                // TODO: hacer el request al backend de marcar la version como vista o
                /** @type {?} */
                var m = new MessageHandler(this._snackBar);
                m.showMessage(StatusCode.OK, "Revisión marcada como vista!!!");
            }
        };
        /**
         * @return {?}
         */
        JournalViewVersionComponent.prototype.fieldEditingJournalChange = /**
         * @return {?}
         */
        function () {
            this.editingJournalChange.emit(this.editingJournal);
        };
        /**
         * @return {?}
         */
        JournalViewVersionComponent.prototype.replace = /**
         * @return {?}
         */
        function () {
            this.editingJournal = this.currentJournal;
            // this.editingJournal.data.classifications = [];
            // this.editingJournal.data.classifications = this.currentJournal.data.classifications;
            this.editingJournalChange.emit(this.editingJournal);
            // // this.currentJournal.data.classifications.forEach((termSource: SourceClasification) => {
            // //     this.editingJournal.data.classifications.push(termSource);
            // // });
            console.log("editingJournal remplazado", this.editingJournal);
        };
        /**
         * Concats a `Journal` property by a equal property in `JournalData`.
         * @param type is a `JournalDataType` enum, that means, `type` has all properties of a `Journal` enumerated as identifyer.
         * @param termId is a `Term` identifyer, only needs if `type` is `JournalDataType.term`.
         * @NOTE this function call `replace(..., true)`
         */
        /**
         * Concats a `Journal` property by a equal property in `JournalData`.
         * \@NOTE this function call `replace(..., true)`
         * @param {?} type is a `JournalDataType` enum, that means, `type` has all properties of a `Journal` enumerated as identifyer.
         * @param {?} termSource
         * @return {?}
         */
        JournalViewVersionComponent.prototype.concat = /**
         * Concats a `Journal` property by a equal property in `JournalData`.
         * \@NOTE this function call `replace(..., true)`
         * @param {?} type is a `JournalDataType` enum, that means, `type` has all properties of a `Journal` enumerated as identifyer.
         * @param {?} termSource
         * @return {?}
         */
        function (type, termSource) {
            if (type == JournalDataType.term) {
                /** @type {?} */
                var notFound = true;
                for (var index = 0; index < this.editingJournal.data.classifications.length; index++) {
                    /** @type {?} */
                    var element = this.editingJournal.data.classifications[index];
                    if (element.id == termSource.id) {
                        this.editingJournal.data.classifications[index].data =
                            termSource.data;
                        notFound = false;
                    }
                }
                if (notFound) {
                    this.editingJournal.data.classifications.push(termSource);
                }
                this.editingJournalChange.emit(this.editingJournal);
            }
        };
        /**
         * @return {?}
         */
        JournalViewVersionComponent.prototype.replaceSubjects = /**
         * @return {?}
         */
        function () {
            this.replaceClassifications(VocabulariesInmutableNames.SUBJECTS);
        };
        /**
         * @return {?}
         */
        JournalViewVersionComponent.prototype.replaceIndexes = /**
         * @return {?}
         */
        function () {
            this.replaceClassifications(VocabulariesInmutableNames.INDEXES);
        };
        /**
         * @param {?} vocab
         * @return {?}
         */
        JournalViewVersionComponent.prototype.replaceClassifications = /**
         * @param {?} vocab
         * @return {?}
         */
        function (vocab) {
            /** @type {?} */
            var found = false;
            /** @type {?} */
            var newts = [];
            this.editingJournal.data.classifications.forEach((/**
             * @param {?} ts
             * @return {?}
             */
            function (ts) {
                if (ts.vocabulary != vocab) {
                    newts.push(ts);
                }
            }));
            this.currentJournal.data.classifications.forEach((/**
             * @param {?} ts
             * @return {?}
             */
            function (ts) {
                if (ts.vocabulary == vocab) {
                    newts.push(ts);
                }
            }));
            this.editingJournal.data.classifications = newts;
            this.editingJournalChange.emit(this.editingJournal);
        };
        /**
         * @return {?}
         */
        JournalViewVersionComponent.prototype.replaceOrganizations = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var found = false;
            /** @type {?} */
            var newts = [];
            this.currentJournal.data.organizations.forEach((/**
             * @param {?} ts
             * @return {?}
             */
            function (ts) {
                newts.push(ts);
            }));
            this.editingJournal.data.organizations = newts;
            this.editingJournalChange.emit(this.editingJournal);
        };
        JournalViewVersionComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-journal-view-version",
                        template: "<mat-card *ngIf=\"currentJournal.data\">\n  <mat-card-header>\n    <!-- <img mat-card-avatar *ngIf=\"currentJournal.data.logo; else logotemplate\" [style.background-size]=\"'cover'\" src=\"currentJournal.data.logo\">\n            <ng-template #logotemplate>\n                <img mat-card-avatar [src]=\"defaultLogo\" alt=\"\">\n            </ng-template> -->\n\n    <mat-card-title>\n      <div fxLAyout=\"row\" fxLayoutAlign=\"space-between start\">\n        <mat-icon\n          class=\"mat-18 notification-position\"\n          color=\"accent\"\n          *ngIf=\"currentJournal.is_current\"\n          matTooltip=\"{{ currentJournal.comment }}\"\n          >star</mat-icon\n        >\n        <mat-icon\n          class=\"mat-18 notification-position\"\n          color=\"accent\"\n          *ngIf=\"!currentJournal.reviewed\"\n          matTooltip=\"{{ currentJournal.comment }}\"\n          >adjust</mat-icon\n        >\n      </div>\n    </mat-card-title>\n\n    <mat-card-subtitle>\n      <mat-label> {{ currentJournal.created_at | date }}. </mat-label>\n      <mat-label>\n        {{ currentJournal.userprofile.identify() }}\n      </mat-label>\n    </mat-card-subtitle>\n  </mat-card-header>\n\n  <mat-divider [inset]=\"true\" style=\"margin-bottom: 1em\"></mat-divider>\n\n  <mat-card-content>\n    <toco-journal-view-version-field\n      (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.title\"\n    ></toco-journal-view-version-field>\n\n    <!-- subtitle -->\n    <toco-journal-view-version-field\n      (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.subtitle\"\n    ></toco-journal-view-version-field>\n\n    <toco-journal-view-version-field\n    (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.shortname\"\n    ></toco-journal-view-version-field>\n\n    <mat-label style=\"font-weight: bold\">ISSN: </mat-label>\n    <div style=\"margin-left: 0.8em\">\n      <toco-journal-view-version-field\n      (editingJournalChange)=\"fieldEditingJournalChange()\"\n        [editingJournal]=\"editingJournal\"\n        [currentJournal]=\"currentJournal\"\n        [type]=\"journalDataType.issnP\"\n      ></toco-journal-view-version-field>\n\n      <toco-journal-view-version-field\n      (editingJournalChange)=\"fieldEditingJournalChange()\"\n        [editingJournal]=\"editingJournal\"\n        [currentJournal]=\"currentJournal\"\n        [type]=\"journalDataType.issnE\"\n      ></toco-journal-view-version-field>\n\n      <toco-journal-view-version-field\n      (editingJournalChange)=\"fieldEditingJournalChange()\"\n        [editingJournal]=\"editingJournal\"\n        [currentJournal]=\"currentJournal\"\n        [type]=\"journalDataType.issnL\"\n      ></toco-journal-view-version-field>\n    </div>\n    <mat-label style=\"font-weight: bold\">RNPS: </mat-label>\n    <div style=\"margin-left: 0.8em\">\n      <toco-journal-view-version-field\n      (editingJournalChange)=\"fieldEditingJournalChange()\"\n        [editingJournal]=\"editingJournal\"\n        [currentJournal]=\"currentJournal\"\n        [type]=\"journalDataType.rnpsP\"\n      ></toco-journal-view-version-field>\n      <toco-journal-view-version-field\n      (editingJournalChange)=\"fieldEditingJournalChange()\"\n        [editingJournal]=\"editingJournal\"\n        [currentJournal]=\"currentJournal\"\n        [type]=\"journalDataType.rnpsE\"\n      ></toco-journal-view-version-field>\n    </div>\n    <toco-journal-view-version-field\n    (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.url\"\n    ></toco-journal-view-version-field>\n\n    <toco-journal-view-version-field\n    (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.oaiurl\"\n    ></toco-journal-view-version-field>\n\n    <toco-journal-view-version-field\n    (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.email\"\n    ></toco-journal-view-version-field>\n\n    <toco-journal-view-version-field\n    (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.seriadas_cubanas\"\n    ></toco-journal-view-version-field>\n\n    <toco-journal-view-version-field\n    (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.purpose\"\n    ></toco-journal-view-version-field>\n\n    <toco-journal-view-version-field\n    (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.start_year\"\n    ></toco-journal-view-version-field>\n\n    <toco-journal-view-version-field\n    (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.end_year\"\n    ></toco-journal-view-version-field>\n\n    <toco-journal-view-version-field\n    (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.frequency\"\n    ></toco-journal-view-version-field>\n\n    <toco-journal-view-version-field\n    (editingJournalChange)=\"fieldEditingJournalChange()\"\n      [editingJournal]=\"editingJournal\"\n      [currentJournal]=\"currentJournal\"\n      [type]=\"journalDataType.description\"\n    ></toco-journal-view-version-field>\n\n    <div\n      *ngIf=\"currentJournal.data.description\"\n      class=\"e2e-inner-html-bound text-align-justify\"\n      [innerHTML]=\"currentJournal.data.description\"\n    ></div>\n\n    <mat-label style=\"font-weight: bold\">Redes Sociales:</mat-label>\n    <div style=\"margin-left: 0.8em\">\n      <toco-journal-view-version-field\n      (editingJournalChange)=\"fieldEditingJournalChange()\"\n        [editingJournal]=\"editingJournal\"\n        [currentJournal]=\"currentJournal\"\n        [type]=\"journalDataType.facebook\"\n      ></toco-journal-view-version-field>\n\n      <toco-journal-view-version-field\n      (editingJournalChange)=\"fieldEditingJournalChange()\"\n        [editingJournal]=\"editingJournal\"\n        [currentJournal]=\"currentJournal\"\n        [type]=\"journalDataType.twitter\"\n      ></toco-journal-view-version-field>\n\n      <toco-journal-view-version-field\n      (editingJournalChange)=\"fieldEditingJournalChange()\"\n        [editingJournal]=\"editingJournal\"\n        [currentJournal]=\"currentJournal\"\n        [type]=\"journalDataType.linkedin\"\n      ></toco-journal-view-version-field>\n    </div>\n\n    <!-- show terms -->\n    <mat-divider\n      [inset]=\"true\"\n      style=\"margin-bottom: 1em; margin-top: 1em\"\n    ></mat-divider>\n\n    <!-- <p>\n      <mat-label style=\"font-weight: bold;\"> Instituci\u00F3n: </mat-label>\n      <mat-label\n        *ngIf=\"currentInstitutionTerms.length == 0\"\n        class=\"text-muted text-through\"\n        >Vac\u00EDo</mat-label\n      >\n      <ng-container *ngFor=\"let termSource of currentInstitutionTerms\">\n        <mat-label style=\"padding-left: 1em;\">\n          {{ termSource.description }}\n        </mat-label>\n      </ng-container>\n    </p> -->\n    <!-- <mat-card style=\"margin: 1em; background-color: whitesmoke;\">\n      <mat-card-header>\n        <mat-card-title> Grupo: </mat-card-title>\n        <mat-label\n          *ngIf=\"currentGroupTerms.length == 0\"\n          class=\"text-muted text-through\"\n          >Vac\u00EDo</mat-label\n        >\n      </mat-card-header>\n      <mat-card-content>\n        <mat-chip-list>\n          <ng-container *ngFor=\"let termSource of currentGroupTerms\">\n            <mat-chip>\n              <button\n                mat-icon-button\n                color=\"accent\"\n                matTooltip=\"Agregar\"\n                (click)=\"concat(journalDataType.term, termSource)\"\n              >\n                <mat-icon class=\"mat-18\">merge_type</mat-icon>\n              </button>\n              {{ termSource.description }}\n            </mat-chip>\n          </ng-container>\n        </mat-chip-list>\n      </mat-card-content>\n    </mat-card>\n\n    <mat-card style=\"margin: 1em; background-color: whitesmoke;\">\n      <mat-card-header>\n        <mat-card-title> Provincia: </mat-card-title>\n        <mat-label\n          *ngIf=\"currentProvinceTerms.length == 0\"\n          class=\"text-muted text-through\"\n          >Vac\u00EDo</mat-label\n        >\n      </mat-card-header>\n      <mat-card-content>\n        <mat-chip-list>\n          <ng-container *ngFor=\"let termSource of currentProvinceTerms\">\n            <mat-chip>\n              <button\n                mat-icon-button\n                color=\"accent\"\n                matTooltip=\"Agregar\"\n                (click)=\"concat(journalDataType.term, termSource)\"\n              >\n                <mat-icon class=\"mat-18\">merge_type</mat-icon>\n              </button>\n              {{ termSource.description }}\n            </mat-chip>\n          </ng-container>\n        </mat-chip-list>\n      </mat-card-content>\n    </mat-card> -->\n\n    <mat-card style=\"margin: 1em; background-color: whitesmoke\">\n      <mat-card-header>\n        <mat-card-title> Licencia: </mat-card-title>\n        <mat-label\n          *ngIf=\"currentLicenceTerms.length == 0\"\n          class=\"text-muted text-through\"\n          >Vac\u00EDo</mat-label\n        >\n      </mat-card-header>\n      <mat-card-content>\n        <mat-chip-list>\n          <ng-container *ngFor=\"let termSource of currentLicenceTerms\">\n            <mat-chip>\n              <button\n                mat-icon-button\n                color=\"accent\"\n                matTooltip=\"Agregar\"\n                (click)=\"concat(journalDataType.term, termSource)\"\n              >\n                <mat-icon class=\"mat-18\">merge_type</mat-icon>\n              </button>\n              {{ termSource.description }}\n            </mat-chip>\n          </ng-container>\n        </mat-chip-list>\n      </mat-card-content>\n    </mat-card>\n\n    <mat-card style=\"margin: 1em; background-color: whitesmoke\">\n      <mat-card-header>\n        <mat-card-title>\n          <button\n            mat-icon-button\n            color=\"accent\"\n            matTooltip=\"Reemplazar\"\n            (click)=\"replaceSubjects()\"\n          >\n            <mat-icon class=\"mat-18\">merge_type</mat-icon>\n          </button>\n\n          Materias:\n        </mat-card-title>\n        <mat-label\n          *ngIf=\"currentSubjectTerms.length == 0\"\n          class=\"text-muted text-through\"\n          >Vac\u00EDo</mat-label\n        >\n      </mat-card-header>\n      <mat-card-content>\n        <mat-chip-list>\n          <ng-container *ngFor=\"let termSource of currentSubjectTerms\">\n            <mat-chip>\n              <!-- <button\n                mat-icon-button\n                color=\"accent\"\n                matTooltip=\"Agregar\"\n                (click)=\"concat(journalDataType.term, termSource)\"\n              >\n                <mat-icon class=\"mat-18\">merge_type</mat-icon>\n              </button> -->\n              {{ termSource.description }}\n            </mat-chip>\n          </ng-container>\n        </mat-chip-list>\n      </mat-card-content>\n    </mat-card>\n\n    <mat-card style=\"margin: 1em; background-color: whitesmoke\">\n      <mat-card-header>\n        <mat-card-title>\n          <button\n            mat-icon-button\n            color=\"accent\"\n            matTooltip=\"Reemplazar\"\n            (click)=\"replaceOrganizations()\"\n          >\n            <mat-icon class=\"mat-18\">merge_type</mat-icon>\n          </button>\n          Organizaciones:\n        </mat-card-title>\n      </mat-card-header>\n      <mat-card-content>\n        <toco-source-organizations\n          [sourceData]=\"currentJournal.data\"\n          [editable]=\"false\"\n          [ngStyle]=\"{ margin: '1em' }\"\n        >\n        </toco-source-organizations>\n      </mat-card-content>\n    </mat-card>\n\n    <mat-card style=\"margin: 1em; background-color: whitesmoke\">\n      <mat-card-header>\n        <mat-card-title>\n          <button\n            mat-icon-button\n            color=\"accent\"\n            matTooltip=\"Reemplazar\"\n            (click)=\"replaceIndexes()\"\n          >\n            <mat-icon class=\"mat-18\">merge_type</mat-icon>\n          </button>\n\n          Indizaciones:\n        </mat-card-title>\n        <!-- <mat-label\n          *ngIf=\"currentDataBaseTerms.length == 0\"\n          class=\"text-muted text-through\"\n          >Vac\u00EDo</mat-label\n        > -->\n      </mat-card-header>\n      <mat-card-content>\n        <toco-source-indexes\n          [sourceData]=\"currentJournal.data\"\n          [editable]=\"false\"\n          [ngStyle]=\"{ margin: '1em' }\"\n        >\n        </toco-source-indexes>\n        <!-- <mat-accordion>\n          <ng-container *ngFor=\"let termSource of currentDataBaseTerms\">\n            <mat-expansion-panel\n              (opened)=\"panelOpenState = true\"\n              (closed)=\"panelOpenState = false\"\n            >\n              <mat-expansion-panel-header>\n                <mat-panel-title>\n                  <button\n                    mat-icon-button\n                    color=\"accent\"\n                    matTooltip=\"Agregar\"\n                    (click)=\"concat(journalDataType.term, termSource)\"\n                  >\n                    <mat-icon class=\"mat-18\">merge_type</mat-icon>\n                  </button>\n                  {{ termSource.description }}\n                </mat-panel-title>\n                <mat-panel-description> </mat-panel-description>\n              </mat-expansion-panel-header>\n              <p *ngIf=\"termSource.data\">\n                <strong>URL: </strong> {{ termSource.data.url }}\n              </p>\n              <p *ngIf=\"termSource.data && termSource.data['initial_cover']\">\n                <strong>Cobertura inicio: </strong>\n                {{ termSource.data[\"initial_cover\"] }}\n              </p>\n              <p *ngIf=\"termSource.data && termSource.data['end_cover']\">\n                <strong>Cobertura hasta: </strong>\n                {{ termSource.data[\"end_cover\"] }}\n              </p>\n            </mat-expansion-panel>\n          </ng-container>\n        </mat-accordion> -->\n      </mat-card-content>\n    </mat-card>\n  </mat-card-content>\n\n  <mat-divider [inset]=\"true\"></mat-divider>\n\n  <!-- <mat-card-actions\n    fxLayout=\"row wrap\"\n    fxLayoutAlign=\"space-between center\"\n    fxLayoutGap=\"10px\"\n    style=\"padding: 1em\"\n  >\n    <mat-checkbox\n                [(ngModel)]=\"currentJournalChecked\"\n                (change)=\"markAsViewed()\"\n            >\n                Marcar como Visto\n            </mat-checkbox>\n\n    <div fxLayoutGap=\"10px\">\n      <button mat-stroked-button color=\"primary\" (click)=\"replace()\">\n        Sustituir todos los campos\n      </button>\n      <!-- <button mat-raised-button color=\"accent\">Descartar</button>\n    </div>\n  </mat-card-actions> -->\n</mat-card>\n",
                        styles: [".text-muted{color:rgba(0,0,0,.54);padding-left:.2em}.text-through{text-decoration:line-through}.notification-position{position:absolute;top:0;right:0}p{padding-top:.8em}.overlay{opacity:.4;background:#000;width:100%;height:100%;z-index:10;top:0;left:0;position:fixed}"]
                    }] }
        ];
        /** @nocollapse */
        JournalViewVersionComponent.ctorParameters = function () { return [
            { type: material.MatSnackBar }
        ]; };
        JournalViewVersionComponent.propDecorators = {
            currentJournal: [{ type: core.Input }],
            type: [{ type: core.Input }],
            editingJournal: [{ type: core.Input }],
            editingJournalChange: [{ type: core.Output }]
        };
        return JournalViewVersionComponent;
    }());
    if (false) {
        /** @type {?} */
        JournalViewVersionComponent.prototype.currentJournal;
        /** @type {?} */
        JournalViewVersionComponent.prototype.type;
        /** @type {?} */
        JournalViewVersionComponent.prototype.editingJournal;
        /** @type {?} */
        JournalViewVersionComponent.prototype.journalDataType;
        /** @type {?} */
        JournalViewVersionComponent.prototype.currentInstitutionTerms;
        /** @type {?} */
        JournalViewVersionComponent.prototype.currentDataBaseTerms;
        /** @type {?} */
        JournalViewVersionComponent.prototype.currentGroupTerms;
        /** @type {?} */
        JournalViewVersionComponent.prototype.currentProvinceTerms;
        /** @type {?} */
        JournalViewVersionComponent.prototype.currentSubjectTerms;
        /** @type {?} */
        JournalViewVersionComponent.prototype.currentLicenceTerms;
        /** @type {?} */
        JournalViewVersionComponent.prototype.vocabularies;
        /** @type {?} */
        JournalViewVersionComponent.prototype.panelOpenState;
        /** @type {?} */
        JournalViewVersionComponent.prototype.currentJournalChecked;
        /** @type {?} */
        JournalViewVersionComponent.prototype.editingJournalChange;
        /**
         * @type {?}
         * @private
         */
        JournalViewVersionComponent.prototype._snackBar;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/catalog-filters/catalog-filters.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CatalogFiltersComponent = /** @class */ (function (_super) {
        __extends(CatalogFiltersComponent, _super);
        function CatalogFiltersComponent(componentFactoryResolver, childrenService, service, taxonomyService, _snackBar, env) {
            var _this = _super.call(this, componentFactoryResolver, childrenService) || this;
            _this.componentFactoryResolver = componentFactoryResolver;
            _this.childrenService = childrenService;
            _this.service = service;
            _this.taxonomyService = taxonomyService;
            _this._snackBar = _snackBar;
            _this.env = env;
            return _this;
        }
        /**
         * @return {?}
         */
        CatalogFiltersComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            _super.prototype.ngOnInit.call(this);
            this.addOperator();
            // tslint:disable-next-line: no-use-before-declare
            default_filters$1.forEach((/**
             * @param {?} filter
             * @return {?}
             */
            function (filter) {
                _this.filters_data.push(filter);
            }));
            this.service.getJournalsVocab().pipe(operators.catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                /** @type {?} */
                var m = new MessageHandler(_this._snackBar);
                m.showMessage(StatusCode.serverError, error.message);
                return rxjs.of(null);
            })))
                .subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                if (response) {
                    response.data.vocabularies.forEach((/**
                     * @param {?} vocab
                     * @return {?}
                     */
                    function (vocab) {
                        if (VocabulariesInmutableNames.CUBAN_INTITUTIONS === vocab.id
                            && _this.env.topOrganizationPID !== '') {
                            console.log(_this.env.topOrganizationPID);
                            _this.taxonomyService.getTermByUUID(_this.env.topOrganizationPID).subscribe((/**
                             * @param {?} termsResponse
                             * @return {?}
                             */
                            function (termsResponse) {
                                _this.filters_data.push({
                                    index: _this.filters_data.length,
                                    field: 'terms',
                                    type: 'tree',
                                    placeholder: vocab.human_name,
                                    name: vocab.human_name,
                                    idVocab: vocab.id,
                                    selectOptions: termsResponse.data.term_node.children,
                                    is_enabled: true
                                });
                            }));
                        }
                        else {
                            _this.service.getTerminosByVocab(vocab.id).subscribe((/**
                             * @param {?} termsResponse
                             * @return {?}
                             */
                            function (termsResponse) {
                                _this.filters_data.push({
                                    index: _this.filters_data.length,
                                    field: 'terms',
                                    type: 'select-autocomplete',
                                    placeholder: vocab.human_name,
                                    name: vocab.human_name,
                                    idVocab: vocab.id,
                                    selectOptions: termsResponse.data.terms,
                                    is_enabled: true
                                });
                            }));
                        }
                    }));
                }
                else {
                    /** @type {?} */
                    var m = new MessageHandler(_this._snackBar);
                    m.showMessage(StatusCode.serverError, "No puedo cargar los vocabularios");
                }
            }));
        };
        /**
         * @return {?}
         */
        CatalogFiltersComponent.prototype.addOperator = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var f = new FilterItem(BooleanFilterComponent, { field: 'op', value: true, name: ['AND', 'OR'], is_enabled: false, index: -1 });
            // this.current_filters.push(f);
            /** @type {?} */
            var componentFactory = this.componentFactoryResolver.resolveComponentFactory(f.component);
            /** @type {?} */
            var viewContainerRef = this.adHost.viewContainerRef;
            // viewContainerRef.clear();
            /** @type {?} */
            var componentRef = viewContainerRef.createComponent(componentFactory);
            ((/** @type {?} */ (componentRef.instance))).data = f.data;
        };
        CatalogFiltersComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-catalog-filters-container',
                        template: "<!-- <div fxLayout=\"row wrap\" fxLayoutAlign=\"start center\" fxLayoutAlign.xs=\"center center\" fxLayoutGap=\"1em\" fxLayoutGap.xs=\"0\"> -->\n\n  <ng-template toco-Filter></ng-template>\n\n<!-- </div> -->\n\n<button mat-icon-button [matMenuTriggerFor]=\"menu\">\n    <mat-icon>add</mat-icon>\n</button>\n  <mat-menu #menu=\"matMenu\" >\n    <ng-container *ngFor=\"let item of filters_data,let i=index\">\n        <ng-container *ngIf=\"item.is_enabled\">\n          <button mat-menu-item (click)=\"addFilter(i)\">\n            {{item.name}}\n          </button>\n        </ng-container>\n    </ng-container>\n    \n\n    \n  </mat-menu>",
                        styles: [".width-100{width:100%}.mat-menu-item{height:37px}"]
                    }] }
        ];
        /** @nocollapse */
        CatalogFiltersComponent.ctorParameters = function () { return [
            { type: core.ComponentFactoryResolver },
            { type: FilterContainerService },
            { type: CatalogService },
            { type: TaxonomyService },
            { type: material.MatSnackBar },
            { type: Environment }
        ]; };
        return CatalogFiltersComponent;
    }(FilterContainerComponent));
    if (false) {
        /**
         * @type {?}
         * @protected
         */
        CatalogFiltersComponent.prototype.componentFactoryResolver;
        /**
         * @type {?}
         * @protected
         */
        CatalogFiltersComponent.prototype.childrenService;
        /**
         * @type {?}
         * @protected
         */
        CatalogFiltersComponent.prototype.service;
        /**
         * @type {?}
         * @private
         */
        CatalogFiltersComponent.prototype.taxonomyService;
        /**
         * @type {?}
         * @private
         */
        CatalogFiltersComponent.prototype._snackBar;
        /**
         * @type {?}
         * @private
         */
        CatalogFiltersComponent.prototype.env;
    }
    /** @type {?} */
    var default_filters$1 = [
        {
            index: 0,
            field: 'title',
            type: 'search',
            placeholder: 'Título',
            name: 'Título',
            is_enabled: true
        },
        {
            index: 1,
            field: 'issn',
            type: 'text',
            placeholder: 'ISSN',
            name: 'ISSN',
            is_enabled: true
        } /*,
            {
                index: 2,
                field: 'e_issn',
                type: 'text',
                placeholder: 'eISSN',
                name: 'eISSN',
                is_enabled: true
            },
            {
                index: 3,
                field: 'i_issn',
                type: 'text',
                placeholder: 'iISSN',
                name: 'iISSN',
                is_enabled: true
            }*/,
        {
            index: 2,
            field: 'rnps',
            type: 'number',
            placeholder: 'RNPS',
            name: 'RNPS',
            is_enabled: true
        } /*,
            {
                index: 5,
                field: 'term',
                type: 'select',
                placeholder: 'Términos',
                name: 'Términos',
                is_enabled: true
            } */
    ];

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/catalog/catalog.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var CatalogComponent = /** @class */ (function () {
        function CatalogComponent(service, metadata, filterService, env, _snackBar, dialog) {
            this.service = service;
            this.metadata = metadata;
            this.filterService = filterService;
            this.env = env;
            this._snackBar = _snackBar;
            this.dialog = dialog;
            // journalList: Journal[] = [];
            this.loading = true;
            this.hasErrors = false;
            this.dataSource = new table.MatTableDataSource();
            this.columnsToDisplay = ['title', 'rnps', 'p-issn', 'url'];
            this.length = 0;
            this.pageSize = 5;
            this.pageSizeOptions = [5, 10, 15, 20];
            this.sceibaHost = '';
            this.layoutPosition = [
                {
                    name: 'Derecha',
                    layout: 'row-reverse',
                    aling: 'center baseline',
                    width: '22'
                },
                {
                    name: 'Izquierda',
                    layout: 'row',
                    aling: 'center baseline',
                    width: '22'
                },
                {
                    name: 'Arriba',
                    layout: 'column',
                    aling: 'center center',
                    width: '90'
                },
                {
                    name: 'Abajo',
                    layout: 'column-reverse',
                    aling: 'center center',
                    width: '90'
                }
            ];
            this.currentlayout = this.layoutPosition[1];
            this.sceibaHost = env.sceibaHost + '/catalog';
            env.topOrganizationPID;
        }
        /**
         * @return {?}
         */
        CatalogComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.metadata.setStandardMeta("Catálogo de Revistas Científicas", "", "");
            this.paginator.firstPage();
            this.paginator.pageSize = 5;
            try {
                this.fetchJournalData();
                this.filterService.paramsChanged.pipe(operators.catchError((/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) {
                    /** @type {?} */
                    var m = new MessageHandler(_this._snackBar);
                    m.showMessage(StatusCode.serverError, error.message);
                    return rxjs.of([]);
                })))
                    .subscribe((/**
                 * @param {?} params
                 * @return {?}
                 */
                function (params) {
                    _this.params = params;
                    _this.fetchJournalData();
                }));
            }
            catch (err) {
                /** @type {?} */
                var m = new MessageHandler(this._snackBar);
                m.showMessage(StatusCode.serverError, err.message);
            }
        };
        // onPaginatorChanged(){
        //   this.filterService.changeFilter('count',this.paginator.pageSize, false);
        //   this.filterService.changeFilter('page',this.paginator.pageIndex);
        // }
        // onPaginatorChanged(){
        //   this.filterService.changeFilter('count',this.paginator.pageSize, false);
        //   this.filterService.changeFilter('page',this.paginator.pageIndex);
        // }
        /**
         * @return {?}
         */
        CatalogComponent.prototype.fetchJournalData = 
        // onPaginatorChanged(){
        //   this.filterService.changeFilter('count',this.paginator.pageSize, false);
        //   this.filterService.changeFilter('page',this.paginator.pageIndex);
        // }
        /**
         * @return {?}
         */
        function () {
            var _this = this;
            /** @type {?} */
            var arr = new Array();
            rxjs.merge().pipe(operators.startWith({}), operators.switchMap((/**
             * @return {?}
             */
            function () {
                //this.loading = true;
                return (/** @type {?} */ (_this.service)).getJournalsPage(_this.paginator.pageSize, _this.paginator.pageIndex, _this.params);
            })), operators.map((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                // Flip flag to show that loading has finished.
                _this.loading = false;
                _this.length = response.data.sources.count;
                response.data.sources.data.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    /** @type {?} */
                    var j = new Journal();
                    j.id = item.id;
                    j.uuid = item.uuid;
                    /** @type {?} */
                    var info = new JournalData();
                    info.url = item.data != null ? item.data.url : '';
                    info.title = item.name;
                    info.subtitle = item.subtitle;
                    info.shortname = item.shortname;
                    /** @type {?} */
                    var issn = new ISSN();
                    issn.e = item.data != null ? item.data.issn.e : '';
                    issn.l = item.data != null ? item.data.issn.l : '';
                    issn.p = item.data != null ? item.data.issn.p : '';
                    info.issn = issn;
                    info.rnps = item.data != null ? item.data.rnps : '';
                    info.logo = item.data != null ? item.data.logo : '';
                    info.purpose = item.purpose;
                    info.description = item.data != null ? item.data.description : '';
                    j.data = info;
                    arr.push(j);
                }));
                return arr;
            })), operators.catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                _this.loading = false;
                _this.hasErrors = true;
                /** @type {?} */
                var m = new MessageHandler(_this._snackBar);
                m.showMessage(StatusCode.serverError, error.message);
                // Catch if the GitHub API has reached its rate limit. Return empty data.
                // this.isRateLimitReached = true;
                return rxjs.of([]);
            }))).subscribe((/**
             * @param {?} data
             * @return {?}
             */
            function (data) { return _this.dataSource.data = data; }));
        };
        /**
         * @return {?}
         */
        CatalogComponent.prototype.onScrollUp = /**
         * @return {?}
         */
        function () {
            // console.log("scrolled up!!");
        };
        /**
         * @return {?}
         */
        CatalogComponent.prototype.isEmpty = /**
         * @return {?}
         */
        function () {
            if (this.dataSource.data.length === 0 && this.hasErrors) {
                //this.loading = false;
                return true;
            }
            return false;
        };
        /**
         * @return {?}
         */
        CatalogComponent.prototype.isLoading = /**
         * @return {?}
         */
        function () {
            return this.loading;
        };
        /**
         * @return {?}
         */
        CatalogComponent.prototype.openme = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var a = navigator.userAgent.match(/Android/i);
            /** @type {?} */
            var b = navigator.userAgent.match(/BlackBerry/i);
            /** @type {?} */
            var apple = navigator.userAgent.match(/iPhone|iPad|iPod/i);
            /** @type {?} */
            var o = navigator.userAgent.match(/Opera Mini/i);
            /** @type {?} */
            var i = navigator.userAgent.match(/IEMobile/i);
            if (a != null || b != null || apple != null || o != null || i != null) {
                return false;
            }
            return true;
        };
        /**
         * @param {?} index
         * @return {?}
         */
        CatalogComponent.prototype.changeLayoutPosition = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.currentlayout = this.layoutPosition[index];
        };
        /**
         * @param {?} uuid
         * @return {?}
         */
        CatalogComponent.prototype.viewJournal = /**
         * @param {?} uuid
         * @return {?}
         */
        function (uuid) {
            var _this = this;
            this.service.getSourceByUUID(uuid).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                console.log(response);
                if (response.status == "success") {
                    /** @type {?} */
                    var journalVersion = new JournalVersion();
                    journalVersion.deepcopy(response.data.sources);
                    /** @type {?} */
                    var dialogRef = _this.dialog.open(DialogCatalogJournalInfoDialog, {
                        data: {
                            journalVersion: journalVersion,
                            journalUUID: uuid
                        }
                    });
                    dialogRef.afterClosed();
                }
                else {
                    /** @type {?} */
                    var m = new MessageHandler(_this._snackBar);
                    m.showMessage(StatusCode.serverError, 'No fue posible encontrar la Revista');
                }
            }), (/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                console.log('error');
            }), (/**
             * @return {?}
             */
            function () { }));
        };
        CatalogComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-catalog',
                        template: "<!-- <div infiniteScroll [infiniteScrollDistance]=\"0\" [infiniteScrollUpDistance]=\"0.5\" [infiniteScrollThrottle]=\"10\" (scrolled)=\"onScrollDown()\"\n  (scrolledUp)=\"onScrollUp()\"> -->\n\n<!-- <toco-page-header [info]=\"['Cat\u00E1logo de Revistas Cient\u00EDficas Cubanas']\">\n    </toco-page-header> -->\n<div fxLayoutAlign=\"end center\" fxLayout=\"row\">\n    <button mat-icon-button [matMenuTriggerFor]=\"menu\">\n        <mat-icon>view_quilt</mat-icon>\n    </button>\n    <mat-menu #menu=\"matMenu\">\n        <button mat-menu-item (click)=\"changeLayoutPosition(0)\">\n            <mat-icon>arrow_forward</mat-icon>\n            <span>{{layoutPosition[0].name}}</span>\n        </button>\n        <button mat-menu-item (click)=\"changeLayoutPosition(1)\">\n            <mat-icon>arrow_back</mat-icon>\n            <span>{{layoutPosition[1].name}}</span>\n        </button>\n        <button mat-menu-item (click)=\"changeLayoutPosition(2)\">\n            <mat-icon>arrow_upward</mat-icon>\n            <span>{{layoutPosition[2].name}}</span>\n        </button>\n        <button mat-menu-item (click)=\"changeLayoutPosition(3)\">\n            <mat-icon>arrow_downward</mat-icon>\n            <span>{{layoutPosition[3].name}}</span>\n        </button>\n    </mat-menu>\n</div>\n\n\n<div fxLayout=\"{{currentlayout.layout}}\" fxLayout.xs=\"column nowrap\"\n    fxLayoutAlign=\"{{currentlayout.aling}}\">\n\n    <toco-catalog-filters-container *ngIf=\"!isEmpty()\" fxLayout=\"row wrap\" fxLayout.xs=\"column wrap\" fxFlex=\"{{currentlayout.width}}\"\n        fxLayoutAlign=\"start center\" fxLayoutAlign.xs=\"center center\" fxLayoutGap=\"1em\"\n        class=\"width-90 back-grey mat-elevation-z8\">\n    </toco-catalog-filters-container>\n\n\n\n    <div class=\"mat-elevation-z8 width-90 margin1em\">\n        <table *ngIf=\"!isEmpty()\" mat-table [dataSource]=\"dataSource\" multiTemplateDataRows>\n            <ng-container matColumnDef=\"title\">\n                <th mat-header-cell *matHeaderCellDef>Titulo</th>\n                <td mat-cell *matCellDef=\"let element\"> {{element.data.title}} </td>\n            </ng-container>\n            <ng-container matColumnDef=\"rnps\">\n                <th mat-header-cell *matHeaderCellDef>RNPS</th>\n                <td mat-cell *matCellDef=\"let element\"> {{element.data.rnps}} </td>\n            </ng-container>\n            <ng-container matColumnDef=\"p-issn\">\n                <th mat-header-cell *matHeaderCellDef>P-ISSN</th>\n                <td mat-cell *matCellDef=\"let element\"> {{element.data.issn.p}} </td>\n            </ng-container>\n            <ng-container matColumnDef=\"url\">\n                <th mat-header-cell *matHeaderCellDef>URL</th>\n                <td mat-cell *matCellDef=\"let element\"> {{element.data.url}} </td>\n            </ng-container>\n\n            <!-- Expanded Content Column - The detail row is made up of this one column that spans across all columns -->\n            <ng-container matColumnDef=\"expandedDetail\">\n                <td mat-cell *matCellDef=\"let element\" [attr.colspan]=\"columnsToDisplay.length\">\n                    <div class=\"example-element-detail\"\n                        [@detailExpand]=\"element == expandedElement ? 'expanded' : 'collapsed'\">\n                        <div class=\"example-element-description e2e-inner-html-bound\"\n                            [innerHTML]=\"element.data.description\"></div>\n                        <div class=\"example-element-description\" fxLayout=\"row\" fxLayoutAlign=\"center end\">\n                            <button mat-stroked-button color=\"primary\" (click)=\"viewJournal(element.uuid)\">\n                                Ver\n                            </button>\n                        </div>\n\n                    </div>\n                </td>\n            </ng-container>\n\n            <tr mat-header-row *matHeaderRowDef=\"columnsToDisplay\"></tr>\n            <tr mat-row *matRowDef=\"let element; columns: columnsToDisplay;\" class=\"example-element-row\"\n                [class.example-expanded-row]=\"expandedElement === element\" (click)=\"expandedElement = element\">\n            </tr>\n            <tr mat-row *matRowDef=\"let row; columns: ['expandedDetail']\" class=\"example-detail-row\"></tr>\n        </table>\n\n        <h1 *ngIf=\"isEmpty()\">No hay Informaci\u00F3n para Mostrar</h1>\n\n        <mat-paginator [length]=\"length\" [pageSize]=\"pageSize\" [pageSizeOptions]=\"pageSizeOptions\"\n            (page)=\"fetchJournalData()\">\n        </mat-paginator>\n    </div>\n\n\n</div>\n<mat-card *ngIf=\"isLoading()\" class=\"center-spinner\" fxLayout=\"row\" fxLayoutAlign=\"center center\" fxLayoutGap=\"gappx\">\n    <mat-spinner></mat-spinner>\n    <!--<mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>-->\n</mat-card>\n\n\n<!--\n      </mat-drawer-content>\n\n    </mat-drawer-container> -->\n\n<!-- </div> -->",
                        animations: [
                            animations.trigger('detailExpand', [
                                animations.state('collapsed', animations.style({ height: '0px', minHeight: '0', display: 'none' })),
                                animations.state('expanded', animations.style({ height: '*' })),
                                animations.transition('expanded <=> collapsed', animations.animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
                            ]),
                        ],
                        styles: [".width-card{width:30%;min-width:240px;margin-left:24px;margin-top:24px}.card-float-left{float:left}.center-spinner{width:90.5%;min-width:240px;margin-left:24px;margin-right:24px;margin-top:24px}.back-grey{background:rgba(0,0,0,.01);margin:1.5em 1em;padding:1em;min-width:18em}.width-90{width:90%}.width-93{width:93.5%}table{width:90%}.margin1em{margin:1em}.menu-pull-right{flex:1 1 auto}table.mat-table{width:100%}tr.example-detail-row{height:0}tr.example-element-row:not(.example-expanded-row):hover{background:#f5f5f5}tr.example-element-row:not(.example-expanded-row):active{background:#efefef}.example-element-row td{border-bottom-width:0}.example-element-detail{overflow:hidden;display:flex}.example-element-diagram{min-width:80px;border:2px solid #000;padding:8px;font-weight:lighter;margin:8px 0;height:104px}.example-element-symbol{font-weight:700;font-size:40px;line-height:normal}.example-element-description{padding:16px}.example-element-description-attribution{opacity:.5}.height-auto{height:auto!important}"]
                    }] }
        ];
        /** @nocollapse */
        CatalogComponent.ctorParameters = function () { return [
            { type: CatalogService },
            { type: MetadataService },
            { type: FiltersService },
            { type: Environment },
            { type: material.MatSnackBar },
            { type: material.MatDialog }
        ]; };
        CatalogComponent.propDecorators = {
            paginator: [{ type: core.ViewChild, args: [paginator.MatPaginator, { static: true },] }],
            filter_component: [{ type: core.ViewChild, args: [CatalogFiltersComponent, { static: true },] }]
        };
        return CatalogComponent;
    }());
    if (false) {
        /** @type {?} */
        CatalogComponent.prototype.loading;
        /**
         * @type {?}
         * @private
         */
        CatalogComponent.prototype.hasErrors;
        /** @type {?} */
        CatalogComponent.prototype.dataSource;
        /** @type {?} */
        CatalogComponent.prototype.columnsToDisplay;
        /** @type {?} */
        CatalogComponent.prototype.expandedElement;
        /** @type {?} */
        CatalogComponent.prototype.length;
        /** @type {?} */
        CatalogComponent.prototype.pageSize;
        /** @type {?} */
        CatalogComponent.prototype.pageSizeOptions;
        /** @type {?} */
        CatalogComponent.prototype.pageEvent;
        /** @type {?} */
        CatalogComponent.prototype.params;
        /** @type {?} */
        CatalogComponent.prototype.sceibaHost;
        /** @type {?} */
        CatalogComponent.prototype.layoutPosition;
        /** @type {?} */
        CatalogComponent.prototype.currentlayout;
        /** @type {?} */
        CatalogComponent.prototype.paginator;
        /** @type {?} */
        CatalogComponent.prototype.filter_component;
        /**
         * @type {?}
         * @private
         */
        CatalogComponent.prototype.service;
        /**
         * @type {?}
         * @private
         */
        CatalogComponent.prototype.metadata;
        /**
         * @type {?}
         * @private
         */
        CatalogComponent.prototype.filterService;
        /**
         * @type {?}
         * @private
         */
        CatalogComponent.prototype.env;
        /**
         * @type {?}
         * @private
         */
        CatalogComponent.prototype._snackBar;
        /** @type {?} */
        CatalogComponent.prototype.dialog;
    }
    var DialogCatalogJournalInfoDialog = /** @class */ (function () {
        function DialogCatalogJournalInfoDialog(dialogRef, data) {
            this.dialogRef = dialogRef;
            this.data = data;
        }
        /**
         * @return {?}
         */
        DialogCatalogJournalInfoDialog.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            console.log(this.data);
        };
        /**
         * @return {?}
         */
        DialogCatalogJournalInfoDialog.prototype.onNoClick = /**
         * @return {?}
         */
        function () {
            this.dialogRef.close();
        };
        DialogCatalogJournalInfoDialog.decorators = [
            { type: core.Component, args: [{
                        selector: 'dialog-catalog-journal-info',
                        template: "<mat-dialog-content class=\"height-auto\">\n                    <toco-journal-view-info\n                        [journalVersion]=\"data.journalVersion\"\n                    >\n                    </toco-journal-view-info>\n                </mat-dialog-content>"
                    }] }
        ];
        /** @nocollapse */
        DialogCatalogJournalInfoDialog.ctorParameters = function () { return [
            { type: material.MatDialogRef },
            { type: undefined, decorators: [{ type: core.Inject, args: [material.MAT_DIALOG_DATA,] }] }
        ]; };
        return DialogCatalogJournalInfoDialog;
    }());
    if (false) {
        /** @type {?} */
        DialogCatalogJournalInfoDialog.prototype.dialogRef;
        /** @type {?} */
        DialogCatalogJournalInfoDialog.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/sources-list/sources-list.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var SourcesListComponent = /** @class */ (function () {
        function SourcesListComponent(service, metadata, filterService, env) {
            this.service = service;
            this.metadata = metadata;
            this.filterService = filterService;
            this.env = env;
            this.journalList = [];
            this.loading = true;
            this.dataSource = new table.MatTableDataSource();
            this.columnsToDisplay = ['title', 'rnps', 'p-issn'];
            this.length = 0;
            this.pageSize = 5;
            this.pageSizeOptions = [5, 10, 15, 20];
            this.sceibaHost = '';
            this.layoutPosition = [
                {
                    name: 'Derecha',
                    layout: 'row-reverse',
                    aling: 'center baseline',
                    width: '22'
                },
                {
                    name: 'Izquierda',
                    layout: 'row',
                    aling: 'center baseline',
                    width: '22'
                },
                {
                    name: 'Arriba',
                    layout: 'column',
                    aling: 'center center',
                    width: '90'
                },
                {
                    name: 'Abajo',
                    layout: 'column-reverse',
                    aling: 'center center',
                    width: '90'
                }
            ];
            this.currentlayout = this.layoutPosition[1];
            this.sceibaHost = env.sceibaHost + '/catalog';
        }
        /**
         * @return {?}
         */
        SourcesListComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.metadata.setStandardMeta("Catálogo de Revistas Científicas", "", "");
            this.paginator.firstPage();
            this.paginator.pageSize = 5;
            this.service.getJournalsCount().subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                _this.length = response.data.count;
            }));
            this.fetchJournalData();
            this.filterService.paramsChanged.subscribe((/**
             * @param {?} params
             * @return {?}
             */
            function (params) {
                _this.params = params;
                _this.fetchJournalData();
            }));
        };
        // onPaginatorChanged(){
        //   this.filterService.changeFilter('count',this.paginator.pageSize, false);
        //   this.filterService.changeFilter('page',this.paginator.pageIndex);
        // }
        // onPaginatorChanged(){
        //   this.filterService.changeFilter('count',this.paginator.pageSize, false);
        //   this.filterService.changeFilter('page',this.paginator.pageIndex);
        // }
        /**
         * @return {?}
         */
        SourcesListComponent.prototype.fetchJournalData = 
        // onPaginatorChanged(){
        //   this.filterService.changeFilter('count',this.paginator.pageSize, false);
        //   this.filterService.changeFilter('page',this.paginator.pageIndex);
        // }
        /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.loading = true;
            // this.dataSource.data = this.service.getJournalsPage(this.count, this.page);
            /** @type {?} */
            var arr = new Array();
            rxjs.merge().pipe(operators.startWith({}), operators.switchMap((/**
             * @return {?}
             */
            function () {
                _this.loading = true;
                return (/** @type {?} */ (_this.service)).getJournalsPage(_this.paginator.pageSize, _this.paginator.pageIndex, _this.params);
            })), operators.map((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                // Flip flag to show that loading has finished.
                _this.loading = false;
                // this.isRateLimitReached = false;
                // this.resultsLength = response.total_count;
                _this.length = response.data.sources.count;
                response.data.sources.data.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                function (item) {
                    /** @type {?} */
                    var j = new Journal();
                    j.id = item.id;
                    j.uuid = item.uuid;
                    /** @type {?} */
                    var info = new JournalData();
                    info.url = item.data != null ? item.data.url : '';
                    info.title = item.name;
                    info.subtitle = item.subtitle;
                    info.shortname = item.shortname;
                    /** @type {?} */
                    var issn = new ISSN();
                    issn.e = item.data != null ? item.data.issn.e : '';
                    issn.l = item.data != null ? item.data.issn.l : '';
                    issn.p = item.data != null ? item.data.issn.p : '';
                    info.issn = issn;
                    info.rnps = item.data != null ? item.data.rnps : '';
                    info.logo = item.data != null ? item.data.logo : '';
                    info.purpose = item.purpose;
                    info.description = item.data != null ? item.data.description : '';
                    j.data = info;
                    arr.push(j);
                }));
                return arr;
            })), operators.catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                _this.loading = false;
                console.log('ERRORRR ' + error);
                // Catch if the GitHub API has reached its rate limit. Return empty data.
                // this.isRateLimitReached = true;
                return rxjs.of([]);
            }))).subscribe((/**
             * @param {?} data
             * @return {?}
             */
            function (data) { return _this.dataSource.data = data; }));
        };
        /**
         * @return {?}
         */
        SourcesListComponent.prototype.onScrollUp = /**
         * @return {?}
         */
        function () {
            // console.log("scrolled up!!");
        };
        /**
         * @return {?}
         */
        SourcesListComponent.prototype.isEmpty = /**
         * @return {?}
         */
        function () {
            if (this.journalList.length == 0) {
                this.loading = false;
                return true;
            }
            return false;
        };
        /**
         * @return {?}
         */
        SourcesListComponent.prototype.isLoading = /**
         * @return {?}
         */
        function () {
            return this.loading;
        };
        /**
         * @return {?}
         */
        SourcesListComponent.prototype.openme = /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var a = navigator.userAgent.match(/Android/i);
            /** @type {?} */
            var b = navigator.userAgent.match(/BlackBerry/i);
            /** @type {?} */
            var apple = navigator.userAgent.match(/iPhone|iPad|iPod/i);
            /** @type {?} */
            var o = navigator.userAgent.match(/Opera Mini/i);
            /** @type {?} */
            var i = navigator.userAgent.match(/IEMobile/i);
            if (a != null || b != null || apple != null || o != null || i != null) {
                return false;
            }
            return true;
        };
        /**
         * @param {?} index
         * @return {?}
         */
        SourcesListComponent.prototype.changeLayoutPosition = /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this.currentlayout = this.layoutPosition[index];
        };
        SourcesListComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-sources-list',
                        template: "<!-- <div infiniteScroll [infiniteScrollDistance]=\"0\" [infiniteScrollUpDistance]=\"0.5\" [infiniteScrollThrottle]=\"10\" (scrolled)=\"onScrollDown()\"\n  (scrolledUp)=\"onScrollUp()\"> -->\n\n\n    <!-- <toco-page-header [info]=\"['Cat\u00E1logo de Revistas Cient\u00EDficas Cubanas']\">\n    </toco-page-header> -->\n    <div fxLayoutAlign=\"end center\" fxLayout=\"row\">\n      <button mat-icon-button [matMenuTriggerFor]=\"menu\">\n        <mat-icon>view_quilt</mat-icon>\n      </button>\n      <mat-menu #menu=\"matMenu\">\n        <button mat-menu-item (click)=\"changeLayoutPosition(0)\">\n          <mat-icon>arrow_forward</mat-icon>\n          <span>{{layoutPosition[0].name}}</span>\n        </button>\n        <button mat-menu-item (click)=\"changeLayoutPosition(1)\">\n          <mat-icon>arrow_back</mat-icon>\n          <span>{{layoutPosition[1].name}}</span>\n        </button>\n        <button mat-menu-item (click)=\"changeLayoutPosition(2)\">\n          <mat-icon>arrow_upward</mat-icon>\n          <span>{{layoutPosition[2].name}}</span>\n        </button>\n        <button mat-menu-item (click)=\"changeLayoutPosition(3)\">\n          <mat-icon>arrow_downward</mat-icon>\n          <span>{{layoutPosition[3].name}}</span>\n        </button>\n      </mat-menu>\n    </div>\n\n\n    <div fxLayout=\"{{currentlayout.layout}}\" fxLayout.xs=\"column nowrap\" fxLayoutAlign=\"{{currentlayout.aling}}\">\n\n      <toco-catalog-filters-container fxLayout=\"row wrap\" fxLayout.xs=\"column wrap\" fxFlex=\"{{currentlayout.width}}\" fxLayoutAlign=\"start center\" fxLayoutAlign.xs=\"center center\"\n        fxLayoutGap=\"1em\" class=\"width-90 back-grey mat-elevation-z8\">\n      </toco-catalog-filters-container>\n\n\n\n      <div class=\"mat-elevation-z8 width-90 margin1em\">\n        <table mat-table [dataSource]=\"dataSource\" multiTemplateDataRows>\n          <ng-container matColumnDef=\"title\">\n            <th mat-header-cell *matHeaderCellDef>Titulo</th>\n            <td mat-cell *matCellDef=\"let element\"> {{element.data.title}} </td>\n          </ng-container>\n          <ng-container matColumnDef=\"rnps\">\n            <th mat-header-cell *matHeaderCellDef>RNPS</th>\n            <td mat-cell *matCellDef=\"let element\"> {{element.data.rnps}} </td>\n          </ng-container>\n          <ng-container matColumnDef=\"p-issn\">\n            <th mat-header-cell *matHeaderCellDef>P-ISSN</th>\n            <td mat-cell *matCellDef=\"let element\"> {{element.data.issn.p}} </td>\n          </ng-container>\n\n          <!-- Expanded Content Column - The detail row is made up of this one column that spans across all columns -->\n          <ng-container matColumnDef=\"expandedDetail\">\n            <td mat-cell *matCellDef=\"let element\" [attr.colspan]=\"columnsToDisplay.length\">\n              <div class=\"example-element-detail\" [@detailExpand]=\"element == expandedElement ? 'expanded' : 'collapsed'\">\n                <div class=\"example-element-description e2e-inner-html-bound\" [innerHTML]=\"element.data.description\"></div>\n\n              </div>\n            </td>\n          </ng-container>\n\n          <tr mat-header-row *matHeaderRowDef=\"columnsToDisplay\"></tr>\n          <tr mat-row *matRowDef=\"let element; columns: columnsToDisplay;\" class=\"example-element-row\" [class.example-expanded-row]=\"expandedElement === element\"\n            (click)=\"expandedElement = element\">\n          </tr>\n          <tr mat-row *matRowDef=\"let row; columns: ['expandedDetail']\" class=\"example-detail-row\"></tr>\n        </table>\n        <mat-paginator [length]=\"length\"\n              [pageSize]=\"pageSize\"\n              [pageSizeOptions]=\"pageSizeOptions\"\n              (page)=\"fetchJournalData()\">\n        </mat-paginator>\n      </div>\n\n      <mat-card *ngIf=\"!isEmpty()\" class=\"center-spinner\" fxLayout=\"row\" fxLayoutAlign=\"center center\" fxLayoutGap=\"gappx\">\n        <mat-spinner></mat-spinner>\n        <!--<mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>-->\n      </mat-card>\n\n      <!-- <mat-card *ngIf=\"isEmpty()\" class=\"center-spinner\" fxLayout=\"row\" fxLayoutAlign=\"center center\" fxLayoutGap=\"gappx\">\n        <h1>No hay Informaci\u00F3n para Mostrar</h1>\n      </mat-card> -->\n    </div>\n\n    <!--\n      </mat-drawer-content>\n\n\n\n    </mat-drawer-container> -->\n\n<!-- </div> -->\n",
                        animations: [
                            animations.trigger('detailExpand', [
                                animations.state('collapsed', animations.style({ height: '0px', minHeight: '0', display: 'none' })),
                                animations.state('expanded', animations.style({ height: '*' })),
                                animations.transition('expanded <=> collapsed', animations.animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
                            ]),
                        ],
                        styles: [".width-card{width:30%;min-width:240px;margin-left:24px;margin-top:24px}.card-float-left{float:left}.center-spinner{width:90.5%;min-width:240px;margin-left:24px;margin-right:24px;margin-top:24px}.back-grey{background:rgba(0,0,0,.01);margin:1.5em 1em;padding:1em;min-width:18em}.width-90{width:90%}.width-93{width:93.5%}table{width:90%}.margin1em{margin:1em}.menu-pull-right{flex:1 1 auto}table.mat-table{width:100%}tr.example-detail-row{height:0}tr.example-element-row:not(.example-expanded-row):hover{background:#f5f5f5}tr.example-element-row:not(.example-expanded-row):active{background:#efefef}.example-element-row td{border-bottom-width:0}.example-element-detail{overflow:hidden;display:flex}.example-element-diagram{min-width:80px;border:2px solid #000;padding:8px;font-weight:lighter;margin:8px 0;height:104px}.example-element-symbol{font-weight:700;font-size:40px;line-height:normal}.example-element-description{padding:16px}.example-element-description-attribution{opacity:.5}"]
                    }] }
        ];
        /** @nocollapse */
        SourcesListComponent.ctorParameters = function () { return [
            { type: CatalogService },
            { type: MetadataService },
            { type: FiltersService },
            { type: Environment }
        ]; };
        SourcesListComponent.propDecorators = {
            paginator: [{ type: core.ViewChild, args: [paginator.MatPaginator, { static: true },] }],
            filter_component: [{ type: core.ViewChild, args: [CatalogFiltersComponent, { static: true },] }]
        };
        return SourcesListComponent;
    }());
    if (false) {
        /** @type {?} */
        SourcesListComponent.prototype.journalList;
        /**
         * @type {?}
         * @private
         */
        SourcesListComponent.prototype.loading;
        /** @type {?} */
        SourcesListComponent.prototype.dataSource;
        /** @type {?} */
        SourcesListComponent.prototype.columnsToDisplay;
        /** @type {?} */
        SourcesListComponent.prototype.expandedElement;
        /** @type {?} */
        SourcesListComponent.prototype.length;
        /** @type {?} */
        SourcesListComponent.prototype.pageSize;
        /** @type {?} */
        SourcesListComponent.prototype.pageSizeOptions;
        /** @type {?} */
        SourcesListComponent.prototype.pageEvent;
        /** @type {?} */
        SourcesListComponent.prototype.params;
        /** @type {?} */
        SourcesListComponent.prototype.sceibaHost;
        /** @type {?} */
        SourcesListComponent.prototype.layoutPosition;
        /** @type {?} */
        SourcesListComponent.prototype.currentlayout;
        /** @type {?} */
        SourcesListComponent.prototype.paginator;
        /** @type {?} */
        SourcesListComponent.prototype.filter_component;
        /**
         * @type {?}
         * @private
         */
        SourcesListComponent.prototype.service;
        /**
         * @type {?}
         * @private
         */
        SourcesListComponent.prototype.metadata;
        /**
         * @type {?}
         * @private
         */
        SourcesListComponent.prototype.filterService;
        /**
         * @type {?}
         * @private
         */
        SourcesListComponent.prototype.env;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/sources.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var ɵ0$2 = { displayDefaultIndicatorType: false };
    var SourcesModule = /** @class */ (function () {
        function SourcesModule() {
        }
        SourcesModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            JournalViewComponent,
                            JournalViewTermComponent,
                            JournalViewInfoComponent,
                            JournalViewInfoFieldComponent,
                            JournalViewFieldComponent,
                            JournalEditComponent,
                            SourceEditAddIndexComponent,
                            JournalViewVersionComponent,
                            CatalogComponent,
                            CatalogFiltersComponent,
                            SourcesListComponent,
                            DialogCatalogJournalInfoDialog,
                            SourceOrganizationsComponent,
                            SourceOrganizationSelectDialog,
                            SourceOrganizationSelectTopDialog,
                            SourceIndexesComponent
                        ],
                        entryComponents: [
                            SourceEditAddIndexComponent,
                            DialogCatalogJournalInfoDialog,
                            SourceOrganizationSelectDialog,
                            SourceOrganizationSelectTopDialog
                        ],
                        imports: [
                            SharedModule,
                            CoreModule,
                            forms.ReactiveFormsModule,
                            TocoFormsModule,
                            OrganizationsModule
                        ],
                        exports: [
                            JournalViewComponent,
                            JournalEditComponent,
                            JournalViewInfoComponent,
                            CatalogComponent,
                            SourcesListComponent
                        ],
                        providers: [
                            SourceService,
                            TaxonomyService,
                            {
                                provide: stepper$1.STEPPER_GLOBAL_OPTIONS,
                                useValue: ɵ0$2
                            }
                        ]
                    },] }
        ];
        return SourcesModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/sources/public-api.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/taxonomy/vocabularies/vocabularies.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var VocabularyDialogComponent = /** @class */ (function () {
        function VocabularyDialogComponent(service, _formBuilder, dialogRef, _snackBar, data) {
            this.service = service;
            this._formBuilder = _formBuilder;
            this.dialogRef = dialogRef;
            this._snackBar = _snackBar;
            this.data = data;
            this.actionLabel = 'Aceptar';
            this.hasService = false;
            if (data.accept) {
                this.accept = data.accept;
                this.hasService = true;
                this.vocab = new Vocabulary();
                if (data.vocab === null) {
                    this.vocab.isNew = true;
                }
                else {
                    this.vocab.deepcopy(data.vocab);
                    this.actionLabel = 'Actualizar';
                }
            }
        }
        /**
         * @return {?}
         */
        VocabularyDialogComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.hasService) {
                this.formGroup = this._formBuilder.group({});
                this.panels = [
                    {
                        title: this.vocab.isNew ? 'Nuevo Vocabulario' : 'Editar Vocabulario',
                        description: '',
                        iconName: '',
                        formSection: this.formGroup,
                        formSectionContent: [
                            {
                                name: 'name',
                                label: 'Identificador',
                                type: FormFieldType.identifier,
                                required: true,
                                width: '100%',
                                value: this.vocab.name,
                                startHint: new HintValue(HintPosition.start, 'Un identificador es una secuencia de letras')
                            },
                            {
                                name: 'human_name',
                                label: 'Nombre',
                                type: FormFieldType.text,
                                required: false,
                                width: '100%',
                                value: this.vocab.human_name,
                                startHint: new HintValue(HintPosition.start, '')
                            },
                            {
                                name: 'description',
                                label: 'Descripción',
                                type: FormFieldType.textarea,
                                required: false,
                                width: '100%',
                                value: this.vocab.description,
                                startHint: new HintValue(HintPosition.start, '')
                            }
                        ]
                    }
                ];
                this.action = {
                    doit: (/**
                     * @param {?} data
                     * @return {?}
                     */
                    function (data) {
                        if (_this.formGroup.valid) {
                            _this.vocab.name = _this.formGroup.value['name'];
                            _this.vocab.human_name = _this.formGroup.value['human_name'];
                            _this.vocab.description = _this.formGroup.value['description'];
                            _this.accept(_this.vocab);
                        }
                        else {
                            /** @type {?} */
                            var m = new MessageHandler(_this._snackBar);
                            m.showMessage(StatusCode.OK, 'El identificador no es válido.');
                        }
                    })
                };
            }
        };
        /**
         * @return {?}
         */
        VocabularyDialogComponent.prototype.onNoClick = /**
         * @return {?}
         */
        function () {
            this.dialogRef.close();
        };
        /**
         * @return {?}
         */
        VocabularyDialogComponent.prototype.acceptAction = /**
         * @return {?}
         */
        function () {
        };
        VocabularyDialogComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-vocabulary-dialog',
                        template: "<form *ngIf=\"hasService\">\n    <toco-form-container\n        [panelsContent]=\"panels\"\n        [formGroup]=\"formGroup\"\n        [useAccordion]=\"false\"\n        [action]=\"action\"\n        [actionLabel]=\"actionLabel\"\n    ></toco-form-container>\n\n\n    <!-- <div>\n        <button mat-raised-button color=\"primary\" (click)=\"acceptAction()\">{{actionLabel}}</button>\n    </div> -->\n</form>\n\n<h2 *ngIf=\"!hasService\"> No Service</h2>\n"
                    }] }
        ];
        /** @nocollapse */
        VocabularyDialogComponent.ctorParameters = function () { return [
            { type: TaxonomyService },
            { type: forms.FormBuilder },
            { type: dialog.MatDialogRef },
            { type: snackBar.MatSnackBar },
            { type: undefined, decorators: [{ type: core.Inject, args: [dialog.MAT_DIALOG_DATA,] }] }
        ]; };
        return VocabularyDialogComponent;
    }());
    if (false) {
        /** @type {?} */
        VocabularyDialogComponent.prototype.panels;
        /** @type {?} */
        VocabularyDialogComponent.prototype.formGroup;
        /** @type {?} */
        VocabularyDialogComponent.prototype.action;
        /** @type {?} */
        VocabularyDialogComponent.prototype.actionLabel;
        /** @type {?} */
        VocabularyDialogComponent.prototype.hasService;
        /** @type {?} */
        VocabularyDialogComponent.prototype.vocab;
        /** @type {?} */
        VocabularyDialogComponent.prototype.accept;
        /**
         * @type {?}
         * @private
         */
        VocabularyDialogComponent.prototype.service;
        /**
         * @type {?}
         * @private
         */
        VocabularyDialogComponent.prototype._formBuilder;
        /** @type {?} */
        VocabularyDialogComponent.prototype.dialogRef;
        /** @type {?} */
        VocabularyDialogComponent.prototype._snackBar;
        /** @type {?} */
        VocabularyDialogComponent.prototype.data;
    }
    var VocabulariesComponent = /** @class */ (function () {
        function VocabulariesComponent(service, oautheStorage, dialog, _snackBar) {
            var _this = this;
            this.service = service;
            this.oautheStorage = oautheStorage;
            this.dialog = dialog;
            this._snackBar = _snackBar;
            this.vocabulariesChangeObserver = {
                next: (/**
                 * @param {?} result
                 * @return {?}
                 */
                function (result) {
                    _this.dialog.closeAll();
                    _this.loadVocabularies();
                    /** @type {?} */
                    var voc = new Vocabulary();
                    voc.deepcopy(result.data.vocabulary);
                    _this.selectVocab(voc);
                    /** @type {?} */
                    var m = new MessageHandler(_this._snackBar);
                    m.showMessage(StatusCode.OK, result.message);
                }),
                error: (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    console.log('error: ' + err + '.');
                }),
                complete: (/**
                 * @return {?}
                 */
                function () {
                    console.log('complete.');
                })
            };
            this.vocabCtrl = new forms.FormControl();
            this.selectedVocab = new core.EventEmitter();
            this.currentVocab = null;
            this.vocabularies = [];
            this.loading = false;
            this.emiterShowTerms = new core.EventEmitter();
        }
        /**
         * @return {?}
         */
        VocabulariesComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.getAuthenticatedUserPermissions();
            this.loadVocabularies();
        };
        /**
         * @return {?}
         */
        VocabulariesComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
        };
        /**
         * @param {?} item
         * @return {?}
         */
        VocabulariesComponent.prototype.selectVocab = /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this.currentVocab = item;
        };
        /**
         * @return {?}
         */
        VocabulariesComponent.prototype.loadVocabularies = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.loading = true;
            this.service.getVocabularies().pipe(operators.catchError((/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                /** @type {?} */
                var m = new MessageHandler(_this._snackBar);
                m.showMessage(StatusCode.serverError, err.message);
                // TODO: Maybe you must set a better return.
                return rxjs.of(null);
            })), operators.finalize((/**
             * @return {?}
             */
            function () { return _this.loading = false; })))
                .subscribe((/**
             * @param {?} response
             * @return {?}
             */
            function (response) {
                if (response) {
                    _this.vocabularies = response.data.vocabularies;
                    _this.filteredVocabularies = _this.vocabCtrl.valueChanges
                        .pipe(operators.startWith(''), operators.map((/**
                     * @param {?} value
                     * @return {?}
                     */
                    function (value) {
                        return _this.vocabularies.filter((/**
                         * @param {?} vocab
                         * @return {?}
                         */
                        function (vocab) { return vocab.name.toLowerCase().includes(value.toLowerCase()); }));
                    })));
                }
                else {
                    _this.vocabularies = [];
                }
            }));
        };
        /**
         * @return {?}
         */
        VocabulariesComponent.prototype.newVocab = /**
         * @return {?}
         */
        function () {
            this.openVocabDialog(null);
        };
        /**
         * @param {?} vocab
         * @return {?}
         */
        VocabulariesComponent.prototype.editVocab = /**
         * @param {?} vocab
         * @return {?}
         */
        function (vocab) {
            this.openVocabDialog(vocab);
        };
        /**
         * @private
         * @param {?} vocab
         * @return {?}
         */
        VocabulariesComponent.prototype.openVocabDialog = /**
         * @private
         * @param {?} vocab
         * @return {?}
         */
        function (vocab) {
            var _this = this;
            /** @type {?} */
            var dialogRef = this.dialog.open(VocabularyDialogComponent, {
                data: {
                    vocab: vocab,
                    accept: (/**
                     * @param {?} voc
                     * @return {?}
                     */
                    function (voc) {
                        _this.dialog.closeAll();
                        if (voc.isNew) {
                            _this.service.newVocabulary(voc).pipe().subscribe(_this.vocabulariesChangeObserver);
                        }
                        else {
                            _this.service.editVocabulary(voc).pipe().subscribe(_this.vocabulariesChangeObserver);
                        }
                    })
                }
            });
            dialogRef.afterClosed().subscribe((/**
             * @param {?} result
             * @return {?}
             */
            function (result) {
                console.log('dialog closed');
            }));
        };
        /**
         * @param {?} vocab
         * @return {?}
         */
        VocabulariesComponent.prototype.deleteVocab = /**
         * @param {?} vocab
         * @return {?}
         */
        function (vocab) {
        };
        /**
         * @return {?}
         */
        VocabulariesComponent.prototype.onSelectionChange = /**
         * @return {?}
         */
        function () {
            this.selectedVocab.emit(this.currentVocab);
        };
        /**
         * @return {?}
         */
        VocabulariesComponent.prototype.getAuthenticatedUserPermissions = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.service.getCurrentUserPermissions().pipe(operators.catchError((/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                /** @type {?} */
                var m = new MessageHandler(_this._snackBar);
                m.showMessage(StatusCode.serverError, err.message);
                // TODO: Maybe you must set a better return.
                return rxjs.of(null);
            })))
                .subscribe((/**
             * @param {?} request
             * @return {?}
             */
            function (request) {
                if (request.status == 'success') {
                    /** @type {?} */
                    var permJson = JSON.stringify(request.data.permissions.actions);
                    _this.oautheStorage.setItem('user_permissions', permJson);
                }
            }));
        };
        /**
         * @param {?} permission
         * @param {?=} id
         * @return {?}
         */
        VocabulariesComponent.prototype.hasPermission = /**
         * @param {?} permission
         * @param {?=} id
         * @return {?}
         */
        function (permission, id) {
            /** @type {?} */
            var userPermission = JSON.parse(this.oautheStorage.getItem('user_permissions'));
            if (!userPermission) {
                return false;
            }
            switch (permission) {
                case 'add':
                    if (userPermission.taxonomy_full_editor_actions === null)
                        return true;
                    return false;
                case 'edit':
                    if (userPermission.taxonomy_full_editor_actions === null)
                        return true;
                    if (userPermission.vocabulary_editor_actions) {
                        /** @type {?} */
                        var arr = userPermission.vocabulary_editor_actions;
                        if (arr.includes(id)) {
                            return true;
                        }
                    }
                    else if (userPermission.taxonomy_full_editor_actions) {
                        return true;
                    }
                    return false;
                default:
                    return false;
            }
        };
        VocabulariesComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-vocabularies',
                        template: "<mat-card>\n  <mat-card-header>\n    <mat-card-title>\n      <div fxLayout=\"row\" fxLayoutAlign=\"space-between none\">\n        Vocabularios\n        <button *ngIf=\"hasPermission('add')\" mat-icon-button (click)=\"newVocab()\" matTooltip=\"Adicionar Vocabulario\">\n          <mat-icon>library_add</mat-icon>\n        </button>\n      </div>\n    </mat-card-title>\n  </mat-card-header>\n  <mat-card-content [style.overflow]=\"'auto'\" [style.height]=\"'25em'\">\n    <mat-spinner *ngIf=\"loading; else elseTemplate\"></mat-spinner>\n    <ng-template #elseTemplate>\n\n\n      <mat-form-field [ngStyle]=\"{'width': '100%'}\">\n        <mat-label>Vocabularios</mat-label>\n        <mat-select\n          [(value)]=\"currentVocab\"\n          (selectionChange)=\"onSelectionChange()\"\n        >\n          <mat-option *ngFor=\"let option of vocabularies\" [value]=\"option\">\n            {{option.human_name}}\n          </mat-option>\n        </mat-select>\n      </mat-form-field>\n      \n\n      <!-- <mat-form-field>\n        <input matInput placeholder=\"Vocabularios\" aria-label=\"Vocabularios\" [matAutocomplete]=\"auto\"\n          [formControl]=\"vocabCtrl\">\n        <mat-autocomplete #auto=\"matAutocomplete\">\n          <mat-option *ngFor=\"let item of filteredVocabularies | async\" [value]=\"item.human_name\" (click)=selectVocab(item) (keydown.enter)=selectVocab(item)>\n            {{item.human_name}}\n          </mat-option>\n        </mat-autocomplete>\n      </mat-form-field> -->\n\n\n      <mat-card *ngIf=\"currentVocab\">\n        <mat-card-header>\n          <mat-card-title></mat-card-title>\n          <mat-card-subtitle>\n              <strong>Identificador: </strong> {{ currentVocab.name }}\n              </mat-card-subtitle>\n        </mat-card-header>\n        <mat-card-content>\n            <strong>Nombre: </strong> {{ currentVocab.human_name }}\n          <p> <strong> Descripci\u00F3n: </strong> </p>\n          <div class=\"e2e-inner-html-bound  text-align-justify\" [innerHTML]=\"currentVocab.description\"></div>\n\n        </mat-card-content>\n        <mat-card-actions>\n          <button mat-flat-button *ngIf=\"hasPermission('edit', currentVocab.id)\" (click)=\"editVocab(currentVocab)\">Editar \n            <mat-icon>edit</mat-icon>\n          </button>\n        </mat-card-actions>\n      </mat-card>\n      \n    </ng-template>\n  </mat-card-content>\n</mat-card>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        VocabulariesComponent.ctorParameters = function () { return [
            { type: TaxonomyService },
            { type: angularOauth2Oidc.OAuthStorage },
            { type: dialog.MatDialog },
            { type: snackBar.MatSnackBar }
        ]; };
        VocabulariesComponent.propDecorators = {
            selectedVocab: [{ type: core.Output }],
            emiterShowTerms: [{ type: core.Output }]
        };
        return VocabulariesComponent;
    }());
    if (false) {
        /**
         * @type {?}
         * @private
         */
        VocabulariesComponent.prototype.vocabulariesChangeObserver;
        /** @type {?} */
        VocabulariesComponent.prototype.vocabCtrl;
        /** @type {?} */
        VocabulariesComponent.prototype.filteredVocabularies;
        /** @type {?} */
        VocabulariesComponent.prototype.selectedVocab;
        /** @type {?} */
        VocabulariesComponent.prototype.currentVocab;
        /** @type {?} */
        VocabulariesComponent.prototype.vocabularies;
        /** @type {?} */
        VocabulariesComponent.prototype.loading;
        /** @type {?} */
        VocabulariesComponent.prototype.emiterShowTerms;
        /**
         * @type {?}
         * @private
         */
        VocabulariesComponent.prototype.service;
        /**
         * @type {?}
         * @private
         */
        VocabulariesComponent.prototype.oautheStorage;
        /** @type {?} */
        VocabulariesComponent.prototype.dialog;
        /**
         * @type {?}
         * @private
         */
        VocabulariesComponent.prototype._snackBar;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/taxonomy/term-generic/term-generic.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TermGenericComponent = /** @class */ (function () {
        function TermGenericComponent(_formBuilder, _snackBar, data) {
            this._formBuilder = _formBuilder;
            this._snackBar = _snackBar;
            this.data = data;
            this.panels = [];
            this.actionLabel = "Adicionar";
            // term: Term;
            this.hasService = false;
            if (data.accept && data.currentVocab) {
                this.accept = data.accept;
                this.hasService = true;
                this.vocab = data.currentVocab;
                if (data.term) {
                    this.actionLabel = "Actualizar";
                    if (!this.data.term.data) {
                        this.data.term.data = this._getTermDataObject();
                    }
                }
                else {
                    this.data.term = new Term();
                    this.data.term.isNew = true;
                    this.data.term.vocabulary_id = data.currentVocab.id;
                }
            }
        }
        /**
         * @return {?}
         */
        TermGenericComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            this.formGroup = this._formBuilder.group({});
            this.panels = [
                {
                    title: "Término",
                    description: "",
                    iconName: "",
                    formSection: this.formGroup,
                    formSectionContent: this._getContent()
                }
            ];
            this.action = {
                doit: /**
                 * @param {?} data
                 * @return {?}
                 */
                function (data) {
                    if (this.formGroup.valid) {
                        // get the result from formGroup
                        /** @type {?} */
                        var result = new Term();
                        result.deepcopy(this.data.term);
                        result.deepcopy(this.formGroup.value);
                        result.data = this._getTermDataObject();
                        result.data.deepcopy(this.formGroup.value);
                        // Set the parent term, if any
                        /** @type {?} */
                        var parent_1 = this.formGroup.value["parent_id"];
                        if (parent_1 && parent_1[0]) {
                            result.parent_id = parent_1[0].id;
                        }
                        else {
                            result.parent_id = null;
                        }
                        // if the term is an index, then set miar_class and group_mes
                        // clasifications
                        if (this.vocab.id == VocabulariesInmutableNames.INDEXES) {
                            result.class_ids = [];
                            /** @type {?} */
                            var miar = this.formGroup.value["miar_class"];
                            /** @type {?} */
                            var mes = this.formGroup.value["group_mes"];
                            if (miar && miar[0]) {
                                result.class_ids.push(miar[0].id);
                            }
                            if (mes && mes[0]) {
                                result.class_ids.push(mes[0].id);
                            }
                        }
                        this.accept((/** @type {?} */ (result)));
                    }
                }
            };
        };
        /**
         * Returns the panel's content.
         */
        /**
         * Returns the panel's content.
         * @private
         * @return {?}
         */
        TermGenericComponent.prototype._getContent = /**
         * Returns the panel's content.
         * @private
         * @return {?}
         */
        function () {
            // TODO: use TermHelper
            switch (this.vocab.id) {
                case VocabulariesInmutableNames.CUBAN_INTITUTIONS:
                    return [
                        {
                            name: "name",
                            label: "Nombre",
                            type: FormFieldType.text,
                            required: true,
                            value: this.data.term.name ? this.data.term.name : null,
                            width: "100%"
                        },
                        {
                            name: "grid",
                            label: "Identificador GRID",
                            type: FormFieldType.text,
                            required: false,
                            value: this.data.term.data.grid ? this.data.term.data.grid : null,
                            width: "50%"
                        },
                        {
                            name: "description",
                            label: "Descripción",
                            type: FormFieldType.textarea,
                            required: false,
                            value: this.data.term.description
                                ? this.data.term.description
                                : null,
                            width: "100%"
                        },
                        {
                            name: "email",
                            label: "Email",
                            type: FormFieldType.email,
                            required: true,
                            value: this.data.term.data.email ? this.data.term.data.email : null,
                            width: "45%"
                        },
                        {
                            name: "website",
                            label: "Sitio Web Oficial",
                            type: FormFieldType.url,
                            required: false,
                            value: this.data.term.data.website
                                ? this.data.term.data.website
                                : null,
                            width: "45%"
                        },
                        {
                            name: "address",
                            label: "Dirección",
                            type: FormFieldType.textarea,
                            required: false,
                            value: this.data.term.data.address
                                ? this.data.term.data.address
                                : null,
                            width: "100%"
                        },
                        {
                            name: "parent_id",
                            label: "Jerarquía Institucional (Institución Superior)",
                            type: FormFieldType.vocabulary,
                            required: false,
                            extraContent: {
                                multiple: false,
                                selectedTermsIds: this.data.term.parent_id
                                    ? [this.data.term.parent_id]
                                    : null,
                                vocab: this.vocab.id
                            },
                            width: "100%"
                        }
                    ];
                case VocabulariesInmutableNames.INDEXES:
                    return [
                        {
                            name: "name",
                            label: "Nombre",
                            type: FormFieldType.text,
                            required: true,
                            value: this.data.term.name ? this.data.term.name : null,
                            width: "100%"
                        },
                        {
                            name: "url",
                            label: "URL",
                            type: FormFieldType.url,
                            required: false,
                            value: this.data.term.data.url ? this.data.term.data.url : null,
                            width: "100%"
                        },
                        {
                            name: "abrev",
                            label: "Identificadores",
                            type: FormFieldType.text,
                            required: false,
                            value: this.data.term.data.abrev ? this.data.term.data.abrev : null,
                            width: "30%"
                        },
                        {
                            name: "initial_cover",
                            label: "Cobertura inicio",
                            type: FormFieldType.text,
                            required: false,
                            value: this.data.term.data.initial_cover
                                ? this.data.term.data.initial_cover
                                : null,
                            width: "30%"
                        },
                        {
                            name: "end_cover",
                            label: "Cobertura",
                            type: FormFieldType.text,
                            required: false,
                            value: this.data.term.data.end_cover
                                ? this.data.term.data.end_cover
                                : null,
                            width: "30%"
                        },
                        {
                            name: "description",
                            label: "Descripción",
                            type: FormFieldType.textarea,
                            required: false,
                            value: this.data.term.description
                                ? this.data.term.description
                                : null,
                            width: "100%"
                        },
                        {
                            name: "miar_class",
                            label: "Tipología de sistemas de indización",
                            type: FormFieldType.vocabulary,
                            required: false,
                            extraContent: {
                                multiple: false,
                                selectedTermsIds: this.data.term.class_ids
                                    ? this.data.term.class_ids
                                    : null,
                                vocab: VocabulariesInmutableNames.INDEXES_CLASIFICATION
                            },
                            width: "48%"
                        },
                        {
                            name: "group_mes",
                            label: "Grupos, Categorías según criterios de “calidad” de las publicaciones ",
                            type: FormFieldType.vocabulary,
                            startHint: new HintValue(HintPosition.start, ""),
                            required: false,
                            extraContent: {
                                multiple: false,
                                selectedTermsIds: this.data.term.class_ids
                                    ? this.data.term.class_ids
                                    : null,
                                vocab: VocabulariesInmutableNames.INDEXES_CLASIFICATION
                            },
                            width: "48%"
                        }
                    ];
                default:
                    return [
                        {
                            name: "name",
                            label: "Nombre",
                            type: FormFieldType.text,
                            required: true,
                            width: "100%",
                            value: this.data.term.name ? this.data.term.name : null
                        },
                        {
                            name: "description",
                            label: "Descripción",
                            type: FormFieldType.textarea,
                            required: false,
                            width: "100%",
                            value: this.data.term.description
                                ? this.data.term.description
                                : null
                        },
                        {
                            name: "parent_id",
                            label: "Término Padre",
                            type: FormFieldType.vocabulary,
                            startHint: new HintValue(HintPosition.start, ""),
                            required: false,
                            extraContent: {
                                multiple: false,
                                selectedTermsIds: this.data.term.parent_id
                                    ? [this.data.term.parent_id]
                                    : null,
                                vocab: this.vocab.id
                            },
                            width: "50%"
                        }
                    ];
            }
        };
        /**
         * @private
         * @return {?}
         */
        TermGenericComponent.prototype._getTermDataObject = /**
         * @private
         * @return {?}
         */
        function () {
            switch (this.vocab.id) {
                case VocabulariesInmutableNames.CUBAN_INTITUTIONS:
                    return new TermInstitutionData();
                case VocabulariesInmutableNames.INDEXES:
                    return new TermIndexData();
                default:
                    return new EntityBase();
            }
        };
        TermGenericComponent.decorators = [
            { type: core.Component, args: [{
                        selector: "toco-term-generic",
                        template: "\n<toco-form-container\n    [panelsContent]=\"panels\"\n    [useAccordion]=\"'false'\"\n    [action]=\"action\"\n    [actionLabel]=\"actionLabel\"\n    [formGroup]=\"formGroup\"\n></toco-form-container>\n\n<h2 *ngIf=\"!hasService\"> No Service</h2>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        TermGenericComponent.ctorParameters = function () { return [
            { type: forms.FormBuilder },
            { type: material.MatSnackBar },
            { type: undefined, decorators: [{ type: core.Inject, args: [dialog.MAT_DIALOG_DATA,] }] }
        ]; };
        return TermGenericComponent;
    }());
    if (false) {
        /** @type {?} */
        TermGenericComponent.prototype.panels;
        /** @type {?} */
        TermGenericComponent.prototype.formGroup;
        /** @type {?} */
        TermGenericComponent.prototype.action;
        /** @type {?} */
        TermGenericComponent.prototype.actionLabel;
        /** @type {?} */
        TermGenericComponent.prototype.hasService;
        /** @type {?} */
        TermGenericComponent.prototype.accept;
        /** @type {?} */
        TermGenericComponent.prototype.vocab;
        /**
         * @type {?}
         * @private
         */
        TermGenericComponent.prototype._formBuilder;
        /** @type {?} */
        TermGenericComponent.prototype._snackBar;
        /**
         * @type {?}
         * @private
         */
        TermGenericComponent.prototype.data;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/taxonomy/terms/terms.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /**
     * Flattened tree node that has been created from a TermNode through the flattener. Flattened
     * nodes include level index and whether they can be expanded or not.
     * @record
     */
    function FlatTreeNode$1() { }
    if (false) {
        /** @type {?} */
        FlatTreeNode$1.prototype.name;
        /** @type {?} */
        FlatTreeNode$1.prototype.level;
        /** @type {?} */
        FlatTreeNode$1.prototype.expandable;
    }
    var TermsComponent = /** @class */ (function () {
        function TermsComponent(service, oautheStorage, dialog, _snackBar) {
            var _this = this;
            this.service = service;
            this.oautheStorage = oautheStorage;
            this.dialog = dialog;
            this._snackBar = _snackBar;
            this.loading = false;
            this.termsTreeObserver = {
                next: (/**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    _this.dataSource.data = response.data.tree.term_node;
                    _this.loading = !_this.loading;
                }),
                error: (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    console.log('error: ' + err + '.');
                }),
                complete: (/**
                 * @return {?}
                 */
                function () {
                    console.log('complete');
                })
            };
            this.termChangeObserver = {
                next: (/**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    _this.loading = !_this.loading;
                    _this.service.getTermsTreeByVocab(_this.currentVocab.id).subscribe(_this.termsTreeObserver);
                    _this.dialog.closeAll();
                    /** @type {?} */
                    var m = new MessageHandler(_this._snackBar);
                    m.showMessage(StatusCode.OK, response.message);
                }),
                error: (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    console.log('error: ' + err + '.');
                }),
                complete: (/**
                 * @return {?}
                 */
                function () {
                    console.log('complete');
                })
            };
            this.currentVocab = null;
            this.treeFlattener = new tree.MatTreeFlattener(this.transformer, this.getLevel, this.isExpandable, this.getChildren);
            this.treeControl = new tree$1.FlatTreeControl(this.getLevel, this.isExpandable);
            this.dataSource = new tree.MatTreeFlatDataSource(this.treeControl, this.treeFlattener);
        }
        /**
         * @return {?}
         */
        TermsComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            if (!this.oautheStorage.getItem('user_permission')) {
                this.getAuthenticatedUserPermissions();
            }
        };
        /**
         * @return {?}
         */
        TermsComponent.prototype.ngOnChanges = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.currentVocab != null) {
                this.loading = true;
                this.service.getTermsTreeByVocab(this.currentVocab.id)
                    .subscribe((/**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    _this.dataSource.data = response.data.tree.term_node;
                }), (/**
                 * @param {?} err
                 * @return {?}
                 */
                function (err) {
                    console.log('error: ' + err + '.');
                }), (/**
                 * @return {?}
                 */
                function () {
                    _this.loading = false;
                }));
            }
        };
        /**
         * @return {?}
         */
        TermsComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
        };
        /** Transform the data to something the tree can read. */
        /**
         * Transform the data to something the tree can read.
         * @param {?} node
         * @param {?} level
         * @return {?}
         */
        TermsComponent.prototype.transformer = /**
         * Transform the data to something the tree can read.
         * @param {?} node
         * @param {?} level
         * @return {?}
         */
        function (node, level) {
            return {
                name: node.term.identifier,
                term: node.term,
                level: level,
                expandable: (node.children.length > 0)
            };
        };
        /** Get the level of the node */
        /**
         * Get the level of the node
         * @param {?} node
         * @return {?}
         */
        TermsComponent.prototype.getLevel = /**
         * Get the level of the node
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return node.level;
        };
        /** Get whether the node is expanded or not. */
        /**
         * Get whether the node is expanded or not.
         * @param {?} node
         * @return {?}
         */
        TermsComponent.prototype.isExpandable = /**
         * Get whether the node is expanded or not.
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return node.expandable;
        };
        /** Get whether the node has children or not. */
        /**
         * Get whether the node has children or not.
         * @param {?} index
         * @param {?} node
         * @return {?}
         */
        TermsComponent.prototype.hasChild = /**
         * Get whether the node has children or not.
         * @param {?} index
         * @param {?} node
         * @return {?}
         */
        function (index, node) {
            return node.expandable;
        };
        /** Get the children for the node. */
        /**
         * Get the children for the node.
         * @param {?} node
         * @return {?}
         */
        TermsComponent.prototype.getChildren = /**
         * Get the children for the node.
         * @param {?} node
         * @return {?}
         */
        function (node) {
            return rxjs.of(node.children);
        };
        /**
         * @return {?}
         */
        TermsComponent.prototype.addTerm = /**
         * @return {?}
         */
        function () {
            this.openTermDialog(null);
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TermsComponent.prototype.editTerm = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            this.openTermDialog(node.term);
        };
        /**
         * @private
         * @param {?} term
         * @return {?}
         */
        TermsComponent.prototype.openTermDialog = /**
         * @private
         * @param {?} term
         * @return {?}
         */
        function (term) {
            var _this = this;
            /** @type {?} */
            var dialogRef = this.dialog.open(TermGenericComponent, {
                data: {
                    term: term,
                    terms: this.dataSource.data,
                    currentVocab: this.currentVocab,
                    accept: (/**
                     * @param {?} term
                     * @return {?}
                     */
                    function (term) {
                        _this.dialog.closeAll();
                        if (term.isNew) {
                            _this.service.newTerm(term).pipe().subscribe(_this.termChangeObserver);
                        }
                        else {
                            _this.service.editTerm(term).pipe().subscribe(_this.termChangeObserver);
                        }
                    })
                }
            });
            dialogRef.afterClosed().subscribe((/**
             * @param {?} result
             * @return {?}
             */
            function (result) {
                console.log('dialog closed');
            }));
        };
        /**
         * @param {?} node
         * @return {?}
         */
        TermsComponent.prototype.deleteTerm = /**
         * @param {?} node
         * @return {?}
         */
        function (node) {
            console.log(node);
        };
        /**
         * @return {?}
         */
        TermsComponent.prototype.getAuthenticatedUserPermissions = /**
         * @return {?}
         */
        function () {
            var _this = this;
            this.service.getCurrentUserPermissions().pipe(operators.catchError((/**
             * @param {?} err
             * @return {?}
             */
            function (err) {
                /** @type {?} */
                var m = new MessageHandler(_this._snackBar);
                m.showMessage(StatusCode.serverError, err.message);
                // TODO: Maybe you must set a better return.
                return rxjs.of(null);
            })))
                .subscribe((/**
             * @param {?} request
             * @return {?}
             */
            function (request) {
                if (request.status == 'success') {
                    /** @type {?} */
                    var permJson = JSON.stringify(request.data.permissions.actions);
                    _this.oautheStorage.setItem('user_permissions', permJson);
                }
            }));
        };
        /**
         * @param {?} permission
         * @param {?=} id
         * @return {?}
         */
        TermsComponent.prototype.hasPermission = /**
         * @param {?} permission
         * @param {?=} id
         * @return {?}
         */
        function (permission, id) {
            /** @type {?} */
            var userPermission = JSON.parse(this.oautheStorage.getItem('user_permissions'));
            if (!userPermission) {
                return false;
            }
            switch (permission) {
                case 'add':
                    if (userPermission.taxonomy_full_editor_actions === null)
                        return true;
                    return false;
                case 'edit':
                    if (userPermission.taxonomy_full_editor_actions === null)
                        return true;
                    if (userPermission.vocabulary_editor_actions) {
                        /** @type {?} */
                        var arr = userPermission.vocabulary_editor_actions;
                        if (arr.includes(id)) {
                            return true;
                        }
                    }
                    else if (userPermission.taxonomy_full_editor_actions) {
                        return true;
                    }
                    return false;
                default:
                    return false;
            }
        };
        TermsComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-terms',
                        template: "<mat-card>\n    <mat-card-header>\n        <mat-card-title>\n            <div fxLayout=\"row\" fxLayoutAlign=\"space-between none\">\n                T\u00E9rminos\n                <ng-container *ngIf=\"currentVocab\"> de {{ currentVocab.human_name}} </ng-container>\n\n                <button mat-icon-button *ngIf=\"currentVocab && hasPermission('add')\" (click)=\"addTerm()\"\n                    matTooltip=\"Adicionar T\u00E9rmino\">\n                    <mat-icon>library_add</mat-icon>\n                </button>\n\n            </div>\n        </mat-card-title>\n    </mat-card-header>\n    <mat-card-content [style.overflow]=\"'auto'\" [style.height]=\"'25em'\">\n        <mat-spinner *ngIf=\"loading; else elseTemplate\"></mat-spinner>\n\n        <ng-template #elseTemplate>\n            <mat-tree [dataSource]=\"dataSource\" [treeControl]=\"treeControl\" class=\"padd\">\n                <mat-tree-node class=\"hover\" *matTreeNodeDef=\"let node\" matTreeNodeToggle matTreeNodePadding\n                    fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n                    <div fxLayout=\"row\" fxLayoutAlign=\"start center\">\n                        <button mat-icon-button disabled></button>\n                        {{ node.name }}\n                    </div> \n                    <button mat-icon-button *ngIf=\"currentVocab && hasPermission('edit', currentVocab.id)\" (click)=\"editTerm(node)\" matTooltip=\"Editar\">\n                    <mat-icon>edit</mat-icon>\n                    </button>\n                </mat-tree-node>\n\n                <mat-tree-node class=\"hover\" *matTreeNodeDef=\"let node; when: hasChild\" matTreeNodePadding>\n                    <button mat-icon-button matTreeNodeToggle [attr.aria-label]=\"'toggle ' + node.name\">\n                        <mat-icon class=\"mat-icon-rtl-mirror\">\n                            {{treeControl.isExpanded(node) ? 'expand_more' : 'chevron_right'}}\n                        </mat-icon>\n                    </button>\n                    <div class=\"item-width\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n                        {{ node.name }}\n                        <div>\n                            <button mat-icon-button *ngIf=\"currentVocab && hasPermission('edit', currentVocab.id)\" (click)=\"editTerm(node)\" matTooltip=\"Editar\">\n                                <mat-icon>edit</mat-icon>\n                            </button>\n                            <!-- <button mat-icon-button (click)=\"deleteTerm(node)\" matTooltip=\"Eliminar\">\n                                <mat-icon>delete</mat-icon>\n                            </button> -->\n                        </div>\n                    </div>\n\n                </mat-tree-node>\n            </mat-tree>\n        </ng-template>\n    </mat-card-content>\n</mat-card>",
                        styles: [".type-icon{color:#757575;margin-right:5px}.item-width{width:100%}.padd{padding:.7em}.hover:hover{transform:scale(1.02);box-shadow:0 0 10px 0 rgba(0,0,0,.4);border-radius:3px}"]
                    }] }
        ];
        /** @nocollapse */
        TermsComponent.ctorParameters = function () { return [
            { type: TaxonomyService },
            { type: angularOauth2Oidc.OAuthStorage },
            { type: dialog.MatDialog },
            { type: snackBar.MatSnackBar }
        ]; };
        TermsComponent.propDecorators = {
            currentVocab: [{ type: core.Input }]
        };
        return TermsComponent;
    }());
    if (false) {
        /** @type {?} */
        TermsComponent.prototype.loading;
        /**
         * The TreeControl controls the expand/collapse state of tree nodes.
         * @type {?}
         */
        TermsComponent.prototype.treeControl;
        /**
         * The TreeFlattener is used to generate the flat list of items from hierarchical data.
         * @type {?}
         */
        TermsComponent.prototype.treeFlattener;
        /**
         * The MatTreeFlatDataSource connects the control and flattener to provide data.
         * @type {?}
         */
        TermsComponent.prototype.dataSource;
        /**
         * @type {?}
         * @private
         */
        TermsComponent.prototype.termsTreeObserver;
        /**
         * @type {?}
         * @private
         */
        TermsComponent.prototype.termChangeObserver;
        /** @type {?} */
        TermsComponent.prototype.currentVocab;
        /**
         * @type {?}
         * @private
         */
        TermsComponent.prototype.service;
        /**
         * @type {?}
         * @private
         */
        TermsComponent.prototype.oautheStorage;
        /** @type {?} */
        TermsComponent.prototype.dialog;
        /**
         * @type {?}
         * @private
         */
        TermsComponent.prototype._snackBar;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/taxonomy/taxonomy/taxonomy.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TaxonomyComponent = /** @class */ (function () {
        function TaxonomyComponent() {
            this.vocabs = { title: 'Vocabularios', cols: 1, rows: 1 };
            this.terms = { title: 'Terminos de', cols: 1, rows: 2 };
            this.current_vocab = { name: '', description: '' };
        }
        /**
         * @return {?}
         */
        TaxonomyComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
        };
        /**
         * @param {?} vocab
         * @return {?}
         */
        TaxonomyComponent.prototype.vocabChange = /**
         * @param {?} vocab
         * @return {?}
         */
        function (vocab) {
            this.currentVocab = vocab;
        };
        /**
         * @return {?}
         */
        TaxonomyComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
        function () {
        };
        TaxonomyComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-taxonomy',
                        template: "<div class=\"grid-container\">\n  <!-- <h1 class=\"mat-h1\">Taxonom\u00EDa</h1> -->\n  <div fxLayout=\"row\" fxLayout.xs=\"column\" fxLayoutGap=\u201D32px\u201D fxLayoutAlign=\"space-around none\">\n    \n    <toco-vocabularies \n      fxFlex=\"38%\" \n      (selectedVocab)=\"vocabChange($event)\"\n    ></toco-vocabularies>\n\n    <toco-terms \n      fxFlex=\"58%\" \n      [currentVocab]=\"currentVocab\"\n    ></toco-terms>\n  </div>\n</div>",
                        styles: [".grid-container{margin:20px}.dashboard-card{position:absolute;top:15px;left:15px;right:15px;bottom:15px;overflow:hidden;display:flex;flex-direction:column}.dashboard-card>.mat-card-title-group{display:block}.dashboard-card>.mat-card-content{overflow-y:auto}"]
                    }] }
        ];
        /** @nocollapse */
        TaxonomyComponent.ctorParameters = function () { return []; };
        return TaxonomyComponent;
    }());
    if (false) {
        /** @type {?} */
        TaxonomyComponent.prototype.vocabs;
        /** @type {?} */
        TaxonomyComponent.prototype.terms;
        /** @type {?} */
        TaxonomyComponent.prototype.current_vocab;
        /** @type {?} */
        TaxonomyComponent.prototype.currentVocab;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/taxonomy/terms-viewer/terms-viewer.component.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TermsViewerComponent = /** @class */ (function () {
        function TermsViewerComponent(taxonomyService) {
            this.taxonomyService = taxonomyService;
            /**
             * receive vocab_id and a list of terms ids.
             * show in a chiplist the terms of vocab_id
             */
            this.vocabulary_id = null;
            this.ids = null;
            this.terms = [];
        }
        /**
         * @return {?}
         */
        TermsViewerComponent.prototype.ngOnInit = /**
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.vocabulary_id) {
                console.log(this.ids);
                this.taxonomyService.getTermListByIDs(this.ids)
                    .subscribe((/**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    console.log(response);
                    if (response.data.term) {
                        response.data.term.forEach((/**
                         * @param {?} term
                         * @return {?}
                         */
                        function (term) {
                            if (term.vocabulary_id == _this.vocabulary_id) {
                                _this.terms.push(term);
                            }
                        }));
                    }
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                function (error) { }), (/**
                 * @return {?}
                 */
                function () { }));
            }
        };
        TermsViewerComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'toco-terms-viewer',
                        template: "<mat-chip-list>\n  <mat-chip *ngFor=\"let term of terms\">{{ term.name }}</mat-chip>\n</mat-chip-list>\n",
                        styles: [""]
                    }] }
        ];
        /** @nocollapse */
        TermsViewerComponent.ctorParameters = function () { return [
            { type: TaxonomyService }
        ]; };
        TermsViewerComponent.propDecorators = {
            vocabulary_id: [{ type: core.Input }],
            ids: [{ type: core.Input }]
        };
        return TermsViewerComponent;
    }());
    if (false) {
        /**
         * receive vocab_id and a list of terms ids.
         * show in a chiplist the terms of vocab_id
         * @type {?}
         */
        TermsViewerComponent.prototype.vocabulary_id;
        /** @type {?} */
        TermsViewerComponent.prototype.ids;
        /** @type {?} */
        TermsViewerComponent.prototype.terms;
        /**
         * @type {?}
         * @private
         */
        TermsViewerComponent.prototype.taxonomyService;
    }

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/taxonomy/taxonomy.module.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TaxonomyModule = /** @class */ (function () {
        function TaxonomyModule() {
        }
        TaxonomyModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            VocabulariesComponent,
                            VocabularyDialogComponent,
                            TermsComponent,
                            TaxonomyComponent,
                            TermGenericComponent,
                            TermsViewerComponent
                        ],
                        entryComponents: [
                            VocabularyDialogComponent,
                            TermGenericComponent
                        ],
                        imports: [
                            SharedModule,
                            forms.ReactiveFormsModule,
                            TocoFormsModule
                        ],
                        exports: [
                            TaxonomyComponent,
                            VocabulariesComponent,
                            TermsViewerComponent
                        ],
                        providers: []
                    },] }
        ];
        return TaxonomyModule;
    }());

    /**
     * @fileoverview added by tsickle
     * Generated from: lib/taxonomy/utils.ts
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    var TermHelper = /** @class */ (function () {
        function TermHelper() {
        }
        /**
         * @param {?} term
         * @return {?}
         */
        TermHelper.getPanelContentToEdit = /**
         * @param {?} term
         * @return {?}
         */
        function (term) {
            // console.log(term);
            // console.log(term);
            /** @type {?} */
            var result = null;
            if (term) {
                switch (term.vocabulary_id) {
                    case VocabulariesInmutableNames.CUBAN_INTITUTIONS:
                        result = [
                            {
                                name: "name",
                                label: "Nombre",
                                type: FormFieldType.text,
                                required: true,
                                value: term.identifier ? term.identifier : null,
                                width: "100%"
                            },
                            {
                                name: "grid",
                                label: "Identificador GRID",
                                type: FormFieldType.text,
                                required: false,
                                value: term.data["grid"] ? term.data["grid"] : null,
                                width: "50%"
                            },
                            {
                                name: "description",
                                label: "Descripción",
                                type: FormFieldType.textarea,
                                required: false,
                                value: term.description ? term.description : null,
                                width: "100%"
                            },
                            {
                                name: "email",
                                label: "Email",
                                type: FormFieldType.email,
                                required: true,
                                value: term.data["email"] ? term.data["email"] : null,
                                width: "45%"
                            },
                            {
                                name: "website",
                                label: "Sitio Web Oficial",
                                type: FormFieldType.url,
                                required: false,
                                value: term.data["website"] ? term.data["website"] : null,
                                width: "45%"
                            },
                            {
                                name: "address",
                                label: "Dirección",
                                type: FormFieldType.textarea,
                                required: false,
                                value: term.data["address"] ? term.data["address"] : null,
                                width: "100%"
                            },
                            {
                                name: "parent_id",
                                label: "Jerarquía Institucional (Institución Superior)",
                                type: FormFieldType.vocabulary,
                                required: false,
                                extraContent: {
                                    multiple: false,
                                    selectedTermsIds: term.parent_id ? [term.parent_id] : null,
                                    vocab: term.vocabulary_id
                                },
                                width: "100%"
                            }
                        ];
                        break;
                    case VocabulariesInmutableNames.INDEXES:
                        result = [
                            {
                                name: "name",
                                label: "Nombre",
                                type: FormFieldType.text,
                                required: true,
                                value: term.identifier ? term.identifier : null,
                                width: "100%"
                            },
                            {
                                name: "url",
                                label: "URL",
                                type: FormFieldType.url,
                                required: false,
                                value: term.data["url"] ? term.data["url"] : null,
                                width: "100%"
                            },
                            {
                                name: "abrev",
                                label: "Identificadores",
                                type: FormFieldType.text,
                                required: false,
                                value: term.data["abrev"] ? term.data["abrev"] : null,
                                width: "30%"
                            },
                            {
                                name: "initial_cover",
                                label: "Cobertura inicio",
                                type: FormFieldType.text,
                                required: false,
                                value: term.data["initial_cover"]
                                    ? term.data["initial_cover"]
                                    : null,
                                width: "30%"
                            },
                            {
                                name: "end_cover",
                                label: "Cobertura",
                                type: FormFieldType.text,
                                required: false,
                                value: term.data["end_cover"] ? term.data["end_cover"] : null,
                                width: "30%"
                            },
                            {
                                name: "description",
                                label: "Descripción",
                                type: FormFieldType.textarea,
                                required: false,
                                value: term.description ? term.description : null,
                                width: "100%"
                            },
                            {
                                name: "miar_class",
                                label: "Tipología de sistemas de indización",
                                type: FormFieldType.vocabulary,
                                required: false,
                                extraContent: {
                                    multiple: false,
                                    selectedTermsIds: term.class_ids ? term.class_ids : null,
                                    vocab: VocabulariesInmutableNames.INDEXES_CLASIFICATION
                                },
                                width: "48%"
                            },
                            {
                                name: "group_mes",
                                label: "Grupos, Categorías según criterios de “calidad” de las publicaciones ",
                                type: FormFieldType.vocabulary,
                                startHint: new HintValue(HintPosition.start, ""),
                                required: false,
                                extraContent: {
                                    multiple: false,
                                    selectedTermsIds: term.class_ids ? term.class_ids : null,
                                    vocab: VocabulariesInmutableNames.INDEXES_CLASIFICATION
                                },
                                width: "48%"
                            }
                        ];
                        break;
                    default:
                        result = [
                            {
                                name: "name",
                                label: "Nombre",
                                type: FormFieldType.text,
                                required: true,
                                width: "100%",
                                value: term.identifier ? term.identifier : null
                            },
                            {
                                name: "description",
                                label: "Descripción",
                                type: FormFieldType.textarea,
                                required: false,
                                width: "100%",
                                value: term.description ? term.description : null
                            },
                            {
                                name: "parent_id",
                                label: "Término Padre",
                                type: FormFieldType.vocabulary,
                                startHint: new HintValue(HintPosition.start, ""),
                                required: false,
                                extraContent: {
                                    multiple: false,
                                    selectedTermsIds: term.parent_id ? [term.parent_id] : null,
                                    vocab: term.vocabulary_id
                                },
                                width: "50%"
                            }
                        ];
                }
            }
            return result;
        };
        return TermHelper;
    }());

    exports.ActionButtonComponent = ActionButtonComponent;
    exports.ActionControl = ActionControl;
    exports.ActionText = ActionText;
    exports.Address = Address;
    exports.Aggr = Aggr;
    exports.AggrBucket = AggrBucket;
    exports.AggregationsComponent = AggregationsComponent;
    exports.AngularMaterialModule = AngularMaterialModule;
    exports.AuthBackend = AuthBackend;
    exports.AuthenticationComponent = AuthenticationComponent;
    exports.AuthenticationModule = AuthenticationModule;
    exports.AutocompleteFilter = AutocompleteFilter;
    exports.BackendModule = BackendModule;
    exports.BodyComponent = BodyComponent;
    exports.BooleanFilterComponent = BooleanFilterComponent;
    exports.CACHABLE_URL_PROVIDER = CACHABLE_URL_PROVIDER;
    exports.Cachable = Cachable;
    exports.CachableUrl = CachableUrl;
    exports.CachingInterceptor = CachingInterceptor;
    exports.CatalogComponent = CatalogComponent;
    exports.CatalogService = CatalogService;
    exports.CategoryQuestion = CategoryQuestion;
    exports.CategoryQuestionType = CategoryQuestionType;
    exports.CellContentWrap = CellContentWrap;
    exports.CheckboxComponent = CheckboxComponent;
    exports.ComponentFactory_Depr = ComponentFactory_Depr;
    exports.ContainerControl = ContainerControl;
    exports.ContainerLabelDiffLangComponent = ContainerLabelDiffLangComponent;
    exports.ContainerPanelActionComponent = ContainerPanelActionComponent;
    exports.ContainerPanelComponent = ContainerPanelComponent;
    exports.ContainerSimpleComponent = ContainerSimpleComponent;
    exports.ContentPosition = ContentPosition;
    exports.CoreModule = CoreModule;
    exports.DatepickerComponent = DatepickerComponent;
    exports.DatepickerYearComponent = DatepickerYearComponent;
    exports.DialogCatalogJournalInfoDialog = DialogCatalogJournalInfoDialog;
    exports.DialogContentComponent = DialogContentComponent;
    exports.DialogDeleteConfirmComponent = DialogDeleteConfirmComponent;
    exports.DialogDeleteConfirmMessageData = DialogDeleteConfirmMessageData;
    exports.DialogMessageData = DialogMessageData;
    exports.ENDPOINT_APIS = ENDPOINT_APIS;
    exports.EmailValue = EmailValue;
    exports.EntitiesModule = EntitiesModule;
    exports.Entity = Entity;
    exports.EntityBase = EntityBase;
    exports.Environment = Environment;
    exports.EqualLengthDirective = EqualLengthDirective;
    exports.Error404Component = Error404Component;
    exports.Evaluation = Evaluation;
    exports.EvaluationOnlyAnswer = EvaluationOnlyAnswer;
    exports.ExtraValidators = ExtraValidators;
    exports.FilterContainerComponent = FilterContainerComponent;
    exports.FilterContainerService = FilterContainerService;
    exports.FilterDirective = FilterDirective;
    exports.FilterHttpMap = FilterHttpMap;
    exports.FilterItem = FilterItem;
    exports.FiltersModule = FiltersModule;
    exports.FiltersService = FiltersService;
    exports.FooterComponent = FooterComponent;
    exports.FormContainerComponent = FormContainerComponent;
    exports.FormContainerService = FormContainerService;
    exports.FormFieldControl = FormFieldControl;
    exports.FormFieldType = FormFieldType;
    exports.GeoNamesAdmin = GeoNamesAdmin;
    exports.GeoNamesCity = GeoNamesCity;
    exports.GetViewContainerDirective = GetViewContainerDirective;
    exports.HTTP_INTERCEPTOR_PROVIDERS = HTTP_INTERCEPTOR_PROVIDERS;
    exports.HandlerComponent = HandlerComponent;
    exports.HarvestedItem = HarvestedItem;
    exports.HarvesterComponent = HarvesterComponent;
    exports.HarvesterFiltersComponent = HarvesterFiltersComponent;
    exports.HarvesterModule = HarvesterModule;
    exports.HarvesterService = HarvesterService;
    exports.HintPosition = HintPosition;
    exports.HintValue = HintValue;
    exports.Hit = Hit;
    exports.HitList = HitList;
    exports.HomeComponent = HomeComponent;
    exports.HttpService = HttpService;
    exports.ISSN = ISSN;
    exports.IconService = IconService;
    exports.IconSource = IconSource;
    exports.IconValue = IconValue;
    exports.Identifier = Identifier;
    exports.IdentifierSchemas = IdentifierSchemas;
    exports.IdentifierValue = IdentifierValue;
    exports.InfoCardComponent = InfoCardComponent;
    exports.InputBoolComponent = InputBoolComponent;
    exports.InputControl = InputControl;
    exports.InputEmailComponent = InputEmailComponent;
    exports.InputIdentifierComponent = InputIdentifierComponent;
    exports.InputIssnComponent = InputIssnComponent;
    exports.InputNumberComponent = InputNumberComponent;
    exports.InputRnpsComponent = InputRnpsComponent;
    exports.InputSelectComponent = InputSelectComponent;
    exports.InputTextComponent = InputTextComponent;
    exports.InputUrlComponent = InputUrlComponent;
    exports.InstitutionalRepository = InstitutionalRepository;
    exports.IssnOrg = IssnOrg;
    exports.IssnType_Abbreviation = IssnType_Abbreviation;
    exports.IssnType_Label = IssnType_Label;
    exports.IssnValue = IssnValue;
    exports.Journal = Journal;
    exports.JournalCardComponent = JournalCardComponent;
    exports.JournalData = JournalData;
    exports.JournalDataType = JournalDataType;
    exports.JournalEditComponent = JournalEditComponent;
    exports.JournalGeneralData = JournalGeneralData;
    exports.JournalReference = JournalReference;
    exports.JournalVersion = JournalVersion;
    exports.JournalViewComponent = JournalViewComponent;
    exports.LANGUAGE_ABBRS_LIST = LANGUAGE_ABBRS_LIST;
    exports.LANGUAGE_TEXTS_LIST = LANGUAGE_TEXTS_LIST;
    exports.LabelDiffLang = LabelDiffLang;
    exports.LanguageAbbrs = LanguageAbbrs;
    exports.LanguageTexts = LanguageTexts;
    exports.Links = Links;
    exports.MARKDOWN_FILE_EXTENSION = MARKDOWN_FILE_EXTENSION;
    exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER;
    exports.MainInstitution = MainInstitution;
    exports.MessageHandler = MessageHandler;
    exports.MessageService = MessageService;
    exports.MetadataService = MetadataService;
    exports.NavComponent = NavComponent;
    exports.NotificationButtonComponent = NotificationButtonComponent;
    exports.NotificationInfo = NotificationInfo;
    exports.NotificationListComponent = NotificationListComponent;
    exports.NotificationModule = NotificationModule;
    exports.NotificationService = NotificationService;
    exports.OauthAuthenticationService = OauthAuthenticationService;
    exports.OperationAction = OperationAction;
    exports.OrgAddComponent = OrgAddComponent;
    exports.OrgEditComponent = OrgEditComponent;
    exports.OrgSearchComponent = OrgSearchComponent;
    exports.OrgTreeViewerComponent = OrgTreeViewerComponent;
    exports.OrgViewComponent = OrgViewComponent;
    exports.Organization = Organization;
    exports.OrganizationDataSource = OrganizationDataSource;
    exports.OrganizationFlatNode = OrganizationFlatNode;
    exports.OrganizationRelationships = OrganizationRelationships;
    exports.OrganizationService = OrganizationService;
    exports.OrganizationServiceNoAuth = OrganizationServiceNoAuth;
    exports.OrganizationsModule = OrganizationsModule;
    exports.PageHeaderComponent = PageHeaderComponent;
    exports.PageNotFoundComponent = PageNotFoundComponent;
    exports.Person = Person;
    exports.PersonComponent = PersonComponent;
    exports.PersonModule = PersonModule;
    exports.PersonViewComponent = PersonViewComponent;
    exports.ProgressComponent = ProgressComponent;
    exports.QueryInputComponent = QueryInputComponent;
    exports.QueryParamKey = QueryParamKey;
    exports.REFRESH_X_CACHE = REFRESH_X_CACHE;
    exports.REQUEST_CACHE_DIFFERENT_TIME_WITH_MAP_PROVIDER = REQUEST_CACHE_DIFFERENT_TIME_WITH_MAP_PROVIDER;
    exports.RNPS = RNPS;
    exports.ROOT_API = ROOT_API;
    exports.Record = Record;
    exports.RecordComponent = RecordComponent;
    exports.RecordListComponent = RecordListComponent;
    exports.Redirect = Redirect;
    exports.RedirectProperties = RedirectProperties;
    exports.RedirectPropertiesIdtype = RedirectPropertiesIdtype;
    exports.Redirected = Redirected;
    exports.Reference = Reference;
    exports.Relationship = Relationship;
    exports.RepositoriesComponent = RepositoriesComponent;
    exports.Repository = Repository;
    exports.RepositoryComponent = RepositoryComponent;
    exports.RepositorySet = RepositorySet;
    exports.RequestCache = RequestCache;
    exports.RequestCacheDifferentTimeWithMap = RequestCacheDifferentTimeWithMap;
    exports.ResponseStatus = ResponseStatus;
    exports.RnpsValue = RnpsValue;
    exports.RoadMapComponent = RoadMapComponent;
    exports.RoadMapSceibaComponent = RoadMapSceibaComponent;
    exports.Role = Role;
    exports.SavingInfoSchema = SavingInfoSchema;
    exports.SceibaAppsComponent = SceibaAppsComponent;
    exports.SearchModule = SearchModule;
    exports.SearchResponse = SearchResponse;
    exports.SearchService = SearchService;
    exports.SectionCategory = SectionCategory;
    exports.SelectAutocompleteFilterComponent = SelectAutocompleteFilterComponent;
    exports.SelectComponent = SelectComponent;
    exports.SelectFilterComponent = SelectFilterComponent;
    exports.SelectFilterOldComponent = SelectFilterOldComponent;
    exports.SelectOrgsComponent = SelectOrgsComponent;
    exports.SelectTreeComponent = SelectTreeComponent;
    exports.SharedModule = SharedModule;
    exports.SimpleAuthenticationService = SimpleAuthenticationService;
    exports.SocialNetworks = SocialNetworks;
    exports.SortDirection = SortDirection;
    exports.Source = Source;
    exports.SourceClasification = SourceClasification;
    exports.SourceData = SourceData;
    exports.SourceOrganization = SourceOrganization;
    exports.SourceOrganizationRole = SourceOrganizationRole;
    exports.SourcePersonRole = SourcePersonRole;
    exports.SourceService = SourceService;
    exports.SourceServiceNoAuth = SourceServiceNoAuth;
    exports.SourceStatus = SourceStatus;
    exports.SourceSystems = SourceSystems;
    exports.SourceTypes = SourceTypes;
    exports.SourceVersion = SourceVersion;
    exports.SourcesListComponent = SourcesListComponent;
    exports.SourcesModule = SourcesModule;
    exports.StaticChipsComponent = StaticChipsComponent;
    exports.StaticTableComponent = StaticTableComponent;
    exports.StaticTextComponent = StaticTextComponent;
    exports.StaticsModule = StaticsModule;
    exports.StatusCode = StatusCode;
    exports.SurveySection = SurveySection;
    exports.TableComponent = TableComponent;
    exports.TaxonomyComponent = TaxonomyComponent;
    exports.TaxonomyModule = TaxonomyModule;
    exports.TaxonomyService = TaxonomyService;
    exports.Term = Term;
    exports.TermHelper = TermHelper;
    exports.TermIndexData = TermIndexData;
    exports.TermInstitutionData = TermInstitutionData;
    exports.TermParentComponent = TermParentComponent;
    exports.TextAlign = TextAlign;
    exports.TextInputAppearance = TextInputAppearance;
    exports.TextareaComponent = TextareaComponent;
    exports.TitleFilterComponent = TitleFilterComponent;
    exports.TocoFormsModule = TocoFormsModule;
    exports.TocoLibComponent = TocoLibComponent;
    exports.TocoLibModule = TocoLibModule;
    exports.TocoLibService = TocoLibService;
    exports.TreeFilterComponent = TreeFilterComponent;
    exports.UrlValue = UrlValue;
    exports.User = User;
    exports.UserProfile = UserProfile;
    exports.UserProfileService = UserProfileService;
    exports.UserService = UserService;
    exports.UserSourcesRoles = UserSourcesRoles;
    exports.VocabulariesComponent = VocabulariesComponent;
    exports.VocabulariesInmutableNames = VocabulariesInmutableNames;
    exports.Vocabulary = Vocabulary;
    exports.VocabularyComponent = VocabularyComponent;
    exports.VocabularyDialogComponent = VocabularyDialogComponent;
    exports.VocabularyTreeComponent = VocabularyTreeComponent;
    exports.YEAR_MODE_FORMATS = YEAR_MODE_FORMATS;
    exports.authConfig = authConfig;
    exports.clickDefault = clickDefault;
    exports.cloneFormControl = cloneFormControl;
    exports.cloneFormSection = cloneFormSection;
    exports.cloneValue = cloneValue;
    exports.cloneValueToUndefined = cloneValueToUndefined;
    exports.convertLangFromNumberToString = convertLangFromNumberToString;
    exports.convertLangFromStringToNumber = convertLangFromStringToNumber;
    exports.defaultTableContent = defaultTableContent;
    exports.filterPredicate = filterPredicate;
    exports.getHttpEventTypeToString = getHttpEventTypeToString;
    exports.getPathWithLangExtension = getPathWithLangExtension;
    exports.instRepoEmpty = instRepoEmpty;
    exports.isDescendant = isDescendant;
    exports.isDisabledDefault = isDisabledDefault;
    exports.logComplete = logComplete;
    exports.logError = logError;
    exports.mainInstEmpty = mainInstEmpty;
    exports.sortData = sortData;
    exports.sortingDataAccessor = sortingDataAccessor;
    exports.storageFactory = storageFactory;
    exports.ɵa = CoreRoutingModule;
    exports.ɵb = HarvesterRoutingModule;
    exports.ɵc = OrgViewAccordionComponent;
    exports.ɵd = OrgViewAddressComponent;
    exports.ɵe = OrgViewGeoNamesCityComponent;
    exports.ɵf = OrgViewRelationshipComponent;
    exports.ɵg = OrgTableEditComponent;
    exports.ɵh = JournalViewTermComponent;
    exports.ɵi = JournalViewInfoComponent;
    exports.ɵj = JournalViewInfoFieldComponent;
    exports.ɵk = SourceOrganizationsComponent;
    exports.ɵl = SourceOrganizationSelectTopDialog;
    exports.ɵm = SourceOrganizationSelectDialog;
    exports.ɵn = SourceIndexesComponent;
    exports.ɵo = SourceEditAddIndexComponent;
    exports.ɵp = JournalViewFieldComponent;
    exports.ɵq = JournalViewVersionComponent;
    exports.ɵr = CatalogFiltersComponent;
    exports.ɵs = TermsComponent;
    exports.ɵt = TermGenericComponent;
    exports.ɵu = TermsViewerComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=toco-lib.umd.js.map
